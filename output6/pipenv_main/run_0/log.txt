Launching subshell in virtual environment...
Traceback (most recent call last):
  File "/usr/local/bin/pipenv", line 7, in <module>
    sys.exit(cli())
             ^^^^^
  File "/usr/local/lib/python3.12/dist-packages/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.12/dist-packages/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.12/dist-packages/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.12/dist-packages/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.12/dist-packages/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.12/dist-packages/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.12/dist-packages/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.12/dist-packages/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.12/dist-packages/pipenv/cli/command.py", line 401, in shell
    do_shell(
  File "/usr/local/lib/python3.12/dist-packages/pipenv/routines/shell.py", line 49, in do_shell
    shell.fork_compat(*fork_args)
  File "/usr/local/lib/python3.12/dist-packages/pipenv/shells.py", line 133, in fork_compat
    c.interact(escape_character=None)
  File "/usr/local/lib/python3.12/dist-packages/pipenv/vendor/pexpect/pty_spawn.py", line 788, in interact
    mode = tty.tcgetattr(self.STDIN_FILENO)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
termios.error: (25, 'Inappropriate ioctl for device')
Bottle v0.14-dev server starting up (using AutoServer(handler_class=<class 'pypiserver.__main__.WsgiHandler'>))...
Listening on http://0.0.0.0:8080/
Hit Ctrl-C to quit.
============================= test session starts ==============================
platform linux -- Python 3.12.11, pytest-8.4.0, pluggy-1.6.0 -- /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python
cachedir: .pytest_cache
rootdir: /app
configfile: pyproject.toml
plugins: cov-4.1.0, xdist-3.7.0, flaky-3.8.1, timeout-2.4.0
created: 40/40 workers
40 workers [412 items]

scheduling tests via LoadScheduling

tests/integration/test_cli.py::test_pipenv_py
tests/integration/test_cli.py::test_pipenv_support
tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[packages]
tests/integration/test_cli.py::test_pipenv_graph
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[0]
tests/integration/test_cli.py::test_scripts
tests/integration/test_dot_venv.py::test_venv_at_project_root[yes]
tests/integration/test_cli.py::test_pipenv_verify_locked_passing
tests/integration/test_cli.py::test_pipenv_clear
tests/integration/test_cli.py::test_man
tests/integration/test_cli.py::test_venv_envs
tests/integration/test_import_requirements.py::test_auth_with_pw_redacted
tests/integration/test_dot_venv.py::test_venv_in_project[1]
tests/integration/test_cli.py::test_pipenv_where
tests/integration/test_dot_venv.py::test_venv_at_project_root[1]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[no]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[0]
tests/integration/test_dot_venv.py::test_reuse_previous_venv
tests/integration/test_dot_venv.py::test_venv_in_project_default_when_venv_exists
tests/integration/test_dot_venv.py::test_venv_file[foo/test-venv]
tests/integration/test_cli.py::test_pipenv_check
[gw4] [  0%] SKIPPED tests/integration/test_cli.py::test_pipenv_check
tests/integration/test_import_requirements.py::test_import_requirements_with_path_object
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[no]
tests/integration/test_cli.py::test_pipenv_verify_without_pipfile
[gw5] [  0%] SKIPPED tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[packages]
tests/integration/test_import_requirements.py::test_auth_with_pw_are_variables_passed_to_pipfile
tests/integration/test_install_basic.py::test_mirror_install
tests/integration/test_install_basic.py::test_basic_dev_install
tests/integration/test_install_basic.py::test_install_with_version_req_default_operator
tests/integration/test_dot_venv.py::test_venv_in_project[yes]
[gw9] [  0%] SKIPPED tests/integration/test_cli.py::test_pipenv_clear
tests/integration/test_install_basic.py::test_extras_install
tests/integration/test_install_basic.py::test_backup_resolver
[gw30] [  0%] SKIPPED tests/integration/test_install_basic.py::test_backup_resolver
tests/integration/test_install_basic.py::test_install_creates_pipfile
tests/integration/test_install_basic.py::test_install_with_pipfile_including_exact_python_version
tests/integration/test_install_basic.py::test_clean_on_empty_venv
tests/integration/test_install_basic.py::test_editable_no_args
tests/integration/test_install_basic.py::test_requirements_to_pipfile
tests/integration/test_install_basic.py::test_outline_table_specifier
tests/integration/test_install_basic.py::test_install_non_exist_dep
tests/integration/test_install_basic.py::test_rewrite_outline_table
tests/integration/test_install_basic.py::test_system_and_deploy_work
tests/integration/test_cli.py::test_pipenv_clean
tests/integration/test_cli.py::test_pipenv_outdated_prerelease
tests/integration/test_install_basic.py::test_alternative_version_specifier
tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[CVE]
[gw4] [  1%] SKIPPED tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[CVE]
tests/integration/test_install_basic.py::test_category_not_sorted_without_directive
[gw26] [  1%] PASSED tests/integration/test_import_requirements.py::test_import_requirements_with_path_object
tests/integration/test_install_basic.py::test_basic_install
[gw8] [  1%] PASSED tests/integration/test_cli.py::test_man
tests/integration/test_cli.py::test_install_parse_error
[gw7] [  1%] PASSED tests/integration/test_cli.py::test_scripts
tests/integration/test_cli.py::test_help
[gw34] [  2%] PASSED tests/integration/test_install_basic.py::test_editable_no_args
tests/integration/test_install_basic.py::test_install_venv_project_directory
[gw6] [  2%] PASSED tests/integration/test_cli.py::test_venv_envs
tests/integration/test_cli.py::test_bare_output
[gw24] [  2%] PASSED tests/integration/test_import_requirements.py::test_auth_with_pw_are_variables_passed_to_pipfile
tests/integration/test_import_requirements.py::test_auth_with_only_username_variable_passed_to_pipfile
[gw0] [  2%] PASSED tests/integration/test_cli.py::test_pipenv_where
[gw2] [  3%] PASSED tests/integration/test_cli.py::test_pipenv_support
tests/integration/test_cli.py::test_pipenv_rm
tests/integration/test_cli.py::test_pipenv_venv
[gw10] [  3%] PASSED tests/integration/test_cli.py::test_pipenv_verify_without_pipfile
tests/integration/test_cli.py::test_pipenv_verify_without_pipfile_lock
[gw23] [  3%] PASSED tests/integration/test_import_requirements.py::test_auth_with_pw_redacted
tests/integration/test_import_requirements.py::test_auth_with_username_redacted
[gw36] [  3%] PASSED tests/integration/test_install_basic.py::test_install_creates_pipfile
tests/integration/test_install_basic.py::test_create_pipfile_requires_python_full_version
[gw33] [  4%] PASSED tests/integration/test_install_basic.py::test_clean_on_empty_venv
tests/integration/test_install_basic.py::test_install_does_not_extrapolate_environ
[gw7] [  4%] PASSED tests/integration/test_cli.py::test_help
tests/integration/test_install_markers.py::test_specific_package_environment_markers
[gw6] [  4%] PASSED tests/integration/test_cli.py::test_bare_output
tests/integration/test_install_markers.py::test_install_package_with_invalid_python_version_specifier
[gw24] [  4%] PASSED tests/integration/test_import_requirements.py::test_auth_with_only_username_variable_passed_to_pipfile
tests/integration/test_install_misc.py::test_install_uri_with_extras
[gw10] [  5%] PASSED tests/integration/test_cli.py::test_pipenv_verify_without_pipfile_lock
tests/integration/test_install_paths.py::test_install_path_with_spaces
[gw23] [  5%] PASSED tests/integration/test_import_requirements.py::test_auth_with_username_redacted
tests/integration/test_install_twists.py::test_local_extras_install
[gw1] [  5%] PASSED tests/integration/test_cli.py::test_pipenv_py
tests/integration/test_cli.py::test_pipenv_site_packages
[gw8] [  5%] PASSED tests/integration/test_cli.py::test_install_parse_error
tests/integration/test_install_markers.py::test_package_environment_markers
[gw21] [  6%] PASSED tests/integration/test_dot_venv.py::test_venv_file[foo/test-venv]
[gw22] [  6%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_default_when_venv_exists
tests/integration/test_dot_venv.py::test_venv_name_accepts_custom_name_environment_variable
tests/integration/test_dot_venv.py::test_empty_venv_file
[gw11] [  6%] PASSED tests/integration/test_cli.py::test_pipenv_verify_locked_passing
tests/integration/test_cli.py::test_pipenv_verify_locked_outdated_failing
[gw18] [  6%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[no]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[off] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:43] "GET /simple/six/ HTTP/1.1" 404 745


[gw19] [  7%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[0]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[false]
[gw39] [  7%] FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table
tests/integration/test_install_basic.py::test_rewrite_outline_table_ooo
[gw36] [  7%] PASSED tests/integration/test_install_basic.py::test_create_pipfile_requires_python_full_version
tests/integration/test_install_twists.py::TestDirectDependencies::test_https_dependency_links_install
[gw36] [  7%] SKIPPED tests/integration/test_install_twists.py::TestDirectDependencies::test_https_dependency_links_install
tests/integration/test_install_twists.py::test_normalize_name_install
[gw17] [  8%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[yes]
tests/integration/test_dot_venv.py::test_venv_at_project_root[on]
[gw16] [  8%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[1]
tests/integration/test_dot_venv.py::test_venv_at_project_root[true] <LocalRequest: GET http://localhost:8080/simple/urllib3/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:45] "GET /simple/urllib3/ HTTP/1.1" 404 753

<LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:45] "GET /simple/six/ HTTP/1.1" 404 745

<LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:45] "GET /simple/requests/ HTTP/1.1" 404 755


[gw38] [  8%] PASSED tests/integration/test_install_basic.py::test_install_non_exist_dep
tests/integration/test_install_basic.py::test_install_package_with_dots
[gw26] [  8%] FAILED tests/integration/test_install_basic.py::test_basic_install
tests/integration/test_install_categories.py::test_multiple_category_install[prereq, other]
[gw29] [  8%] FAILED tests/integration/test_install_basic.py::test_extras_install
[gw35] [  9%] FAILED tests/integration/test_install_basic.py::test_system_and_deploy_work
tests/integration/test_install_basic.py::test_pinned_pipfile
tests/integration/test_install_basic.py::test_system_works
[gw28] [  9%] PASSED tests/integration/test_install_basic.py::test_install_with_version_req_default_operator
tests/integration/test_install_basic.py::test_install_without_dev_section
[gw2] [  9%] PASSED tests/integration/test_cli.py::test_pipenv_rm
tests/integration/test_install_misc.py::test_install_command_with_star_specifier <LocalRequest: GET http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:47] "GET /packages/plette/plette-0.2.2-py2.py3-none-any.whl HTTP/1.1" 404 820

<LocalRequest: GET http://localhost:8080/simple/setuptools/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:47] "GET /simple/setuptools/ HTTP/1.1" 404 759


[gw1] [  9%] PASSED tests/integration/test_cli.py::test_pipenv_site_packages
tests/integration/test_install_twists.py::test_install_local_uri_special_character
[gw24] [ 10%] FAILED tests/integration/test_install_misc.py::test_install_uri_with_extras
tests/integration/test_install_misc.py::test_install_major_version_star_specifier
[gw21] [ 10%] PASSED tests/integration/test_dot_venv.py::test_empty_venv_file
tests/integration/test_install_twists.py::test_outdated_should_compare_postreleases_without_failing
[gw11] [ 10%] PASSED tests/integration/test_cli.py::test_pipenv_verify_locked_outdated_failing
tests/integration/test_install_twists.py::test_skip_lock_respects_markers
[gw22] [ 10%] PASSED tests/integration/test_dot_venv.py::test_venv_name_accepts_custom_name_environment_variable
tests/integration/test_install_twists.py::test_install_skip_lock
[gw18] [ 11%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[off]
tests/integration/test_install_twists.py::test_install_dev_with_skip_lock
[gw31] [ 11%] PASSED tests/integration/test_install_basic.py::test_outline_table_specifier
tests/integration/test_install_basic.py::test_bad_packages
[gw19] [ 11%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[false]
tests/integration/test_install_uri.py::test_urls_work
[gw5] [ 11%] FAILED tests/integration/test_cli.py::test_pipenv_clean
[gw30] [ 12%] PASSED tests/integration/test_install_basic.py::test_alternative_version_specifier
tests/integration/test_install_categories.py::test_basic_category_install
tests/integration/test_install_basic.py::test_install_dev_use_default_constraints
[gw37] [ 12%] PASSED tests/integration/test_install_basic.py::test_install_with_pipfile_including_exact_python_version
tests/integration/test_install_basic.py::test_install_with_pipfile_including_invalid_python_version
[gw32] [ 12%] PASSED tests/integration/test_install_basic.py::test_requirements_to_pipfile <LocalRequest: GET http://localhost:8080/simple/six/>

tests/integration/test_install_basic.py::test_skip_requirements_when_pipfile 404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:51] "GET /simple/six/ HTTP/1.1" 404 745


[gw39] [ 12%] FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table_ooo
tests/integration/test_install_uri.py::test_vcs_install
[gw34] [ 13%] PASSED tests/integration/test_install_basic.py::test_install_venv_project_directory
tests/integration/test_install_markers.py::test_global_overrides_environment_markers
[gw7] [ 13%] PASSED tests/integration/test_install_markers.py::test_specific_package_environment_markers
tests/integration/test_install_markers.py::test_top_level_overrides_environment_markers <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:53] "GET /simple/six/ HTTP/1.1" 404 745


[gw16] [ 13%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[true]
tests/integration/test_install_uri.py::test_vcs_entry_supersedes_non_vcs
[gw17] [ 13%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[on]
tests/integration/test_install_uri.py::test_install_local_vcs_not_in_lockfile
[gw17] [ 14%] FAILED tests/integration/test_install_uri.py::test_install_local_vcs_not_in_lockfile
tests/integration/test_install_uri.py::test_get_vcs_refs
[gw33] [ 14%] FAILED tests/integration/test_install_basic.py::test_install_does_not_extrapolate_environ
tests/integration/test_install_twists.py::test_local_package
[gw33] [ 14%] SKIPPED tests/integration/test_install_twists.py::test_local_package
tests/integration/test_install_twists.py::test_local_tar_gz_file
[gw25] [ 14%] PASSED tests/integration/test_install_basic.py::test_mirror_install
tests/integration/test_install_basic.py::test_bad_mirror_install
[gw12] [ 15%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[1]
tests/integration/test_dot_venv.py::test_venv_in_project[true] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:55] "GET /simple/six/ HTTP/1.1" 404 745


[gw13] [ 15%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[yes]
tests/integration/test_dot_venv.py::test_venv_in_project[on]
[gw20] [ 15%] PASSED tests/integration/test_dot_venv.py::test_reuse_previous_venv
tests/integration/test_dot_venv.py::test_venv_file[test-venv]
[gw8] [ 15%] PASSED tests/integration/test_install_markers.py::test_package_environment_markers
tests/integration/test_install_markers.py::test_platform_python_implementation_marker
[gw9] [ 16%] PASSED tests/integration/test_cli.py::test_pipenv_outdated_prerelease
tests/integration/test_install_basic.py::test_install_tarball_is_actually_installed
[gw14] [ 16%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[no]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[off]
[gw26] [ 16%] FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq, other]
tests/integration/test_install_categories.py::test_multiple_category_install_from_requirements <LocalRequest: GET http://localhost:8080/simple/backports-html/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:56] "GET /simple/backports-html/ HTTP/1.1" 404 767


[gw15] [ 16%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[0]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[false] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:56] "GET /simple/six/ HTTP/1.1" 404 745


[gw27] [ 16%] PASSED tests/integration/test_install_basic.py::test_basic_dev_install
tests/integration/test_install_basic.py::test_install_without_dev
[gw22] [ 17%] FAILED tests/integration/test_install_twists.py::test_install_skip_lock
tests/integration/test_install_twists.py::test_skip_lock_installs_correct_version
[gw38] [ 17%] FAILED tests/integration/test_install_basic.py::test_install_package_with_dots
tests/integration/test_install_vcs.py::test_install_github_vcs
[gw0] [ 17%] PASSED tests/integration/test_cli.py::test_pipenv_venv
tests/integration/test_install_misc.py::test_install_full_wildcard_specifier
[gw39] [ 17%] FAILED tests/integration/test_install_uri.py::test_vcs_install
tests/integration/test_install_uri.py::test_install_git_tag <LocalRequest: GET http://localhost:8080/simple/notapackage/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:58] "GET /simple/notapackage/ HTTP/1.1" 404 761


[gw31] [ 18%] PASSED tests/integration/test_install_basic.py::test_bad_packages
tests/integration/test_lock.py::test_complex_lock_with_vcs_deps
[gw1] [ 18%] PASSED tests/integration/test_install_twists.py::test_install_local_uri_special_character
tests/integration/test_install_twists.py::test_multiple_editable_packages_should_not_race <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:59] "GET /simple/six/ HTTP/1.1" 404 745

<LocalRequest: GET http://localhost:8080/simple/ibm-db-sa-py3/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:59] "GET /simple/ibm-db-sa-py3/ HTTP/1.1" 404 765

<LocalRequest: GET http://localhost:8080/simple/apscheduler/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:46:59] "GET /simple/apscheduler/ HTTP/1.1" 404 761

<LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:00] "GET /simple/requests/ HTTP/1.1" 404 755


[gw30] [ 18%] FAILED tests/integration/test_install_categories.py::test_basic_category_install
tests/integration/test_install_categories.py::test_basic_category_install_from_requirements
[gw37] [ 18%] PASSED tests/integration/test_install_basic.py::test_install_with_pipfile_including_invalid_python_version
tests/integration/test_lock.py::test_complex_deps_lock_and_install_properly
[gw21] [ 19%] FAILED tests/integration/test_install_twists.py::test_outdated_should_compare_postreleases_without_failing
tests/integration/test_install_twists.py::test_install_remote_wheel_file_with_extras
[gw24] [ 19%] PASSED tests/integration/test_install_misc.py::test_install_major_version_star_specifier
tests/integration/test_lock.py::test_lock_includes_hashes_for_all_platforms
[gw28] [ 19%] PASSED tests/integration/test_install_basic.py::test_install_without_dev_section
tests/integration/test_lock.py::test_lock_gathers_pyproject_dependencies
[gw5] [ 19%] FAILED tests/integration/test_install_basic.py::test_install_dev_use_default_constraints
tests/integration/test_install_basic.py::test_install_does_not_exclude_packaging
[gw29] [ 20%] PASSED tests/integration/test_install_basic.py::test_pinned_pipfile
tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[False] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:01] "GET /simple/six/ HTTP/1.1" 404 745


tests/integration/test_install_markers.py::test_global_overrides_environment_markers
[gw16] [ 20%] FAILED tests/integration/test_install_uri.py::test_vcs_entry_supersedes_non_vcs
tests/integration/test_install_uri.py::test_vcs_can_use_markers
[gw2] [ 20%] PASSED tests/integration/test_install_misc.py::test_install_command_with_star_specifier
tests/integration/test_install_nested_setup.py::test_install_path_with_nested_setup_module
[gw32] [ 20%] FAILED tests/integration/test_install_basic.py::test_skip_requirements_when_pipfile
tests/integration/test_lock.py::test_private_index_lock_requirements
[gw38] [ 21%] FAILED tests/integration/test_install_vcs.py::test_install_github_vcs
tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[True]
[gw20] [ 21%] PASSED tests/integration/test_dot_venv.py::test_venv_file[test-venv]
tests/integration/test_lock.py::test_default_lock_overwrite_dev_lock
[gw39] [ 21%] FAILED tests/integration/test_install_uri.py::test_install_git_tag
tests/integration/test_pipenv.py::test_proper_names_unmanaged_virtualenv
[gw39] [ 21%] PASSED tests/integration/test_pipenv.py::test_proper_names_unmanaged_virtualenv
tests/integration/test_project.py::test_maintain_file_line_endings[\r\n]
[gw17] [ 22%] FAILED tests/integration/test_install_uri.py::test_get_vcs_refs
tests/integration/test_lock.py::test_lock_editable_vcs_with_ref_in_git
[gw29] [ 22%] FAILED tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[False]
tests/integration/test_install_vcs.py::test_install_vcs_ref_by_commit_hash
[gw3] [ 22%] PASSED tests/integration/test_cli.py::test_pipenv_graph
tests/integration/test_cli.py::test_pipenv_graph_reverse <LocalRequest: GET http://localhost:8080/simple/depends-on-marked-package/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:05] "GET /simple/depends-on-marked-package/ HTTP/1.1" 404 789


[gw7] [ 22%] PASSED tests/integration/test_install_markers.py::test_top_level_overrides_environment_markers
tests/integration/test_lock.py::test_lock_updated_source
tests/integration/test_install_markers.py::test_platform_python_implementation_marker
[gw38] [ 23%] FAILED tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[True]
tests/integration/test_project.py::test_maintain_file_line_endings[\n]
[gw37] [ 23%] PASSED tests/integration/test_lock.py::test_complex_deps_lock_and_install_properly
tests/integration/test_lock.py::test_lock_extras_without_install <LocalRequest: GET http://localhost:8080/simple/setuptools/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:07] "GET /simple/setuptools/ HTTP/1.1" 404 759


[gw1] [ 23%] FAILED tests/integration/test_install_twists.py::test_multiple_editable_packages_should_not_race
tests/integration/test_pipenv.py::test_directory_with_leading_dash <LocalRequest: GET http://localhost:8080/simple/yarl/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:08] "GET /simple/yarl/ HTTP/1.1" 404 747


[gw11] [ 23%] PASSED tests/integration/test_install_twists.py::test_skip_lock_respects_markers
tests/integration/test_install_twists.py::test_no_duplicate_source_on_install <LocalRequest: GET http://localhost:8080/simple/funcsigs/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:08] "GET /simple/funcsigs/ HTTP/1.1" 404 755


[gw33] [ 24%] FAILED tests/integration/test_install_twists.py::test_local_tar_gz_file
tests/integration/test_lock.py::test_lock_editable_vcs_with_markers_without_install
[gw34] [ 24%] FAILED tests/integration/test_install_markers.py::test_global_overrides_environment_markers
tests/integration/test_install_markers.py::test_resolver_unique_markers
[gw24] [ 24%] FAILED tests/integration/test_lock.py::test_lock_includes_hashes_for_all_platforms
tests/integration/test_lock.py::test_resolve_skip_unmatched_requirements
[gw16] [ 24%] FAILED tests/integration/test_install_uri.py::test_vcs_can_use_markers
tests/integration/test_project.py::test_get_source[True]
[gw35] [ 25%] PASSED tests/integration/test_install_basic.py::test_system_works
tests/integration/test_install_vcs.py::test_vcs_dev_package_install
[gw6] [ 25%] PASSED tests/integration/test_install_markers.py::test_install_package_with_invalid_python_version_specifier
tests/integration/test_install_markers.py::test_environment_variable_value_does_not_change_hash
[gw31] [ 25%] FAILED tests/integration/test_lock.py::test_complex_lock_with_vcs_deps
tests/integration/test_lock.py::test_lock_with_prereleases
[gw30] [ 25%] PASSED tests/integration/test_install_categories.py::test_basic_category_install_from_requirements
tests/integration/test_install_categories.py::test_multiple_category_install[prereq other]
[gw26] [ 25%] PASSED tests/integration/test_install_categories.py::test_multiple_category_install_from_requirements
tests/integration/test_install_categories.py::test_multiple_category_install_proceeds_in_order_specified
[gw26] [ 26%] SKIPPED tests/integration/test_install_categories.py::test_multiple_category_install_proceeds_in_order_specified
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_without_env_var_expansion
[gw17] [ 26%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_ref_in_git
[gw0] [ 26%] PASSED tests/integration/test_install_misc.py::test_install_full_wildcard_specifier
tests/integration/test_install_misc.py::test_install_single_equals_star_specifier
tests/integration/test_lock.py::test_lock_editable_vcs_with_extras_without_install
[gw22] [ 26%] PASSED tests/integration/test_install_twists.py::test_skip_lock_installs_correct_version
tests/integration/test_pipenv.py::test_update_locks
[gw25] [ 27%] PASSED tests/integration/test_install_basic.py::test_bad_mirror_install
tests/integration/test_lock.py::test_lockfile_with_empty_dict
[gw12] [ 27%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[true]
tests/integration/test_lock.py::test_lock_after_update_source_name <LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:13] "GET /simple/requests/ HTTP/1.1" 404 755


[gw13] [ 27%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[on]
tests/integration/test_lock.py::test_lock_nested_vcs_direct_url
[gw7] [ 27%] FAILED tests/integration/test_lock.py::test_lock_updated_source
tests/integration/test_lock.py::test_lock_editable_vcs_without_install
[gw15] [ 28%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[false]
tests/integration/test_lockfile.py::test_git_branch_contains_slashes
[gw15] [ 28%] PASSED tests/integration/test_lockfile.py::test_git_branch_contains_slashes
tests/integration/test_lockfile.py::test_git_branch_contains_subdirectory_fragment
[gw26] [ 28%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_without_env_var_expansion
tests/integration/test_requirements.py::test_requirements_from_deps[deps0-True-True-expected0]
[gw26] [ 28%] PASSED tests/integration/test_requirements.py::test_requirements_from_deps[deps0-True-True-expected0]
tests/integration/test_run.py::test_run_with_usr_env_shebang
[gw15] [ 29%] PASSED tests/integration/test_lockfile.py::test_git_branch_contains_subdirectory_fragment
tests/integration/test_run.py::test_scripts_with_package_functions <LocalRequest: GET http://localhost:8080/simple/tablib/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:15] "GET /simple/tablib/ HTTP/1.1" 404 751


[gw1] [ 29%] PASSED tests/integration/test_pipenv.py::test_directory_with_leading_dash
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile
[gw14] [ 29%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[off]
tests/integration/test_lock.py::test_pinned_pipfile_no_null_markers_when_extras
[gw28] [ 29%] PASSED tests/integration/test_lock.py::test_lock_gathers_pyproject_dependencies
tests/integration/test_lock.py::test_lock_requirements_file
[gw33] [ 30%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_markers_without_install
tests/integration/test_lock.py::test_lockfile_corrupted
[gw4] [ 30%] PASSED tests/integration/test_install_basic.py::test_category_not_sorted_without_directive
tests/integration/test_install_basic.py::test_category_sorted_with_directive_when_insalling_with_extras
[gw3] [ 30%] FAILED tests/integration/test_cli.py::test_pipenv_graph_reverse
tests/integration/test_project.py::test_no_sources_in_pipfile
[gw29] [ 30%] FAILED tests/integration/test_install_vcs.py::test_install_vcs_ref_by_commit_hash
tests/integration/test_project.py::test_run_in_virtualenv <LocalRequest: GET http://localhost:8080/simple/pytz/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:16] "GET /simple/pytz/ HTTP/1.1" 404 747

<LocalRequest: GET http://localhost:8080/simple/depends-on-marked-package/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:17] "GET /simple/depends-on-marked-package/ HTTP/1.1" 404 789


[gw25] [ 31%] PASSED tests/integration/test_lock.py::test_lockfile_with_empty_dict
tests/integration/test_lock.py::test_vcs_lock_respects_top_level_pins
[gw27] [ 31%] PASSED tests/integration/test_install_basic.py::test_install_without_dev
tests/integration/test_pipenv.py::test_deploy_works
[gw16] [ 31%] FAILED tests/integration/test_project.py::test_get_source[True]
tests/integration/test_requirements.py::test_requirements_with_git_requirements <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:17] "GET /simple/six/ HTTP/1.1" 404 745


[gw24] [ 31%] PASSED tests/integration/test_lock.py::test_resolve_skip_unmatched_requirements
tests/integration/test_requirements.py::test_requirements_generates_requirements_with_from_pipfile
[gw8] [ 32%] FAILED tests/integration/test_install_markers.py::test_platform_python_implementation_marker
tests/integration/test_lock.py::test_dev_lock_use_default_packages_as_constraint
[gw11] [ 32%] FAILED tests/integration/test_install_twists.py::test_no_duplicate_source_on_install
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_multiple_sources
[gw33] [ 32%] PASSED tests/integration/test_lock.py::test_lockfile_corrupted
tests/integration/test_sync.py::test_sync_error_without_lockfile
[gw16] [ 32%] PASSED tests/integration/test_requirements.py::test_requirements_with_git_requirements
tests/integration/test_uninstall.py::test_mirror_uninstall
[gw16] [ 33%] SKIPPED tests/integration/test_uninstall.py::test_mirror_uninstall
tests/integration/test_uninstall.py::test_uninstall_all_dev_with_shared_dependencies
[gw17] [ 33%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_extras_without_install
tests/integration/test_requirements.py::test_requirements_from_deps[deps2-True-True-expected2]
[gw17] [ 33%] PASSED tests/integration/test_requirements.py::test_requirements_from_deps[deps2-True-True-expected2]
tests/integration/test_uninstall.py::test_uninstall_category_with_shared_requirement
[gw5] [ 33%] PASSED tests/integration/test_install_basic.py::test_install_does_not_exclude_packaging
tests/integration/test_install_basic.py::test_install_will_supply_extra_pip_args
[gw5] [ 33%] SKIPPED tests/integration/test_install_basic.py::test_install_will_supply_extra_pip_args
tests/integration/test_uninstall.py::test_category_sorted_alphabetically_with_directive
[gw6] [ 34%] PASSED tests/integration/test_install_markers.py::test_environment_variable_value_does_not_change_hash
tests/integration/test_requirements.py::test_requirements_markers_get_included <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:21] "GET /simple/six/ HTTP/1.1" 404 745


[gw35] [ 34%] FAILED tests/integration/test_install_vcs.py::test_vcs_dev_package_install
tests/integration/test_lock.py::test_lock_handle_eggs
[gw33] [ 34%] PASSED tests/integration/test_sync.py::test_sync_error_without_lockfile
tests/integration/test_uninstall.py::test_normalize_name_uninstall
[gw13] [ 34%] FAILED tests/integration/test_lock.py::test_lock_nested_vcs_direct_url
tests/integration/test_lock.py::test_lock_package_with_compatible_release_specifier <LocalRequest: GET http://localhost:8080/simple/jdcal/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:22] "GET /simple/jdcal/ HTTP/1.1" 404 749


[gw32] [ 35%] PASSED tests/integration/test_lock.py::test_private_index_lock_requirements
tests/integration/test_lock.py::test_private_index_lock_requirements_for_not_canonical_package
[gw30] [ 35%] FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq other]
tests/integration/test_requirements.py::test_requirements_hashes_get_included
[gw7] [ 35%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_without_install
tests/integration/test_run.py::test_scripts
[gw22] [ 35%] FAILED tests/integration/test_pipenv.py::test_update_locks
tests/integration/test_run.py::test_env
[gw15] [ 36%] PASSED tests/integration/test_run.py::test_scripts_with_package_functions
tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[False]
[gw26] [ 36%] PASSED tests/integration/test_run.py::test_run_with_usr_env_shebang
tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[True]
[gw6] [ 36%] PASSED tests/integration/test_requirements.py::test_requirements_markers_get_included
tests/integration/test_uninstall.py::test_category_not_sorted_without_directive <LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:24] "GET /simple/requests/ HTTP/1.1" 404 755


[gw30] [ 36%] PASSED tests/integration/test_requirements.py::test_requirements_hashes_get_included
[gw25] [ 37%] FAILED tests/integration/test_lock.py::test_vcs_lock_respects_top_level_pins
tests/integration/test_update.py::test_get_modified_pipfile_entries_changed_version
tests/integration/test_uninstall.py::test_uninstall_requests
[gw8] [ 37%] FAILED tests/integration/test_lock.py::test_dev_lock_use_default_packages_as_constraint
tests/integration/test_lock.py::test_lock_specific_named_category
[gw22] [ 37%] PASSED tests/integration/test_run.py::test_env
tests/integration/test_update.py::test_update_without_lockfile
[gw26] [ 37%] PASSED tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[True]
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"-expected_updates1]
[gw12] [ 38%] PASSED tests/integration/test_lock.py::test_lock_after_update_source_name
tests/integration/test_lock.py::test_lock_nested_direct_url
[gw15] [ 38%] PASSED tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[False]
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.31.0"-expected_updates0]
[gw0] [ 38%] PASSED tests/integration/test_install_misc.py::test_install_single_equals_star_specifier
tests/integration/test_requirements.py::test_requirements_from_deps[deps1-True-True-expected1]
[gw0] [ 38%] PASSED tests/integration/test_requirements.py::test_requirements_from_deps[deps1-True-True-expected1]
tests/integration/test_upgrade.py::test_upgrade_only_adds_to_explicit_categories
[gw36] [ 39%] PASSED tests/integration/test_install_twists.py::test_normalize_name_install
tests/integration/test_install_uri.py::test_install_named_index_alias
[gw37] [ 39%] PASSED tests/integration/test_lock.py::test_lock_extras_without_install
[gw9] [ 39%] PASSED tests/integration/test_install_basic.py::test_install_tarball_is_actually_installed
tests/integration/test_install_basic.py::test_category_sorted_alphabetically_with_directive
tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_with_yes
[gw37] [ 39%] PASSED tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_with_yes
tests/integration/test_windows.py::test_case_changes_windows
[gw37] [ 40%] SKIPPED tests/integration/test_windows.py::test_case_changes_windows
tests/integration/test_windows.py::test_local_path_windows
[gw37] [ 40%] SKIPPED tests/integration/test_windows.py::test_local_path_windows
tests/integration/test_windows.py::test_local_path_windows_forward_slash
[gw37] [ 40%] SKIPPED tests/integration/test_windows.py::test_local_path_windows_forward_slash
tests/integration/test_windows.py::test_pipenv_clean_windows
[gw37] [ 40%] SKIPPED tests/integration/test_windows.py::test_pipenv_clean_windows
tests/integration/test_windows.py::test_pipenv_run_with_special_chars_windows
[gw37] [ 41%] SKIPPED tests/integration/test_windows.py::test_pipenv_run_with_special_chars_windows
tests/unit/test_cmdparse.py::test_parse
[gw37] [ 41%] PASSED tests/unit/test_cmdparse.py::test_parse
tests/unit/test_cmdparse.py::test_parse_error
[gw37] [ 41%] PASSED tests/unit/test_cmdparse.py::test_parse_error
tests/unit/test_cmdparse.py::test_extend
[gw37] [ 41%] PASSED tests/unit/test_cmdparse.py::test_extend
tests/unit/test_cmdparse.py::test_cmdify
[gw37] [ 41%] PASSED tests/unit/test_cmdparse.py::test_cmdify
tests/unit/test_cmdparse.py::test_cmdify_complex
[gw37] [ 42%] PASSED tests/unit/test_cmdparse.py::test_cmdify_complex
tests/unit/test_cmdparse.py::test_cmdify_quote_if_paren_in_command
[gw37] [ 42%] PASSED tests/unit/test_cmdparse.py::test_cmdify_quote_if_paren_in_command
tests/unit/test_cmdparse.py::test_cmdify_quote_if_carets
[gw37] [ 42%] PASSED tests/unit/test_cmdparse.py::test_cmdify_quote_if_carets
tests/unit/test_core.py::test_suppress_nested_venv_warning
[gw37] [ 42%] PASSED tests/unit/test_core.py::test_suppress_nested_venv_warning
tests/unit/test_core.py::test_load_dot_env_from_environment_variable_location
[gw37] [ 43%] PASSED tests/unit/test_core.py::test_load_dot_env_from_environment_variable_location
tests/unit/test_core.py::test_doesnt_load_dot_env_if_disabled
[gw37] [ 43%] PASSED tests/unit/test_core.py::test_doesnt_load_dot_env_if_disabled
tests/unit/test_core.py::test_load_dot_env_warns_if_file_doesnt_exist
[gw37] [ 43%] PASSED tests/unit/test_core.py::test_load_dot_env_warns_if_file_doesnt_exist
tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url
[gw37] [ 43%] PASSED tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url
tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url_and_extras
[gw37] [ 44%] PASSED tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url_and_extras
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-True]
[gw37] [ 44%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-True]
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-False]
[gw37] [ 44%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-False]
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-True]
[gw37] [ 44%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-True]
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-False]
[gw37] [ 45%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-False]
tests/unit/test_environments.py::test_get_from_env_default[True-None]
[gw37] [ 45%] PASSED tests/unit/test_environments.py::test_get_from_env_default[True-None]
tests/unit/test_environments.py::test_get_from_env_default[True-default]
[gw37] [ 45%] PASSED tests/unit/test_environments.py::test_get_from_env_default[True-default]
tests/unit/test_environments.py::test_get_from_env_default[True-1]
[gw37] [ 45%] PASSED tests/unit/test_environments.py::test_get_from_env_default[True-1]
tests/unit/test_environments.py::test_get_from_env_default[False-None]
[gw37] [ 46%] PASSED tests/unit/test_environments.py::test_get_from_env_default[False-None]
tests/unit/test_environments.py::test_get_from_env_default[False-default]
[gw37] [ 46%] PASSED tests/unit/test_environments.py::test_get_from_env_default[False-default]
tests/unit/test_environments.py::test_get_from_env_default[False-1]
[gw37] [ 46%] PASSED tests/unit/test_environments.py::test_get_from_env_default[False-1]
tests/unit/test_environments.py::test_pipenv_venv_in_project_set_true
[gw37] [ 46%] PASSED tests/unit/test_environments.py::test_pipenv_venv_in_project_set_true
tests/unit/test_environments.py::test_pipenv_venv_in_project_set_false
[gw37] [ 47%] PASSED tests/unit/test_environments.py::test_pipenv_venv_in_project_set_false
tests/unit/test_environments.py::test_pipenv_venv_in_project_unset
[gw37] [ 47%] PASSED tests/unit/test_environments.py::test_pipenv_venv_in_project_unset
tests/unit/test_funktools.py::test_unnest
[gw37] [ 47%] PASSED tests/unit/test_funktools.py::test_unnest
tests/unit/test_funktools.py::test_is_iterable[iterable0-True]
[gw37] [ 47%] PASSED tests/unit/test_funktools.py::test_is_iterable[iterable0-True]
tests/unit/test_funktools.py::test_is_iterable[iterable1-True]
[gw37] [ 48%] PASSED tests/unit/test_funktools.py::test_is_iterable[iterable1-True]
tests/unit/test_funktools.py::test_is_iterable[abcdef-True]
[gw37] [ 48%] PASSED tests/unit/test_funktools.py::test_is_iterable[abcdef-True]
tests/unit/test_funktools.py::test_is_iterable[None-False]
[gw37] [ 48%] PASSED tests/unit/test_funktools.py::test_is_iterable[None-False]
tests/unit/test_funktools.py::test_is_iterable[1234-False]
[gw37] [ 48%] PASSED tests/unit/test_funktools.py::test_is_iterable[1234-False]
tests/unit/test_funktools.py::test_unnest_none
[gw3] [ 49%] PASSED tests/integration/test_project.py::test_no_sources_in_pipfile
[gw37] [ 49%] PASSED tests/unit/test_funktools.py::test_unnest_none
tests/integration/test_sync.py::test_mirror_lock_sync
tests/unit/test_funktools.py::test_dedup
[gw37] [ 49%] PASSED tests/unit/test_funktools.py::test_dedup
tests/unit/test_utils.py::test_convert_deps_to_pip[deps0-expected0]
[gw37] [ 49%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps0-expected0]
tests/unit/test_utils.py::test_convert_deps_to_pip[deps1-expected1]
[gw37] [ 50%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps1-expected1]
tests/unit/test_utils.py::test_convert_deps_to_pip[deps2-expected2]
[gw37] [ 50%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps2-expected2]
tests/unit/test_utils.py::test_convert_deps_to_pip[deps3-expected3]
[gw37] [ 50%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps3-expected3]
tests/unit/test_utils.py::test_convert_deps_to_pip[deps4-expected4]
[gw37] [ 50%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps4-expected4]
tests/unit/test_utils.py::test_convert_deps_to_pip[deps5-expected5]
[gw37] [ 50%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps5-expected5]
tests/unit/test_utils.py::test_convert_deps_to_pip[deps6-expected6]
[gw37] [ 51%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps6-expected6]
tests/unit/test_utils.py::test_convert_deps_to_pip[deps7-expected7]
[gw37] [ 51%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps7-expected7]
tests/unit/test_utils.py::test_convert_deps_to_pip_star_specifier
[gw37] [ 51%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_star_specifier
tests/unit/test_utils.py::test_convert_deps_to_pip_extras_no_version
[gw37] [ 51%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_extras_no_version
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps0-expected0]
[gw37] [ 52%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps0-expected0]
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps1-expected1]
[gw37] [ 52%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps1-expected1]
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps2-expected2]
[gw37] [ 52%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps2-expected2]
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way_uvicorn
[gw37] [ 52%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way_uvicorn
tests/unit/test_utils.py::test_get_constraints_from_deps[deps0-expected0]
[gw37] [ 53%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps0-expected0]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps1-expected1]
[gw37] [ 53%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps1-expected1]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps2-expected2]
[gw37] [ 53%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps2-expected2]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps3-expected3]
[gw37] [ 53%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps3-expected3]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps4-expected4]
[gw37] [ 54%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps4-expected4]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps5-expected5]
[gw37] [ 54%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps5-expected5]
tests/unit/test_utils.py::test_parse_indexes[-i https://example.com/simple/-result0]
[gw37] [ 54%] PASSED tests/unit/test_utils.py::test_parse_indexes[-i https://example.com/simple/-result0]
tests/unit/test_utils.py::test_parse_indexes[--extra-index-url=https://example.com/simple/-result1]
[gw37] [ 54%] PASSED tests/unit/test_utils.py::test_parse_indexes[--extra-index-url=https://example.com/simple/-result1]
tests/unit/test_utils.py::test_parse_indexes[--trusted-host=example.com-result2]
[gw37] [ 55%] PASSED tests/unit/test_utils.py::test_parse_indexes[--trusted-host=example.com-result2]
tests/unit/test_utils.py::test_parse_indexes[# -i https://example.com/simple/-result3]
[gw37] [ 55%] PASSED tests/unit/test_utils.py::test_parse_indexes[# -i https://example.com/simple/-result3]
tests/unit/test_utils.py::test_parse_indexes[requests # -i https://example.com/simple/-result4]
[gw37] [ 55%] PASSED tests/unit/test_utils.py::test_parse_indexes[requests # -i https://example.com/simple/-result4]
tests/unit/test_utils.py::test_parse_indexes_individual_lines[-i https://example.com/simple/ --extra-index-url=https://extra.com/simple/]
[gw37] [ 55%] PASSED tests/unit/test_utils.py::test_parse_indexes_individual_lines[-i https://example.com/simple/ --extra-index-url=https://extra.com/simple/]
tests/unit/test_utils.py::test_parse_indexes_individual_lines[--extra-index-url https://example.com/simple/ --trusted-host=example.com]
[gw37] [ 56%] PASSED tests/unit/test_utils.py::test_parse_indexes_individual_lines[--extra-index-url https://example.com/simple/ --trusted-host=example.com]
tests/unit/test_utils.py::test_parse_indexes_individual_lines[requests -i https://example.com/simple/]
[gw37] [ 56%] PASSED tests/unit/test_utils.py::test_parse_indexes_individual_lines[requests -i https://example.com/simple/]
tests/unit/test_utils.py::TestUtils::test_is_required_version[*-*-True]
[gw37] [ 56%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[*-*-True]
tests/unit/test_utils.py::TestUtils::test_is_required_version[2.1.6-==2.1.4-False]
[gw37] [ 56%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[2.1.6-==2.1.4-False]
tests/unit/test_utils.py::TestUtils::test_is_required_version[20160913->=20140815-True]
[gw37] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[20160913->=20140815-True]
tests/unit/test_utils.py::TestUtils::test_is_required_version[1.4-specified_ver3-True]
[gw37] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[1.4-specified_ver3-True]
tests/unit/test_utils.py::TestUtils::test_is_required_version[2.13.0-specified_ver4-False]
[gw37] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[2.13.0-specified_ver4-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[entry0-True]
[gw37] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[entry0-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[entry1-True]
[gw37] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[entry1-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[*-False]
[gw37] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[*-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[entry3-False]
[gw37] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[entry3-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[package-False]
[gw37] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[package-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[git+https://github.com/requests/requests.git#egg=requests-True]
[gw37] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[git+https://github.com/requests/requests.git#egg=requests-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[git+git@github.com:requests/requests.git#egg=requests-True]
[gw37] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[git+git@github.com:requests/requests.git#egg=requests-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[gitdb2-False]
[gw37] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[gitdb2-False]
tests/unit/test_utils.py::TestUtils::test_python_version_from_bad_path
[gw37] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_from_bad_path
tests/unit/test_utils.py::TestUtils::test_python_version_from_non_python
[gw37] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_from_non_python
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2-3.6.2]
[gw37] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2-3.6.2]
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2 :: Continuum Analytics, Inc.-3.6.2]
[gw37] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2 :: Continuum Analytics, Inc.-3.6.2]
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.20 :: Continuum Analytics, Inc.-3.6.20]
[gw37] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.20 :: Continuum Analytics, Inc.-3.6.20]
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.5.3 (3f6eaa010fce78cc7973bdc1dfdb95970f08fed2, Jan 13 2018, 18:14:01)\n[PyPy 5.10.1 with GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]-3.5.3]
[gw37] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.5.3 (3f6eaa010fce78cc7973bdc1dfdb95970f08fed2, Jan 13 2018, 18:14:01)\n[PyPy 5.10.1 with GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]-3.5.3]
tests/unit/test_utils.py::TestUtils::test_is_valid_url
[gw37] [ 61%] PASSED tests/unit/test_utils.py::TestUtils::test_is_valid_url
tests/unit/test_utils.py::TestUtils::test_download_file <LocalRequest: GET http://localhost:8080/simple/randomwords/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:29] "GET /simple/randomwords/ HTTP/1.1" 404 761


[gw37] [ 61%] PASSED tests/unit/test_utils.py::TestUtils::test_download_file
tests/unit/test_utils.py::TestUtils::test_is_python_command[python-True]
[gw37] [ 61%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python3.7-True]
[gw37] [ 61%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python3.7-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python2.7-True]
[gw37] [ 62%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python2.7-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python2-True]
[gw37] [ 62%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python2-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python3-True]
[gw37] [ 62%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python3-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[pypy3-True]
[gw37] [ 62%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[pypy3-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[anaconda3-5.3.0-True]
[gw37] [ 63%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[anaconda3-5.3.0-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[which-False]
[gw37] [ 63%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[which-False]
tests/unit/test_utils.py::TestUtils::test_is_python_command[vim-False]
[gw37] [ 63%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[vim-False]
tests/unit/test_utils.py::TestUtils::test_is_python_command[miniconda-True]
[gw37] [ 63%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[miniconda-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[micropython-True]
[gw37] [ 64%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[micropython-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[ironpython-True]
[gw37] [ 64%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[ironpython-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[jython3.5-True]
[gw37] [ 64%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[jython3.5-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[2-True]
[gw37] [ 64%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[2-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[2.7-True]
[gw37] [ 65%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[2.7-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[3.7-True]
[gw37] [ 65%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[3.7-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[3-True]
[gw37] [ 65%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[3-True]
tests/unit/test_utils.py::TestUtils::test_new_line_end_of_toml_file
[gw37] [ 65%] PASSED tests/unit/test_utils.py::TestUtils::test_new_line_end_of_toml_file
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[c:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
[gw37] [ 66%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[c:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[C:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
[gw37] [ 66%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[C:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[\\\\host\\share\\file.zip-\\\\host\\share\\file.zip]
[gw37] [ 66%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[\\\\host\\share\\file.zip-\\\\host\\share\\file.zip]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[artifacts\\file.zip-artifacts\\file.zip]
[gw37] [ 66%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[artifacts\\file.zip-artifacts\\file.zip]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[.\\artifacts\\file.zip-.\\artifacts\\file.zip]
[gw37] [ 66%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[.\\artifacts\\file.zip-.\\artifacts\\file.zip]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[..\\otherproject\\file.zip-..\\otherproject\\file.zip]
[gw37] [ 67%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[..\\otherproject\\file.zip-..\\otherproject\\file.zip]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[/usr/local/bin/python-/usr/local/bin/python]
[gw37] [ 67%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[/usr/local/bin/python-/usr/local/bin/python]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[artifacts/file.zip-artifacts/file.zip]
[gw37] [ 67%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[artifacts/file.zip-artifacts/file.zip]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[./artifacts/file.zip-./artifacts/file.zip]
[gw37] [ 67%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[./artifacts/file.zip-./artifacts/file.zip]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[../otherproject/file.zip-../otherproject/file.zip]
[gw37] [ 68%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[../otherproject/file.zip-../otherproject/file.zip]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources0-expected_args0]
[gw37] [ 68%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources0-expected_args0]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources1-expected_args1]
[gw37] [ 68%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources1-expected_args1]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources2-expected_args2]
[gw37] [ 68%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources2-expected_args2]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources3-expected_args3]
[gw37] [ 69%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources3-expected_args3]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources4-expected_args4]
[gw37] [ 69%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources4-expected_args4]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources5-expected_args5]
[gw37] [ 69%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources5-expected_args5]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources6-expected_args6]
[gw37] [ 69%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources6-expected_args6]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources7-expected_args7]
[gw37] [ 70%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources7-expected_args7]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources8-expected_args8]
[gw37] [ 70%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources8-expected_args8]
tests/unit/test_utils.py::TestUtils::test_invalid_prepare_pip_source_args
[gw37] [ 70%] PASSED tests/unit/test_utils.py::TestUtils::test_invalid_prepare_pip_source_args
tests/unit/test_utils.py::TestUtils::test_project_python_tries_python3_before_python_if_system_is_true
[gw37] [ 70%] PASSED tests/unit/test_utils.py::TestUtils::test_project_python_tries_python3_before_python_if_system_is_true
tests/unit/test_utils.py::TestUtils::test_env_to_bool[True-True]
[gw37] [ 71%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[True-True]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[False-False]
[gw19] [ 71%] PASSED tests/integration/test_install_uri.py::test_urls_work
[gw37] [ 71%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[False-False]
tests/integration/test_install_uri.py::test_file_urls_work
tests/unit/test_utils.py::TestUtils::test_env_to_bool[true-True]
[gw37] [ 71%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[true-True]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[off-False]
[gw37] [ 72%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[off-False]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[0-False]
[gw37] [ 72%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[0-False]
tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_true
[gw37] [ 72%] PASSED tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_true
tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_false
[gw37] [ 72%] PASSED tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_false
tests/unit/test_utils.py::TestUtils::test_is_env_truthy_does_not_exisxt
[gw37] [ 73%] PASSED tests/unit/test_utils.py::TestUtils::test_is_env_truthy_does_not_exisxt
tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_nt
[gw37] [ 73%] SKIPPED tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_nt
tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_posix
[gw37] [ 73%] PASSED tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_posix
tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_not_found
[gw37] [ 73%] SKIPPED tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_not_found
tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_found
[gw37] [ 74%] SKIPPED tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_found
tests/unit/test_vcs.py::test_vcs_url_processor_basic_expansion
[gw37] [ 74%] PASSED tests/unit/test_vcs.py::test_vcs_url_processor_basic_expansion
tests/unit/test_vcs.py::test_vcs_url_processor_auth_handling
[gw37] [ 74%] PASSED tests/unit/test_vcs.py::test_vcs_url_processor_auth_handling
tests/unit/test_vcs.py::test_vcs_url_processor_missing_env_var
[gw37] [ 74%] PASSED tests/unit/test_vcs.py::test_vcs_url_processor_missing_env_var
tests/unit/test_vcs.py::test_install_req_from_pipfile_vcs_with_env_vars
[gw37] [ 75%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_vcs_with_env_vars
tests/unit/test_vcs.py::test_install_req_from_pipfile_with_auth
[gw37] [ 75%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_with_auth
tests/unit/test_vcs.py::test_install_req_from_pipfile_editable
[gw37] [ 75%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_editable
tests/unit/test_vcs.py::test_install_req_from_pipfile_subdirectory
[gw37] [ 75%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_subdirectory
tests/unit/test_vcs.py::test_various_vcs_url_formats[git+https://${HOST}/${REPO}.git-https://github.com/org/repo.git-package-name @ git+https://${HOST}/${REPO}.git@main]
[gw37] [ 75%] PASSED tests/unit/test_vcs.py::test_various_vcs_url_formats[git+https://${HOST}/${REPO}.git-https://github.com/org/repo.git-package-name @ git+https://${HOST}/${REPO}.git@main]
tests/unit/test_vcs.py::test_various_vcs_url_formats[git+ssh://${USER}@${HOST}:${REPO}.git-git+ssh://git@${HOST}:${REPO}.git-package-name @ git+ssh://${USER}@${HOST}:${REPO}.git@main]
[gw37] [ 76%] PASSED tests/unit/test_vcs.py::test_various_vcs_url_formats[git+ssh://${USER}@${HOST}:${REPO}.git-git+ssh://git@${HOST}:${REPO}.git-package-name @ git+ssh://${USER}@${HOST}:${REPO}.git@main]
tests/unit/test_vcs.py::test_git_ssh_shorthand_format
[gw37] [ 76%] PASSED tests/unit/test_vcs.py::test_git_ssh_shorthand_format
tests/unit/test_vcs.py::test_git_url_format_variations
[gw37] [ 76%] PASSED tests/unit/test_vcs.py::test_git_url_format_variations
tests/unit/test_vcs.py::test_ssh_protocol_variations
[gw37] [ 76%] PASSED tests/unit/test_vcs.py::test_ssh_protocol_variations
tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git-]
[gw37] [ 77%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git-]
tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@dev-dev]
[gw37] [ 77%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@dev-dev]
tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@feature-feature]
[gw37] [ 77%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@feature-feature]
tests/unit/test_vcs.py::test_complex_ssh_url_handling
[gw37] [ 77%] PASSED tests/unit/test_vcs.py::test_complex_ssh_url_handling
tests/unit/test_vcs.py::test_git_protocol_handling
[gw37] [ 78%] PASSED tests/unit/test_vcs.py::test_git_protocol_handling
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+]
[gw37] [ 78%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+]
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+https://]
[gw37] [ 78%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+https://]
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+ssh://]
[gw37] [ 78%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+ssh://]
[gw31] [ 79%] PASSED tests/integration/test_lock.py::test_lock_with_prereleases
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+git://]
tests/integration/test_requirements.py::test_requirements_markers_get_excluded
[gw37] [ 79%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+git://]
tests/unit/test_vendor.py::test_token_date[dt0-1992-08-19]
[gw37] [ 79%] PASSED tests/unit/test_vendor.py::test_token_date[dt0-1992-08-19]
tests/unit/test_vendor.py::test_token_date[dt1-15:10:00]
[gw37] [ 79%] PASSED tests/unit/test_vendor.py::test_token_date[dt1-15:10:00]
tests/unit/test_vendor.py::test_token_date[dt2-15:10:00+00:00]
[gw37] [ 80%] PASSED tests/unit/test_vendor.py::test_token_date[dt2-15:10:00+00:00]
tests/unit/test_vendor.py::test_token_date[dt3-15:10:00+08:00]
[gw37] [ 80%] PASSED tests/unit/test_vendor.py::test_token_date[dt3-15:10:00+08:00]
tests/unit/test_vendor.py::test_token_date[dt4-1992-08-19T15:10:00]
[gw37] [ 80%] PASSED tests/unit/test_vendor.py::test_token_date[dt4-1992-08-19T15:10:00]
tests/unit/test_vendor.py::test_token_date[dt5-1992-08-19T15:10:00Z]
[gw37] [ 80%] PASSED tests/unit/test_vendor.py::test_token_date[dt5-1992-08-19T15:10:00Z]
tests/unit/test_vendor.py::test_token_date[dt6-1992-08-19T15:10:00+08:00]
[gw37] [ 81%] PASSED tests/unit/test_vendor.py::test_token_date[dt6-1992-08-19T15:10:00+08:00]
[gw35] [ 81%] FAILED tests/integration/test_lock.py::test_lock_handle_eggs
tests/integration/test_uninstall.py::test_uninstall_without_venv <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:31] "GET /simple/six/ HTTP/1.1" 404 745


[gw13] [ 81%] FAILED tests/integration/test_lock.py::test_lock_package_with_compatible_release_specifier
tests/integration/test_update.py::test_update_outdated_with_outdated_package[--dev] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:32] "GET /simple/six/ HTTP/1.1" 404 745


[gw31] [ 81%] PASSED tests/integration/test_requirements.py::test_requirements_markers_get_excluded
tests/unit/test_vcs.py::test_normalize_vcs_url_with_env_vars
[gw31] [ 82%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_with_env_vars
[gw11] [ 82%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_multiple_sources
tests/integration/test_uninstall.py::test_uninstall_all_dev
[gw7] [ 82%] PASSED tests/integration/test_run.py::test_scripts
tests/integration/test_update.py::test_get_modified_pipfile_entries_vcs_changes
[gw8] [ 82%] FAILED tests/integration/test_lock.py::test_lock_specific_named_category
[gw28] [ 83%] PASSED tests/integration/test_lock.py::test_lock_requirements_file
tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[False]
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {version = "==2.31.0", extras = ["security"]}-[packages]\nrequests = {version = "==2.31.0", extras = ["security", "socks"]}-expected_updates5] <LocalRequest: GET http://localhost:8080/simple/test-package/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:34] "GET /simple/test-package/ HTTP/1.1" 404 763

<LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:34] "GET /simple/six/ HTTP/1.1" 404 745


[gw20] [ 83%] PASSED tests/integration/test_lock.py::test_default_lock_overwrite_dev_lock
tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
[gw12] [ 83%] FAILED tests/integration/test_lock.py::test_lock_nested_direct_url
tests/integration/test_upgrade.py::test_pipenv_dependency_incompatibility_resolution
[gw34] [ 83%] PASSED tests/integration/test_install_markers.py::test_resolver_unique_markers
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_from_categories
[gw3] [ 83%] FAILED tests/integration/test_sync.py::test_mirror_lock_sync
tests/unit/test_help.py::test_help
[gw26] [ 84%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"-expected_updates1]
tests/integration/test_upgrade.py::test_category_not_sorted_without_directive
[gw15] [ 84%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.31.0"-expected_updates0]
tests/integration/test_upgrade.py::test_upgrade_updates_lockfile_in_all_categories
[gw39] [ 84%] PASSED tests/integration/test_project.py::test_maintain_file_line_endings[\r\n]
tests/integration/test_project.py::test_many_indexes
[gw3] [ 84%] PASSED tests/unit/test_help.py::test_help
[gw1] [ 85%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile
tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[True]
[gw27] [ 85%] PASSED tests/integration/test_pipenv.py::test_deploy_works
tests/integration/test_uninstall.py::test_uninstall_django
[gw27] [ 85%] SKIPPED tests/integration/test_uninstall.py::test_uninstall_django
[gw17] [ 85%] PASSED tests/integration/test_uninstall.py::test_uninstall_category_with_shared_requirement
tests/integration/test_uninstall.py::test_uninstall_multiple_categories <LocalRequest: GET http://localhost:8080/simple/tablib/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:41] "GET /simple/tablib/ HTTP/1.1" 404 751

<LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:41] "GET /simple/requests/ HTTP/1.1" 404 755

<LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:41] "GET /simple/six/ HTTP/1.1" 404 745


[gw38] [ 86%] PASSED tests/integration/test_project.py::test_maintain_file_line_endings[\n]
tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_no_yes
[gw19] [ 86%] FAILED tests/integration/test_install_uri.py::test_file_urls_work
tests/unit/test_utils.py::TestUtils::test_env_to_bool[1-True]
[gw19] [ 86%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[1-True]
[gw38] [ 86%] PASSED tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_no_yes
[gw11] [ 87%] FAILED tests/integration/test_uninstall.py::test_uninstall_all_dev
tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
[gw30] [ 87%] PASSED tests/integration/test_update.py::test_get_modified_pipfile_entries_changed_version
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"\n[dev-packages]-[packages]\nrequests = "==2.31.0"\n[dev-packages]\npytest = "==7.4.0"-expected_updates3]
[gw7] [ 87%] FAILED tests/integration/test_update.py::test_get_modified_pipfile_entries_vcs_changes
[gw24] [ 87%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_with_from_pipfile
tests/integration/test_uninstall.py::test_uninstall_all_local_files
[gw29] [ 88%] PASSED tests/integration/test_project.py::test_run_in_virtualenv
tests/integration/test_sync.py::test_sync_should_not_lock
[gw8] [ 88%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {version = "==2.31.0", extras = ["security"]}-[packages]\nrequests = {version = "==2.31.0", extras = ["security", "socks"]}-expected_updates5] <LocalRequest: GET http://localhost:8080/simple/click/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:43] "GET /simple/click/ HTTP/1.1" 404 749

<LocalRequest: GET http://localhost:8080/simple/pip/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:44] "GET /simple/pip/ HTTP/1.1" 404 745


[gw32] [ 88%] PASSED tests/integration/test_lock.py::test_private_index_lock_requirements_for_not_canonical_package
tests/integration/test_update.py::test_get_modified_pipfile_entries_new_package
[gw13] [ 88%] FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[--dev]
[gw36] [ 89%] FAILED tests/integration/test_install_uri.py::test_install_named_index_alias
tests/integration/test_install_uri.py::test_install_specifying_index_url
[gw5] [ 89%] PASSED tests/integration/test_uninstall.py::test_category_sorted_alphabetically_with_directive
tests/integration/test_uninstall.py::test_sorting_handles_str_values_and_dict_values
[gw6] [ 89%] PASSED tests/integration/test_uninstall.py::test_category_not_sorted_without_directive
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"\nurllib3 = "==2.0.0"-expected_updates2]
[gw33] [ 89%] PASSED tests/integration/test_uninstall.py::test_normalize_name_uninstall
tests/integration/test_update.py::test_update_outdated_with_outdated_package[]
[gw24] [ 90%] FAILED tests/integration/test_uninstall.py::test_uninstall_all_local_files
[gw16] [ 90%] PASSED tests/integration/test_uninstall.py::test_uninstall_all_dev_with_shared_dependencies
tests/integration/test_uninstall.py::test_uninstall_missing_parameters
[gw25] [ 90%] PASSED tests/integration/test_uninstall.py::test_uninstall_requests
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4] <LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:47] "GET /simple/requests/ HTTP/1.1" 404 755


[gw20] [ 90%] FAILED tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
[gw22] [ 91%] PASSED tests/integration/test_update.py::test_update_without_lockfile
tests/integration/test_upgrade.py::test_category_sorted_alphabetically_with_directive
[gw35] [ 91%] PASSED tests/integration/test_uninstall.py::test_uninstall_without_venv
[gw4] [ 91%] PASSED tests/integration/test_install_basic.py::test_category_sorted_with_directive_when_insalling_with_extras
tests/integration/test_install_basic.py::test_install_respects_lockfile_versions
[gw28] [ 91%] PASSED tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[False]
[gw29] [ 91%] PASSED tests/integration/test_sync.py::test_sync_should_not_lock
[gw26] [ 92%] PASSED tests/integration/test_upgrade.py::test_category_not_sorted_without_directive
[gw30] [ 92%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"\n[dev-packages]-[packages]\nrequests = "==2.31.0"\n[dev-packages]\npytest = "==7.4.0"-expected_updates3]
[gw23] [ 92%] PASSED tests/integration/test_install_twists.py::test_local_extras_install
tests/integration/test_install_twists.py::test_local_extras_install_alternate
[gw39] [ 92%] PASSED tests/integration/test_project.py::test_many_indexes
[gw18] [ 93%] PASSED tests/integration/test_install_twists.py::test_install_dev_with_skip_lock
tests/integration/test_install_uri.py::test_basic_vcs_install_with_env_var
[gw9] [ 93%] PASSED tests/integration/test_install_basic.py::test_category_sorted_alphabetically_with_directive
tests/integration/test_install_basic.py::test_sorting_handles_str_values_and_dict_values
[gw0] [ 93%] PASSED tests/integration/test_upgrade.py::test_upgrade_only_adds_to_explicit_categories
tests/integration/test_upgrade_cleanup.py::test_upgrade_removes_unused_dependencies
[gw18] [ 93%] FAILED tests/integration/test_install_uri.py::test_basic_vcs_install_with_env_var
[gw25] [ 94%] FAILED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]
[gw1] [ 94%] PASSED tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[True] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:54] "GET /simple/six/ HTTP/1.1" 404 745


[gw6] [ 94%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"\nurllib3 = "==2.0.0"-expected_updates2]
[gw17] [ 94%] PASSED tests/integration/test_uninstall.py::test_uninstall_multiple_categories <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:54] "GET /simple/six/ HTTP/1.1" 404 745


[gw16] [ 95%] FAILED tests/integration/test_uninstall.py::test_uninstall_missing_parameters
[gw4] [ 95%] PASSED tests/integration/test_install_basic.py::test_install_respects_lockfile_versions <LocalRequest: GET http://localhost:8080/simple/pip/>
404 Not Found
127.0.0.1 - - [05/Sep/2025 23:47:56] "GET /simple/pip/ HTTP/1.1" 404 745


[gw15] [ 95%] PASSED tests/integration/test_upgrade.py::test_upgrade_updates_lockfile_in_all_categories
[gw33] [ 95%] FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[]
[gw21] [ 96%] PASSED tests/integration/test_install_twists.py::test_install_remote_wheel_file_with_extras
tests/integration/test_project.py::test_pipfile_envvar_expansion
[gw21] [ 96%] PASSED tests/integration/test_project.py::test_pipfile_envvar_expansion
[gw10] [ 96%] PASSED tests/integration/test_install_paths.py::test_install_path_with_spaces
tests/integration/test_install_twists.py::test_local_path_issue_6016
[gw34] [ 96%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_from_categories
[gw32] [ 97%] PASSED tests/integration/test_update.py::test_get_modified_pipfile_entries_new_package
[gw22] [ 97%] PASSED tests/integration/test_upgrade.py::test_category_sorted_alphabetically_with_directive
[gw2] [ 97%] PASSED tests/integration/test_install_nested_setup.py::test_install_path_with_nested_setup_module
tests/integration/test_project.py::test_get_source[False]
[gw2] [ 97%] PASSED tests/integration/test_project.py::test_get_source[False]
[gw5] [ 98%] PASSED tests/integration/test_uninstall.py::test_sorting_handles_str_values_and_dict_values
[gw14] [ 98%] PASSED tests/integration/test_lock.py::test_pinned_pipfile_no_null_markers_when_extras
tests/integration/test_lock.py::test_private_index_skip_lock
[gw9] [ 98%] PASSED tests/integration/test_install_basic.py::test_sorting_handles_str_values_and_dict_values
[gw0] [ 98%] PASSED tests/integration/test_upgrade_cleanup.py::test_upgrade_removes_unused_dependencies
[gw14] [ 99%] PASSED tests/integration/test_lock.py::test_private_index_skip_lock
[gw36] [ 99%] PASSED tests/integration/test_install_uri.py::test_install_specifying_index_url
[gw10] [ 99%] PASSED tests/integration/test_install_twists.py::test_local_path_issue_6016
[gw12] [ 99%] PASSED tests/integration/test_upgrade.py::test_pipenv_dependency_incompatibility_resolution
[gw23] [100%] PASSED tests/integration/test_install_twists.py::test_local_extras_install_alternate

=================================== FAILURES ===================================
__________________________ test_rewrite_outline_table __________________________
[gw39] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fddff275800>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_rewrite_outline_table>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fde04f7f9b0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddffb98ce0>>>, ...]
kwargs = {'item': <Function test_rewrite_outline_table>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddffb98ce0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddffb98ce0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fde04b19850>
item = <Function test_rewrite_outline_table>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddffb98ce0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddffb98ce0>>
item = <Function test_rewrite_outline_table>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddffb98ce0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fddff26e000>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddffb98ce0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddffb98ce0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_rewrite_outline_table>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fde04f7f9b0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_rewrite_outline_table>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fddffb98ce0>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_rewrite_outline_table(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{}"
    verify_ssl = false
    name = "testindex"

    [packages]
    six = {}

    [packages.requests]
    version = "*"
    extras = ["socks"]
                """.format(
                    p.index_url, '{version = "*"}'
                ).strip()
                f.write(contents)
            c = p.pipenv("install colorama")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install colorama', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-pnx03e_8-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 687ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-pnx03e_8-tests-I_5wkYhe\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-pnx03e_8-tests-I_5wkYhe\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.fact...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:526: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install colorama
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-pnx03e_8-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 687ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-pnx03e_8-tests-I_5wkYhe
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-pnx03e_8-tests-I_5wkYhe
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_basic_install ______________________________
[gw26] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8571de5620>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f85739a59d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f857336ae70>>>, ...]
kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f857336ae70>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f857336ae70>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f85736929c0>
item = <Function test_basic_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f857336ae70>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f857336ae70>>
item = <Function test_basic_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f857336ae70>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_basic_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8572031200>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_basic_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f857336ae70>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f857336ae70>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_basic_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_basic_install>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f85739a59d0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_basic_install>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_basic_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f857336ae70>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_basic_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six -v', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nRunning command: $ \n/root/.local/share/virtualenvs/pipenv-foabwect-tests-iVv4tVfj/bin/python \n/app/pipenv/vendor/pipdeptree -l --reverse --json-tree\nBuilding requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.network.session:adding trusted host: \n\'localhost:8080\' (from line 2 of \n/tmp/pipenv-i_8hhezd-requirements/pipenv-0xakaxyc-constraints.txt)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'six\'), None)\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the requirement six (from versions: none)\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 429, in resolve\n    self._add_to_criteria(self.state.criteria, r, parent=None)\n  File "/app/pipenv/patched/pip/_ve...=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-foabwect-tests-iVv4tVfj\nPipfile.lock not found, creating...\nLocking  dependencies...\nLocking  dependencies...\nUpdated Pipfile.lock \n(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!\nCommand output: [\n    {\n        "key": "pip",\n        "package_name": "pip",\n        "installed_version": "25.1.1",\n        "required_version": "25.1.1",\n        "dependencies": []\n    }\n]\n\nUpgrading six in  dependencies.\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:19: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six -v
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Running command: $
/root/.local/share/virtualenvs/pipenv-foabwect-tests-iVv4tVfj/bin/python
/app/pipenv/vendor/pipdeptree -l --reverse --json-tree
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.network.session:adding trusted host:
'localhost:8080' (from line 2 of
/tmp/pipenv-i_8hhezd-requirements/pipenv-0xakaxyc-constraints.txt)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('six'), None)
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('six')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
                            ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('six'), parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for six
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
six
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n3'), version_str='3.12.11', major=3, minor=12, patch=11, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.12.11')>, architecture=None, company='PythonCore',
name='python3',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-foabwect-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 396ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-foabwect-tests-iVv4tVfj
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-foabwect-tests-iVv4tVfj
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Command output: [
    {
        "key": "pip",
        "package_name": "pip",
        "installed_version": "25.1.1",
        "required_version": "25.1.1",
        "dependencies": []
    }
]

Upgrading six in  dependencies.
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________________ test_extras_install ______________________________
[gw29] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f2a16791800>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2a1c10b650>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17262b40>>>, ...]
kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17262b40>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17262b40>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f2a17f00740>
item = <Function test_extras_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17262b40>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17262b40>>
item = <Function test_extras_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17262b40>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_extras_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f2a16b73d40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_extras_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17262b40>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_extras_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17262b40>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_extras_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_extras_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_extras_install>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2a1c10b650>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_extras_install>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_extras_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_extras_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_extras_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f2a17262b40>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.extras
    @pytest.mark.install
    def test_extras_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install requests[socks]")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install requests[socks]', returncode=1, stdout='Installing requests...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-cwr8ansf-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 397ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-cwr8ansf-tests-klCO5WTb\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-cwr8...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:135: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install requests[socks]
Installing requests...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-cwr8ansf-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 397ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-cwr8ansf-tests-klCO5WTb
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-cwr8ansf-tests-klCO5WTb
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading requests in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_system_and_deploy_work __________________________
[gw35] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f019da25800>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_system_and_deploy_work>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f019f4a33e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019f07f050>>>, ...]
kwargs = {'item': <Function test_system_and_deploy_work>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019f07f050>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019f07f050>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f019f3b01d0>
item = <Function test_system_and_deploy_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019f07f050>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019f07f050>>
item = <Function test_system_and_deploy_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019f07f050>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_system_and_deploy_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f019de7b540>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_system_and_deploy_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019f07f050>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_system_and_deploy_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019f07f050>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_system_and_deploy_work>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_system_and_deploy_work>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f019f4a33e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_system_and_deploy_work>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f019f07f050>, index_url='http://localhost:8080/simple')

    @pytest.mark.cli
    @pytest.mark.deploy
    @pytest.mark.system
    def test_system_and_deploy_work(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install urllib3")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install urllib3', returncode=1, stdout='Installing urllib3...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-52i1rgje-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 794ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-52i1rgje-tests-LkIzYnvv\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-52i1rgje-test...\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for urllib3\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:371: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install urllib3
Installing urllib3...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-52i1rgje-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 794ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-52i1rgje-tests-LkIzYnvv
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-52i1rgje-tests-LkIzYnvv
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading urllib3 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement urllib3 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for urllib3

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_install_uri_with_extras _________________________
[gw24] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fe613f19bc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_uri_with_extras>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe619ac9a30>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61945b4d0>>>, ...]
kwargs = {'item': <Function test_install_uri_with_extras>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61945b4d0>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61945b4d0>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fe619479c40>
item = <Function test_install_uri_with_extras>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61945b4d0>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61945b4d0>>
item = <Function test_install_uri_with_extras>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61945b4d0>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_uri_with_extras>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fe6183f2980>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_uri_with_extras>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61945b4d0>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_uri_with_extras>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61945b4d0>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_uri_with_extras>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_uri_with_extras>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe619ac9a30>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_uri_with_extras>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fe61945b4d0>, index_url='https://pypi.org/simple')

    @pytest.mark.urls
    @pytest.mark.extras
    @pytest.mark.install
    def test_install_uri_with_extras(pipenv_instance_pypi):
        server = DEFAULT_PRIVATE_PYPI_SERVER.replace("/simple", "")
        file_uri = f"{server}/packages/plette/plette-0.2.2-py2.py3-none-any.whl"
        with pipenv_instance_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    plette = {{file = "{file_uri}", extras = ["validation"]}}
    """
                f.write(contents)
            c = p.pipenv("install")
>           assert c.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-0juh3ioy-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 373ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0juh3ioy-tests-LFyjKydh\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-0juh3ioy-tests-LFyjKydh\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.network.download:HTTP error 404 whi... can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Could not install requirement plette@ \nhttp://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl from \nhttp://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl (from \nplette@ \nhttp://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl->-r \n/tmp/pipenv-ahel0_v4-requirements/pipenv-wzamdt6l-constraints.txt (line 3)) \nbecause of HTTP error 404 Client Error: Not Found for url: \nhttp://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl for URL \nhttp://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_misc.py:25: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-0juh3ioy-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 373ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0juh3ioy-tests-LFyjKydh
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-0juh3ioy-tests-LFyjKydh
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.network.download:HTTP error 404 while
getting http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Could not install requirement plette@
http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl from
http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl (from
plette@
http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl->-r
/tmp/pipenv-ahel0_v4-requirements/pipenv-wzamdt6l-constraints.txt (line 3))
because of HTTP error 404 Client Error: Not Found for url:
http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl for URL
http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_pipenv_clean _______________________________
[gw5] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f6cf70b9a80>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6cfe40b7d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf790ccb0>>>, ...]
kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf790ccb0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf790ccb0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6cfcb5bc20>
item = <Function test_pipenv_clean>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf790ccb0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf790ccb0>>
item = <Function test_pipenv_clean>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf790ccb0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_clean>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f6cf72cee80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_clean>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf790ccb0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_clean>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf790ccb0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_clean>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_pipenv_clean>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6cfe40b7d0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_pipenv_clean>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f6cf790ccb0>, index_url='http://localhost:8080/simple')

    @pytest.mark.cli
    @pytest.mark.skipif(
        sys.version_info[:2] == (3, 8) and os.name == "nt",
        reason="This test is not working om Windows Python 3. 8",
    )
    def test_pipenv_clean(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open("setup.py", "w") as f:
                f.write('from setuptools import setup; setup(name="empty")')
            c = p.pipenv("install -e .")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -e .', returncode=1, stdout='Installing -e ....\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-4qfu4cg4-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 452ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-4qfu4cg4-tests-56kkSp1s\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-4qfu4cg4-tests-56kk...lure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: pip subprocess to install build dependencies exited with 1\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_cli.py:208: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -e .
Installing -e ....
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-4qfu4cg4-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 452ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-4qfu4cg4-tests-56kkSp1s
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-4qfu4cg4-tests-56kkSp1s
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading -e . in  dependencies.
ERROR:pip.subprocessor:pip subprocess to install build dependencies exited with
1
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: pip subprocess to install build dependencies exited with 1

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________________ test_rewrite_outline_table_ooo ________________________
[gw39] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fddff2771a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fde04f7f9b0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fde041821b0>>>, ...]
kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fde041821b0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fde041821b0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fde04b19850>
item = <Function test_rewrite_outline_table_ooo>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fde041821b0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fde041821b0>>
item = <Function test_rewrite_outline_table_ooo>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fde041821b0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table_ooo>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fddfed01240>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table_ooo>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fde041821b0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table_ooo>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fde041821b0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table_ooo>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_rewrite_outline_table_ooo>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fde04f7f9b0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_rewrite_outline_table_ooo>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fde041821b0>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_rewrite_outline_table_ooo(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{}"
    verify_ssl = false
    name = "testindex"

    [packages]
    six = {}

    # Out-of-order
    [pipenv]
    allow_prereleases = false

    [packages.requests]
    version = "*"
    extras = ["socks"]
                """.format(
                    p.index_url, '{version = "*"}'
                ).strip()
                f.write(contents)
            c = p.pipenv("install colorama")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install colorama', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-wjp1m2vr-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 394ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-wjp1m2vr-tests-9xXgpAPV\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-wjp1m2vr-tests-9xXgpAPV\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.fact...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:561: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install colorama
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-wjp1m2vr-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 394ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-wjp1m2vr-tests-9xXgpAPV
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-wjp1m2vr-tests-9xXgpAPV
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_install_local_vcs_not_in_lockfile ____________________
[gw17] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9c3b6c9620>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9c40f11d60>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c404cd4f0>>>, ...]
kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c404cd4f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c404cd4f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9c40e63c20>
item = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c404cd4f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c404cd4f0>>
item = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c404cd4f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_local_vcs_not_in_lockfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f9c3ba73500>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_local_vcs_not_in_lockfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c404cd4f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c404cd4f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_local_vcs_not_in_lockfile>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_local_vcs_not_in_lockfile>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9c40f11d60>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f9c404cd4f0>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_local_vcs_not_in_lockfile(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            # six_path = os.path.join(p.path, "six")
            six_path = p._pipfile.get_fixture_path("git/six/")
>           c = subprocess_run(["git", "clone", six_path, "./six"])
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_install_uri.py:196:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = ['git', 'clone', PosixPath('/app/tests/test_artifacts/git/six'), './six']
block = True, text = True, capture_output = True, encoding = 'utf-8', env = None
other_kwargs = {'env': {'CI': '1', 'COLUMNS': '80', 'HOME': '/root', 'HOSTNAME': '4f4660d07118', ...}, 'stderr': -1, 'stdout': -1}
_env = {'CI': '1', 'COLUMNS': '80', 'HOME': '/root', 'HOSTNAME': '4f4660d07118', ...}

    def subprocess_run(
        args,
        *,
        block=True,
        text=True,
        capture_output=True,
        encoding="utf-8",
        env=None,
        **other_kwargs,
    ):
        """A backward compatible version of subprocess.run().

        It outputs text with default encoding, and store all outputs in the returned object instead of
        printing onto stdout.
        """
        _env = os.environ.copy()
        _env["PYTHONIOENCODING"] = encoding
        if env:
            # Ensure all environment variables are strings
            string_env = {k: str(v) for k, v in env.items() if v is not None}
            _env.update(string_env)
        other_kwargs["env"] = _env
        if capture_output:
            other_kwargs["stdout"] = subprocess.PIPE
            other_kwargs["stderr"] = subprocess.PIPE
        if block:
>           return subprocess.run(
                args, text=text, encoding=encoding, check=False, **other_kwargs
            )

pipenv/utils/processes.py:71:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

input = None, capture_output = False, timeout = None, check = False
popenargs = (['git', 'clone', PosixPath('/app/tests/test_artifacts/git/six'), './six'],)
kwargs = {'encoding': 'utf-8', 'env': {'CI': '1', 'COLUMNS': '80', 'HOME': '/root', 'HOSTNAME': '4f4660d07118', ...}, 'stderr': -1, 'stdout': -1, ...}

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.

        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.

        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.

        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.

        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.

        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.

        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE

        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE

>       with Popen(*popenargs, **kwargs) as process:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/subprocess.py:548:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['git', 'clone', PosixPath('/app/tests/test_ar...>
args = ['git', 'clone', PosixPath('/app/tests/test_artifacts/git/six'), './six']
bufsize = -1, executable = None, stdin = None, stdout = -1, stderr = -1
preexec_fn = None, close_fds = True, shell = False, cwd = None
env = {'CI': '1', 'COLUMNS': '80', 'HOME': '/root', 'HOSTNAME': '4f4660d07118', ...}
universal_newlines = None, startupinfo = None, creationflags = 0
restore_signals = True, start_new_session = False, pass_fds = ()

    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=True,
                 shell=False, cwd=None, env=None, universal_newlines=None,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=(), *, user=None, group=None, extra_groups=None,
                 encoding=None, errors=None, text=None, umask=-1, pipesize=-1,
                 process_group=None):
        """Create new Popen instance."""
        if not _can_fork_exec:
            raise OSError(
                errno.ENOTSUP, f"{sys.platform} does not support processes."
            )

        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()

        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError("bufsize must be an integer")

        if pipesize is None:
            pipesize = -1  # Restore default
        if not isinstance(pipesize, int):
            raise TypeError("pipesize must be an integer")

        if _mswindows:
            if preexec_fn is not None:
                raise ValueError("preexec_fn is not supported on Windows "
                                 "platforms")
        else:
            # POSIX
            if pass_fds and not close_fds:
                warnings.warn("pass_fds overriding close_fds.", RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError("startupinfo is only supported on Windows "
                                 "platforms")
            if creationflags != 0:
                raise ValueError("creationflags is only supported on Windows "
                                 "platforms")

        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.encoding = encoding
        self.errors = errors
        self.pipesize = pipesize

        # Validate the combinations of text and universal_newlines
        if (text is not None and universal_newlines is not None
            and bool(universal_newlines) != bool(text)):
            raise SubprocessError('Cannot disambiguate when both text '
                                  'and universal_newlines are supplied but '
                                  'different. Pass one or the other.')

        self.text_mode = encoding or errors or text or universal_newlines
        if self.text_mode and encoding is None:
            self.encoding = encoding = _text_encoding()

        # How long to resume waiting on a child after the first ^C.
        # There is no right value for this.  The purpose is to be polite
        # yet remain good for interactive users trying to exit a tool.
        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()

        self._closed_child_pipe_fds = False

        if self.text_mode:
            if bufsize == 1:
                line_buffering = True
                # Use the default buffer size for the underlying binary streams
                # since they don't support line buffering.
                bufsize = -1
            else:
                line_buffering = False

        if process_group is None:
            process_group = -1  # The internal APIs are int-only

        gid = None
        if group is not None:
            if not hasattr(os, 'setregid'):
                raise ValueError("The 'group' parameter is not supported on the "
                                 "current platform")

            elif isinstance(group, str):
                try:
                    import grp
                except ImportError:
                    raise ValueError("The group parameter cannot be a string "
                                     "on systems without the grp module")

                gid = grp.getgrnam(group).gr_gid
            elif isinstance(group, int):
                gid = group
            else:
                raise TypeError("Group must be a string or an integer, not {}"
                                .format(type(group)))

            if gid < 0:
                raise ValueError(f"Group ID cannot be negative, got {gid}")

        gids = None
        if extra_groups is not None:
            if not hasattr(os, 'setgroups'):
                raise ValueError("The 'extra_groups' parameter is not "
                                 "supported on the current platform")

            elif isinstance(extra_groups, str):
                raise ValueError("Groups must be a list, not a string")

            gids = []
            for extra_group in extra_groups:
                if isinstance(extra_group, str):
                    try:
                        import grp
                    except ImportError:
                        raise ValueError("Items in extra_groups cannot be "
                                         "strings on systems without the "
                                         "grp module")

                    gids.append(grp.getgrnam(extra_group).gr_gid)
                elif isinstance(extra_group, int):
                    gids.append(extra_group)
                else:
                    raise TypeError("Items in extra_groups must be a string "
                                    "or integer, not {}"
                                    .format(type(extra_group)))

            # make sure that the gids are all positive here so we can do less
            # checking in the C code
            for gid_check in gids:
                if gid_check < 0:
                    raise ValueError(f"Group ID cannot be negative, got {gid_check}")

        uid = None
        if user is not None:
            if not hasattr(os, 'setreuid'):
                raise ValueError("The 'user' parameter is not supported on "
                                 "the current platform")

            elif isinstance(user, str):
                try:
                    import pwd
                except ImportError:
                    raise ValueError("The user parameter cannot be a string "
                                     "on systems without the pwd module")
                uid = pwd.getpwnam(user).pw_uid
            elif isinstance(user, int):
                uid = user
            else:
                raise TypeError("User must be a string or an integer")

            if uid < 0:
                raise ValueError(f"User ID cannot be negative, got {uid}")

        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin--->  p2cread
        # c2pread    <--stdout---  c2pwrite
        # errread    <--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.

        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)

        # From here on, raising exceptions may cause file descriptor leakage

        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).

        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)

        try:
            if p2cwrite != -1:
                self.stdin = io.open(p2cwrite, 'wb', bufsize)
                if self.text_mode:
                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                            line_buffering=line_buffering,
                            encoding=encoding, errors=errors)
            if c2pread != -1:
                self.stdout = io.open(c2pread, 'rb', bufsize)
                if self.text_mode:
                    self.stdout = io.TextIOWrapper(self.stdout,
                            encoding=encoding, errors=errors)
            if errread != -1:
                self.stderr = io.open(errread, 'rb', bufsize)
                if self.text_mode:
                    self.stderr = io.TextIOWrapper(self.stderr,
                            encoding=encoding, errors=errors)

>           self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
                                restore_signals,
                                gid, gids, uid, umask,
                                start_new_session, process_group)

/usr/lib/python3.12/subprocess.py:1026:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['git', 'clone', PosixPath('/app/tests/test_ar...>
args = ['git', 'clone', PosixPath('/app/tests/test_artifacts/git/six'), './six']
executable = b'git', preexec_fn = None, close_fds = True, pass_fds = ()
cwd = None
env = {'CI': '1', 'COLUMNS': '80', 'HOME': '/root', 'HOSTNAME': '4f4660d07118', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = 17, c2pwrite = 18, errread = 19, errwrite = 20
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False, process_group = -1

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session, process_group):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and process_group == -1
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        process_group, gid, gids, uid, umask,
                        preexec_fn, _USE_VFORK)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                if err_msg == "noexec:chdir":
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                elif err_msg == "noexec":
                    err_msg = ""
                    err_filename = None
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
                if err_filename is not None:
>                   raise child_exception_type(errno_num, err_msg, err_filename)
E                   FileNotFoundError: [Errno 2] No such file or directory: 'git'

/usr/lib/python3.12/subprocess.py:1955: FileNotFoundError
__________________ test_install_does_not_extrapolate_environ ___________________
[gw33] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7ff5ed5c1a80>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff5ef293a10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5eeafb1d0>>>, ...]
kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5eeafb1d0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5eeafb1d0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7ff5eee201a0>
item = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5eeafb1d0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5eeafb1d0>>
item = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5eeafb1d0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_does_not_extrapolate_environ>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7ff5eda6b0c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_does_not_extrapolate_environ>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5eeafb1d0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5eeafb1d0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_does_not_extrapolate_environ>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_does_not_extrapolate_environ>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff5ef293a10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7ff5eeafb1d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_install_does_not_extrapolate_environ(pipenv_instance_private_pypi):
        """Ensure environment variables are not expanded in lock file."""
        with temp_environ(), pipenv_instance_private_pypi() as p:
            os.environ["PYPI_URL"] = p.pypi

            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [[source]]
    url = '${PYPI_URL}/simple'
    verify_ssl = true
    name = 'mockpi'
                """
                )

            # Ensure simple install does not extrapolate.
            c = p.pipenv("install -v")
            assert c.returncode == 0
            assert p.pipfile["source"][0]["url"] == "${PYPI_URL}/simple"
            assert p.lockfile["_meta"]["sources"][0]["url"] == "${PYPI_URL}/simple"

            # Ensure package install does not extrapolate.
            c = p.pipenv("install six -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six -v', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (eddaee)...\nAll dependencies are now up-to-date!\nRunning command: $ \n/root/.local/share/virtualenvs/pipenv-25j6iqbq-tests-eWza9w_J/bin/python \n/app/pipenv/vendor/pipdeptree -l --reverse --json-tree\nBuilding requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'six\'), None)\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the requirement six (from versions: none)\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 429, in resolve\n    self._add_to_criteria(self.state.criteria, r, parent=None)\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 151, in _add_to_criteria\n    raise RequirementsConflicted(criterion)\npipenv.patched.pip._vendor.resolvelib.resolvers.exceptions...    results, resolver = resolve_deps(\n                        ^^^^^^^^^^^^^\n  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps\n    results, hashes, internal_resolver = actually_resolve_deps(\n                                         ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps\n    resolver.resolve()\n  File "/app/pipenv/utils/resolver.py", line 471, in resolve\n    raise ResolutionFailure(message=e)\npipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for \nsix\nLocking Failed!\n', stderr='Command output: [\n    {\n        "key": "pip",\n        "package_name": "pip",\n        "installed_version": "25.1.1",\n        "required_version": "25.1.1",\n        "dependencies": []\n    }\n]\n\nUpgrading six in  dependencies.\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:324: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six -v
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (eddaee)...
All dependencies are now up-to-date!
Running command: $
/root/.local/share/virtualenvs/pipenv-25j6iqbq-tests-eWza9w_J/bin/python
/app/pipenv/vendor/pipdeptree -l --reverse --json-tree
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('six'), None)
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('six')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
                            ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('six'), parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for six
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
six
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Command output: [
    {
        "key": "pip",
        "package_name": "pip",
        "installed_version": "25.1.1",
        "required_version": "25.1.1",
        "dependencies": []
    }
]

Upgrading six in  dependencies.
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________ test_multiple_category_install[prereq, other] _________________
[gw26] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8571ecb6a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f85739a59d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8572f6b8f0>>>, ...]
kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8572f6b8f0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8572f6b8f0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f85736929c0>
item = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8572f6b8f0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8572f6b8f0>>
item = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8572f6b8f0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq, other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8571983d40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq, other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8572f6b8f0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8572f6b8f0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq, other]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_multiple_category_install[prereq, other]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f85739a59d0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f8572f6b8f0>, index_url='http://localhost:8080/simple')
categories = 'prereq, other'

    @pytest.mark.categories
    @pytest.mark.install
    @pytest.mark.parametrize("categories", ["prereq other", "prereq, other"])
    def test_multiple_category_install(pipenv_instance_private_pypi, categories):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv('install six --categories="prereq other"')
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --categories="prereq other"', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-ga8wt31o-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 322ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ga8wt31o-tests-JOClPtgx\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_categories.py:47: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --categories="prereq other"
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-ga8wt31o-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 322ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ga8wt31o-tests-JOClPtgx
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-ga8wt31o-tests-JOClPtgx
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_install_skip_lock ____________________________
[gw22] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f093afc9620>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f0940b10b00>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f093b2d41d0>>>, ...]
kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f093b2d41d0>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f093b2d41d0>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f0940679c70>
item = <Function test_install_skip_lock>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f093b2d41d0>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f093b2d41d0>>
item = <Function test_install_skip_lock>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f093b2d41d0>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_skip_lock>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f093abbd0c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_skip_lock>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f093b2d41d0>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_skip_lock>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f093b2d41d0>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_skip_lock>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_skip_lock>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_skip_lock>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f0940b10b00>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_skip_lock>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_skip_lock>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_skip_lock>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_skip_lock>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f093b2d41d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    @pytest.mark.skip_lock
    @pytest.mark.needs_internet
    def test_install_skip_lock(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{}"
    verify_ssl = true
    name = "pypi"
    [packages]
    six = {}
                """.format(
                    p.index_url, '{version = "*", index = "pypi"}'
                ).strip()
                f.write(contents)
            c = p.pipenv("install --skip-lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install --skip-lock', returncode=1, stdout='Installing dependencies from Pipfile...\n', stderr="The flag --skip-lock has been reintroduced (but is not recommended).  Without \nthe lock resolver it is difficult to manage multiple package indexes, and hash \nchecking is not provided.  However it can help manage installs with current \ndeficiencies in locking across platforms.\nWarning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-vr8toutn-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 421ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vr8toutn-tests-ZUJvnBO7\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-vr8toutn-tests-ZUJvnBO7\nLooking in indexes: http://localhost:8080/simple\nERROR: Could not find a version that satisfies the requirement six (from \nversions: none)\nERROR: No matching distribution found for six\nERROR: Couldn't install package: {}\n Package installation failed...\n").returncode

tests/integration/test_install_twists.py:410: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install --skip-lock
Installing dependencies from Pipfile...

Command failed...
----------------------------- Captured stderr call -----------------------------
The flag --skip-lock has been reintroduced (but is not recommended).  Without
the lock resolver it is difficult to manage multiple package indexes, and hash
checking is not provided.  However it can help manage installs with current
deficiencies in locking across platforms.
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-vr8toutn-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 421ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vr8toutn-tests-ZUJvnBO7
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-vr8toutn-tests-ZUJvnBO7
Looking in indexes: http://localhost:8080/simple
ERROR: Could not find a version that satisfies the requirement six (from
versions: none)
ERROR: No matching distribution found for six
ERROR: Couldn't install package: {}
 Package installation failed...

________________________ test_install_package_with_dots ________________________
[gw38] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f11564e9bc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f115d6b9490>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f115683d3d0>>>, ...]
kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f115683d3d0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f115683d3d0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1157ef81d0>
item = <Function test_install_package_with_dots>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f115683d3d0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f115683d3d0>>
item = <Function test_install_package_with_dots>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f115683d3d0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_package_with_dots>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f11569e7580>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_package_with_dots>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f115683d3d0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_package_with_dots>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f115683d3d0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_package_with_dots>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_package_with_dots>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f115d6b9490>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_package_with_dots>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f115683d3d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_install_package_with_dots(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install backports.html")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install backports.html', returncode=1, stdout='Installing backports.html...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-pcb2tglz-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 366ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-pcb2tglz-tests-DWzDzfdJ\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv...lutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for backports.html\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:500: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install backports.html
Installing backports.html...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-pcb2tglz-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 366ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-pcb2tglz-tests-DWzDzfdJ
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-pcb2tglz-tests-DWzDzfdJ
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading backports.html in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement backports.html (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for backports.html

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________________________ test_vcs_install _______________________________
[gw39] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fddff277740>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fde04f7f9b0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f00e0>>>, ...]
kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f00e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f00e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fde04b19850>
item = <Function test_vcs_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f00e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f00e0>>
item = <Function test_vcs_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f00e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_vcs_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fddfed6be40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_vcs_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f00e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f00e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_install>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fde04f7f9b0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_install>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_install>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_install>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fddff1f00e0>, index_url='https://pypi.org/simple')

    @pytest.mark.e
    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_vcs_install(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            c = p.pipenv(
                "install git+https://github.com/lidatong/dataclasses-json.git@v0.5.7"
            )
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install git+https://github.com/lidatong/dataclasses-json.git@v0.5.7', returncode=1, stdout='Installing git+https://github.com/lidatong/dataclasses-json.git@v0.5.7...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-zbsxf1kn-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 395ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-zbsxf1kn-tests-W9cs5nxy\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-zbsxf1kn-tests-W9cs5nxy\nPipfile.lock not found, creating...\nLocking  dependencies...\nLocking ... File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link\n    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack\n    self.obtain(location, url=url, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - do you have \'git\' installed and in your PATH?\n').returncode

tests/integration/test_install_uri.py:88: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install git+https://github.com/lidatong/dataclasses-json.git@v0.5.7
Installing git+https://github.com/lidatong/dataclasses-json.git@v0.5.7...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-zbsxf1kn-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 395ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-zbsxf1kn-tests-W9cs5nxy
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-zbsxf1kn-tests-W9cs5nxy
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/lidatong/dataclasses-json.git (to revision v0.5.7) to /tmp/tmpl32wqt7b
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?

_________________________ test_basic_category_install __________________________
[gw30] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9008591d00>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_basic_category_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9009ec3530>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9009a8db80>>>, ...]
kwargs = {'item': <Function test_basic_category_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9009a8db80>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9009a8db80>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9009a6f680>
item = <Function test_basic_category_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9009a8db80>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9009a8db80>>
item = <Function test_basic_category_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9009a8db80>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_basic_category_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f90089bf7c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_basic_category_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9009a8db80>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_category_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9009a8db80>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_category_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_basic_category_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9009ec3530>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_basic_category_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f9009a8db80>, index_url='http://localhost:8080/simple')

    @pytest.mark.categories
    @pytest.mark.install
    def test_basic_category_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six --categories prereq")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --categories prereq', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-jbjtvr_3-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 394ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-jbjtvr_3-tests-hFeBfV1D\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-j...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_categories.py:12: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --categories prereq
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-jbjtvr_3-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 394ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-jbjtvr_3-tests-hFeBfV1D
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-jbjtvr_3-tests-hFeBfV1D
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________ test_outdated_should_compare_postreleases_without_failing ___________
[gw21] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fae310d59e0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fae32e57bc0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fae329ef740>>>, ...]
kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fae329ef740>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fae329ef740>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fae32cad460>
item = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fae329ef740>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fae329ef740>>
item = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fae329ef740>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_outdated_should_compare_postreleases_without_failing>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fae31150a40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_outdated_should_compare_postreleases_without_failing>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fae329ef740>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fae329ef740>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_outdated_should_compare_postreleases_without_failing>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_outdated_should_compare_postreleases_without_failing>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fae32e57bc0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fae329ef740>, index_url='http://localhost:8080/simple')

    @pytest.mark.skipif(
        os.name == "nt" and sys.version_info[:2] == (3, 8),
        reason="Seems to work on 3.8 but not via the CI",
    )
    @pytest.mark.outdated
    def test_outdated_should_compare_postreleases_without_failing(
        pipenv_instance_private_pypi,
    ):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install ibm-db-sa-py3==0.3.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install ibm-db-sa-py3==0.3.0', returncode=1, stdout='Installing ibm-db-sa-py3==0.3.0...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-ad2upsom-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 432ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ad2upsom-tests-qJOVwJLK\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtua...Failure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for ibm-db-sa-py3==0.3.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:369: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install ibm-db-sa-py3==0.3.0
Installing ibm-db-sa-py3==0.3.0...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-ad2upsom-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 432ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ad2upsom-tests-qJOVwJLK
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-ad2upsom-tests-qJOVwJLK
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading ibm-db-sa-py3==0.3.0 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement ibm-db-sa-py3==0.3.0 (from
versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for ibm-db-sa-py3==0.3.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

___________________ test_install_dev_use_default_constraints ___________________
[gw5] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f6cf70bb380>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6cfe40b7d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf7348b60>>>, ...]
kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf7348b60>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf7348b60>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6cfcb5bc20>
item = <Function test_install_dev_use_default_constraints>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf7348b60>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf7348b60>>
item = <Function test_install_dev_use_default_constraints>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf7348b60>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_dev_use_default_constraints>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f6cf6b63900>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_dev_use_default_constraints>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf7348b60>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_dev_use_default_constraints>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6cf7348b60>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_dev_use_default_constraints>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_dev_use_default_constraints>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6cfe40b7d0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_dev_use_default_constraints>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f6cf7348b60>, index_url='http://localhost:8080/simple')

    @pytest.mark.dev
    @pytest.mark.install
    def test_install_dev_use_default_constraints(pipenv_instance_private_pypi):
        # See https://github.com/pypa/pipenv/issues/4371
        # See https://github.com/pypa/pipenv/issues/2987
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install requests==2.14.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install requests==2.14.0', returncode=1, stdout='Installing requests==2.14.0...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-yr87rcd5-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 414ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-yr87rcd5-tests-_0vQwBjd\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pi...tionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests==2.14.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:577: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install requests==2.14.0
Installing requests==2.14.0...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-yr87rcd5-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 414ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-yr87rcd5-tests-_0vQwBjd
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-yr87rcd5-tests-_0vQwBjd
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading requests==2.14.0 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests==2.14.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests==2.14.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________ test_vcs_entry_supersedes_non_vcs _______________________
[gw16] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f6e2574d620>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e27473a10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e26cc9580>>>, ...]
kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e26cc9580>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e26cc9580>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6e26ca3c20>
item = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e26cc9580>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e26cc9580>>
item = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e26cc9580>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_entry_supersedes_non_vcs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f6e25c2db40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_entry_supersedes_non_vcs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e26cc9580>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e26cc9580>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_entry_supersedes_non_vcs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_entry_supersedes_non_vcs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e27473a10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f6e26cc9580>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_vcs_entry_supersedes_non_vcs(pipenv_instance_pypi):
        """See issue #2181 -- non-editable VCS dep was specified, but not showing up
        in the lockfile -- due to not running pip install before locking and not locking
        the resolution graph of non-editable vcs dependencies.
        """
        with pipenv_instance_pypi() as p:
            jinja2_uri = p._pipfile.get_fixture_path("git/jinja2").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    f"""
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
    Flask = "*"
    Jinja2 = {{ref = "2.11.0", git = "{jinja2_uri}"}}
                """.strip()
                )
            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-58ujou3y-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 316ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-58ujou3y-tests-qrQs1dim\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-58ujou3y-tests-qrQs1dim\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'gi... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:257: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-58ujou3y-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 316ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-58ujou3y-tests-qrQs1dim
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-58ujou3y-tests-qrQs1dim
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________ test_skip_requirements_when_pipfile ______________________
[gw32] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f18a9add760>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f18ab383770>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f18a9d58200>>>, ...]
kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f18a9d58200>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f18a9d58200>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f18ab46bc20>
item = <Function test_skip_requirements_when_pipfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f18a9d58200>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f18a9d58200>>
item = <Function test_skip_requirements_when_pipfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f18a9d58200>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_skip_requirements_when_pipfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f18a9be8800>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_skip_requirements_when_pipfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f18a9d58200>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_skip_requirements_when_pipfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f18a9d58200>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_skip_requirements_when_pipfile>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_skip_requirements_when_pipfile>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f18ab383770>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_skip_requirements_when_pipfile>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f18a9d58200>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    @pytest.mark.requirements
    def test_skip_requirements_when_pipfile(pipenv_instance_private_pypi):
        """Ensure requirements.txt is NOT imported when

        1. We do `pipenv install [package]`
        2. A Pipfile already exists when we run `pipenv install`.
        """
        with pipenv_instance_private_pypi() as p:
            with open("requirements.txt", "w") as f:
                f.write("requests==2.18.1\n")
            c = p.pipenv("install six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-wo2muyfy-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 291ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-wo2muyfy-tests-SfVCvWMz\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-wo2muyfy-tests-SfVCvW...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:276: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-wo2muyfy-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 291ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-wo2muyfy-tests-SfVCvWMz
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-wo2muyfy-tests-SfVCvWMz
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

___________________________ test_install_github_vcs ____________________________
[gw38] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f11564eaf20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_github_vcs>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f115d6b9490>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1157a08830>>>, ...]
kwargs = {'item': <Function test_install_github_vcs>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1157a08830>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1157a08830>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1157ef81d0>
item = <Function test_install_github_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1157a08830>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1157a08830>>
item = <Function test_install_github_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1157a08830>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_github_vcs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f1155ff9240>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_github_vcs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1157a08830>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1157a08830>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_github_vcs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_github_vcs>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f115d6b9490>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_github_vcs>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_github_vcs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f1157a08830>, index_url='https://pypi.org/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_install_github_vcs(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            c = p.pipenv("install git+https://github.com/reagento/adaptix.git@2.16")
>           assert not c.returncode
E           assert not 1
E            +  where 1 = CompletedProcess(args='pipenv install git+https://github.com/reagento/adaptix.git@2.16', returncode=1, stdout='Installing git+https://github.com/reagento/adaptix.git@2.16...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-bqn1lknx-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 451ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-bqn1lknx-tests-9lS25Y89\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-bqn1lknx-tests-9lS25Y89\nPipfile.lock not found, creating...\nLocking  dependencies...\nLocking  dependencies...\nUpda... File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link\n    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack\n    self.obtain(location, url=url, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - do you have \'git\' installed and in your PATH?\n').returncode

tests/integration/test_install_vcs.py:12: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install git+https://github.com/reagento/adaptix.git@2.16
Installing git+https://github.com/reagento/adaptix.git@2.16...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-bqn1lknx-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 451ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-bqn1lknx-tests-9lS25Y89
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-bqn1lknx-tests-9lS25Y89
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/reagento/adaptix.git (to revision 2.16) to /tmp/tmp7hzgj0d_
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?

_____________________________ test_install_git_tag _____________________________
[gw39] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fddff277d80>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fde04f7f9b0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f2fc0>>>, ...]
kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f2fc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f2fc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fde04b19850>
item = <Function test_install_git_tag>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f2fc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f2fc0>>
item = <Function test_install_git_tag>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f2fc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_git_tag>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fddfeb43f00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_git_tag>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f2fc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_git_tag>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fddff1f2fc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_git_tag>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_git_tag>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_git_tag>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fde04f7f9b0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_git_tag>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_git_tag>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_git_tag>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_git_tag>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fddff1f2fc0>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_git_tag(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install git+https://github.com/benjaminp/six.git@1.11.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install git+https://github.com/benjaminp/six.git@1.11.0', returncode=1, stdout='Installing git+https://github.com/benjaminp/six.git@1.11.0...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-_p5ushp9-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 368ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-_p5ushp9-tests-T38Fsm-A\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-_p5ushp9-tests-T38Fsm-A\nPipfile.lock not found, creating...\nLocking  dependencies...\nLocking  dependencies...\nUpdate... File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link\n    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack\n    self.obtain(location, url=url, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - do you have \'git\' installed and in your PATH?\n').returncode

tests/integration/test_install_uri.py:99: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install git+https://github.com/benjaminp/six.git@1.11.0
Installing git+https://github.com/benjaminp/six.git@1.11.0...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-_p5ushp9-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 368ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-_p5ushp9-tests-T38Fsm-A
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-_p5ushp9-tests-T38Fsm-A
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/benjaminp/six.git (to revision 1.11.0) to /tmp/tmpmu2ksukb
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?

______________________________ test_get_vcs_refs _______________________________
[gw17] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9c3b6cb380>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9c40f11d60>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c42725310>>>, ...]
kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c42725310>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c42725310>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9c40e63c20>
item = <Function test_get_vcs_refs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c42725310>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c42725310>>
item = <Function test_get_vcs_refs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c42725310>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_vcs_refs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f9c3affc7c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_vcs_refs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c42725310>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_vcs_refs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c42725310>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_vcs_refs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_get_vcs_refs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9c40f11d60>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_get_vcs_refs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f9c42725310>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_get_vcs_refs(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six', returncode=1, stdout='Installing -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-i856n9v7-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 279ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-i856n9v7-tests-R2XTPdcd\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully cr... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:212: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six
Installing -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-i856n9v7-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 279ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-i856n9v7-tests-R2XTPdcd
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-i856n9v7-tests-R2XTPdcd
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six in
dependencies.
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________ test_install_github_vcs_with_credentials[False] ________________
[gw29] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f2a16793100>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2a1c10b650>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17c059d0>>>, ...]
kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17c059d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17c059d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f2a17f00740>
item = <Function test_install_github_vcs_with_credentials[False]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17c059d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17c059d0>>
item = <Function test_install_github_vcs_with_credentials[False]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17c059d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_github_vcs_with_credentials[False]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f2a1641ff80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_github_vcs_with_credentials[False]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17c059d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs_with_credentials[False]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a17c059d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs_with_credentials[False]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_github_vcs_with_credentials[False]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2a1c10b650>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_github_vcs_with_credentials[False]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f2a17c059d0>, index_url='https://pypi.org/simple')
use_credentials = False

    @pytest.mark.basic
    @pytest.mark.install
    @pytest.mark.parametrize("use_credentials", [True, False])
    def test_install_github_vcs_with_credentials(pipenv_instance_pypi, use_credentials):
        with pipenv_instance_pypi() as p:
            # Set environment variables
            os.environ['GIT_REPO'] = 'github.com/reagento/adaptix.git'
            if use_credentials:
                os.environ['GIT_USERNAME'] = 'git'  # Use 'git' as a dummy username
                os.environ['GIT_PASSWORD'] = ''  # Empty password for public repos
                url = "git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16"
            else:
                url = "git+https://${GIT_REPO}@2.16"
            if os.name == 'nt':
                c = p.pipenv(f"install {url} -v")
            else:
                c = p.pipenv(f"install '{url}' -v")
>           assert c.returncode == 0, f"Install failed with error: {c.stderr}"
E           AssertionError: Install failed with error: Warning: the environment variable LANG is not set!
E             We recommend setting this in ~/.profile (or equivalent) for proper expected
E             behavior.
E             Using python: None
E             Path to python:
E             PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
E             n3'), version_str='3.12.11', major=3, minor=12, patch=11, is_prerelease=False,
E             is_postrelease=False, is_devrelease=False, is_debug=False,
E             version=<Version('3.12.11')>, architecture=None, company='PythonCore',
E             name='python3',
E             executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3')
E             Creating a virtualenv for this project
E             Pipfile: /tmp/pipenv-zc8ygox6-tests/Pipfile
E             Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
E             virtualenv...
E             created virtual environment CPython3.12.11.final.0-64 in 248ms
E               creator
E             CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-zc8ygox6-tests-qFWRzEZn
E             , clear=False, no_vcs_ignore=False, global=False)
E               seeder FromAppData(download=False, pip=bundle, via=copy,
E             app_data_dir=/root/.local/share/virtualenv)
E                 added seed packages: pip==25.1.1
E               activators
E             BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
E             ,PythonActivator
E
E             Successfully created virtual environment!
E             Virtualenv location: /root/.local/share/virtualenvs/pipenv-zc8ygox6-tests-qFWRzEZn
E             Pipfile.lock not found, creating...
E             Locking  dependencies...
E             Locking  dependencies...
E             Updated Pipfile.lock
E             (94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
E             INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/reagento/adaptix.git (to revision 2.16) to /tmp/tmp2u65qmku
E             CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
E             Traceback (most recent call last):
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
E                 return call_subprocess(
E                        ^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
E                 proc = subprocess.Popen(
E                        ^^^^^^^^^^^^^^^^^
E               File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
E                 self._execute_child(args, executable, preexec_fn, close_fds,
E               File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
E                 raise child_exception_type(errno_num, err_msg, err_filename)
E             FileNotFoundError: [Errno 2] No such file or directory: 'git'
E
E             During handling of the above exception, another exception occurred:
E
E             Traceback (most recent call last):
E               File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
E                 sys.exit(cli())
E                          ^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
E                 return self.main(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/cli/options.py", line 51, in main
E                 return super().main(*args, **kwargs, windows_expand_args=False)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1078, in main
E                 rv = self.invoke(ctx)
E                      ^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
E                 return _process_result(sub_ctx.command.invoke(sub_ctx))
E                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
E                 return ctx.invoke(self.callback, **ctx.params)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 783, in invoke
E                 return __callback(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
E                 return ctx.invoke(f, obj, *args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 783, in invoke
E                 return __callback(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/cli/command.py", line 208, in install
E                 do_install(
E               File "/app/pipenv/routines/install.py", line 318, in do_install
E                 new_packages, _ = handle_new_packages(
E                                   ^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
E                 added, cat, normalized_name = project.add_package_to_pipfile(
E                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
E                 name, normalized_name, entry = self.generate_package_pipfile_entry(
E                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
E                 req_name = determine_package_name(package)
E                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
E                 local_file = unpack_url(
E                              ^^^^^^^^^^^
E               File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
E                 unpack_vcs_link(link, location, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
E                 vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
E                 self.obtain(location, url=url, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
E                 self.fetch_new(dest, url, rev_options, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
E                 if self.get_git_version() >= (2, 17):
E                    ^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
E                 version = self.run_command(
E                           ^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
E                 return super().run_command(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
E                 raise BadCommand(
E             pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?
E
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args="pipenv install 'git+https://${GIT_REPO}@2.16' -v", returncode=1, stdout='Installing git+https://${GIT_REPO}@2.16...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nUsing python: None\nPath to python: \nPythonInfo(path=PosixPath(\'/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho\nn3\'), version_str=\'3.12.11\', major=3, minor=12, patch=11, is_prerelease=False, \nis_postrelease=False, is_devrelease=False, is_debug=False, \nversion=<Version(\'3.12.11\')>, architecture=None, company=\'PythonCore\', \nname=\'python3\', \nexecutable=\'/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3\')\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-zc8ygox6-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 248ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-zc8ygox6-tests-qFWRzEZn\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/... File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link\n    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack\n    self.obtain(location, url=url, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - do you have \'git\' installed and in your PATH?\n').returncode

tests/integration/test_install_vcs.py:33: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install 'git+https://${GIT_REPO}@2.16' -v
Installing git+https://${GIT_REPO}@2.16...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n3'), version_str='3.12.11', major=3, minor=12, patch=11, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.12.11')>, architecture=None, company='PythonCore',
name='python3',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-zc8ygox6-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 248ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-zc8ygox6-tests-qFWRzEZn
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-zc8ygox6-tests-qFWRzEZn
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/reagento/adaptix.git (to revision 2.16) to /tmp/tmp2u65qmku
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?

________________ test_install_github_vcs_with_credentials[True] ________________
[gw38] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f11564eb740>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f115d6b9490>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f11568c0f50>>>, ...]
kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f11568c0f50>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f11568c0f50>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1157ef81d0>
item = <Function test_install_github_vcs_with_credentials[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f11568c0f50>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f11568c0f50>>
item = <Function test_install_github_vcs_with_credentials[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f11568c0f50>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_github_vcs_with_credentials[True]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f1155e742c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_github_vcs_with_credentials[True]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f11568c0f50>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs_with_credentials[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f11568c0f50>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs_with_credentials[True]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_github_vcs_with_credentials[True]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f115d6b9490>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_github_vcs_with_credentials[True]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f11568c0f50>, index_url='https://pypi.org/simple')
use_credentials = True

    @pytest.mark.basic
    @pytest.mark.install
    @pytest.mark.parametrize("use_credentials", [True, False])
    def test_install_github_vcs_with_credentials(pipenv_instance_pypi, use_credentials):
        with pipenv_instance_pypi() as p:
            # Set environment variables
            os.environ['GIT_REPO'] = 'github.com/reagento/adaptix.git'
            if use_credentials:
                os.environ['GIT_USERNAME'] = 'git'  # Use 'git' as a dummy username
                os.environ['GIT_PASSWORD'] = ''  # Empty password for public repos
                url = "git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16"
            else:
                url = "git+https://${GIT_REPO}@2.16"
            if os.name == 'nt':
                c = p.pipenv(f"install {url} -v")
            else:
                c = p.pipenv(f"install '{url}' -v")
>           assert c.returncode == 0, f"Install failed with error: {c.stderr}"
E           AssertionError: Install failed with error: Warning: the environment variable LANG is not set!
E             We recommend setting this in ~/.profile (or equivalent) for proper expected
E             behavior.
E             Using python: None
E             Path to python:
E             PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
E             n3'), version_str='3.12.11', major=3, minor=12, patch=11, is_prerelease=False,
E             is_postrelease=False, is_devrelease=False, is_debug=False,
E             version=<Version('3.12.11')>, architecture=None, company='PythonCore',
E             name='python3',
E             executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3')
E             Creating a virtualenv for this project
E             Pipfile: /tmp/pipenv-brnjy7eb-tests/Pipfile
E             Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
E             virtualenv...
E             created virtual environment CPython3.12.11.final.0-64 in 305ms
E               creator
E             CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-brnjy7eb-tests-JquivqZi
E             , clear=False, no_vcs_ignore=False, global=False)
E               seeder FromAppData(download=False, pip=bundle, via=copy,
E             app_data_dir=/root/.local/share/virtualenv)
E                 added seed packages: pip==25.1.1
E               activators
E             BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
E             ,PythonActivator
E
E             Successfully created virtual environment!
E             Virtualenv location: /root/.local/share/virtualenvs/pipenv-brnjy7eb-tests-JquivqZi
E             Pipfile.lock not found, creating...
E             Locking  dependencies...
E             Locking  dependencies...
E             Updated Pipfile.lock
E             (94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
E             INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://git:****@github.com/reagento/adaptix.git (to revision 2.16) to /tmp/tmpg52xlfmj
E             CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
E             Traceback (most recent call last):
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
E                 return call_subprocess(
E                        ^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
E                 proc = subprocess.Popen(
E                        ^^^^^^^^^^^^^^^^^
E               File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
E                 self._execute_child(args, executable, preexec_fn, close_fds,
E               File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
E                 raise child_exception_type(errno_num, err_msg, err_filename)
E             FileNotFoundError: [Errno 2] No such file or directory: 'git'
E
E             During handling of the above exception, another exception occurred:
E
E             Traceback (most recent call last):
E               File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
E                 sys.exit(cli())
E                          ^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
E                 return self.main(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/cli/options.py", line 51, in main
E                 return super().main(*args, **kwargs, windows_expand_args=False)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1078, in main
E                 rv = self.invoke(ctx)
E                      ^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
E                 return _process_result(sub_ctx.command.invoke(sub_ctx))
E                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
E                 return ctx.invoke(self.callback, **ctx.params)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 783, in invoke
E                 return __callback(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
E                 return ctx.invoke(f, obj, *args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 783, in invoke
E                 return __callback(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/cli/command.py", line 208, in install
E                 do_install(
E               File "/app/pipenv/routines/install.py", line 318, in do_install
E                 new_packages, _ = handle_new_packages(
E                                   ^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
E                 added, cat, normalized_name = project.add_package_to_pipfile(
E                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
E                 name, normalized_name, entry = self.generate_package_pipfile_entry(
E                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
E                 req_name = determine_package_name(package)
E                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
E                 local_file = unpack_url(
E                              ^^^^^^^^^^^
E               File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
E                 unpack_vcs_link(link, location, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
E                 vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
E                 self.obtain(location, url=url, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
E                 self.fetch_new(dest, url, rev_options, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
E                 if self.get_git_version() >= (2, 17):
E                    ^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
E                 version = self.run_command(
E                           ^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
E                 return super().run_command(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
E                 raise BadCommand(
E             pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?
E
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args="pipenv install 'git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16' -v", returncode=1, stdout='Installing git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nUsing python: None\nPath to python: \nPythonInfo(path=PosixPath(\'/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho\nn3\'), version_str=\'3.12.11\', major=3, minor=12, patch=11, is_prerelease=False, \nis_postrelease=False, is_devrelease=False, is_debug=False, \nversion=<Version(\'3.12.11\')>, architecture=None, company=\'PythonCore\', \nname=\'python3\', \nexecutable=\'/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3\')\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-brnjy7eb-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 305ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-brnjy7eb-tests-JquivqZi\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromApp... File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link\n    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack\n    self.obtain(location, url=url, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - do you have \'git\' installed and in your PATH?\n').returncode

tests/integration/test_install_vcs.py:33: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install 'git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16' -v
Installing git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n3'), version_str='3.12.11', major=3, minor=12, patch=11, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.12.11')>, architecture=None, company='PythonCore',
name='python3',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-brnjy7eb-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 305ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-brnjy7eb-tests-JquivqZi
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-brnjy7eb-tests-JquivqZi
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://git:****@github.com/reagento/adaptix.git (to revision 2.16) to /tmp/tmpg52xlfmj
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?

_______________ test_multiple_editable_packages_should_not_race ________________
[gw1] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f4dee4f1d00>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f4df53ca870>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4dee8e83b0>>>, ...]
kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4dee8e83b0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4dee8e83b0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f4df55ca8a0>
item = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4dee8e83b0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4dee8e83b0>>
item = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4dee8e83b0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_editable_packages_should_not_race>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f4dee5c64c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_editable_packages_should_not_race>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4dee8e83b0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4dee8e83b0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_editable_packages_should_not_race>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_multiple_editable_packages_should_not_race>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f4df53ca870>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f4dee8e83b0>, index_url='http://localhost:8080/simple')
testsroot = '/app/tests'

    @pytest.mark.run
    @pytest.mark.files
    @pytest.mark.install
    def test_multiple_editable_packages_should_not_race(
        pipenv_instance_private_pypi, testsroot
    ):
        """Test for a race condition that can occur when installing multiple 'editable' packages at
        once, and which causes some of them to not be importable.

        This issue had been fixed for VCS packages already, but not local 'editable' packages.

        So this test locally installs packages from tarballs that have already been committed in
        the local `pypi` dir to avoid using VCS packages.
        """
        pkgs = ["six", "jinja2"]

        with pipenv_instance_private_pypi() as p:
            pipfile_string = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [dev-packages]

    [packages]
            """

            for pkg_name in pkgs:
                source_path = p._pipfile.get_fixture_path(f"git/{pkg_name}/")
                shutil.copytree(source_path, pkg_name)

                pipfile_string += (
                    f'"{pkg_name}" = {{path = "./{pkg_name}", editable = true}}\n'
                )

            with open(p.pipfile_path, "w") as f:
                f.write(pipfile_string.strip())

            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-nw8e3g9m-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 341ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-nw8e3g9m-tests-fnvW69p1\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-nw8e3g9m-tests-fnvW69p1\nPipfile.lock not found, creating...\nLocking  dependencies...\n[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main\.../pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: file:///tmp/pipenv-nw8e3g9m-tests/six (from -r \n/tmp/pipenv-fu6k7qdb-requirements/pipenv-7xblpyff-constraints.txt (line 4)) does\nnot appear to be a Python project: neither \'setup.py\' nor \'pyproject.toml\' \nfound.\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:353: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-nw8e3g9m-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 341ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-nw8e3g9m-tests-fnvW69p1
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-nw8e3g9m-tests-fnvW69p1
Pipfile.lock not found, creating...
Locking  dependencies...
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: file:///tmp/pipenv-nw8e3g9m-tests/six (from -r
/tmp/pipenv-fu6k7qdb-requirements/pipenv-7xblpyff-constraints.txt (line 4)) does
not appear to be a Python project: neither 'setup.py' nor 'pyproject.toml'
found.

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_local_tar_gz_file ____________________________
[gw33] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7ff5ed5c25c0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff5ef293a10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed588590>>>, ...]
kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed588590>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed588590>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7ff5eee201a0>
item = <Function test_local_tar_gz_file>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed588590>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed588590>>
item = <Function test_local_tar_gz_file>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed588590>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_local_tar_gz_file>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7ff5ed0e4840>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_local_tar_gz_file>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed588590>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_local_tar_gz_file>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed588590>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_local_tar_gz_file>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_local_tar_gz_file>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff5ef293a10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_local_tar_gz_file>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7ff5ed588590>, index_url='http://localhost:8080/simple')
testsroot = '/app/tests'

    @pytest.mark.files
    @pytest.mark.local
    def test_local_tar_gz_file(pipenv_instance_private_pypi, testsroot):
        file_name = "requests-2.19.1.tar.gz"

        with pipenv_instance_private_pypi() as p:
            requests_path = p._pipfile.get_fixture_path(f"{file_name}")

            # This tests for a bug when installing a zipfile
            c = p.pipenv(f"install {requests_path}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install /app/tests/test_artifacts/requests-2.19.1.tar.gz', returncode=1, stdout='Installing /app/tests/test_artifacts/requests-2.19.1.tar.gz...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-lso_lpw6-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 293ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-lso_lpw6-tests-amOKtEYP\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual envi...lure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: pip subprocess to install build dependencies exited with 1\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:278: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install /app/tests/test_artifacts/requests-2.19.1.tar.gz
Installing /app/tests/test_artifacts/requests-2.19.1.tar.gz...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-lso_lpw6-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 293ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-lso_lpw6-tests-amOKtEYP
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-lso_lpw6-tests-amOKtEYP
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading /app/tests/test_artifacts/requests-2.19.1.tar.gz in  dependencies.
ERROR:pip.subprocessor:pip subprocess to install build dependencies exited with
1
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: pip subprocess to install build dependencies exited with 1

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________ test_global_overrides_environment_markers ___________________
[gw34] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fdf1e022d40>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fdf1f62b650>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf1f1f5820>>>, ...]
kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf1f1f5820>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf1f1f5820>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fdf1f701100>
item = <Function test_global_overrides_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf1f1f5820>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf1f1f5820>>
item = <Function test_global_overrides_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf1f1f5820>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_global_overrides_environment_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fdf1d7adec0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_global_overrides_environment_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf1f1f5820>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_global_overrides_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf1f1f5820>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_global_overrides_environment_markers>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_global_overrides_environment_markers>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fdf1f62b650>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_global_overrides_environment_markers>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fdf1f1f5820>, index_url='http://localhost:8080/simple')

    @flaky
    @pytest.mark.markers
    @pytest.mark.install
    def test_global_overrides_environment_markers(pipenv_instance_private_pypi):
        """Empty (unconditional) dependency should take precedence.
        If a dependency is specified without environment markers, it should
        override dependencies with environment markers. In this example,
        APScheduler requires funcsigs only on Python 2, but since funcsigs is
        also specified as an unconditional dep, its markers should be empty.
        """
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    apscheduler = "*"
    funcsigs = "*"
                """.strip()
                f.write(contents)

            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-xp7qexvx-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 430ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-xp7qexvx-tests-xDxXiFf7\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-xp7qexvx-tests-xDxXiFf7\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for funcsigs\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_markers.py:130: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-7pr4k92e-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 357ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-7pr4k92e-tests-mnl5w0NH
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-7pr4k92e-tests-mnl5w0NH
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement apscheduler (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for apscheduler

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-xp7qexvx-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 430ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-xp7qexvx-tests-xDxXiFf7
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-xp7qexvx-tests-xDxXiFf7
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement funcsigs (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for funcsigs

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________ test_lock_includes_hashes_for_all_platforms __________________
[gw24] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fe618072f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe619ac9a30>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61828e720>>>, ...]
kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61828e720>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61828e720>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fe619479c40>
item = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61828e720>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61828e720>>
item = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61828e720>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_includes_hashes_for_all_platforms>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fe613a97040>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_includes_hashes_for_all_platforms>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61828e720>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe61828e720>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_includes_hashes_for_all_platforms>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_includes_hashes_for_all_platforms>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe619ac9a30>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fe61828e720>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    def test_lock_includes_hashes_for_all_platforms(pipenv_instance_private_pypi):
        """Locking should include hashes for *all* platforms, not just the
        platform we're running lock on."""

        # releases = pytest_pypi.app.packages['yarl'].releases

        releases = {
            "yarl-1.3.0-cp35-cp35m-manylinux1_x86_64.whl": "3890ab952d508523ef4881457c4099056546593fa05e93da84c7250516e632eb",
            "yarl-1.3.0-cp35-cp35m-win_amd64.whl": "b25de84a8c20540531526dfbb0e2d2b648c13fd5dd126728c496d7c3fea33310",
            "yarl-1.3.0-cp36-cp36m-manylinux1_x86_64.whl": "5badb97dd0abf26623a9982cd448ff12cb39b8e4c94032ccdedf22ce01a64842",
            "yarl-1.3.0-cp36-cp36m-win_amd64.whl": "c6e341f5a6562af74ba55205dbd56d248daf1b5748ec48a0200ba227bb9e33f4",
            "yarl-1.3.0-cp37-cp37m-win_amd64.whl": "73f447d11b530d860ca1e6b582f947688286ad16ca42256413083d13f260b7a0",
            "yarl-1.3.0.tar.gz": "024ecdc12bc02b321bc66b41327f930d1c2c543fa9a561b39861da9388ba7aa9",
        }

        def get_hash(release_name):
            # Convert a specific filename to a hash like what would show up in a Pipfile.lock.
            # For example:
            # 'yarl-1.3.0-cp35-cp35m-manylinux1_x86_64.whl' -> 'sha256:3890ab952d508523ef4881457c4099056546593fa05e93da84c7250516e632eb'
            return f"sha256:{releases[release_name]}"

        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    yarl = "==1.3.0"
                """.strip()
                f.write(contents)

            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-jwlsg1d1-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 323ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-jwlsg1d1-tests-i4W6ThvK\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-jwlsg1d1-tests-i4W6ThvK\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the...esolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for yarl==1.3.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:141: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-jwlsg1d1-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 323ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-jwlsg1d1-tests-i4W6ThvK
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-jwlsg1d1-tests-i4W6ThvK
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement yarl==1.3.0 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for yarl==1.3.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

___________________________ test_vcs_can_use_markers ___________________________
[gw16] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f6e2574e520>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_can_use_markers>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e27473a10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e28abd4f0>>>, ...]
kwargs = {'item': <Function test_vcs_can_use_markers>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e28abd4f0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e28abd4f0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6e26ca3c20>
item = <Function test_vcs_can_use_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e28abd4f0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e28abd4f0>>
item = <Function test_vcs_can_use_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e28abd4f0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_vcs_can_use_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f6e252c41c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_vcs_can_use_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e28abd4f0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_can_use_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e28abd4f0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_can_use_markers>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_can_use_markers>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e27473a10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_can_use_markers>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f6e28abd4f0>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_vcs_can_use_markers(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            path = p._pipfile.get_fixture_path("git/six/")
            p._pipfile.install(
                "six",
                {
                    "git": f"{path.as_uri()}",
                    "ref": "1.11.0",
                    "markers": "sys_platform == 'linux'",
                },
            )
            assert "six" in p.pipfile["packages"]
            c = p.pipenv("install -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -v', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.operations.prepare:Obtaining six from \ngit+file:/app/tests/test_artifacts/git/six@1.11.0#egg=six (from -r \n/tmp/pipenv-388sv18u-requirements/pipenv-wpofc5h6-constraints.txt (line 2))\nINFO:pipenv.patched.pip._internal.vcs.git:Cloning \nfile:///app/tests/test_artifacts/git/six (to revision 1.11.0) to \n/root/.local/share/virtualenvs/pipenv-qk6zayen-tests-pz_afva0/src/six\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'git\' while\nexecuting command git version\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in \nrun_command\n    return call_subprocess(\n           ^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in \ncall_subprocess\n    proc = subprocess.Popen(\n           ^^^^^^^^^^^^^^^^^\n  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child\n   ...alenv for this project\nPipfile: /tmp/pipenv-qk6zayen-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 333ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-qk6zayen-tests-pz_afva0\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-qk6zayen-tests-pz_afva0\nPipfile.lock not found, creating...\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_install_uri.py:288: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -v
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.operations.prepare:Obtaining six from
git+file:/app/tests/test_artifacts/git/six@1.11.0#egg=six (from -r
/tmp/pipenv-388sv18u-requirements/pipenv-wpofc5h6-constraints.txt (line 2))
INFO:pipenv.patched.pip._internal.vcs.git:Cloning
file:///app/tests/test_artifacts/git/six (to revision 1.11.0) to
/root/.local/share/virtualenvs/pipenv-qk6zayen-tests-pz_afva0/src/six
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n3'), version_str='3.12.11', major=3, minor=12, patch=11, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.12.11')>, architecture=None, company='PythonCore',
name='python3',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-qk6zayen-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 333ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-qk6zayen-tests-pz_afva0
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-qk6zayen-tests-pz_afva0
Pipfile.lock not found, creating...
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________________ test_complex_lock_with_vcs_deps ________________________
[gw31] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f1b04ed59e0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1b06969a30>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1b06319010>>>, ...]
kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1b06319010>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1b06319010>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1b06652900>
item = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1b06319010>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1b06319010>>
item = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1b06319010>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_complex_lock_with_vcs_deps>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f1b04ebe800>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_complex_lock_with_vcs_deps>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1b06319010>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1b06319010>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_complex_lock_with_vcs_deps>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_complex_lock_with_vcs_deps>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1b06969a30>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f1b06319010>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.complex
    @pytest.mark.needs_internet
    def test_complex_lock_with_vcs_deps(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            dateutil_uri = p._pipfile.get_fixture_path("git/dateutil").as_uri()
            with open(p.pipfile_path, "w") as f:
                contents = (
                    """
    [packages]
    click = "==6.7"

    [dev-packages]
    requests = {git = "%s"}
                """.strip()
                    % requests_uri
                )
                f.write(contents)

            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nSuccess!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-5qi20vby-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 421ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5qi20vby-tests-rCJyeZ7v\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-5qi20vby-tests-rCJyeZ7v\nPipfile.lock not found, creating...\nLocking  dependencies...\nLocking  d... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:188: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Success!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-5qi20vby-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 421ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5qi20vby-tests-rCJyeZ7v
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-5qi20vby-tests-rCJyeZ7v
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_lock_editable_vcs_with_ref_in_git ____________________
[gw17] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9c3b6cad40>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9c40f11d60>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b25be30>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b25be30>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b25be30>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9c40e63c20>
item = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b25be30>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b25be30>>
item = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b25be30>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_ref_in_git>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f9c3b183a40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_ref_in_git>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b25be30>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b25be30>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_ref_in_git>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_with_ref_in_git>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9c40f11d60>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f9c3b25be30>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_with_ref_in_git(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    requests = {git = "%s@883caaf", editable = true}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-qnfwl0ev-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 303ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-qnfwl0ev-tests-mK_K0QG5\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-qnfwl0ev-tests-mK_K0QG5\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'git\' while\nexecuting command git version... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:400: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-qnfwl0ev-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 303ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-qnfwl0ev-tests-mK_K0QG5
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-qnfwl0ev-tests-mK_K0QG5
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

___________________________ test_lock_updated_source ___________________________
[gw7] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f6e8bb660c0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_updated_source>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e915a4350>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e90dc7e60>>>, ...]
kwargs = {'item': <Function test_lock_updated_source>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e90dc7e60>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e90dc7e60>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6e928828a0>
item = <Function test_lock_updated_source>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e90dc7e60>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e90dc7e60>>
item = <Function test_lock_updated_source>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e90dc7e60>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_updated_source>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f6e8bbb7780>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_updated_source>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e90dc7e60>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_updated_source>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e90dc7e60>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_updated_source>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_updated_source>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_updated_source>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e915a4350>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_updated_source>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_updated_source>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_updated_source>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_updated_source>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f6e90dc7e60>, index_url='http://localhost:8080/simple')

    @pytest.mark.index
    @pytest.mark.install
    def test_lock_updated_source(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{url}/${{MY_ENV_VAR}}"
    name = "localpypi"
    verify_ssl = false

    [packages]
    requests = "==2.14.0"
                """.strip().format(
                    url=p.pypi
                )
                f.write(contents)

            with temp_environ():
                os.environ["MY_ENV_VAR"] = "simple"
                c = p.pipenv("lock")
>               assert c.returncode == 0
E               assert 1 == 0
E                +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-0idkdl_d-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 445ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0idkdl_d-tests-J0aMNGXG\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-0idkdl_d-tests-J0aMNGXG\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the...tionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests==2.14.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:344: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-0idkdl_d-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 445ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0idkdl_d-tests-J0aMNGXG
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-0idkdl_d-tests-J0aMNGXG
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests==2.14.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests==2.14.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________ test_lock_editable_vcs_with_markers_without_install ______________
[gw33] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7ff5ed5c37e0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff5ef293a10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed76aea0>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed76aea0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed76aea0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7ff5eee201a0>
item = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed76aea0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed76aea0>>
item = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed76aea0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_markers_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7ff5ed30f600>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_markers_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed76aea0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed76aea0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_markers_without_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_with_markers_without_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff5ef293a10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7ff5ed76aea0>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_with_markers_without_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    requests = {git = "%s", editable = true, markers = "python_version >= '2.6'"}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-39ox7yvs-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 364ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-39ox7yvs-tests-zsIEv4U-\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-39ox7yvs-tests-zsIEv4U-\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'git\' while\nexecuting command git version... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:447: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-39ox7yvs-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 364ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-39ox7yvs-tests-zsIEv4U-
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-39ox7yvs-tests-zsIEv4U-
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________________ test_pipenv_graph_reverse ___________________________
[gw3] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fe3114ed760>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_pipenv_graph_reverse>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe3134d8830>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe312a42f30>>>, ...]
kwargs = {'item': <Function test_pipenv_graph_reverse>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe312a42f30>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe312a42f30>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fe312f7fa10>
item = <Function test_pipenv_graph_reverse>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe312a42f30>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe312a42f30>>
item = <Function test_pipenv_graph_reverse>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe312a42f30>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_graph_reverse>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fe311ac9f80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_graph_reverse>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe312a42f30>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_graph_reverse>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe312a42f30>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_graph_reverse>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_pipenv_graph_reverse>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe3134d8830>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_pipenv_graph_reverse>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fe312a42f30>, index_url='http://localhost:8080/simple')

    @pytest.mark.cli
    def test_pipenv_graph_reverse(pipenv_instance_private_pypi):
        from pipenv.cli import cli
        from pipenv.vendor.click.testing import CliRunner

        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install tablib==0.13.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install tablib==0.13.0', returncode=1, stdout='Installing tablib==0.13.0...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-0d1slb_z-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 360ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0d1slb_z-tests-86xEEh1w\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv...lutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for tablib==0.13.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_cli.py:108: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install tablib==0.13.0
Installing tablib==0.13.0...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-0d1slb_z-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 360ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0d1slb_z-tests-86xEEh1w
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-0d1slb_z-tests-86xEEh1w
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading tablib==0.13.0 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement tablib==0.13.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for tablib==0.13.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________ test_install_vcs_ref_by_commit_hash ______________________
[gw29] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f2a16793880>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2a1c10b650>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a167191c0>>>, ...]
kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a167191c0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a167191c0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f2a17f00740>
item = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a167191c0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a167191c0>>
item = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a167191c0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_vcs_ref_by_commit_hash>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f2a15f70240>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_vcs_ref_by_commit_hash>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a167191c0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2a167191c0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_vcs_ref_by_commit_hash>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_vcs_ref_by_commit_hash>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2a1c10b650>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f2a167191c0>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_vcs_ref_by_commit_hash(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install -e git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a59#egg=six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -e git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a59#egg=six', returncode=1, stdout='Installing -e \ngit+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a5\n9#egg=six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-gkt74dmq-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 378ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gkt74dmq-tests-xWQNiyTX\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_vcs.py:56: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -e git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a59#egg=six
Installing -e
git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a5
9#egg=six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-gkt74dmq-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 378ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gkt74dmq-tests-xWQNiyTX
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-gkt74dmq-tests-xWQNiyTX
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading -e
git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a5
9#egg=six in  dependencies.
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_get_source[True] _____________________________
[gw16] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f6e2574ef20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e27473a10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e258e2bd0>>>, ...]
kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e258e2bd0>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e258e2bd0>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6e26ca3c20>
item = <Function test_get_source[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e258e2bd0>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e258e2bd0>>
item = <Function test_get_source[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e258e2bd0>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_source[True]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f6e25127900>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_source[True]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e258e2bd0>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_source[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e258e2bd0>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_source[True]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_get_source[True]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_get_source[True]>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e27473a10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_get_source[True]>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_source[True]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_source[True]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_get_source[True]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f6e258e2bd0>, index_url='http://localhost:8080/simple')
lock_first = True

    @pytest.mark.project
    @pytest.mark.sources
    @pytest.mark.parametrize("lock_first", [True, False])
    def test_get_source(pipenv_instance_private_pypi, lock_first):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
    pytz = "*"
    six = {{version = "*", index = "pypi"}}

    [dev-packages]
                """.strip()
                f.write(contents)

            if lock_first:
                # force source to be cached
                c = p.pipenv("lock")
>               assert c.returncode == 0
E               assert 1 == 0
E                +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-rv1u_hcd-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 431ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-rv1u_hcd-tests-ObFcuEJ_\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-rv1u_hcd-tests-ObFcuEJ_\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the...eps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for pytz\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_project.py:64: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-rv1u_hcd-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 431ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-rv1u_hcd-tests-ObFcuEJ_
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-rv1u_hcd-tests-ObFcuEJ_
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement pytz (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for pytz

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________ test_platform_python_implementation_marker __________________
[gw8] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fd2acd62160>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd2ae2eb3e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2adeb6840>>>, ...]
kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2adeb6840>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2adeb6840>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fd2ae1f81d0>
item = <Function test_platform_python_implementation_marker>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2adeb6840>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2adeb6840>>
item = <Function test_platform_python_implementation_marker>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2adeb6840>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_platform_python_implementation_marker>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fd2ac483280>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_platform_python_implementation_marker>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2adeb6840>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_platform_python_implementation_marker>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2adeb6840>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_platform_python_implementation_marker>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_platform_python_implementation_marker>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd2ae2eb3e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_platform_python_implementation_marker>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fd2adeb6840>, index_url='http://localhost:8080/simple')

    @flaky
    @pytest.mark.markers
    def test_platform_python_implementation_marker(pipenv_instance_private_pypi):
        """Markers should be converted during locking to help users who input this
        incorrectly.
        """
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install depends-on-marked-package")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install depends-on-marked-package', returncode=1, stdout='Installing depends-on-marked-package...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-2hdnpl74-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 405ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-2hdnpl74-tests-aN-SBd21\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/sh...re]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for depends-on-marked-package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_markers.py:49: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install depends-on-marked-package
Installing depends-on-marked-package...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-gegwk8f_-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 302ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gegwk8f_-tests-zCTE8SWa
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-gegwk8f_-tests-zCTE8SWa
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading depends-on-marked-package in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement depends-on-marked-package (from
versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for depends-on-marked-package

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

----------------------------- Captured stdout call -----------------------------
$ pipenv install depends-on-marked-package
Installing depends-on-marked-package...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-2hdnpl74-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 405ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-2hdnpl74-tests-aN-SBd21
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-2hdnpl74-tests-aN-SBd21
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading depends-on-marked-package in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement depends-on-marked-package (from
versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for depends-on-marked-package

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________ test_no_duplicate_source_on_install ______________________
[gw11] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f5f25ec1bc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5f27b6ff80>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f268629c0>>>, ...]
kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f268629c0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f268629c0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f5f27419cd0>
item = <Function test_no_duplicate_source_on_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f268629c0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f268629c0>>
item = <Function test_no_duplicate_source_on_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f268629c0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_no_duplicate_source_on_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f5f25e9fa00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_no_duplicate_source_on_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f268629c0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_no_duplicate_source_on_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f268629c0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_no_duplicate_source_on_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_no_duplicate_source_on_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5f27b6ff80>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_no_duplicate_source_on_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f5f268629c0>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    def test_no_duplicate_source_on_install(pipenv_instance_private_pypi):
        """Ensure that running pipenv install with an index URL doesn't create duplicate [[source]] sections."""
        with pipenv_instance_private_pypi() as p:
            # Create initial Pipfile with a source
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
                """.strip()
                f.write(contents)

            # Install a package with a custom index
            c = p.pipenv(f"install six --index {p.index_url}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --index http://localhost:8080/simple', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (3cbc06)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-lc695hqr-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 317ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-lc695hqr-tests-G5DU2ygg\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/vir...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:502: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --index http://localhost:8080/simple
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (3cbc06)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-lc695hqr-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 317ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-lc695hqr-tests-G5DU2ygg
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-lc695hqr-tests-G5DU2ygg
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(ebffa69a1fa192d1cef7cb42ad79231ca976565c5ce371a70160b3048d3cbc06)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________ test_lock_editable_vcs_with_extras_without_install ______________
[gw17] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9c3b6cb060>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9c40f11d60>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b2dc050>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b2dc050>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b2dc050>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9c40e63c20>
item = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b2dc050>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b2dc050>>
item = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b2dc050>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_extras_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f9c3a9ece80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_extras_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b2dc050>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9c3b2dc050>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_extras_without_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_with_extras_without_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9c40f11d60>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f9c3b2dc050>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.extras
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_with_extras_without_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    requests = {git = "%s", editable = true, extras = ["socks"]}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-y51ken23-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 411ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-y51ken23-tests-b5LAgrom\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-y51ken23-tests-b5LAgrom\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'git\' while\nexecuting command git version... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:424: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-y51ken23-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 411ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-y51ken23-tests-b5LAgrom
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-y51ken23-tests-b5LAgrom
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_vcs_dev_package_install _________________________
[gw35] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f019da27100>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_dev_package_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f019f4a33e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01a0e552e0>>>, ...]
kwargs = {'item': <Function test_vcs_dev_package_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01a0e552e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01a0e552e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f019f3b01d0>
item = <Function test_vcs_dev_package_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01a0e552e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01a0e552e0>>
item = <Function test_vcs_dev_package_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01a0e552e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_dev_package_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f019d63bb80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_dev_package_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01a0e552e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_dev_package_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01a0e552e0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_dev_package_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_dev_package_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_dev_package_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f019f4a33e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_dev_package_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_dev_package_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_dev_package_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_dev_package_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f01a0e552e0>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.dev
    @pytest.mark.install
    def test_vcs_dev_package_install(pipenv_instance_pypi):
        """Ensure VCS packages can be properly installed into dev-packages via --dev flag with existing Pipfile."""
        with pipenv_instance_pypi() as p:
            # Create a Pipfile with some existing packages
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
    six = "*"

    [dev-packages]
    pytest-xdist = {git = "https://github.com/pytest-dev/pytest-xdist.git", ref = "v3.6.1"}
                """.strip()
                f.write(contents)

            # Install a VCS package with --dev flag
            c = p.pipenv("install --dev -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install --dev -v', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'six\'), None)\nINFO:pipenv.patched.pip._internal.operations.prepare:Collecting six (from -r \n/tmp/pipenv-d3w3bugo-requirements/pipenv-fi96t71j-constraints.txt (line 2))\nINFO:pipenv.patched.pip._internal.network.download:Using cached \nsix-1.17.0-py2.py3-none-any.whl.metadata (1.7 kB)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng_round(0)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.pinnin\ng(LinkCandidate(\'https://files.pythonhosted.org/packages/b7/ce/149a00dd41f10bc29\ne5921b496af8b574d8413afcd5e30dfa0ed46c2cc5e/six-1.17.0-py2.py3-none-any.whl \n(from https://pypi.org/simple/six/) \n(requires-python:!=3.0.*,!=3.1.*,!=3.2.*,>=2.7)\'))\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.ending\n_round(0, state)\nINFO:pipenv.patched.pip._internal.resolution.resolv...ile: /tmp/pipenv-5q81wkqq-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 399ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5q81wkqq-tests--KywacpO\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-5q81wkqq-tests--KywacpO\nPipfile.lock not found, creating...\nLocking  dependencies...\n\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_install_vcs.py:100: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install --dev -v
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('six'), None)
INFO:pipenv.patched.pip._internal.operations.prepare:Collecting six (from -r
/tmp/pipenv-d3w3bugo-requirements/pipenv-fi96t71j-constraints.txt (line 2))
INFO:pipenv.patched.pip._internal.network.download:Using cached
six-1.17.0-py2.py3-none-any.whl.metadata (1.7 kB)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng_round(0)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.pinnin
g(LinkCandidate('https://files.pythonhosted.org/packages/b7/ce/149a00dd41f10bc29
e5921b496af8b574d8413afcd5e30dfa0ed46c2cc5e/six-1.17.0-py2.py3-none-any.whl
(from https://pypi.org/simple/six/)
(requires-python:!=3.0.*,!=3.1.*,!=3.2.*,>=2.7)'))
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.ending
_round(0, state)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng_round(1)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.ending
(State(mapping=OrderedDict({'six':
LinkCandidate('https://files.pythonhosted.org/packages/b7/ce/149a00dd41f10bc29e5
921b496af8b574d8413afcd5e30dfa0ed46c2cc5e/six-1.17.0-py2.py3-none-any.whl (from
https://pypi.org/simple/six/)
(requires-python:!=3.0.*,!=3.1.*,!=3.2.*,>=2.7)')}), criteria={'six':
Criterion((SpecifierRequirement('six'), via=None))}, backtrack_causes=[]))
INFO:pipenv.patched.pip._internal.network.download:Using cached
six-1.17.0-py2.py3-none-any.whl (11 kB)
Success!
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.operations.prepare:Collecting pytest-xdist@
git+https://github.com/pytest-dev/pytest-xdist.git@v3.6.1 (from -r
/tmp/pipenv-k1ty2q34-requirements/pipenv-btk8638k-constraints.txt (line 2))
INFO:pipenv.patched.pip._internal.vcs.git:Cloning
https://github.com/pytest-dev/pytest-xdist.git (to revision v3.6.1) to
/tmp/pip-temp-xbnzqixe/pytest-xdist_ba70fec490844ae093df779c75a5e00d
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n3'), version_str='3.12.11', major=3, minor=12, patch=11, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.12.11')>, architecture=None, company='PythonCore',
name='python3',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-5q81wkqq-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 399ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5q81wkqq-tests--KywacpO
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-5q81wkqq-tests--KywacpO
Pipfile.lock not found, creating...
Locking  dependencies...

Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________________ test_lock_nested_vcs_direct_url ________________________
[gw13] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fc9ca7ed620>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc9d0198410>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cad191f0>>>, ...]
kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cad191f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cad191f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fc9cbcc0c50>
item = <Function test_lock_nested_vcs_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cad191f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cad191f0>>
item = <Function test_lock_nested_vcs_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cad191f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_nested_vcs_direct_url>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fc9ca5bb440>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_nested_vcs_direct_url>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cad191f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_nested_vcs_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cad191f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_nested_vcs_direct_url>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_nested_vcs_direct_url>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_nested_vcs_direct_url>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc9d0198410>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_nested_vcs_direct_url>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_nested_vcs_direct_url>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_nested_vcs_direct_url>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_nested_vcs_direct_url>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fc9cad191f0>, index_url='https://pypi.org/simple')

    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_nested_vcs_direct_url(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            p._pipfile.add(
                "pep508_package",
                {
                    "git": "https://github.com/techalchemy/test-project.git",
                    "editable": True,
                    "ref": "master",
                    "subdirectory": "parent_folder/pep508-package",
                },
            )
            c = p.pipenv("lock -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock -v', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.operations.prepare:Collecting pep508_package@ \ngit+https://github.com/techalchemy/test-project.git@master#subdirectory=parent_f\nolder/pep508-package (from -r \n/tmp/pipenv-pajbtfij-requirements/pipenv-ajp0vcju-constraints.txt (line 2))\nINFO:pipenv.patched.pip._internal.vcs.git:Cloning \nhttps://github.com/techalchemy/test-project.git (to revision master) to \n/tmp/pip-temp-ic6aekkv/pep508-package_a648933c52d9410ea2e8a853bea929c8\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'git\' while\nexecuting command git version\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in \nrun_command\n    return call_subprocess(\n           ^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in \ncall_subprocess\n    proc = subprocess.Popen(\n           ^^^^^^^^^^^^^^^^^\n  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n  File "/usr/lib/py...Aip0Q/bin/python3')\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-cebmmzhl-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 431ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-cebmmzhl-tests-W-znWv1h\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-cebmmzhl-tests-W-znWv1h\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_lock.py:562: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock -v
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.operations.prepare:Collecting pep508_package@
git+https://github.com/techalchemy/test-project.git@master#subdirectory=parent_f
older/pep508-package (from -r
/tmp/pipenv-pajbtfij-requirements/pipenv-ajp0vcju-constraints.txt (line 2))
INFO:pipenv.patched.pip._internal.vcs.git:Cloning
https://github.com/techalchemy/test-project.git (to revision master) to
/tmp/pip-temp-ic6aekkv/pep508-package_a648933c52d9410ea2e8a853bea929c8
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n3'), version_str='3.12.11', major=3, minor=12, patch=11, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.12.11')>, architecture=None, company='PythonCore',
name='python3',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-cebmmzhl-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 431ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-cebmmzhl-tests-W-znWv1h
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-cebmmzhl-tests-W-znWv1h
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________ test_multiple_category_install[prereq other] _________________
[gw30] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9008592e80>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9009ec3530>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f900873fe30>>>, ...]
kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f900873fe30>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f900873fe30>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9009a6f680>
item = <Function test_multiple_category_install[prereq other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f900873fe30>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f900873fe30>>
item = <Function test_multiple_category_install[prereq other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f900873fe30>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f90080a4200>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f900873fe30>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f900873fe30>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq other]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_multiple_category_install[prereq other]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9009ec3530>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_multiple_category_install[prereq other]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f900873fe30>, index_url='http://localhost:8080/simple')
categories = 'prereq other'

    @pytest.mark.categories
    @pytest.mark.install
    @pytest.mark.parametrize("categories", ["prereq other", "prereq, other"])
    def test_multiple_category_install(pipenv_instance_private_pypi, categories):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv('install six --categories="prereq other"')
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --categories="prereq other"', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-pqpponnx-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 413ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-pqpponnx-tests-0nrOS1RP\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_categories.py:47: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --categories="prereq other"
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-pqpponnx-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 413ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-pqpponnx-tests-0nrOS1RP
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-pqpponnx-tests-0nrOS1RP
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_lock_editable_vcs_without_install ____________________
[gw7] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f6e8bb67100>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e915a4350>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e92682990>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e92682990>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e92682990>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6e928828a0>
item = <Function test_lock_editable_vcs_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e92682990>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e92682990>>
item = <Function test_lock_editable_vcs_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e92682990>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f6e8b476880>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e92682990>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e92682990>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_without_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_without_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e915a4350>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_without_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f6e92682990>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_without_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/six").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    six = {git = "%s", editable = true}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-4f56jej6-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 397ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-4f56jej6-tests-TLl2yD59\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-4f56jej6-tests-TLl2yD59\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'git\' while\nexecuting command git version... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:381: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-4f56jej6-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 397ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-4f56jej6-tests-TLl2yD59
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-4f56jej6-tests-TLl2yD59
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_update_locks _______________________________
[gw22] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f093afc9ee0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f0940b10b00>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f0941f7d460>>>, ...]
kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f0941f7d460>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f0941f7d460>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f0940679c70>
item = <Function test_update_locks>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f0941f7d460>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f0941f7d460>>
item = <Function test_update_locks>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f0941f7d460>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_update_locks>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f093a78db40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_update_locks>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f0941f7d460>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_locks>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f0941f7d460>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_locks>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_locks>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f0940b10b00>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_locks>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f0941f7d460>, index_url='http://localhost:8080/simple')

    @pytest.mark.update
    @pytest.mark.lock
    def test_update_locks(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install jdcal==1.3")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install jdcal==1.3', returncode=1, stdout='Installing jdcal==1.3...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-3r0zzq0w-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 585ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-3r0zzq0w-tests-GEZBghD4\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-3r0zzq0...ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for jdcal==1.3\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_pipenv.py:47: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install jdcal==1.3
Installing jdcal==1.3...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-3r0zzq0w-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 585ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-3r0zzq0w-tests-GEZBghD4
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-3r0zzq0w-tests-GEZBghD4
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading jdcal==1.3 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement jdcal==1.3 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for jdcal==1.3

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_vcs_lock_respects_top_level_pins _____________________
[gw25] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f64d894dc60>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f64da353650>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d89ec890>>>, ...]
kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d89ec890>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d89ec890>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f64d9f1d400>
item = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d89ec890>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d89ec890>>
item = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d89ec890>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_lock_respects_top_level_pins>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f64d8d2e7c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_lock_respects_top_level_pins>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d89ec890>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d89ec890>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_lock_respects_top_level_pins>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_lock_respects_top_level_pins>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f64da353650>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f64d89ec890>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    def test_vcs_lock_respects_top_level_pins(pipenv_instance_private_pypi):
        """Test that locking VCS dependencies respects top level packages pinned in Pipfiles"""

        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            p._pipfile.add(
                "requests", {"editable": True, "git": f"{requests_uri}", "ref": "v2.18.4"}
            )
            p._pipfile.add("urllib3", "==1.21.1")
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-66_4wksj-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 353ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-66_4wksj-tests-8sotH74n\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-66_4wksj-tests-8sotH74n\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'git\' while\nexecuting command git version... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:488: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-66_4wksj-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 353ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-66_4wksj-tests-8sotH74n
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-66_4wksj-tests-8sotH74n
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________ test_dev_lock_use_default_packages_as_constraint _______________
[gw8] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fd2acd62200>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd2ae2eb3e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2ac994a40>>>, ...]
kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2ac994a40>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2ac994a40>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fd2ae1f81d0>
item = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2ac994a40>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2ac994a40>>
item = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2ac994a40>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_dev_lock_use_default_packages_as_constraint>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fd2ac28d840>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_dev_lock_use_default_packages_as_constraint>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2ac994a40>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2ac994a40>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_dev_lock_use_default_packages_as_constraint>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_dev_lock_use_default_packages_as_constraint>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd2ae2eb3e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fd2ac994a40>, index_url='http://localhost:8080/simple')

    @pytest.mark.dev
    @pytest.mark.lock
    @pytest.mark.install
    def test_dev_lock_use_default_packages_as_constraint(pipenv_instance_private_pypi):
        # See https://github.com/pypa/pipenv/issues/4371
        # See https://github.com/pypa/pipenv/issues/2987
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    requests = "<=2.14.0"

    [dev-packages]
    requests = "*"
                    """.strip()
                f.write(contents)

            c = p.pipenv("lock --dev")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --dev', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-l9g7r4w8-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 309ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-l9g7r4w8-tests-hF-_VQ9F\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-l9g7r4w8-tests-hF-_VQ9F\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfi...tionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests<=2.14.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:666: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --dev
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-l9g7r4w8-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 309ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-l9g7r4w8-tests-hF-_VQ9F
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-l9g7r4w8-tests-hF-_VQ9F
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests<=2.14.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests<=2.14.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_lock_handle_eggs _____________________________
[gw35] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f019da27600>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f019f4a33e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019db1e150>>>, ...]
kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019db1e150>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019db1e150>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f019f3b01d0>
item = <Function test_lock_handle_eggs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019db1e150>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019db1e150>>
item = <Function test_lock_handle_eggs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019db1e150>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_handle_eggs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f019d4a7680>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_handle_eggs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019db1e150>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_handle_eggs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f019db1e150>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_handle_eggs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_handle_eggs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f019f4a33e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_handle_eggs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f019db1e150>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.requirements
    def test_lock_handle_eggs(pipenv_instance_private_pypi):
        """Ensure locking works with packages providing egg formats."""
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                f.write(
                    f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    RandomWords = "*"
                """
                )
            c = p.pipenv("lock --verbose")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --verbose', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.network.session:adding trusted host: \n\'localhost:8080\' (from line 2 of \n/tmp/pipenv-u51wxlo6-requirements/pipenv-japfcrac-constraints.txt)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'RandomWords\'), None)\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the requirement RandomWords (from versions: none)\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 429, in resolve\n    self._add_to_criteria(self.state.criteria, r, parent=None)\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 151, in _add_to_criteria\n    raise RequirementsConflicted(criterion)\npipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte\nd: Requirements conflict: SpecifierRequirement(\'RandomWords\')\nThe a...Aip0Q/bin/python3')\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-sznogu4t-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 465ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-sznogu4t-tests-_8tRsV_5\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-sznogu4t-tests-_8tRsV_5\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_lock.py:28: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --verbose
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.network.session:adding trusted host:
'localhost:8080' (from line 2 of
/tmp/pipenv-u51wxlo6-requirements/pipenv-japfcrac-constraints.txt)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('RandomWords'), None)
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement RandomWords (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('RandomWords')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
                            ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('RandomWords'),
parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for RandomWords
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
RandomWords
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n3'), version_str='3.12.11', major=3, minor=12, patch=11, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.12.11')>, architecture=None, company='PythonCore',
name='python3',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-sznogu4t-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 465ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-sznogu4t-tests-_8tRsV_5
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-sznogu4t-tests-_8tRsV_5
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________ test_lock_package_with_compatible_release_specifier ______________
[gw13] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fc9ca7ef4c0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc9d0198410>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9ca57a060>>>, ...]
kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9ca57a060>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9ca57a060>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fc9cbcc0c50>
item = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9ca57a060>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9ca57a060>>
item = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9ca57a060>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_package_with_compatible_release_specifier>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fc9c9f9d780>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_package_with_compatible_release_specifier>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9ca57a060>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9ca57a060>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_package_with_compatible_release_specifier>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_package_with_compatible_release_specifier>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc9d0198410>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fc9ca57a060>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.install
    def test_lock_package_with_compatible_release_specifier(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six~=1.11")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six~=1.11', returncode=1, stdout='Installing six~=1.11...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-wff84mfo-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 406ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-wff84mfo-tests-hQVEJqg7\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-wff84mfo-...[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six~=1.11\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:579: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six~=1.11
Installing six~=1.11...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-wff84mfo-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 406ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-wff84mfo-tests-hQVEJqg7
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-wff84mfo-tests-hQVEJqg7
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six~=1.11 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six~=1.11 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six~=1.11

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________ test_lock_specific_named_category _______________________
[gw8] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fd2acd63a60>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd2ae2eb3e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2aca1a030>>>, ...]
kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2aca1a030>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2aca1a030>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fd2ae1f81d0>
item = <Function test_lock_specific_named_category>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2aca1a030>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2aca1a030>>
item = <Function test_lock_specific_named_category>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2aca1a030>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_specific_named_category>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fd2ac7c3900>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_specific_named_category>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2aca1a030>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_specific_named_category>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd2aca1a030>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_specific_named_category>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_specific_named_category>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd2ae2eb3e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_specific_named_category>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fd2aca1a030>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    def test_lock_specific_named_category(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi(pipfile=False) as p:
            contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = true
    name = "test"

    [packages]
    requests = "*"

    [prereq]
    six = "*"
            """.strip()
            with open(p.pipfile_path, "w") as f:
                f.write(contents)
            c = p.pipenv("lock --categories prereq")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --categories prereq', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-i3vm2rh7-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 392ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-i3vm2rh7-tests-gjyEkeMq\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-i3vm2rh7-tests-gjyEkeMq\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a versio...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:697: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --categories prereq
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-i3vm2rh7-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 392ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-i3vm2rh7-tests-gjyEkeMq
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-i3vm2rh7-tests-gjyEkeMq
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_lock_nested_direct_url __________________________
[gw12] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f02c7fb5b20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_nested_direct_url>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f02cdc11a30>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f02cd5d39e0>>>, ...]
kwargs = {'item': <Function test_lock_nested_direct_url>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f02cd5d39e0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f02cd5d39e0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f02cd5c1cd0>
item = <Function test_lock_nested_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f02cd5d39e0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f02cd5d39e0>>
item = <Function test_lock_nested_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f02cd5d39e0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_nested_direct_url>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f02cc312380>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_nested_direct_url>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f02cd5d39e0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_nested_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f02cd5d39e0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_nested_direct_url>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_nested_direct_url>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f02cdc11a30>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_nested_direct_url>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f02cd5d39e0>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    def test_lock_nested_direct_url(pipenv_instance_private_pypi):
        """
        The dependency 'test_package' has a declared dependency on
        a PEP508 style VCS URL. This ensures that we capture the dependency
        here along with its own dependencies.
        """
        with pipenv_instance_private_pypi(pipfile=False) as p:
            contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = true
    name = "local"

    [packages]
    test_package = "*"
                    """.strip()
            with open(p.pipfile_path, "w") as f:
                f.write(contents)
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-je6arc6x-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 513ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-je6arc6x-tests-e0Y7ur3_\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-je6arc6x-tests-e0Y7ur3_\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the...solutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for test_package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:542: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-je6arc6x-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 513ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-je6arc6x-tests-e0Y7ur3_
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-je6arc6x-tests-e0Y7ur3_
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement test_package (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for test_package

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_mirror_lock_sync _____________________________
[gw3] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fe3114ef100>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe3134d8830>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe3148492e0>>>, ...]
kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe3148492e0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe3148492e0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fe312f7fa10>
item = <Function test_mirror_lock_sync>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe3148492e0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe3148492e0>>
item = <Function test_mirror_lock_sync>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe3148492e0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_mirror_lock_sync>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fe31103a840>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_mirror_lock_sync>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe3148492e0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mirror_lock_sync>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe3148492e0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mirror_lock_sync>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_mirror_lock_sync>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe3134d8830>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_mirror_lock_sync>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fe3148492e0>, index_url='http://localhost:8080/simple')

    @pytest.mark.sync
    @pytest.mark.lock
    def test_mirror_lock_sync(pipenv_instance_private_pypi):
        with temp_environ(), pipenv_instance_private_pypi() as p:
            mirror_url = p.index_url
            assert "pypi.org" not in mirror_url
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [[source]]
    name = "pypi"
    url = "https://pypi.org/simple"
    verify_ssl = true

    [packages]
    six = "==1.12.0"
                """.strip()
                )
            c = p.pipenv(f"lock --pypi-mirror {mirror_url}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --pypi-mirror http://localhost:8080/simple', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-gamffho_-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 310ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gamffho_-tests-_7ipgajO\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-gamffho_-tests-_7ipgajO\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Co...esolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six==1.12.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_sync.py:41: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --pypi-mirror http://localhost:8080/simple
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-gamffho_-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 310ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gamffho_-tests-_7ipgajO
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-gamffho_-tests-_7ipgajO
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six==1.12.0 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six==1.12.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________________ test_file_urls_work ______________________________
[gw19] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f289101d9e0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2892bc59d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f289258b6b0>>>, ...]
kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f289258b6b0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f289258b6b0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f28928b1940>
item = <Function test_file_urls_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f289258b6b0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f289258b6b0>>
item = <Function test_file_urls_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f289258b6b0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_file_urls_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f2891592600>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_file_urls_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f289258b6b0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_file_urls_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f289258b6b0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_file_urls_work>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_file_urls_work>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_file_urls_work>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2892bc59d0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_file_urls_work>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_file_urls_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_file_urls_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_file_urls_work>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f289258b6b0>, index_url='https://pypi.org/simple')

    @pytest.mark.urls
    @pytest.mark.files
    def test_file_urls_work(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            whl = Path(
                Path(__file__).resolve().parent.parent
                / "pypi"
                / "six"
                / "six-1.11.0-py2.py3-none-any.whl"
            )

            try:
                whl = whl.resolve()
            except OSError:
                whl = whl.absolute()
            wheel_url = whl.as_uri()
            c = p.pipenv(f'install "{wheel_url}"')
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install "file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl"', returncode=1, stdout='Installing file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (91492b)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-tlvk8bgh-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 479ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-tlvk8bgh-tests-Gk0R-MVA\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfull...nt(self._ireq, parallel_builds=True)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in \nprepare_linked_requirement\n    return self._prepare_linked_requirement(req, parallel_builds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 637, in \n_prepare_linked_requirement\n    hash = hash_file(local_file.path)[0].hexdigest()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/utils/misc.py", line 622, in hash_file\n    with open(path, "rb") as f:\n         ^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: \n\'/app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl\'\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:70: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install "file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl"
Installing file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl...
Installation Succeeded
Installing dependencies from Pipfile.lock (91492b)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-tlvk8bgh-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 479ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-tlvk8bgh-tests-Gk0R-MVA
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-tlvk8bgh-tests-Gk0R-MVA
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
Upgrading file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl in
dependencies.
WARNING:pipenv.patched.pip._internal.req.constructors:Requirement
'../../app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl' looks like a
filename, but the file does not exist
WARNING:pipenv.patched.pip._internal.req.constructors:Requirement
'../../app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl' looks like a
filename, but the file does not exist
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 637, in
_prepare_linked_requirement
    hash = hash_file(local_file.path)[0].hexdigest()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/misc.py", line 622, in hash_file
    with open(path, "rb") as f:
         ^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory:
'/app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl'

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_uninstall_all_dev ____________________________
[gw11] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f5f25ec2f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5f27b6ff80>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f25fc8b30>>>, ...]
kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f25fc8b30>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f25fc8b30>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f5f27419cd0>
item = <Function test_uninstall_all_dev>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f25fc8b30>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f25fc8b30>>
item = <Function test_uninstall_all_dev>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f25fc8b30>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_uninstall_all_dev>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f5f25a1b040>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_uninstall_all_dev>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f25fc8b30>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_dev>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f25fc8b30>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_dev>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_all_dev>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5f27b6ff80>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_all_dev>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f5f25fc8b30>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    @pytest.mark.uninstall
    def test_uninstall_all_dev(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    name = "pypi"
    url = "{p.index_url}"
    verify_ssl = true

    [packages]
    tablib = "*"

    [dev-packages]
    jinja2 = "==2.11.1"
    six = "==1.12.0"
            """
                f.write(contents)

            c = p.pipenv("install -v --dev")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -v --dev', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'tablib\'), None)\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the requirement tablib (from versions: none)\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 429, in resolve\n    self._add_to_criteria(self.state.criteria, r, parent=None)\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 151, in _add_to_criteria\n    raise RequirementsConflicted(criterion)\npipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte\nd: Requirements conflict: SpecifierRequirement(\'tablib\')\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py", \nline 96, i...alenv for this project\nPipfile: /tmp/pipenv-7w_gtih8-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 422ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-7w_gtih8-tests-9Ch8DDNm\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-7w_gtih8-tests-9Ch8DDNm\nPipfile.lock not found, creating...\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_uninstall.py:127: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -v --dev
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('tablib'), None)
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement tablib (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('tablib')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
                            ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('tablib'),
parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for tablib
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
tablib
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n3'), version_str='3.12.11', major=3, minor=12, patch=11, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.12.11')>, architecture=None, company='PythonCore',
name='python3',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-7w_gtih8-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 422ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-7w_gtih8-tests-9Ch8DDNm
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-7w_gtih8-tests-9Ch8DDNm
Pipfile.lock not found, creating...
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________ test_get_modified_pipfile_entries_vcs_changes _________________
[gw7] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f6e8bb67380>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e915a4350>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e8b997f20>>>, ...]
kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e8b997f20>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e8b997f20>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6e928828a0>
item = <Function test_get_modified_pipfile_entries_vcs_changes>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e8b997f20>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e8b997f20>>
item = <Function test_get_modified_pipfile_entries_vcs_changes>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e8b997f20>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_get_modified_pipfile_entries_vcs_changes>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f6e8b164800>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_get_modified_pipfile_entries_vcs_changes>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e8b997f20>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_modified_pipfile_entries_vcs_changes>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e8b997f20>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_modified_pipfile_entries_vcs_changes>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_get_modified_pipfile_entries_vcs_changes>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e915a4350>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_get_modified_pipfile_entries_vcs_changes>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f6e8b997f20>, index_url='https://pypi.org/simple')

    def test_get_modified_pipfile_entries_vcs_changes(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            # Install VCS package
            p.pipenv("install git+https://github.com/requests/requests.git@main#egg=requests")

            # Change ref
            pipfile = p.pipfile_path
            content = pipfile.read_text()
            content = content.replace(
                'ref = "main"',
                'ref = "master"'
            )
            pipfile.write_text(content)
            project = Project()
            modified = get_modified_pipfile_entries(project, ["packages"])
>           assert "requests" in modified["default"]
E           AssertionError: assert 'requests' in {}

tests/integration/test_update.py:73: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install git+https://github.com/requests/requests.git@main#egg=requests
Installing git+https://github.com/requests/requests.git@main#egg=requests...
Installation Succeeded
Installing dependencies from Pipfile.lock (91492b)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-cw_kirx3-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 362ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-cw_kirx3-tests-Y0y1x4Nh
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-cw_kirx3-tests-Y0y1x4Nh
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
Upgrading git+https://github.com/requests/requests.git@main#egg=requests in
dependencies.
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________ test_update_outdated_with_outdated_package[--dev] _______________
[gw13] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fc9ca7eede0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc9d0198410>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cb59fbf0>>>, ...]
kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cb59fbf0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cb59fbf0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fc9cbcc0c50>
item = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cb59fbf0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cb59fbf0>>
item = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cb59fbf0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[--dev]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fc9ca31a400>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[--dev]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cb59fbf0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc9cb59fbf0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[--dev]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_outdated_with_outdated_package[--dev]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc9d0198410>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fc9cb59fbf0>, index_url='http://localhost:8080/simple')
cmd_option = '--dev'

    @pytest.mark.parametrize("cmd_option", ["", "--dev"])
    @pytest.mark.basic
    @pytest.mark.update
    @pytest.mark.skipif(
        "os.name == 'nt' and sys.version_info[:2] == (3, 8)",
        reason="Seems to work on 3.8 but not via the CI",
    )
    def test_update_outdated_with_outdated_package(pipenv_instance_private_pypi, cmd_option):
        with pipenv_instance_private_pypi() as p:
            package_name = "six"
            p.pipenv(f"install {cmd_option} {package_name}==1.11")
            c = p.pipenv(f"update {package_name} {cmd_option} --outdated")
>           assert f"Package '{package_name}' out-of-date:" in c.stdout
E           assert "Package 'six' out-of-date:" in 'All packages are up to date!\n'
E            +  where 'All packages are up to date!\n' = CompletedProcess(args='pipenv update six --dev --outdated', returncode=0, stdout='All packages are up to date!\n', stderr='').stdout

tests/integration/test_update.py:19: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv update six --dev --outdated
All packages are up to date!

----------------------------- Captured stderr call -----------------------------

________________________ test_install_named_index_alias ________________________
[gw36] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f7a2cad98a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f7a2e509d60>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7a2cb89760>>>, ...]
kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7a2cb89760>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7a2cb89760>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f7a2e45bc20>
item = <Function test_install_named_index_alias>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7a2cb89760>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7a2cb89760>>
item = <Function test_install_named_index_alias>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7a2cb89760>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_named_index_alias>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f7a2c928940>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_named_index_alias>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7a2cb89760>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_named_index_alias>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7a2cb89760>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_named_index_alias>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_named_index_alias>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f7a2e509d60>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_named_index_alias>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f7a2cb89760>, index_url='http://localhost:8080/simple')

    @pytest.mark.urls
    @pytest.mark.index
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_named_index_alias(pipenv_instance_private_pypi):
        """Test that pipenv can install packages from different named index sources.

        This test verifies that the --index parameter works correctly with named aliases
        by setting up two different named sources and installing packages from each.
        """
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "secondary"

    [packages]
    six = "*"

    [dev-packages]
                """.strip()
                f.write(contents)

            # Test installing from the first named index
            c = p.pipenv("install click --index secondary")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install click --index secondary', returncode=1, stdout='Building requirements...\nResolving dependencies...\nSuccess!\nInstalling click...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (451942)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-7vzt5vy9-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 330ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-7vzt5vy9-tests-JJrstANU\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environme...ps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for click\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:142: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install click --index secondary
Building requirements...
Resolving dependencies...
Success!
Installing click...
Installation Succeeded
Installing dependencies from Pipfile.lock (451942)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-7vzt5vy9-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 330ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-7vzt5vy9-tests-JJrstANU
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-7vzt5vy9-tests-JJrstANU
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(06c998ed3e851e0fc0d6f930b0ec71bae475eea6ad118384a4c449f619451942)!
Upgrading click in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement click (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for click

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________________ test_uninstall_all_local_files ________________________
[gw24] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fe61832c680>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe619ac9a30>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe6180995e0>>>, ...]
kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe6180995e0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe6180995e0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fe619479c40>
item = <Function test_uninstall_all_local_files>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe6180995e0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe6180995e0>>
item = <Function test_uninstall_all_local_files>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe6180995e0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_all_local_files>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fe613c96580>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_all_local_files>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe6180995e0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_local_files>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe6180995e0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_local_files>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_all_local_files>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe619ac9a30>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_all_local_files>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fe6180995e0>, index_url='http://localhost:8080/simple')
testsroot = '/app/tests'

    @pytest.mark.files
    @pytest.mark.install
    @pytest.mark.uninstall
    def test_uninstall_all_local_files(pipenv_instance_private_pypi, testsroot):
        with pipenv_instance_private_pypi() as p:
            file_uri = p._pipfile.get_fixture_path(
                "tablib/tablib-0.12.1.tar.gz", fixtures="pypi"
            ).as_uri()
            c = p.pipenv(f"install {file_uri}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz', returncode=1, stdout='Installing file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-gjsc217u-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 519ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gjsc217u-tests-bL2PNDJk\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-gjsc217u-tests-bL2PNDJk\nPipfile.lock not found, creating...\nLocking  dependencies...\nLocking  dependencies...\n...ate_package_pipfile_entry\n    req_name = determine_package_name(package)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/utils/dependencies.py", line 838, in determine_package_name\n    req_name = find_package_name_from_tarball(package.link.file_path)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/utils/dependencies.py", line 646, in find_package_name_from_tarball\n    with tarfile.open(tarball_filepath, "r") as tar_ref:\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/usr/lib/python3.12/tarfile.py", line 1852, in open\n    return func(name, "r", fileobj, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/usr/lib/python3.12/tarfile.py", line 1920, in gzopen\n    fileobj = GzipFile(name, mode + "b", compresslevel, fileobj)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/usr/lib/python3.12/gzip.py", line 201, in __init__\n    fileobj = self.myfileobj = builtins.open(filename, mode or \'rb\')\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: \'/app/tests/pypi/tablib/tablib-0.12.1.tar.gz\'\n').returncode

tests/integration/test_uninstall.py:97: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz
Installing file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-gjsc217u-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 519ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gjsc217u-tests-bL2PNDJk
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-gjsc217u-tests-bL2PNDJk
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 838, in determine_package_name
    req_name = find_package_name_from_tarball(package.link.file_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 646, in find_package_name_from_tarball
    with tarfile.open(tarball_filepath, "r") as tar_ref:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/tarfile.py", line 1852, in open
    return func(name, "r", fileobj, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/tarfile.py", line 1920, in gzopen
    fileobj = GzipFile(name, mode + "b", compresslevel, fileobj)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/gzip.py", line 201, in __init__
    fileobj = self.myfileobj = builtins.open(filename, mode or 'rb')
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '/app/tests/pypi/tablib/tablib-0.12.1.tar.gz'

_______________ test_pipenv_respects_package_index_restrictions ________________
[gw20] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7ff8893460c0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff88ad75a60>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff8892a8dd0>>>, ...]
kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff8892a8dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff8892a8dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7ff88a71dd90>
item = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff8892a8dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff8892a8dd0>>
item = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff8892a8dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_pipenv_respects_package_index_restrictions>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7ff888d09b40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_pipenv_respects_package_index_restrictions>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff8892a8dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff8892a8dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_respects_package_index_restrictions>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_pipenv_respects_package_index_restrictions>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff88ad75a60>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7ff8892a8dd0>, index_url='http://localhost:8080/simple')

    @flaky
    @pytest.mark.lock
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_pipenv_respects_package_index_restrictions(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [[source]]
    url = "{url}"
    verify_ssl = true
    name = "local"

    [packages]
    requests = {requirement}
                    """.strip().format(
                    url=p.index_url, requirement='{version="*", index="local"}'
                )
                f.write(contents)

            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-v4bzym9i-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 242ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-v4bzym9i-tests-2ackVi5j\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-v4bzym9i-tests-2ackVi5j\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:625: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-hoyio89o-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 346ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-hoyio89o-tests-12-qheE6
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-hoyio89o-tests-12-qheE6
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-v4bzym9i-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 242ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-v4bzym9i-tests-2ackVi5j
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-v4bzym9i-tests-2ackVi5j
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________ test_basic_vcs_install_with_env_var ______________________
[gw18] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7efd78195a80>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7efd79fcc350>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efd785ebc80>>>, ...]
kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efd785ebc80>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efd785ebc80>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7efd7b2aa8a0>
item = <Function test_basic_vcs_install_with_env_var>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efd785ebc80>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efd785ebc80>>
item = <Function test_basic_vcs_install_with_env_var>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efd785ebc80>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_basic_vcs_install_with_env_var>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7efd783b3140>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_basic_vcs_install_with_env_var>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efd785ebc80>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_vcs_install_with_env_var>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efd785ebc80>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_vcs_install_with_env_var>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_basic_vcs_install_with_env_var>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_basic_vcs_install_with_env_var>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7efd79fcc350>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_basic_vcs_install_with_env_var>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_vcs_install_with_env_var>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_vcs_install_with_env_var>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_basic_vcs_install_with_env_var>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7efd785ebc80>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_basic_vcs_install_with_env_var(pipenv_instance_pypi):
        from pipenv.cli import cli
        from pipenv.vendor.click.testing import (
            CliRunner,
        )  # not thread safe but macos and linux will expand the env var otherwise

        with pipenv_instance_pypi() as p:
            # edge case where normal package starts with VCS name shouldn't be flagged as vcs
            os.environ["GIT_HOST"] = "github.com"
            cli_runner = CliRunner(mix_stderr=False)
            c = cli_runner.invoke(
                cli, "install -v git+https://${GIT_HOST}/benjaminp/six.git@1.11.0 gitdb2"
            )
>           assert c.exit_code == 0
E           assert 1 == 0
E            +  where 1 = <Result BadCommand("Cannot find command 'git' - do you have 'git' installed and in your PATH?")>.exit_code

tests/integration/test_install_uri.py:25: AssertionError
------------------------------ Captured log call -------------------------------
CRITICAL pip.subprocessor:subprocess.py:138 Error [Errno 2] No such file or directory: 'git' while executing command git version
_ test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4] _
[gw25] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f64d894e020>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f64da353650>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d8b1c050>>>, ...]
kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d8b1c050>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d8b1c050>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f64d9f1d400>
item = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d8b1c050>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d8b1c050>>
item = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d8b1c050>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f64d8663a00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d8b1c050>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f64d8b1c050>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requ..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f64da353650>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requ..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requ..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requ..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f64d8b1c050>, index_url='https://pypi.org/simple')
initial_content = '[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}'
modified_content = '[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}'
expected_updates = {'requests'}

    @pytest.mark.parametrize(
        "initial_content,modified_content,expected_updates",
        [
            # Test no changes case
            (
                '[packages]\nrequests = "==2.31.0"',
                '[packages]\nrequests = "==2.31.0"',
                set()
            ),
            # Test version change
            (
                '[packages]\nrequests = "==2.31.0"',
                '[packages]\nrequests = "==2.32.0"',
                {"requests"}
            ),
            # Test multiple package changes
            (
                '[packages]\nrequests = "==2.31.0"',
                '[packages]\nrequests = "==2.32.0"\nurllib3 = "==2.0.0"',
                {"requests", "urllib3"}
            ),
            # Test dev packages
            (
                '[packages]\nrequests = "==2.31.0"\n[dev-packages]',
                '[packages]\nrequests = "==2.31.0"\n[dev-packages]\npytest = "==7.4.0"',
                {"pytest"}
            ),
            # Test VCS package
            (
                '[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}',
                '[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}',
                {"requests"}
            ),
            # Test extras change
            (
                '[packages]\nrequests = {version = "==2.31.0", extras = ["security"]}',
                '[packages]\nrequests = {version = "==2.31.0", extras = ["security", "socks"]}',
                {"requests"}
            )
        ]
    )
    def test_update_modified_packages(pipenv_instance_pypi, initial_content, modified_content, expected_updates):
        with pipenv_instance_pypi() as p:
            # Write initial Pipfile
            p.pipfile_path.write_text(initial_content)
            p.pipenv("lock")  # Generate initial lockfile

            # Modify Pipfile
            p.pipfile_path.write_text(modified_content)

            project = Project()
            # Verify correct packages identified for update
            modified = get_modified_pipfile_entries(project, ["packages", "dev-packages"])
            all_modified = set()
            for category in modified.values():
                all_modified.update(entry if isinstance(entry, str) else entry.get("name", "") for entry in category)

>           assert all_modified == expected_updates
E           AssertionError: assert set() == {'requests'}
E
E             Extra items in the right set:
E             'requests'
E
E             Full diff:
E             + set()
E             - {
E             -     'requests',
E             - }

tests/integration/test_update.py:143: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-nfraglo8-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 214ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-nfraglo8-tests-tWwtBbC6
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-nfraglo8-tests-tWwtBbC6
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/subprocess.py", line 1026, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.12/subprocess.py", line 1955, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________ test_uninstall_missing_parameters _______________________
[gw16] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f6e258042c0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e27473a10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e257c20f0>>>, ...]
kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e257c20f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e257c20f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6e26ca3c20>
item = <Function test_uninstall_missing_parameters>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e257c20f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e257c20f0>>
item = <Function test_uninstall_missing_parameters>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e257c20f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_missing_parameters>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f6e2510e9c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_missing_parameters>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e257c20f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_missing_parameters>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e257c20f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_missing_parameters>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_missing_parameters>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e27473a10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_missing_parameters>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f6e257c20f0>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    @pytest.mark.uninstall
    def test_uninstall_missing_parameters(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-0r4ydaxe-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 248ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0r4ydaxe-tests-kL9rXGfH\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-0r4ydaxe-tests-kL9rXG...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_uninstall.py:203: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-0r4ydaxe-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create
virtualenv...
created virtual environment CPython3.12.11.final.0-64 in 248ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0r4ydaxe-tests-kL9rXGfH
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-0r4ydaxe-tests-kL9rXGfH
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________ test_update_outdated_with_outdated_package[] _________________
[gw33] linux -- Python 3.12.11 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7ff5ed5c2f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff5ef293a10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed58ae70>>>, ...]
kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed58ae70>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed58ae70>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7ff5eee201a0>
item = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed58ae70>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed58ae70>>
item = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed58ae70>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7ff5ed1a8500>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed58ae70>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff5ed58ae70>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_outdated_with_outdated_package[]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff5ef293a10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7ff5ed58ae70>, index_url='http://localhost:8080/simple')
cmd_option = ''

    @pytest.mark.parametrize("cmd_option", ["", "--dev"])
    @pytest.mark.basic
    @pytest.mark.update
    @pytest.mark.skipif(
        "os.name == 'nt' and sys.version_info[:2] == (3, 8)",
        reason="Seems to work on 3.8 but not via the CI",
    )
    def test_update_outdated_with_outdated_package(pipenv_instance_private_pypi, cmd_option):
        with pipenv_instance_private_pypi() as p:
            package_name = "six"
            p.pipenv(f"install {cmd_option} {package_name}==1.11")
            c = p.pipenv(f"update {package_name} {cmd_option} --outdated")
>           assert f"Package '{package_name}' out-of-date:" in c.stdout
E           assert "Package 'six' out-of-date:" in 'All packages are up to date!\n'
E            +  where 'All packages are up to date!\n' = CompletedProcess(args='pipenv update six  --outdated', returncode=0, stdout='All packages are up to date!\n', stderr='').stdout

tests/integration/test_update.py:19: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv update six  --outdated
All packages are up to date!

----------------------------- Captured stderr call -----------------------------

=============================== warnings summary ===============================
../root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/config/__init__.py:1474: 41 warnings
  /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/config/__init__.py:1474: PytestConfigWarning: Unknown config option: plugins

    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")

tests/integration/conftest.py:47
  /app/tests/integration/conftest.py:47: RuntimeWarning: Failed connecting to internet: http://httpbin.org/ip
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
===Flaky Test Report===

test_complex_deps_lock_and_install_properly passed 1 out of the required 1 times. Success!
test_specific_package_environment_markers passed 1 out of the required 1 times. Success!
test_top_level_overrides_environment_markers passed 1 out of the required 1 times. Success!
test_platform_python_implementation_marker failed (1 runs remaining out of 2).
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install depends-on-marked-package', returncode=1, stdout='Installing depends-on-marked-package...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-gegwk8f_-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 302ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gegwk8f_-tests-zCTE8SWa\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/sh...re]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for depends-on-marked-package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:49>]
test_platform_python_implementation_marker failed; it passed 0 out of the required 1 times.
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install depends-on-marked-package', returncode=1, stdout='Installing depends-on-marked-package...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-2hdnpl74-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 405ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-2hdnpl74-tests-aN-SBd21\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/sh...re]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for depends-on-marked-package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:49>]
test_pipenv_respects_package_index_restrictions failed (1 runs remaining out of 2).
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-hoyio89o-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 346ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-hoyio89o-tests-12-qheE6\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-hoyio89o-tests-12-qheE6\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_lock.py:625>]
test_pipenv_respects_package_index_restrictions failed; it passed 0 out of the required 1 times.
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-v4bzym9i-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 242ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-v4bzym9i-tests-2ackVi5j\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-v4bzym9i-tests-2ackVi5j\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_lock.py:625>]
test_environment_variable_value_does_not_change_hash passed 1 out of the required 1 times. Success!
test_global_overrides_environment_markers failed (1 runs remaining out of 2).
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-7pr4k92e-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 357ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-7pr4k92e-tests-mnl5w0NH\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-7pr4k92e-tests-mnl5w0NH\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could...esolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for apscheduler\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:130>]
test_global_overrides_environment_markers failed; it passed 0 out of the required 1 times.
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-xp7qexvx-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python33.12.11 to create \nvirtualenv...\ncreated virtual environment CPython3.12.11.final.0-64 in 430ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-xp7qexvx-tests-xDxXiFf7\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-xp7qexvx-tests-xDxXiFf7\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for funcsigs\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.12/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:130>]
test_resolver_unique_markers passed 1 out of the required 1 times. Success!

===End Flaky Test Report===
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_cli.py:153: This test will be revisited with the safety changes
SKIPPED [2] tests/integration/test_cli.py:184: This test will be revisited with the safety changes
SKIPPED [1] tests/integration/test_cli.py:272: This test clears the cache that other tests may be using.
SKIPPED [1] tests/integration/test_install_basic.py:163: Package does not work with Python 3.12
SKIPPED [1] tests/integration/test_install_twists.py:185: This test modifies os.environment which has side effects on other tests
SKIPPED [1] tests/integration/test_install_twists.py:223: unconditional skip
SKIPPED [1] tests/integration/test_install_categories.py:80: test is not 3.12 compatible
SKIPPED [1] tests/integration/test_uninstall.py:49: Package does not work with Python 3.12
SKIPPED [1] tests/integration/test_install_basic.py:610: pip 23.3 now vendors in truststore and so test assumptions invalid
SKIPPED [1] tests/integration/test_windows.py:13: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:39: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:54: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:69: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:86: only relevant on windows
SKIPPED [6] tests/unit/test_utils.py:345: Windows file paths tested
SKIPPED [1] tests/unit/test_utils.py:552: Windows test only
SKIPPED [1] tests/unit/test_utils_windows_executable.py:15: Windows test only
SKIPPED [1] tests/unit/test_utils_windows_executable.py:30: Windows test only
SKIPPED [1] tests/integration/test_uninstall.py:24: Package does not work with Python 3.12
FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table - ...
FAILED tests/integration/test_install_basic.py::test_basic_install - assert 1...
FAILED tests/integration/test_install_basic.py::test_extras_install - assert ...
FAILED tests/integration/test_install_basic.py::test_system_and_deploy_work
FAILED tests/integration/test_install_misc.py::test_install_uri_with_extras
FAILED tests/integration/test_cli.py::test_pipenv_clean - assert 1 == 0
FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table_ooo
FAILED tests/integration/test_install_uri.py::test_install_local_vcs_not_in_lockfile
FAILED tests/integration/test_install_basic.py::test_install_does_not_extrapolate_environ
FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq, other]
FAILED tests/integration/test_install_twists.py::test_install_skip_lock - ass...
FAILED tests/integration/test_install_basic.py::test_install_package_with_dots
FAILED tests/integration/test_install_uri.py::test_vcs_install - assert 1 == 0
FAILED tests/integration/test_install_categories.py::test_basic_category_install
FAILED tests/integration/test_install_twists.py::test_outdated_should_compare_postreleases_without_failing
FAILED tests/integration/test_install_basic.py::test_install_dev_use_default_constraints
FAILED tests/integration/test_install_uri.py::test_vcs_entry_supersedes_non_vcs
FAILED tests/integration/test_install_basic.py::test_skip_requirements_when_pipfile
FAILED tests/integration/test_install_vcs.py::test_install_github_vcs - asser...
FAILED tests/integration/test_install_uri.py::test_install_git_tag - assert 1...
FAILED tests/integration/test_install_uri.py::test_get_vcs_refs - assert 1 == 0
FAILED tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[False]
FAILED tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[True]
FAILED tests/integration/test_install_twists.py::test_multiple_editable_packages_should_not_race
FAILED tests/integration/test_install_twists.py::test_local_tar_gz_file - ass...
FAILED tests/integration/test_install_markers.py::test_global_overrides_environment_markers
FAILED tests/integration/test_lock.py::test_lock_includes_hashes_for_all_platforms
FAILED tests/integration/test_install_uri.py::test_vcs_can_use_markers - asse...
FAILED tests/integration/test_lock.py::test_complex_lock_with_vcs_deps - asse...
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_ref_in_git
FAILED tests/integration/test_lock.py::test_lock_updated_source - assert 1 == 0
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_markers_without_install
FAILED tests/integration/test_cli.py::test_pipenv_graph_reverse - assert 1 == 0
FAILED tests/integration/test_install_vcs.py::test_install_vcs_ref_by_commit_hash
FAILED tests/integration/test_project.py::test_get_source[True] - assert 1 == 0
FAILED tests/integration/test_install_markers.py::test_platform_python_implementation_marker
FAILED tests/integration/test_install_twists.py::test_no_duplicate_source_on_install
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_extras_without_install
FAILED tests/integration/test_install_vcs.py::test_vcs_dev_package_install - ...
FAILED tests/integration/test_lock.py::test_lock_nested_vcs_direct_url - asse...
FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq other]
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_without_install
FAILED tests/integration/test_pipenv.py::test_update_locks - assert 1 == 0
FAILED tests/integration/test_lock.py::test_vcs_lock_respects_top_level_pins
FAILED tests/integration/test_lock.py::test_dev_lock_use_default_packages_as_constraint
FAILED tests/integration/test_lock.py::test_lock_handle_eggs - assert 1 == 0
FAILED tests/integration/test_lock.py::test_lock_package_with_compatible_release_specifier
FAILED tests/integration/test_lock.py::test_lock_specific_named_category - as...
FAILED tests/integration/test_lock.py::test_lock_nested_direct_url - assert 1...
FAILED tests/integration/test_sync.py::test_mirror_lock_sync - assert 1 == 0
FAILED tests/integration/test_install_uri.py::test_file_urls_work - assert 1 ...
FAILED tests/integration/test_uninstall.py::test_uninstall_all_dev - assert 1...
FAILED tests/integration/test_update.py::test_get_modified_pipfile_entries_vcs_changes
FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[--dev]
FAILED tests/integration/test_install_uri.py::test_install_named_index_alias
FAILED tests/integration/test_uninstall.py::test_uninstall_all_local_files - ...
FAILED tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
FAILED tests/integration/test_install_uri.py::test_basic_vcs_install_with_env_var
FAILED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]
FAILED tests/integration/test_uninstall.py::test_uninstall_missing_parameters
FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[]
===== 61 failed, 326 passed, 25 skipped, 42 warnings in 141.25s (0:02:21) ======
