Scope: all 10 workspace projects
Lockfile is up to date, resolution step is skipped
Already up to date

â•­ Warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®â”‚                                                                              â”‚â”‚   Ignored build scripts: unrs-resolver.                                      â”‚â”‚   Run "pnpm approve-builds" to pick which dependencies should be allowed     â”‚â”‚   to run scripts.                                                            â”‚â”‚                                                                              â”‚â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

. prepare$ husky && pnpm build
. prepare: .git can't be found
. prepare: > mermaid-monorepo@10.2.4 build /app
. prepare: > pnpm build:esbuild && pnpm build:types
. prepare: > mermaid-monorepo@10.2.4 build:esbuild /app
. prepare: > pnpm run -r clean && tsx .esbuild/build.ts
. prepare: Scope: 9 of 10 workspace projects
. prepare: packages/parser clean$ rimraf dist src/language/generated
. prepare: packages/tiny clean$ rimraf dist
. prepare: packages/tiny clean: Done
. prepare: packages/parser clean: Done
. prepare: packages/mermaid clean$ rimraf dist
. prepare: packages/mermaid clean: Done
. prepare: packages/examples clean$ rimraf dist
. prepare: packages/mermaid-zenuml clean$ rimraf dist
. prepare: packages/examples clean: Done
. prepare: packages/mermaid-zenuml clean: Done
. prepare: Reading config from /app/packages/parser/langium-config.json
. prepare: src/language/info/info.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/info/info.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/info/info.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:29:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:30:18 - Found multiple assignments to 'message' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:32:18 - Found multiple assignments to 'type' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:42:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:44:18 - Found multiple assignments to 'type' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:53:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:55:20 - Found multiple assignments to 'parent' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:17:10 - This rule is declared but never referenced.
. prepare: Writing generated files to /app/packages/parser/src/language/generated
. prepare: [03:21:17] Langium generator finished successfully in 487ms
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-FPAJGGOC.mjs    75.6kb
. prepare:   packages/parser/dist/mermaid-parser.core.mjs                           5.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-FWNWRKHM.mjs     3.8kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-O7ZBX7Z2.mjs     1.9kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-T53DSG4Q.mjs     1.5kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-S6J4BHB3.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-76Q3JFCE.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-LHMN2FUI.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-LBM3YZW2.mjs     1.2kb
. prepare:   ...parser/dist/chunks/mermaid-parser.core/architecture-U656AL7Q.mjs    185b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.core/gitGraph-F6HP7TQM.mjs    169b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.core/treemap-KMMF4GRG.mjs    165b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/packet-BFZMPI3H.mjs    161b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/radar-NHE76QYJ.mjs     157b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/info-NVLQJR56.mjs      153b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/pie-7BOR55EZ.mjs       149b
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-FPAJGGOC.mjs.map  114.9kb
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-FWNWRKHM.mjs.map    8.6kb
. prepare:   packages/parser/dist/mermaid-parser.core.mjs.map                       5.3kb
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-O7ZBX7Z2.mjs.map    4.4kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 43ms
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-CUV4ONQR.mjs    802.5kb
. prepare:   packages/parser/dist/mermaid-parser.esm.mjs                            5.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-AAKHKIIX.mjs      3.7kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-FJ76IR54.mjs      1.8kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-M7HE2OLO.mjs      1.5kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-DLEEDQTW.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-VGLBXUVE.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-B3PWJQJV.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-25RGGQC2.mjs      1.1kb
. prepare:   .../parser/dist/chunks/mermaid-parser.esm/architecture-3LUSXU7A.mjs    185b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.esm/gitGraph-QD2FAQA2.mjs    169b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/treemap-LTEPFSZC.mjs    165b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/packet-6CSEHWCI.mjs     161b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/radar-RQNMY3TF.mjs      157b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/info-GMZAA7BQ.mjs       153b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/pie-NGLVWQ3N.mjs        149b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-CUV4ONQR.mjs.map    1.7mb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-AAKHKIIX.mjs.map    8.5kb
. prepare:   packages/parser/dist/mermaid-parser.esm.mjs.map                        5.3kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-FJ76IR54.mjs.map    4.3kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 196ms
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-L3Q2QJVV.mjs  381.1kb
. prepare:   packages/parser/dist/mermaid-parser.esm.min.mjs                        3.5kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-MMNLCZD2.mjs    1.6kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-T7ZF25BJ.mjs    761b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-H6ZBQRVM.mjs    606b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-IHLWZL4V.mjs    470b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-OQZUXTEW.mjs    465b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-OHOCZHKG.mjs    463b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-BI2MPBQI.mjs    462b
. prepare:   ...ser/dist/chunks/mermaid-parser.esm.min/architecture-PMHMJ2ZY.mjs    132b
. prepare:   .../parser/dist/chunks/mermaid-parser.esm.min/gitGraph-EH3HN3AX.mjs    124b
. prepare:   ...s/parser/dist/chunks/mermaid-parser.esm.min/treemap-KOFTZR4J.mjs    122b
. prepare:   ...es/parser/dist/chunks/mermaid-parser.esm.min/packet-AGCPRN6G.mjs    120b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/radar-S7LXCSCY.mjs    118b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.esm.min/info-HLY6SS6Y.mjs    116b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm.min/pie-65AXTC64.mjs    114b
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-L3Q2QJVV.mjs.map    1.8mb
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-MMNLCZD2.mjs.map    8.8kb
. prepare:   packages/parser/dist/mermaid-parser.esm.min.mjs.map                    5.3kb
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-T7ZF25BJ.mjs.map    4.7kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 206ms
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-CV3G5MRU.mjs         190.3kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/sequenceDiagram-4MX5Z3NR.mjs  149.9kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/blockDiagram-ZYB65J3Q.mjs  134.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-VIW5F6AA.mjs         130.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/c4Diagram-AAMF2YG6.mjs     117.7kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/flowDiagram-THRYKUMA.mjs   102.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-MRT3R2DC.mjs          91.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-JBRWN2VN.mjs          77.6kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.core/xychartDiagram-FDP5SA34.mjs   72.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/ganttDiagram-WV7ZQ7D5.mjs   71.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-LXBSTHXV.mjs          70.1kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/gitGraphDiagram-OJR772UL.mjs   61.4kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/quadrantDiagram-YPSRARAO.mjs   61.1kb
. prepare:   ...mermaid/dist/chunks/mermaid.core/requirementDiagram-EGVEC5DT.mjs   51.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/erDiagram-HZWUO2LU.mjs      46.6kb
. prepare:   ...ermaid/dist/chunks/mermaid.core/timeline-definition-3HZDQTIS.mjs   45.6kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.core/journeyDiagram-FFXJYRFH.mjs   44.9kb
. prepare:   ...mermaid/dist/chunks/mermaid.core/mindmap-definition-LNHGMQRG.mjs   43.4kb
. prepare:   ...ermaid/dist/chunks/mermaid.core/architectureDiagram-KFL7JDKH.mjs   43.3kb
. prepare:   packages/mermaid/dist/mermaid.core.mjs                                42.6kb
. prepare:   ...and 74 more output files...
. prepare: âš¡ Done in 1364ms
. prepare:   packages/mermaid/dist/mermaid.js       6.1mb âš ï¸
. prepare:   packages/mermaid/dist/mermaid.js.map  10.1mb
. prepare: âš¡ Done in 3974ms
. prepare:   packages/mermaid/dist/mermaid.tiny.min.js  1.6mb âš ï¸
. prepare: âš¡ Done in 4218ms
. prepare:   packages/mermaid/dist/mermaid.min.js       2.6mb âš ï¸
. prepare:   packages/mermaid/dist/mermaid.min.js.map  10.2mb
. prepare: âš¡ Done in 4457ms
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-COUQ6RZ3.mjs          933.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-YOB5EFFC.mjs          697.6kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/katex-A6QSACVP.mjs          494.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-NC4V57XB.mjs          436.7kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm/architectureDiagram-L76ZKZTK.mjs  417.2kb
. prepare:   .../mermaid/dist/chunks/mermaid.esm/mindmap-definition-KYUYEQSL.mjs  250.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-3AU3J4PQ.mjs          232.4kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm/sequenceDiagram-WN2LQSXR.mjs  150.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/blockDiagram-5FNOSGNS.mjs   134.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/c4Diagram-SNKOAWKG.mjs      117.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/flowDiagram-ADV24XW4.mjs    102.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-VNOTBLTU.mjs           93.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-W3YOBQ4T.mjs           91.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/ganttDiagram-NY35QN2E.mjs    81.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-TGZYFRKZ.mjs           78.5kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-JUNTMEQM.mjs           77.6kb
. prepare:   ...ages/mermaid/dist/chunks/mermaid.esm/xychartDiagram-LLVWJMIC.mjs   72.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-JRY5QETF.mjs           70.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-IHYUGLNO.mjs           62.9kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm/gitGraphDiagram-36KJ7O45.mjs   61.7kb
. prepare:   ...and 124 more output files...
. prepare: âš¡ Done in 4495ms
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-MBJCTAW2.mjs      433.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-L6MQJ2ZU.mjs      346.9kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/katex-RV2QPRKB.mjs      270.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-F632ZYSZ.mjs      241.5kb
. prepare:   ...aid/dist/chunks/mermaid.esm.min/architectureDiagram-GXAZU6X5.mjs  148.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-DPMNACAB.mjs      115.1kb
. prepare:   ...maid/dist/chunks/mermaid.esm.min/mindmap-definition-75HPFGON.mjs  101.9kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm.min/sequenceDiagram-NCT4EGAA.mjs   86.5kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.esm.min/blockDiagram-HV7WRKX4.mjs   70.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/c4Diagram-S26XAWAN.mjs   68.8kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm.min/flowDiagram-7YKJRSJY.mjs   59.5kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-IXVBHSNP.mjs       57.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-44WDCOIT.mjs       44.3kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.esm.min/ganttDiagram-5J5FM7L2.mjs   42.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-7LIB5WBN.mjs       41.4kb
. prepare:   .../mermaid/dist/chunks/mermaid.esm.min/xychartDiagram-WBSIB3YZ.mjs   38.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-S3YGE35Q.mjs       35.8kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm.min/quadrantDiagram-5BXOXB7R.mjs   33.0kb
. prepare:   ...maid/dist/chunks/mermaid.esm.min/requirementDiagram-CG6N56KZ.mjs   29.7kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-FASC7IG4.mjs       27.8kb
. prepare:   ...and 124 more output files...
. prepare: âš¡ Done in 5018ms
. prepare:   ...unks/mermaid-example-diagram.core/diagram-definition-AUF2VOIT.mjs  22.5kb
. prepare:   ...ges/mermaid-example-diagram/dist/mermaid-example-diagram.core.mjs   557b
. prepare:   ...agram/dist/chunks/mermaid-example-diagram.core/chunk-AKMCXCCK.mjs   291b
. prepare:   .../mermaid-example-diagram.core/diagram-definition-AUF2VOIT.mjs.map  40.9kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.core.mjs.map   786b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.core/chunk-AKMCXCCK.mjs.map    93b
. prepare: âš¡ Done in 43ms
. prepare:   ...unks/mermaid-example-diagram.esm/diagram-definition-ZN3FLJNS.mjs  109.0kb
. prepare:   ...ges/mermaid-example-diagram/dist/mermaid-example-diagram.esm.mjs    555b
. prepare:   ...agram/dist/chunks/mermaid-example-diagram.esm/chunk-6XSXFHVP.mjs    291b
. prepare:   .../mermaid-example-diagram.esm/diagram-definition-ZN3FLJNS.mjs.map  215.0kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.esm.mjs.map    786b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.esm/chunk-6XSXFHVP.mjs.map     93b
. prepare: âš¡ Done in 145ms
. prepare:   .../mermaid-example-diagram.esm.min/diagram-definition-2JINLXFM.mjs   53.0kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.esm.min.mjs    355b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.esm.min/chunk-D2P5M7FY.mjs    164b
. prepare:   ...maid-example-diagram.esm.min/diagram-definition-2JINLXFM.mjs.map  227.2kb
. prepare:   ...aid-example-diagram/dist/mermaid-example-diagram.esm.min.mjs.map    860b
. prepare:   ...st/chunks/mermaid-example-diagram.esm.min/chunk-D2P5M7FY.mjs.map     93b
. prepare: âš¡ Done in 147ms
. prepare:   ...uml/dist/chunks/mermaid-zenuml.core/zenuml-definition-AWJE5BBT.mjs  3.2kb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.core.mjs                   520b
. prepare:   .../mermaid-zenuml/dist/chunks/mermaid-zenuml.core/chunk-CJCKSLXZ.mjs  151b
. prepare:   ...dist/chunks/mermaid-zenuml.core/zenuml-definition-AWJE5BBT.mjs.map  6.7kb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.core.mjs.map               765b
. prepare:   ...maid-zenuml/dist/chunks/mermaid-zenuml.core/chunk-CJCKSLXZ.mjs.map   93b
. prepare: âš¡ Done in 4ms
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.js      5.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.js.map  6.4mb
. prepare: âš¡ Done in 650ms
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.min.js      4.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.min.js.map  6.2mb
. prepare: âš¡ Done in 686ms
. prepare:   ...ml/dist/chunks/mermaid-zenuml.esm/zenuml-definition-H5KMDA2O.mjs  4.9mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.mjs                  518b
. prepare:   ...mermaid-zenuml/dist/chunks/mermaid-zenuml.esm/chunk-OS44DIFC.mjs  151b
. prepare:   ...ist/chunks/mermaid-zenuml.esm/zenuml-definition-H5KMDA2O.mjs.map  6.4mb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.mjs.map              765b
. prepare:   ...aid-zenuml/dist/chunks/mermaid-zenuml.esm/chunk-OS44DIFC.mjs.map   93b
. prepare: âš¡ Done in 719ms
. prepare:   ...ist/chunks/mermaid-zenuml.esm.min/zenuml-definition-XJYTECJ4.mjs  4.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.min.mjs              323b
. prepare:   ...aid-zenuml/dist/chunks/mermaid-zenuml.esm.min/chunk-VDOFMJQL.mjs   95b
. prepare:   ...chunks/mermaid-zenuml.esm.min/zenuml-definition-XJYTECJ4.mjs.map  6.2mb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.min.mjs.map          837b
. prepare:   ...zenuml/dist/chunks/mermaid-zenuml.esm.min/chunk-VDOFMJQL.mjs.map   93b
. prepare: âš¡ Done in 748ms
. prepare:   ...ayout-elk/dist/chunks/mermaid-layout-elk.core/render-M6WAID4X.mjs  26.7kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.core.mjs           543b
. prepare:   ...layout-elk/dist/chunks/mermaid-layout-elk.core/chunk-ZW26E7AF.mjs   151b
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.core/render-M6WAID4X.mjs.map  52.2kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.core.mjs.map       827b
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.core/chunk-ZW26E7AF.mjs.map    93b
. prepare: âš¡ Done in 17ms
. prepare:   ...ayout-elk/dist/chunks/mermaid-layout-elk.esm/render-P27B6YR6.mjs  3.6mb âš ï¸
. prepare:   ...layout-elk/dist/chunks/mermaid-layout-elk.esm/chunk-TWI3KLJS.mjs  1.8kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.mjs          541b
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.esm/render-P27B6YR6.mjs.map  4.4mb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.mjs.map      827b
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.esm/chunk-TWI3KLJS.mjs.map   93b
. prepare: âš¡ Done in 824ms
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.esm.min/render-DDKIELPE.mjs  1.6mb âš ï¸
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.esm.min/chunk-SP2CHFBE.mjs  854b
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.min.mjs      356b
. prepare:   ...k/dist/chunks/mermaid-layout-elk.esm.min/render-DDKIELPE.mjs.map  4.9mb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.min.mjs.map  842b
. prepare:   ...lk/dist/chunks/mermaid-layout-elk.esm.min/chunk-SP2CHFBE.mjs.map   93b
. prepare: âš¡ Done in 852ms
. prepare:   packages/examples/dist/mermaid-examples.core.mjs      15.7kb
. prepare:   packages/examples/dist/mermaid-examples.core.mjs.map  24.8kb
. prepare: âš¡ Done in 12ms
. prepare:   packages/examples/dist/mermaid-examples.esm.min.mjs      13.2kb
. prepare:   packages/examples/dist/mermaid-examples.esm.min.mjs.map  24.5kb
. prepare: âš¡ Done in 13ms
. prepare:   packages/examples/dist/mermaid-examples.esm.mjs      15.7kb
. prepare:   packages/examples/dist/mermaid-examples.esm.mjs.map  24.8kb
. prepare: âš¡ Done in 13ms
. prepare: > mermaid-monorepo@10.2.4 build:types /app
. prepare: > pnpm --filter mermaid types:build-config && tsx .build/types.ts
. prepare: > mermaid@11.10.0 types:build-config /app/packages/mermaid
. prepare: > tsx scripts/create-types-from-json-schema.mts
. prepare: Writing typescript file to ./src/config.type.ts
. prepare: Building types for parser
. prepare: Building types for mermaid
. prepare: Building types for mermaid-example-diagram
. prepare: Building types for mermaid-zenuml
. prepare: Building types for mermaid-layout-elk
. prepare: Building types for examples
. prepare: Done
Done in 36.1s using pnpm v10.4.1

> mermaid-monorepo@10.2.4 test:coverage /app
> vitest --coverage

3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid-example-diagram/src/exampleDiagramDb.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid-example-diagram/src/exampleDiagramRenderer.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid-example-diagram/src/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/clusters.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/createLabel.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/edges.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/index.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/index.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-circle.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-ellipse.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-line.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-node.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-polygon.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-rect.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/markers.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/mermaid-graphlib.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/nodes.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/shapes/note.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/shapes/util.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/c4Db.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/c4Renderer.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/svgDraw.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/class/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/er/erMarkers.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/er/erRenderer.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/gantt/ganttDb.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/gantt/ganttRenderer.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/gantt/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/git/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/requirement/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/sankey/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/sequence/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/sequence/svgDraw.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/state/shapes.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/state/stateRenderer.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/state/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/timeline/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/timeline/svgDraw.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/timeline/timelineDb.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/user-journey/journeyDb.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/user-journey/styles.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/user-journey/svgDraw.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/insertElementsForSize.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/layout-algorithms/dagre/index.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/clusters.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/createLabel.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/edges.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/index.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-circle.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-ellipse.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-line.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-node.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-polygon.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-rect.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/markers.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/setupGraphViewbox.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/index.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-base.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-dark.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-default.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-forest.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-helpers.js' because it would overwrite input file.
3:21:59 AM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-neutral.js' because it would overwrite input file.

 DEV  v3.0.6 /app
      Coverage enabled with v8

 âœ“ packages/mermaid/src/diagrams/xychart/parser/xychart.jison.spec.ts (48 tests) 70ms
 âœ“ packages/mermaid/src/diagrams/quadrant-chart/parser/quadrant.jison.spec.ts (14 tests) 78ms
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
02.238 : DEBUG :  Opting in, graph
02.238 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
02.238 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
02.238 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
02.238 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
02.238 : DEBUG :  Cluster identified C2 { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
02.238 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
02.238 : DEBUG :  Extracting node a {
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
02.238 : WARN :  Cluster identified C1  Replacement id in edges:  a
02.238 : WARN :  Cluster identified C2  Replacement id in edges:  c
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
02.238 : DEBUG :  Not a cluster a [33m0[39m
02.238 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
02.238 : DEBUG :  Not a cluster b [33m0[39m
02.238 : DEBUG :  Extracting node c {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
02.238 : DEBUG :  Not a cluster c [33m0[39m
02.238 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.238 : WARN :  Edge a -> b: {"v":"a","w":"b"}
02.238 : WARN :  Edge a -> b: {}
02.238 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
02.238 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
02.238 : WARN :  Edge C1 -> C2: {}
02.238 : WARN :  Fix XXX {
02.238 : INFO :  cp  a  to  C1  with parent  C1
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
02.238 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
02.238 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.238 : WARN :  Fixing and trixing - removing XXX C1 C2 [90mundefined[39m
02.238 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
02.238 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
02.238 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
02.238 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
02.238 : INFO :  Edge data {} C1
  nodes: [
02.238 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
02.238 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
02.238 : INFO :  Copying as  a b {} [90mundefined[39m
02.238 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] {}
02.238 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.238 : INFO :  Edge data {} C1
02.238 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
02.238 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.238 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
02.238 : DEBUG :  Removing node a
02.238 : INFO :  cp  b  to  C1  with parent  C1
02.238 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
02.238 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.238 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
02.238 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.238 : INFO :  Edge data {} C1
02.238 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
02.238 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.238 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
02.238 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
02.238 : DEBUG :  Removing node b
02.238 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.238 : DEBUG :  Extracting node C2 {
  ],
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.238 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
02.238 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.238 : INFO :  cp  c  to  C2  with parent  C2
02.238 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
02.238 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.238 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
02.238 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.238 : INFO :  Edge data {} C2
02.238 : INFO :  Descendants of  C2  is  [ [32m'c'[39m ]
02.238 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
02.238 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m, [32m'b'[39m ]
02.238 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
02.238 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.238 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
02.238 : DEBUG :  Removing node c
02.238 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.238 : DEBUG :  Done, no node has children [ [32m'a'[39m, [32m'b'[39m ]
02.238 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
02.238 : INFO :  [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]

}
02.238 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
02.238 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.238 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
02.238 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'c'[39m ]
02.238 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.238 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
02.238 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: {}, b: {} },
    _parent: { a: [32m'\x00'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {}, b: {} },
    _in: { a: {}, b: [36m[Object][39m },
    _preds: { a: {}, b: [36m[Object][39m },
    _out: { a: [36m[Object][39m, b: {} },
    _sucs: { a: [36m[Object][39m, b: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: {} },
    _nodeCount: [33m2[39m,
    _edgeCount: [33m1[39m
  }
}
02.238 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.238 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: {} },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.238 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
02.254 : DEBUG :  Opting in, graph
02.254 : DEBUG :  Not a cluster  a { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
02.254 : DEBUG :  Not a cluster  b { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
02.254 : DEBUG :  Not a cluster  c { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
02.254 : DEBUG :  Cluster identified C1 { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
02.254 : DEBUG :  Cluster identified C2 { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
02.254 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
02.254 : DEBUG :  Extracting node a {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.254 : DEBUG :  Not a cluster a [33m0[39m
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
02.254 : WARN :  Cluster identified C1  Replacement id in edges:  b
02.254 : WARN :  Cluster identified C2  Replacement id in edges:  a
02.254 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'b'[39m }  leaves cluster  C2
02.254 : WARN :  Descendants of XXX  C2 :  [ [32m'a'[39m ]
02.254 : WARN :  Edge a -> b: {"v":"a","w":"b"}
02.254 : WARN :  Edge a -> b: {"name":"C1-internal-link"}
02.254 : WARN :  Fix XXX {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
02.254 : WARN :  Edge C1 -> c: {"v":"C1","w":"c"}
02.254 : WARN :  Edge C1 -> c: {"name":"C1-external-link"}
02.254 : DEBUG :  Extracting node b {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
02.254 : DEBUG :  Not a cluster b [33m0[39m
02.254 : DEBUG :  Extracting node c {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
02.254 : WARN :  Fix XXX {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: C1 c Translating:  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
02.254 : WARN :  Fixing and trixing - removing XXX C1 c [90mundefined[39m
02.254 : DEBUG :  Not a cluster c [33m0[39m
02.254 : WARN :  Fix Replacing with XXX C1 c [90mundefined[39m
02.254 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
02.254 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
02.254 : INFO :  cp  b  to  C1  with parent  C1
02.254 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
02.254 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.254 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m } ]
02.254 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
02.254 : INFO :  Edge data { name: [32m'C1-internal-link'[39m } C1
02.254 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
02.254 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.254 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
02.254 : INFO :  Copying as  a b { name: [32m'C1-internal-link'[39m } [90mundefined[39m
02.254 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] { name: [32m'C1-internal-link'[39m }
02.254 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
02.254 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
02.254 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
02.254 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.254 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
02.254 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
02.254 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
02.254 : DEBUG :  Removing node b
02.254 : INFO :  cp  a  to  C1  with parent  C2
02.254 : DEBUG :  Setting parent a C2
02.254 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
02.254 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
02.254 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
02.254 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
02.254 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
02.254 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
02.254 : DEBUG :  Removing node a
02.254 : INFO :  cp  C2  to  C1  with parent  C2
02.254 : INFO :  In copy  C2 root C1 data { data: [33m5[39m } C1
02.254 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.254 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
02.254 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
02.254 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
02.254 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
02.254 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
02.254 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
02.254 : DEBUG :  Removing node C2
02.254 : DEBUG :  Removing node C2
02.254 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.254 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  ],
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.254 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
02.254 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'b'[39m, [32m'C2'[39m ]
02.254 : WARN :  Copying children of  C2 root C1 data { data: [33m5[39m } C1
02.254 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'a'[39m, [32m'C2'[39m ]
02.254 : WARN :  Setting parent a C2
02.254 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
02.254 : DEBUG :  {
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.254 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.254 : WARN :  New list of nodes [ [32m'c'[39m, [32m'C1'[39m ]
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
02.254 : WARN :   Now next level c { data: [33m3[39m }
02.254 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m, a: [36m[Object][39m, C2: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m, a: [32m'C2'[39m, C2: [32m'\x00'[39m },
}
02.254 : DEBUG :  Nodes =  [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ] [33m1[39m
02.254 : DEBUG :  Extracting node b {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {}, a: {}, C2: [36m[Object][39m },
    _in: { b: [36m[Object][39m, a: {}, C2: {} },
    _preds: { b: [36m[Object][39m, a: {}, C2: {} },
    _out: { b: {}, a: [36m[Object][39m, C2: {} },
    _sucs: { b: {}, a: [36m[Object][39m, C2: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
02.254 : DEBUG :  Not a cluster b [33m1[39m
02.254 : DEBUG :  Extracting node a {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m1[39m
02.254 : DEBUG :  Not a cluster a [33m1[39m
02.254 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m5[39m } [90mundefined[39m  Depth  [33m1[39m
02.254 : DEBUG :  {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
02.254 : INFO :  [ [32m'c'[39m, [32m'C1'[39m ]

    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m1[39m
  }
}
02.254 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.254 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
02.254 : WARN :  New list of nodes [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ]
02.254 : WARN :   Now next level b { data: [33m2[39m }
02.254 : WARN :   Now next level a { data: [33m1[39m }
02.254 : WARN :   Now next level C2 { data: [33m5[39m }

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
02.261 : INFO :  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ]
02.261 : DEBUG :  Opting in, graph
02.261 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
02.261 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
02.261 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
02.261 : DEBUG :  Cluster identified C2 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
02.261 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
02.261 : DEBUG :  Extracting node a {
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
02.261 : WARN :  Cluster identified C1  Replacement id in edges:  a
02.261 : WARN :  Cluster identified C2  Replacement id in edges:  b
02.261 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
02.261 : WARN :  Edge C1 -> C2: {"name":"C1-external-link"}
02.261 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
02.261 : WARN :  Fixing and trixing - removing XXX C1 C2 [90mundefined[39m
02.261 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
02.261 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.261 : DEBUG :  Not a cluster a [33m0[39m
02.261 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
02.261 : DEBUG :  Not a cluster b [33m0[39m
02.261 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.261 : INFO :  cp  a  to  C1  with parent  C1
02.261 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
02.261 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.261 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
02.261 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.261 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
02.261 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
02.261 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.261 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
02.261 : DEBUG :  Removing node a
02.261 : DEBUG :  Old graph after copy {
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.261 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.261 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.261 : INFO :  cp  b  to  C2  with parent  C2
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.261 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
02.261 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
02.261 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.261 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
02.261 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.261 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
02.261 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C2
02.261 : INFO :  Descendants of  C2  is  [ [32m'b'[39m ]
}
02.261 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
02.261 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
02.261 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.261 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.261 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
02.261 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
02.261 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
02.261 : DEBUG :  Removing node b
02.261 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.261 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
02.261 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
02.261 : INFO :  [ [32m'C1'[39m, [32m'C2'[39m ]

02.261 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
02.261 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'b'[39m ]
02.261 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.261 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
02.261 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.261 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.261 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.261 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
02.266 : DEBUG :  Opting in, graph
02.266 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
02.266 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
02.266 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
02.266 : WARN :  Cluster identified C1  Replacement id in edges:  a
02.266 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
02.266 : WARN :  Edge C1 -> b: {"data":"link1"}
02.266 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m3[39m } }  ---  [90mundefined[39m
02.266 : WARN :  Fixing and trixing - removing XXX C1 b 1
02.266 : WARN :  Fix Replacing with XXX C1 b 1
02.266 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
02.266 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m ] [33m0[39m
02.266 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.266 : DEBUG :  Not a cluster a [33m0[39m
02.266 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
02.266 : DEBUG :  Not a cluster b [33m0[39m
02.266 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
02.266 : INFO :  cp  a  to  C1  with parent  C1
02.266 : INFO :  In copy  C1 root C1 data { data: [33m3[39m } C1
02.266 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
02.266 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
    { v: [32m'b'[39m, value: [36m[Object][39m },
02.266 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.266 : INFO :  Edge data { data: [32m'link1'[39m } C1
    { v: [32m'C1'[39m, value: [36m[Object][39m }
02.266 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
02.266 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.266 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
02.266 : DEBUG :  Removing node a
02.266 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.266 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
02.266 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.274 : INFO :  { data: [33m4[39m }
02.274 : DEBUG :  Opting in, graph
02.274 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
02.274 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
02.274 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
02.266 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.266 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
02.266 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.266 : WARN :  Copying children of  C1 root C1 data { data: [33m3[39m } C1
02.266 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
02.266 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.266 : WARN :  New list of nodes [ [32m'b'[39m, [32m'C1'[39m ]
02.266 : WARN :   Now next level b { data: [33m2[39m }
02.266 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
02.274 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
02.274 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ] [33m0[39m
02.274 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.274 : DEBUG :  Not a cluster a [33m0[39m
02.274 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
  id: [32m'C1'[39m,
  clusterData: { data: [33m3[39m },
02.274 : DEBUG :  Not a cluster b [33m0[39m
02.274 : DEBUG :  Extracting node c {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
02.274 : DEBUG :  Not a cluster c [33m0[39m
02.274 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  labelText: [90mundefined[39m,
  graph: Graph {
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
02.274 : INFO :  cp  a  to  C1  with parent  C1
02.274 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
02.274 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.274 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
02.274 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.274 : INFO :  Edge data { data: [32m'link1'[39m } C1
02.274 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
02.274 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.274 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
02.274 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
02.274 : INFO :  Edge data { data: [32m'link2'[39m } C1
02.274 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
02.274 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
02.274 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
02.274 : DEBUG :  Removing node a
02.274 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.274 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
02.274 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]

    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.266 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
02.274 : WARN :  Cluster identified C1  Replacement id in edges:  a
02.274 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
02.274 : WARN :  Edge C1 -> b: {"data":"link1"}
02.274 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
02.274 : WARN :  Fixing and trixing - removing XXX C1 b 1
02.274 : WARN :  Fix Replacing with XXX C1 b 1
02.274 : WARN :  Edge C1 -> c: {"v":"C1","w":"c","name":"2"}
02.274 : WARN :  Edge C1 -> c: {"data":"link2"}
02.274 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 c Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
02.274 : WARN :  Fixing and trixing - removing XXX C1 c 2
02.274 : WARN :  Fix Replacing with XXX C1 c 2
02.274 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.274 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.274 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
02.274 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.274 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
02.274 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
02.274 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.274 : WARN :  New list of nodes [ [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ]
02.274 : WARN :   Now next level b { data: [33m2[39m }
02.274 : WARN :   Now next level c { data: [33m3[39m }
02.274 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.274 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
02.281 : DEBUG :  Opting in, graph
02.281 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
02.281 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
02.281 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
02.281 : DEBUG :  Cluster identified A { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
02.281 : DEBUG :  Cluster identified B { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
02.281 : DEBUG :  Cluster identified C { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
02.281 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ] [33m0[39m
02.281 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.281 : DEBUG :  Not a cluster a [33m0[39m
02.281 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
02.281 : DEBUG :  Not a cluster b [33m0[39m
02.281 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
02.281 : DEBUG :  Not a cluster c [33m0[39m
02.281 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.281 : INFO :  cp  a  to  A  with parent  A
02.281 : INFO :  In copy  A root A data [90mundefined[39m A
02.281 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.281 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.281 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.281 : INFO :  Edge data { data: [32m'link1'[39m } A
02.281 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
02.281 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.281 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
02.281 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.281 : INFO :  Edge data { data: [32m'link2'[39m } A
02.281 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
02.281 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.281 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
02.281 : DEBUG :  Removing node a
02.281 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.281 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.281 : INFO :  cp  b  to  B  with parent  B
02.281 : INFO :  In copy  B root B data [90mundefined[39m B
02.281 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.281 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.281 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.281 : INFO :  Edge data { data: [32m'link1'[39m } B
02.281 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
02.281 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.281 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
02.281 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.281 : INFO :  Edge data { data: [32m'link2'[39m } B
02.281 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
02.281 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.281 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
02.281 : DEBUG :  Removing node b
02.281 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.281 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.281 : INFO :  cp  c  to  C  with parent  C
02.281 : INFO :  In copy  C root C data [90mundefined[39m C
02.281 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.281 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.281 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.281 : INFO :  Edge data { data: [32m'link1'[39m } C
02.281 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
02.281 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.281 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
02.281 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.281 : INFO :  Edge data { data: [32m'link2'[39m } C
02.281 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
02.281 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.281 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
02.281 : DEBUG :  Removing node c
02.281 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.281 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
02.281 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
02.281 : DEBUG :  Done, no node has children [ [32m'c'[39m ]

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
02.281 : WARN :  Cluster identified A  Replacement id in edges:  a
02.281 : WARN :  Cluster identified B  Replacement id in edges:  b
02.281 : WARN :  Cluster identified C  Replacement id in edges:  c
02.281 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
02.281 : WARN :  Edge A -> B: {"data":"link1"}
02.281 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
02.281 : WARN :  Fixing and trixing - removing XXX A B 1
02.281 : WARN :  Fix Replacing with XXX A B 1
02.281 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
02.281 : WARN :  Edge A -> C: {"data":"link2"}
02.281 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
02.281 : WARN :  Fixing and trixing - removing XXX A C 2
02.281 : WARN :  Fix Replacing with XXX A C 2
02.281 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.281 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.281 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
02.281 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.281 : WARN :  Copying children of  A root A data [90mundefined[39m A
02.281 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
02.281 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.281 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
02.281 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.281 : WARN :  Copying children of  B root B data [90mundefined[39m B
02.281 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
02.281 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.281 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
02.281 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.281 : WARN :  Copying children of  C root C data [90mundefined[39m C
02.281 : WARN :  Copying (nodes) clusterId C nodes [ [32m'c'[39m ]
02.281 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.281 : WARN :  New list of nodes [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
02.281 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.281 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.281 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.281 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.281 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.281 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
02.295 : DEBUG :  Opting in, graph
02.295 : DEBUG :  Cluster identified C {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
02.295 : WARN :  Cluster identified C  Replacement id in edges:  d
02.295 : WARN :  Cluster identified D  Replacement id in edges:  d
02.295 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  D: [ [32m'd'[39m ]
}
02.295 : DEBUG :  Cluster identified D {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
02.295 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  D: [ [32m'd'[39m ]
}
02.295 : DEBUG :  Not a cluster  d {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
02.295 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
02.295 : DEBUG :  Nodes =  [ [32m'C'[39m, [32m'D'[39m, [32m'd'[39m ] [33m0[39m
02.295 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
02.295 : WARN :  Old graph before copy {
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
02.295 : INFO :  cp  d  to  C  with parent  D
02.295 : DEBUG :  Setting parent d D
02.295 : DEBUG :  Copying Edges []
02.295 : DEBUG :  Removing node d
02.295 : INFO :  cp  D  to  C  with parent  D
02.295 : INFO :  In copy  D root C data { data: [33m2[39m } C
02.295 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.295 : DEBUG :  Copying Edges []
02.295 : DEBUG :  Removing node D
02.295 : DEBUG :  Removing node D
02.295 : DEBUG :  Old graph after copy {
  nodes: [
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'C'[39m, value: [36m[Object][39m },
  nodes: [ { v: [32m'C'[39m, value: [36m[Object][39m } ],
  edges: [],
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.295 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.295 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
02.295 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
02.295 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
02.295 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
02.295 : WARN :  Setting parent d D
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.295 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
02.295 : DEBUG :  {
  nodes: [
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  ],
  edges: [],
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
02.295 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
}
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
02.295 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
02.295 : WARN :  New list of nodes [ [32m'C'[39m ]
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
02.295 : WARN :   Now next level C {
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  clusterNode: [33mtrue[39m,
02.295 : DEBUG :  Not a cluster d [33m0[39m
  id: [32m'C'[39m,
02.295 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
  clusterData: { data: [33m1[39m },
02.295 : DEBUG :  Extracting node d {
  labelText: [90mundefined[39m,
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
02.295 : DEBUG :  Not a cluster d [33m1[39m
02.295 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    _nodeCount: [33m2[39m
  }
}
02.295 : WARN :  extractor -  [33m1[39m {
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
02.295 : INFO :  cp  d  to  D  with parent  D
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
02.295 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
02.295 : WARN :  Old graph before copy {
02.295 : INFO :  In copy  D root D data { data: [33m2[39m } D
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
02.295 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
02.295 : DEBUG :  Copying Edges []
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.295 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
02.295 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
02.295 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.295 : WARN :  New list of nodes [ [32m'D'[39m ]
02.295 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
02.295 : DEBUG :  Removing node d
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
02.295 : DEBUG :  Old graph after copy {
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
  edges: [],
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.295 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.295 : DEBUG :  Done, no node has children [ [32m'd'[39m ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
02.293 : DEBUG :  Opting in, graph
02.293 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
02.293 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
02.293 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
02.293 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
02.293 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
02.293 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
02.293 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
02.293 : DEBUG :  Not a cluster a [33m0[39m
02.293 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
02.293 : DEBUG :  Not a cluster b [33m0[39m
02.293 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
02.293 : DEBUG :  Not a cluster c [33m0[39m
02.293 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.293 : INFO :  cp  a  to  C1  with parent  C1
02.293 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
02.293 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.293 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
02.293 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
02.293 : INFO :  Edge data {} C1
02.293 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
02.293 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
02.293 : INFO :  Copying as  a b {} [90mundefined[39m
02.293 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] {}
02.293 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.293 : INFO :  Edge data {} C1
02.293 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
02.293 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.293 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
02.293 : DEBUG :  Removing node a
02.293 : INFO :  cp  b  to  C1  with parent  C1
02.293 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
02.293 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.293 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
02.293 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.293 : INFO :  Edge data {} C1
02.293 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
02.293 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.293 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
02.293 : DEBUG :  Removing node b
02.293 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.293 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.293 : INFO :  cp  c  to  C2  with parent  C2
02.293 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
02.293 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.293 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
02.293 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.293 : INFO :  Edge data {} C2
02.293 : INFO :  Descendants of  C2  is  [ [32m'c'[39m ]
02.293 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.293 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
02.293 : DEBUG :  Removing node c
02.293 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.293 : DEBUG :  Done, no node has children [ [32m'a'[39m, [32m'b'[39m ]
02.293 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
02.293 : INFO :  [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
02.293 : WARN :  Cluster identified C1  Replacement id in edges:  a
02.293 : WARN :  Cluster identified C2  Replacement id in edges:  c
02.293 : WARN :  Edge a -> b: {"v":"a","w":"b"}
02.293 : WARN :  Edge a -> b: {}
02.293 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
02.293 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
02.293 : WARN :  Edge C1 -> C2: {}
02.293 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
02.293 : WARN :  Fixing and trying - removing XXX C1 C2 [90mundefined[39m
02.293 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
02.293 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.293 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.293 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
02.293 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.293 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
02.293 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m, [32m'b'[39m ]
02.293 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.293 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
02.293 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.293 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
02.293 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'c'[39m ]
02.293 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.293 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
02.293 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: {}, b: {} },
    _parent: { a: [32m'\x00'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {}, b: {} },
    _in: { a: {}, b: [36m[Object][39m },
    _preds: { a: {}, b: [36m[Object][39m },
    _out: { a: [36m[Object][39m, b: {} },
    _sucs: { a: [36m[Object][39m, b: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: {} },
    _nodeCount: [33m2[39m,
    _edgeCount: [33m1[39m
  }
}
02.293 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.293 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: {} },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.293 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
02.303 : INFO :  Graph before { data: [33m2[39m }
02.303 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : DEBUG :  Opting in, graph
02.303 : DEBUG :  Cluster identified C {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
02.303 : DEBUG :  Cluster identified D {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
02.303 : DEBUG :  Not a cluster  d {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
02.303 : DEBUG :  Cluster identified B {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
02.303 : DEBUG :  Not a cluster  b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
02.303 : DEBUG :  Cluster identified A {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
02.303 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
02.303 : DEBUG :  Nodes =  [
  [32m'C'[39m, [32m'D'[39m, [32m'd'[39m,
  [32m'B'[39m, [32m'b'[39m, [32m'A'[39m,
  [32m'a'[39m
] [33m0[39m
02.303 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
02.303 : INFO :  cp  d  to  C  with parent  D
02.303 : DEBUG :  Setting parent d D
02.303 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.303 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.303 : INFO :  Edge data { data: [32m'link1'[39m } C
02.303 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
02.303 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.303 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
02.303 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.303 : INFO :  Edge data { data: [32m'link2'[39m } C
02.303 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
02.303 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.303 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
02.303 : DEBUG :  Removing node d
02.303 : INFO :  cp  D  to  C  with parent  D
02.303 : INFO :  In copy  D root C data { data: [33m2[39m } C
02.303 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.303 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.303 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.303 : INFO :  Edge data { data: [32m'link1'[39m } C
02.303 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
02.303 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.303 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
02.303 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.303 : INFO :  Edge data { data: [32m'link2'[39m } C
02.303 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
02.303 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.303 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
02.303 : DEBUG :  Removing node D
02.303 : DEBUG :  Removing node D
02.303 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.303 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
02.303 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.303 : DEBUG :  Not a cluster d [33m0[39m
02.303 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
02.303 : INFO :  cp  b  to  B  with parent  B
02.303 : INFO :  In copy  B root B data { data: [33m4[39m } B
02.303 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.303 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.303 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.303 : INFO :  Edge data { data: [32m'link1'[39m } B
02.303 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
02.303 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.303 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
02.303 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.303 : INFO :  Edge data { data: [32m'link2'[39m } B
02.303 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
02.303 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.303 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
02.303 : DEBUG :  Removing node b
02.303 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.303 : DEBUG :  Not a cluster b [33m0[39m
02.303 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m6[39m } [90mundefined[39m  Depth  [33m0[39m
02.303 : INFO :  cp  a  to  A  with parent  A
02.303 : INFO :  In copy  A root A data { data: [33m6[39m } A
02.303 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.303 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.303 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.303 : INFO :  Edge data { data: [32m'link1'[39m } A
02.303 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
02.303 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.303 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
02.303 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.303 : INFO :  Edge data { data: [32m'link2'[39m } A
02.303 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
02.303 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.303 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
02.303 : DEBUG :  Removing node a
02.303 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.303 : DEBUG :  Not a cluster a [33m0[39m
02.303 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
02.303 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
02.303 : DEBUG :  Not a cluster d [33m1[39m
02.303 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
02.303 : INFO :  cp  d  to  D  with parent  D
02.303 : INFO :  In copy  D root D data { data: [33m2[39m } D
02.303 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.303 : DEBUG :  Copying Edges []
02.303 : DEBUG :  Removing node d
02.303 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
02.303 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
02.303 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
02.303 : INFO :  A [ [32m'a'[39m ]

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
02.303 : WARN :  Cluster identified C  Replacement id in edges:  d
02.303 : WARN :  Cluster identified D  Replacement id in edges:  d
02.303 : WARN :  Cluster identified B  Replacement id in edges:  b
02.303 : WARN :  Cluster identified A  Replacement id in edges:  a
02.303 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
02.303 : WARN :  Edge A -> B: {"data":"link1"}
02.303 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }
02.303 : WARN :  Fixing and trixing - removing XXX A B 1
02.303 : WARN :  Fix Replacing with XXX A B 1
02.303 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
02.303 : WARN :  Edge A -> C: {"data":"link2"}
02.303 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'D'[39m, clusterData: { data: [33m1[39m } }
02.303 : WARN :  Fixing and trixing - removing XXX A C 2
02.303 : WARN :  Fix Replacing with XXX A C 2
02.303 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
02.303 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
02.303 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
02.303 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
02.303 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
02.303 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
02.303 : WARN :  Setting parent d D
02.303 : WARN :  New graph after copy node: ( C ) {
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
02.316 : DEBUG :  Opting in, graph
02.316 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
02.316 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
02.316 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
02.316 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
02.316 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
02.316 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
02.316 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  nodes: [
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
02.316 : DEBUG :  Not a cluster a [33m0[39m
    { v: [32m'D'[39m, value: [36m[Object][39m }
02.316 : DEBUG :  Extracting node b Map(2) {
  ],
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  edges: [],
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
}
02.316 : DEBUG :  Not a cluster b [33m0[39m
02.303 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.316 : DEBUG :  Extracting node c Map(2) {
02.303 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
02.303 : WARN :  Old graph before copy {
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
02.316 : DEBUG :  Not a cluster c [33m0[39m
02.316 : DEBUG :  Extracting node C1 Map(2) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
02.316 : INFO :  cp  b  to  C1  with parent  C1
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
02.316 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
02.316 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.316 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m } ]
}
02.316 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
02.316 : INFO :  Edge data { name: [32m'C1-internal-link'[39m } C1
02.316 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
02.316 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
02.316 : INFO :  Copying as  a b { name: [32m'C1-internal-link'[39m } [90mundefined[39m
02.303 : WARN :  Copying children of  B root B data { data: [33m4[39m } B
02.316 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] { name: [32m'C1-internal-link'[39m }
02.303 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
02.316 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
02.316 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
02.303 : WARN :  New graph after copy node: ( B ) {
02.316 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
02.316 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
02.316 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
02.316 : DEBUG :  Removing node b
02.316 : INFO :  cp  a  to  C1  with parent  C2
02.316 : DEBUG :  Setting parent a C2
02.316 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
02.303 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
02.316 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
    { v: [32m'A'[39m, value: [36m[Object][39m },
02.316 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
02.316 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
  ],
02.316 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
  edges: [
02.316 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
02.316 : DEBUG :  Removing node a
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
02.316 : INFO :  cp  C2  to  C1  with parent  C2
  ],
02.316 : INFO :  In copy  C2 root C1 data { data: [33m5[39m } C1
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : WARN :  Copying children of  A root A data { data: [33m6[39m } A
02.303 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
02.303 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
02.316 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.316 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
02.316 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
02.316 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
02.316 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
02.316 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
02.316 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
02.316 : DEBUG :  Removing node C2
02.316 : DEBUG :  Removing node C2
02.316 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
}
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
02.303 : WARN :  New list of nodes [ [32m'C'[39m, [32m'B'[39m, [32m'A'[39m ]
02.303 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
  edges: [ { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m } ],
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
}
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
02.316 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.316 : DEBUG :  Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
02.316 : DEBUG :  Nodes =  [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ] [33m1[39m
02.316 : DEBUG :  Extracting node b Map(2) {
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
02.303 : WARN :  extractor -  [33m1[39m {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  nodes: [
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
02.316 : DEBUG :  Not a cluster b [33m1[39m
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
02.316 : DEBUG :  Extracting node a Map(2) {
} [ [32m'd'[39m ]
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
02.303 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
02.303 : WARN :  Old graph before copy {
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
02.303 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
02.303 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.303 : WARN :  New list of nodes [ [32m'D'[39m ]
02.303 : WARN :   Now next level D {
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m1[39m
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
02.316 : DEBUG :  Not a cluster a [33m1[39m
02.316 : DEBUG :  Extracting node C2 Map(2) {
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    _nodes: { d: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.303 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} [33mfalse[39m [33mtrue[39m { data: [33m5[39m } [90mundefined[39m  Depth  [33m1[39m
02.316 : DEBUG :  Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
02.316 : INFO :  [ [32m'c'[39m, [32m'C1'[39m ]

  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.303 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: { data: [33m4[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.303 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.303 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: { data: [33m6[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.303 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
02.316 : WARN :  Cluster identified C1  Replacement id in edges:  b
02.316 : WARN :  Cluster identified C2  Replacement id in edges:  a
02.316 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'b'[39m }  leaves cluster  C2
02.316 : WARN :  Descendants of XXX  C2 :  [ [32m'a'[39m ]
02.316 : WARN :  Edge a -> b: {"v":"a","w":"b"}
02.316 : WARN :  Edge a -> b: {"name":"C1-internal-link"}
02.316 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
02.316 : WARN :  Edge C1 -> c: {"v":"C1","w":"c"}
02.316 : WARN :  Edge C1 -> c: {"name":"C1-external-link"}
02.316 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: C1 c Translating:  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
02.316 : WARN :  Fixing and trying - removing XXX C1 c [90mundefined[39m
02.316 : WARN :  Fix Replacing with XXX C1 c [90mundefined[39m
02.316 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.316 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.316 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
02.316 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.316 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
02.316 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'b'[39m, [32m'C2'[39m ]
02.316 : WARN :  Copying children of  C2 root C1 data { data: [33m5[39m } C1
02.316 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'a'[39m, [32m'C2'[39m ]
02.316 : WARN :  Setting parent a C2
02.316 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.316 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.316 : WARN :  New list of nodes [ [32m'c'[39m, [32m'C1'[39m ]
02.316 : WARN :   Now next level c { data: [33m3[39m }
02.316 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m, a: [36m[Object][39m, C2: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m, a: [32m'C2'[39m, C2: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {}, a: {}, C2: [36m[Object][39m },
    _in: { b: [36m[Object][39m, a: {}, C2: {} },
    _preds: { b: [36m[Object][39m, a: {}, C2: {} },
    _out: { b: {}, a: [36m[Object][39m, C2: {} },
    _sucs: { b: {}, a: [36m[Object][39m, C2: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m1[39m
  }
}
02.316 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.316 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
02.316 : WARN :  New list of nodes [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ]
02.316 : WARN :   Now next level b { data: [33m2[39m }
02.316 : WARN :   Now next level a { data: [33m1[39m }
02.316 : WARN :   Now next level C2 { data: [33m5[39m }

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
02.324 : INFO :  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ]
02.324 : DEBUG :  Opting in, graph
02.324 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.324 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.324 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.324 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.324 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
02.324 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.324 : DEBUG :  Not a cluster a [33m0[39m
02.324 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
02.324 : WARN :  Cluster identified C1  Replacement id in edges:  a
02.324 : WARN :  Cluster identified C2  Replacement id in edges:  b
02.324 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
02.324 : WARN :  Edge C1 -> C2: {"name":"C1-external-link"}
02.324 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
02.324 : WARN :  Fixing and trying - removing XXX C1 C2 [90mundefined[39m
02.324 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
02.324 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
02.324 : DEBUG :  Not a cluster b [33m0[39m
02.324 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.324 : INFO :  cp  a  to  C1  with parent  C1
02.324 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
02.324 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.324 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
02.324 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.324 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
    { v: [32m'C1'[39m },
02.324 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
    { v: [32m'C2'[39m }
02.324 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
  ],
02.324 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
02.324 : DEBUG :  Removing node a
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
02.324 : DEBUG :  Old graph after copy {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
02.324 : WARN :  extractor -  [33m0[39m {
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  nodes: [
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.324 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.324 : INFO :  cp  b  to  C2  with parent  C2
02.324 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
02.324 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.324 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
02.324 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.324 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C2
02.324 : INFO :  Descendants of  C2  is  [ [32m'b'[39m ]
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.324 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
02.324 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
02.324 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
02.324 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
    { v: [32m'C1'[39m },
02.324 : DEBUG :  Removing node b
02.324 : DEBUG :  Old graph after copy {
    { v: [32m'C2'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.324 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
02.324 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
02.324 : INFO :  [ [32m'C1'[39m, [32m'C2'[39m ]

  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.324 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
02.324 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
02.324 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.324 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
02.324 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.324 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
02.324 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'b'[39m ]
02.324 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.324 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
02.324 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.324 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.324 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.324 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
02.322 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.322 : DEBUG :  Opting in, graph
02.322 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
02.322 : DEBUG :  Cluster identified b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
02.322 : DEBUG :  Not a cluster  c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
02.322 : DEBUG :  Not a cluster  d {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
02.322 : DEBUG :  Not a cluster  e {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
02.322 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ] [33m0[39m
02.322 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.322 : DEBUG :  Not a cluster a [33m0[39m
02.322 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
02.322 : INFO :  cp  c  to  b  with parent  b
02.322 : INFO :  In copy  b root b data { data: [33m2[39m } b
02.322 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.322 : DEBUG :  Copying Edges [
  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m },
  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m },
  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
]
02.322 : INFO :  Edge { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
02.322 : INFO :  Edge data { data: [32m'link2'[39m } b
02.322 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.322 : INFO :  Edge is  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
02.322 : INFO :  Copying as  c d { data: [32m'link2'[39m } 2
02.322 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
02.322 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
02.322 : INFO :  Edge data { data: [32m'link2'[39m } b
02.322 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.322 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
02.322 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
02.322 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
02.322 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.322 : INFO :  Edge data { data: [32m'link1'[39m } b
02.322 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.322 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.322 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
02.322 : DEBUG :  Removing node c
02.322 : INFO :  cp  d  to  b  with parent  b
02.322 : INFO :  In copy  b root b data { data: [33m2[39m } b
02.322 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.322 : DEBUG :  Copying Edges [ { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }, { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
02.322 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
02.322 : INFO :  Edge data { data: [32m'link2'[39m } b
02.322 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.322 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
02.322 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
02.322 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
02.322 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.322 : INFO :  Edge data { data: [32m'link1'[39m } b
02.322 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.322 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.322 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
02.322 : DEBUG :  Removing node d
02.322 : INFO :  cp  e  to  b  with parent  b
02.322 : INFO :  In copy  b root b data { data: [33m2[39m } b
02.322 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.322 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
02.322 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.322 : INFO :  Edge data { data: [32m'link1'[39m } b
02.322 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.322 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.322 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
02.322 : DEBUG :  Removing node e
02.322 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m }, { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.322 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.322 : DEBUG :  Not a cluster c [33m0[39m
02.322 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.322 : DEBUG :  Not a cluster d [33m0[39m
02.322 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.322 : DEBUG :  Not a cluster e [33m0[39m
02.322 : DEBUG :  Done, no node has children [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.322 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
02.322 : WARN :  Cluster identified b  Replacement id in edges:  c
02.322 : WARN :  Edge a -> b: {"v":"a","w":"b","name":"1"}
02.322 : WARN :  Edge a -> b: {"data":"link1"}
02.322 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: a b Translating:  [90mundefined[39m  ---  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
02.322 : WARN :  Fixing and trixing - removing XXX a b 1
02.322 : WARN :  Fix Replacing with XXX a b 1
02.322 : WARN :  Edge c -> d: {"v":"c","w":"d","name":"2"}
02.322 : WARN :  Edge c -> d: {"data":"link2"}
02.322 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: c d Translating:  [90mundefined[39m  ---  [90mundefined[39m
02.322 : WARN :  Edge d -> e: {"v":"d","w":"e","name":"2"}
02.322 : WARN :  Edge d -> e: {"data":"link2"}
02.322 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: d e Translating:  [90mundefined[39m  ---  [90mundefined[39m
02.322 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.322 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.322 : WARN :  Cluster without external connections, without a parent and with children b [33m0[39m
02.322 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.322 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
02.322 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.322 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.322 : WARN :  New list of nodes [ [32m'a'[39m, [32m'b'[39m ]
02.322 : WARN :   Now next level a { data: [33m1[39m }
02.322 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, d: [36m[Object][39m, e: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m, d: [32m'\x00'[39m, e: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, d: {}, e: {} },
    _in: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _preds: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _out: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _sucs: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _edgeObjs: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m2[39m
  }
}
02.322 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
02.330 : DEBUG :  Opting in, graph
02.330 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.330 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.330 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.330 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m ] [33m0[39m
02.330 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.330 : DEBUG :  Not a cluster a [33m0[39m
02.330 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
02.330 : DEBUG :  Not a cluster b [33m0[39m
02.330 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
02.330 : INFO :  cp  a  to  C1  with parent  C1
02.330 : INFO :  In copy  C1 root C1 data { data: [33m3[39m } C1
02.330 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.330 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
02.330 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.330 : INFO :  Edge data { data: [32m'link1'[39m } C1
02.330 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
02.330 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.330 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
02.330 : DEBUG :  Removing node a
02.330 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.330 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
02.330 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
02.330 : WARN :  Cluster identified C1  Replacement id in edges:  a
02.330 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
02.330 : WARN :  Edge C1 -> b: {"data":"link1"}
02.330 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m3[39m } }  ---  [90mundefined[39m
02.330 : WARN :  Fixing and trying - removing XXX C1 b 1
02.330 : WARN :  Fix Replacing with XXX C1 b 1
02.330 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.330 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.330 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
02.330 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.330 : WARN :  Copying children of  C1 root C1 data { data: [33m3[39m } C1
02.330 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
02.330 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.330 : WARN :  New list of nodes [ [32m'b'[39m, [32m'C1'[39m ]
02.330 : WARN :   Now next level b { data: [33m2[39m }
02.330 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m3[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.330 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
02.337 : INFO :  { data: [33m4[39m }
02.337 : DEBUG :  Opting in, graph
02.337 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.337 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.337 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.337 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
02.337 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ] [33m0[39m
02.337 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.337 : DEBUG :  Not a cluster a [33m0[39m
02.337 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
02.337 : DEBUG :  Not a cluster b [33m0[39m
02.337 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
02.337 : DEBUG :  Not a cluster c [33m0[39m
02.337 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
02.337 : INFO :  cp  a  to  C1  with parent  C1
02.337 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
02.337 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.337 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
02.337 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.337 : INFO :  Edge data { data: [32m'link1'[39m } C1
02.337 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
02.337 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.337 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
02.337 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
02.337 : INFO :  Edge data { data: [32m'link2'[39m } C1
02.337 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
02.337 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
02.337 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
02.337 : DEBUG :  Removing node a
02.337 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.337 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
02.337 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
02.337 : WARN :  Cluster identified C1  Replacement id in edges:  a
02.337 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
02.337 : WARN :  Edge C1 -> b: {"data":"link1"}
02.337 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
02.337 : WARN :  Fixing and trying - removing XXX C1 b 1
02.337 : WARN :  Fix Replacing with XXX C1 b 1
02.337 : WARN :  Edge C1 -> c: {"v":"C1","w":"c","name":"2"}
02.337 : WARN :  Edge C1 -> c: {"data":"link2"}
02.337 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 c Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
02.337 : WARN :  Fixing and trying - removing XXX C1 c 2
02.337 : WARN :  Fix Replacing with XXX C1 c 2
02.337 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.337 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.337 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
02.337 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.337 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
02.337 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
02.337 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.337 : WARN :  New list of nodes [ [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ]
02.337 : WARN :   Now next level b { data: [33m2[39m }
02.337 : WARN :   Now next level c { data: [33m3[39m }
02.337 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.337 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
02.333 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.333 : DEBUG :  Opting in, graph
02.333 : DEBUG :  Cluster identified a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
02.333 : DEBUG :  Cluster identified b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
02.333 : DEBUG :  Cluster identified c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
02.333 : DEBUG :  Not a cluster  e {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
02.333 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ] [33m0[39m
02.333 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.333 : INFO :  cp  e  to  a  with parent  c
02.333 : DEBUG :  Setting parent e c
02.333 : DEBUG :  Copying Edges []
02.333 : DEBUG :  Removing node e
02.333 : INFO :  cp  c  to  a  with parent  c
02.333 : INFO :  In copy  c root a data { data: [33m3[39m } a
02.333 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.333 : DEBUG :  Copying Edges []
02.333 : DEBUG :  Removing node c
02.333 : DEBUG :  Removing node c
02.333 : INFO :  cp  b  to  a  with parent  b
02.333 : INFO :  In copy  b root a data { data: [33m2[39m } a
02.333 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.333 : DEBUG :  Copying Edges []
02.333 : DEBUG :  Removing node b
02.333 : DEBUG :  Removing node b
02.333 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.333 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.333 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.333 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.333 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.333 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.333 : DEBUG :  Not a cluster e [33m0[39m
02.333 : DEBUG :  Nodes =  [ [32m'e'[39m, [32m'c'[39m, [32m'b'[39m ] [33m1[39m
02.333 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
02.333 : DEBUG :  Not a cluster e [33m1[39m
02.333 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
02.333 : INFO :  cp  e  to  c  with parent  c
02.333 : INFO :  In copy  c root c data { data: [33m3[39m } c
02.333 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.333 : DEBUG :  Copying Edges []
02.333 : DEBUG :  Removing node e
02.333 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.333 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
02.333 : WARN :  Cluster identified a  Replacement id in edges:  e
02.333 : WARN :  Cluster identified b  Replacement id in edges:  e
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
02.333 : WARN :  Cluster identified c  Replacement id in edges:  e
02.333 : WARN :  Adjusted Graph {
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
02.333 : INFO :  cp  c  to  b  with parent  b
    { v: [32m'a'[39m, value: [36m[Object][39m },
02.333 : INFO :  In copy  b root b data { data: [33m2[39m } b
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
02.333 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
02.333 : DEBUG :  Copying Edges []
  edges: [],
02.333 : DEBUG :  Removing node c
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.333 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.333 : WARN :  Cluster without external connections, without a parent and with children a [33m0[39m
02.333 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
02.333 : DEBUG :  Old graph after copy {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
02.333 : WARN :  Copying children of  a root a data { data: [33m1[39m } a
02.333 : WARN :  Copying (nodes) clusterId a nodes [ [32m'b'[39m ]
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
02.333 : WARN :  Copying children of  b root a data { data: [33m2[39m } a
02.333 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'b'[39m ]
  edges: [],
02.333 : WARN :  Copying children of  c root a data { data: [33m3[39m } a
02.333 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m, [32m'c'[39m ]
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
02.333 : WARN :  Setting parent e c
02.333 : WARN :  Setting parent c b
}
02.333 : WARN :  New graph after copy node: ( a ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.333 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.333 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.333 : WARN :  New list of nodes [ [32m'a'[39m ]
02.333 : WARN :   Now next level a {
  clusterNode: [33mtrue[39m,
  id: [32m'a'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { e: [36m[Object][39m, c: [36m[Object][39m, b: [36m[Object][39m },
    _parent: { e: [32m'c'[39m, c: [32m'b'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, e: {}, c: [36m[Object][39m, b: [36m[Object][39m },
02.333 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
02.333 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

    _in: { e: {}, c: {}, b: {} },
    _preds: { e: {}, c: {}, b: {} },
    _out: { e: {}, c: {}, b: {} },
    _sucs: { e: {}, c: {}, b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m3[39m
  }
}
02.333 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.333 : WARN :  Cluster without external connections, without a parent and with children c [33m1[39m
02.333 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.333 : WARN :  Copying children of  c root c data { data: [33m3[39m } c
02.333 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m ]
02.333 : WARN :  New graph after copy node: ( c ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'e'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.333 : WARN :  Cluster without external connections, without a parent and with children b [33m1[39m
02.333 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.333 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
02.333 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m ]
02.333 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.333 : WARN :  New list of nodes [ [32m'b'[39m ]
02.333 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.333 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
02.342 : DEBUG :  Opting in, graph
02.342 : DEBUG :  Not a cluster  a Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
02.342 : DEBUG :  Not a cluster  b Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
02.342 : DEBUG :  Not a cluster  c Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
02.342 : DEBUG :  Cluster identified A Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
02.342 : DEBUG :  Cluster identified B Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
02.342 : DEBUG :  Cluster identified C Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
02.342 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ] [33m0[39m
02.342 : DEBUG :  Extracting node a Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.342 : DEBUG :  Not a cluster a [33m0[39m
02.342 : DEBUG :  Extracting node b Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
02.342 : DEBUG :  Not a cluster b [33m0[39m
02.342 : DEBUG :  Extracting node c Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
02.342 : DEBUG :  Not a cluster c [33m0[39m
02.342 : DEBUG :  Extracting node A Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.342 : INFO :  cp  a  to  A  with parent  A
02.342 : INFO :  In copy  A root A data [90mundefined[39m A
02.342 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.342 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.342 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.342 : INFO :  Edge data { data: [32m'link1'[39m } A
02.342 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
02.342 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.342 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
02.342 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.342 : INFO :  Edge data { data: [32m'link2'[39m } A
02.342 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
02.342 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.342 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
02.342 : DEBUG :  Removing node a
02.342 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.342 : DEBUG :  Extracting node B Map(5) {
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
02.342 : WARN :  Cluster identified A  Replacement id in edges:  a
02.342 : WARN :  Cluster identified B  Replacement id in edges:  b
02.342 : WARN :  Cluster identified C  Replacement id in edges:  c
02.342 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
02.342 : WARN :  Edge A -> B: {"data":"link1"}
02.342 : WARN :  Fix XXX Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
02.342 : WARN :  Fixing and trying - removing XXX A B 1
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
02.342 : WARN :  Fix Replacing with XXX A B 1
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
02.342 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
02.342 : WARN :  Edge A -> C: {"data":"link2"}
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.342 : WARN :  Fix XXX Map(5) {
02.342 : INFO :  cp  b  to  B  with parent  B
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
02.342 : INFO :  In copy  B root B data [90mundefined[39m B
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
02.342 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
02.342 : WARN :  Fixing and trying - removing XXX A C 2
02.342 : WARN :  Fix Replacing with XXX A C 2
02.342 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
02.342 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
02.342 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
02.342 : INFO :  Edge data { data: [32m'link1'[39m } B
  ],
02.342 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
02.342 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
}
02.342 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
02.342 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.342 : INFO :  Edge data { data: [32m'link2'[39m } B
02.342 : WARN :  extractor -  [33m0[39m {
02.342 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
02.342 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
  nodes: [
02.342 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
02.342 : DEBUG :  Removing node b
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
02.342 : DEBUG :  Old graph after copy {
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'A'[39m },
  nodes: [
    { v: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'C'[39m }
    { v: [32m'A'[39m, value: [36m[Object][39m },
  ],
    { v: [32m'B'[39m, value: [36m[Object][39m },
  edges: [
    { v: [32m'C'[39m }
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  ],
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  edges: [
  ],
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.342 : DEBUG :  Extracting node C Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.342 : INFO :  cp  c  to  C  with parent  C
02.342 : INFO :  In copy  C root C data [90mundefined[39m C
02.342 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.342 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.342 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
02.342 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
02.342 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.342 : INFO :  Edge data { data: [32m'link1'[39m } C
02.342 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
02.342 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.342 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
02.342 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.342 : INFO :  Edge data { data: [32m'link2'[39m } C
02.342 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
02.342 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.342 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
02.342 : DEBUG :  Removing node c
02.342 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.342 : WARN :  Copying children of  A root A data [90mundefined[39m A
02.342 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
02.342 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.342 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
02.342 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
02.342 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
02.342 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
02.342 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }

  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.342 : WARN :  Copying children of  B root B data [90mundefined[39m B
02.342 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
02.342 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.342 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
02.342 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.342 : WARN :  Copying children of  C root C data [90mundefined[39m C
02.342 : WARN :  Copying (nodes) clusterId C nodes [ [32m'c'[39m ]
02.342 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.342 : WARN :  New list of nodes [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
02.342 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.342 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.342 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.342 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.342 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.342 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
02.344 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.344 : DEBUG :  Opting in, graph
02.344 : DEBUG :  Cluster identified A {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
02.344 : DEBUG :  Cluster identified B {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
02.344 : DEBUG :  Not a cluster  b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
02.344 : DEBUG :  Not a cluster  c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
02.344 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
02.344 : DEBUG :  Nodes =  [ [32m'A'[39m, [32m'B'[39m, [32m'b'[39m, [32m'c'[39m, [32m'a'[39m ] [33m0[39m
02.344 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m0[39m
02.344 : INFO :  cp  c  to  A  with parent  B
02.344 : DEBUG :  Setting parent c B
02.344 : DEBUG :  Copying Edges [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
02.344 : INFO :  Edge { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
02.344 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} A
02.344 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
02.344 : INFO :  Edge is  { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
02.344 : INFO :  Copying as  b c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} 1
02.344 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
02.344 : WARN :  Cluster identified A  Replacement id in edges:  c
02.344 : WARN :  Cluster identified B  Replacement id in edges:  c
02.344 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }  leaves cluster  B
02.344 : WARN :  Descendants of XXX  B :  [ [32m'c'[39m ]
02.344 : WARN :  Edge b -> B: {"v":"b","w":"B","name":"1"}
02.344 : WARN :  Edge b -> B: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-b-B","classes":"flowchart-link LS-b LE-B"}
02.344 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
02.344 : INFO :  Edge { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
02.344 : INFO :  Edge data {
  minlen: [33m1[39m,
      padding: [33m15[39m
  arrowhead: [32m'normal'[39m,
    }
  },
  B: {
    id: [32m'c'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  classes: [32m'flowchart-link LS-a LE-c'[39m
    clusterData: {
} A
02.344 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
02.344 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
02.344 : INFO :  Copying as  a c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  classes: [32m'flowchart-link LS-a LE-c'[39m
} 2
02.344 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ] {
  minlen: [33m1[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: b B Translating:  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }  ---  {
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  id: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
02.344 : DEBUG :  Removing node c
02.344 : INFO :  cp  B  to  A  with parent  B
02.344 : INFO :  In copy  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
02.344 : DEBUG :  Not Setting parent for node= B cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.344 : DEBUG :  Copying Edges []
02.344 : DEBUG :  Removing node B
    shape: [32m'rect'[39m,
02.344 : DEBUG :  Removing node B
02.344 : INFO :  cp  b  to  A  with parent  A
02.344 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
    labelText: [32m'B'[39m,
    rx: [33m0[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
02.344 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    ry: [33m0[39m,
    class: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'B'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
    padding: [33m15[39m
  },
02.344 : DEBUG :  Copying Edges []
02.344 : DEBUG :  Removing node b
02.344 : INFO :  cp  a  to  A  with parent  A
02.344 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  externalConnections: [33mtrue[39m
}
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
02.344 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.344 : DEBUG :  Copying Edges []
02.344 : DEBUG :  Removing node a
02.344 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'A'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.344 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
02.344 : WARN :  Fixing and trixing - removing XXX b B 1
02.344 : WARN :  Fix Replacing with XXX b c 1
02.344 : WARN :  Edge a -> c: {"v":"a","w":"c","name":"2"}
02.344 : WARN :  Edge a -> c: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-a-c","classes":"flowchart-link LS-a LE-c"}
02.344 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    id: [32m'c'[39m,
    clusterData: {
    }
  },
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
  B: {
    clusterData: {
      labelStyle: [32m''[39m,
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
    externalConnections: [33mtrue[39m
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.344 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: a c Translating:  { id: [32m'c'[39m, clusterData: { data: [33m1[39m } }  ---  { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
02.344 : WARN :  Fixing and trixing - removing XXX a c 2
02.344 : WARN :  Fix Replacing with XXX a c 2
02.344 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
02.344 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.344 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.344 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
02.344 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
}
02.344 : WARN :  Copying children of  A root A data {
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  labelStyle: [32m''[39m,
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  style: [32m''[39m,
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
02.344 : WARN :  Copying (nodes) clusterId A nodes [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
02.344 : WARN :  Copying children of  B root A data {
  labelStyle: [32m''[39m,
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.344 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
02.344 : WARN :  Copying (nodes) clusterId B nodes [ [32m'c'[39m, [32m'B'[39m ]
02.344 : WARN :  Setting parent c B
02.344 : WARN :  New graph after copy node: ( A ) {
      type: [32m'group'[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.344 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.344 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.344 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.344 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.344 : WARN :  New list of nodes [ [32m'A'[39m ]
02.344 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: {
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.344 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
    labelText: [32m'A'[39m,
    rx: [33m0[39m,
    ry: [33m0[39m,
    class: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'A'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
    padding: [33m15[39m
  },
  labelText: [90mundefined[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, B: [36m[Object][39m, b: [36m[Object][39m, a: [36m[Object][39m },
    _parent: { c: [32m'B'[39m, B: [32m'\x00'[39m, b: [32m'\x00'[39m, a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, B: [36m[Object][39m, b: {}, a: {} },
    _in: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.344 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    _preds: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _out: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _sucs: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _edgeObjs: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m4[39m,
    _edgeCount: [33m2[39m
  }
}
02.344 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    clusterData: {
      labelStyle: [32m''[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.344 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mfalse[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
      shape: [32m'rect'[39m,
02.344 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
02.344 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
02.344 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
02.344 : WARN :  New list of nodes [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
02.344 : WARN :   Now next level c {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
}
02.344 : WARN :   Now next level B {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
    clusterData: {
  class: [32m'default'[39m,
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
  style: [32m''[39m,
      rx: [33m0[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
      ry: [33m0[39m,
  padding: [33m15[39m
      class: [32m'default'[39m,
}
      style: [32m''[39m,
02.344 : WARN :   Now next level b {
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.344 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
}
02.344 : WARN :   Now next level a {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
    clusterData: {
  ry: [33m0[39m,
  class: [32m'default'[39m,
      labelStyle: [32m''[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
}

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
02.354 : WARN :  Cluster identified C  Replacement id in edges:  d
      rx: [33m0[39m,
02.354 : WARN :  Cluster identified D  Replacement id in edges:  d
02.354 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
02.354 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  nodes: [
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'C'[39m, value: [36m[Object][39m },
02.344 : DEBUG :  {
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  ],
  A: {
  edges: [],
    id: [32m'c'[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
} [ [32m'd'[39m ]
      labelText: [32m'A'[39m,
02.354 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
      rx: [33m0[39m,
02.354 : WARN :  Old graph before copy {
      ry: [33m0[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      class: [32m'default'[39m,
  nodes: [
      style: [32m''[39m,
    { v: [32m'C'[39m, value: [36m[Object][39m },
      id: [32m'A'[39m,
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
      width: [33m500[39m,
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.354 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
02.354 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
02.354 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
02.354 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
02.354 : WARN :  Setting parent d D
02.354 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
  B: {
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
    id: [32m'c'[39m,
    clusterData: {
  ],
      labelStyle: [32m''[39m,
  edges: [],
      shape: [32m'rect'[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      labelText: [32m'B'[39m,
}
      rx: [33m0[39m,
02.354 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
      ry: [33m0[39m,
02.354 : WARN :  New list of nodes [ [32m'C'[39m ]
      class: [32m'default'[39m,
02.354 : WARN :   Now next level C {
      style: [32m''[39m,
  clusterNode: [33mtrue[39m,
      id: [32m'B'[39m,
  id: [32m'C'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
  clusterData: { data: [33m1[39m },
02.344 : DEBUG :  Nodes =  [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ] [33m1[39m
  label: [90mundefined[39m,
02.344 : DEBUG :  Extracting node c {
  graph: Graph {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _isDirected: [33mtrue[39m,
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
    _isMultigraph: [33mtrue[39m,
  A: {
    _isCompound: [33mtrue[39m,
    id: [32m'c'[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    clusterData: {
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
      labelStyle: [32m''[39m,
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
      shape: [32m'rect'[39m,
    _in: { d: {}, D: {} },
      labelText: [32m'A'[39m,
    _preds: { d: {}, D: {} },
      rx: [33m0[39m,
    _out: { d: {}, D: {} },
      ry: [33m0[39m,
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
      class: [32m'default'[39m,
    _nodeCount: [33m2[39m
      style: [32m''[39m,
  }
}
02.354 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
      style: [32m''[39m,
    { v: [32m'D'[39m, value: [36m[Object][39m }
      id: [32m'B'[39m,
  ],
      width: [33m500[39m,
  edges: [],
      type: [32m'group'[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      padding: [33m15[39m
} [ [32m'd'[39m ]
    },
02.354 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
    externalConnections: [33mtrue[39m
  },
02.354 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
02.354 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
02.354 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
02.354 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.354 : WARN :  New list of nodes [ [32m'D'[39m ]
02.354 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
02.344 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  label: [90mundefined[39m,
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
  graph: Graph {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.344 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
    _in: { d: {} },
      type: [32m'group'[39m,
    _preds: { d: {} },
      padding: [33m15[39m
    },
    _out: { d: {} },
    externalConnections: [33mtrue[39m
    _sucs: { d: {} },
  },
    _edgeObjs: {},
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    _edgeLabels: {},
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    _nodeCount: [33m1[39m
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m {
  }
}
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
02.354 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
02.344 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.344 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
02.344 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.344 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
02.344 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.344 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
02.354 : DEBUG :  Opting in, graph
02.354 : DEBUG :  Cluster identified C Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
02.354 : DEBUG :  Cluster identified D Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
02.354 : DEBUG :  Not a cluster  d Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
02.354 : DEBUG :  Nodes =  [ [32m'C'[39m, [32m'D'[39m, [32m'd'[39m ] [33m0[39m
02.354 : DEBUG :  Extracting node C Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
02.354 : INFO :  cp  d  to  C  with parent  D
02.354 : DEBUG :  Setting parent d D
02.354 : DEBUG :  Copying Edges []
02.354 : DEBUG :  Removing node d
02.354 : INFO :  cp  D  to  C  with parent  D
02.354 : INFO :  In copy  D root C data { data: [33m2[39m } C
02.354 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.354 : DEBUG :  Copying Edges []
02.354 : DEBUG :  Removing node D
02.354 : DEBUG :  Removing node D
02.354 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.354 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.354 : DEBUG :  Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
02.354 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.354 : DEBUG :  Not a cluster d [33m0[39m
02.354 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
02.354 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
02.354 : DEBUG :  Not a cluster d [33m1[39m
02.354 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
02.354 : INFO :  cp  d  to  D  with parent  D
02.354 : INFO :  In copy  D root D data { data: [33m2[39m } D
02.354 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.354 : DEBUG :  Copying Edges []
02.354 : DEBUG :  Removing node d
02.354 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.354 : DEBUG :  Done, no node has children [ [32m'd'[39m ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
02.361 : INFO :  Graph before { data: [33m2[39m }
02.361 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : DEBUG :  Opting in, graph
02.361 : DEBUG :  Cluster identified C Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
02.361 : DEBUG :  Cluster identified D Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
02.361 : DEBUG :  Not a cluster  d Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
02.361 : DEBUG :  Cluster identified B Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
02.361 : DEBUG :  Not a cluster  b Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
02.361 : DEBUG :  Cluster identified A Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
02.361 : DEBUG :  Not a cluster  a Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
02.361 : DEBUG :  Nodes =  [
  [32m'C'[39m, [32m'D'[39m, [32m'd'[39m,
  [32m'B'[39m, [32m'b'[39m, [32m'A'[39m,
  [32m'a'[39m
] [33m0[39m
02.361 : DEBUG :  Extracting node C Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
02.361 : INFO :  cp  d  to  C  with parent  D
02.361 : DEBUG :  Setting parent d D
02.361 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.361 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.361 : INFO :  Edge data { data: [32m'link1'[39m } C
02.361 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
02.361 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.361 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
02.361 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.361 : INFO :  Edge data { data: [32m'link2'[39m } C
02.361 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
02.361 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.361 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
02.361 : DEBUG :  Removing node d
02.361 : INFO :  cp  D  to  C  with parent  D
02.361 : INFO :  In copy  D root C data { data: [33m2[39m } C
02.361 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.361 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.361 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.361 : INFO :  Edge data { data: [32m'link1'[39m } C
02.361 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
02.361 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.361 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
02.361 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.361 : INFO :  Edge data { data: [32m'link2'[39m } C
02.361 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
02.361 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.361 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
02.361 : DEBUG :  Removing node D
02.361 : DEBUG :  Removing node D
02.361 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.361 : DEBUG :  Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
02.361 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.361 : DEBUG :  Not a cluster d [33m0[39m
02.361 : DEBUG :  Extracting node B Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
02.361 : INFO :  cp  b  to  B  with parent  B
02.361 : INFO :  In copy  B root B data { data: [33m4[39m } B
02.361 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.361 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.361 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.361 : INFO :  Edge data { data: [32m'link1'[39m } B
02.361 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
02.361 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.361 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
02.361 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.361 : INFO :  Edge data { data: [32m'link2'[39m } B
02.361 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
02.361 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.361 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
02.361 : DEBUG :  Removing node b
02.361 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : DEBUG :  Extracting node b Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.361 : DEBUG :  Not a cluster b [33m0[39m
02.361 : DEBUG :  Extracting node A Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m6[39m } [90mundefined[39m  Depth  [33m0[39m
02.361 : INFO :  cp  a  to  A  with parent  A
02.361 : INFO :  In copy  A root A data { data: [33m6[39m } A
02.361 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.361 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
02.361 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.361 : INFO :  Edge data { data: [32m'link1'[39m } A
02.361 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
02.361 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
02.361 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
02.361 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.361 : INFO :  Edge data { data: [32m'link2'[39m } A
02.361 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
02.361 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
02.361 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
02.361 : DEBUG :  Removing node a
02.361 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : DEBUG :  Extracting node a Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.361 : DEBUG :  Not a cluster a [33m0[39m
02.361 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
02.361 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
02.361 : DEBUG :  Not a cluster d [33m1[39m
02.361 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
02.361 : INFO :  cp  d  to  D  with parent  D
02.361 : INFO :  In copy  D root D data { data: [33m2[39m } D
02.361 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.361 : DEBUG :  Copying Edges []
02.361 : DEBUG :  Removing node d
02.361 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
02.361 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
02.361 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
02.361 : INFO :  A [ [32m'a'[39m ]

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
02.361 : WARN :  Cluster identified C  Replacement id in edges:  d
02.361 : WARN :  Cluster identified D  Replacement id in edges:  d
02.361 : WARN :  Cluster identified B  Replacement id in edges:  b
02.361 : WARN :  Cluster identified A  Replacement id in edges:  a
02.361 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
02.361 : WARN :  Edge A -> B: {"data":"link1"}
02.361 : WARN :  Fix XXX Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }
02.361 : WARN :  Fixing and trying - removing XXX A B 1
02.361 : WARN :  Fix Replacing with XXX A B 1
02.361 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
02.361 : WARN :  Edge A -> C: {"data":"link2"}
02.361 : WARN :  Fix XXX Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'D'[39m, clusterData: { data: [33m1[39m } }
02.361 : WARN :  Fixing and trying - removing XXX A C 2
02.361 : WARN :  Fix Replacing with XXX A C 2
02.361 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
02.361 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
02.361 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
02.361 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
02.361 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
02.361 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
02.361 : WARN :  Setting parent d D
02.361 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.361 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
02.361 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : WARN :  Copying children of  B root B data { data: [33m4[39m } B
02.361 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
02.361 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
02.361 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : WARN :  Copying children of  A root A data { data: [33m6[39m } A
02.361 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
02.361 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : WARN :  New list of nodes [ [32m'C'[39m, [32m'B'[39m, [32m'A'[39m ]
02.361 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
02.361 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
02.361 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
02.361 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
02.361 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
02.361 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.361 : WARN :  New list of nodes [ [32m'D'[39m ]
02.361 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.361 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.361 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.361 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.361 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: { data: [33m6[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.361 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
02.382 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.382 : DEBUG :  Opting in, graph
02.382 : DEBUG :  Not a cluster  a Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
02.382 : DEBUG :  Cluster identified b Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
02.382 : DEBUG :  Not a cluster  c Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
02.382 : DEBUG :  Not a cluster  d Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
02.382 : DEBUG :  Not a cluster  e Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
02.382 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ] [33m0[39m
02.382 : DEBUG :  Extracting node a Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.382 : DEBUG :  Not a cluster a [33m0[39m
02.382 : DEBUG :  Extracting node b Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
02.382 : INFO :  cp  c  to  b  with parent  b
02.382 : INFO :  In copy  b root b data { data: [33m2[39m } b
02.382 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.382 : DEBUG :  Copying Edges [
  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m },
  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m },
  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
]
02.382 : INFO :  Edge { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
02.382 : WARN :  Cluster identified b  Replacement id in edges:  c
02.382 : WARN :  Edge a -> b: {"v":"a","w":"b","name":"1"}
02.382 : WARN :  Edge a -> b: {"data":"link1"}
02.382 : WARN :  Fix XXX Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: a b Translating:  [90mundefined[39m  ---  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
02.382 : WARN :  Fixing and trying - removing XXX a b 1
02.382 : INFO :  Edge data { data: [32m'link2'[39m } b
02.382 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.382 : INFO :  Edge is  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
02.382 : INFO :  Copying as  c d { data: [32m'link2'[39m } 2
02.382 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
02.382 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
02.382 : INFO :  Edge data { data: [32m'link2'[39m } b
02.382 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.382 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
02.382 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
02.382 : WARN :  Fix Replacing with XXX a b 1
02.382 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
02.382 : WARN :  Edge c -> d: {"v":"c","w":"d","name":"2"}
02.382 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.382 : WARN :  Edge c -> d: {"data":"link2"}
02.382 : INFO :  Edge data { data: [32m'link1'[39m } b
02.382 : WARN :  Fix XXX Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
02.382 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
02.382 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
02.382 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
02.382 : DEBUG :  Removing node c
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
02.382 : INFO :  cp  d  to  b  with parent  b
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
02.382 : INFO :  In copy  b root b data { data: [33m2[39m } b
} ids: c d Translating:  [90mundefined[39m  ---  [90mundefined[39m
02.382 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.382 : WARN :  Edge d -> e: {"v":"d","w":"e","name":"2"}
02.382 : DEBUG :  Copying Edges [ { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }, { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
02.382 : WARN :  Edge d -> e: {"data":"link2"}
02.382 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
02.382 : WARN :  Fix XXX Map(7) {
02.382 : INFO :  Edge data { data: [32m'link2'[39m } b
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
02.382 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
02.382 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
02.382 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
02.382 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
02.382 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.382 : INFO :  Edge data { data: [32m'link1'[39m } b
02.382 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.382 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
02.382 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
02.382 : DEBUG :  Removing node d
02.382 : INFO :  cp  e  to  b  with parent  b
02.382 : INFO :  In copy  b root b data { data: [33m2[39m } b
02.382 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.382 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
02.382 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
02.382 : INFO :  Edge data { data: [32m'link1'[39m } b
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
02.382 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
02.382 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
} ids: d e Translating:  [90mundefined[39m  ---  [90mundefined[39m
02.382 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
02.382 : WARN :  Adjusted Graph {
02.382 : DEBUG :  Removing node e
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
02.382 : DEBUG :  Old graph after copy {
  nodes: [
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m }, { v: [32m'b'[39m, value: [36m[Object][39m } ],
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
}
  ],
02.382 : DEBUG :  Extracting node c Map(7) {
  edges: [
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.382 : DEBUG :  Not a cluster c [33m0[39m
02.382 : DEBUG :  Extracting node d Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  ],
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
}
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
02.382 : WARN :  extractor -  [33m0[39m {
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  nodes: [
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'a'[39m, value: [36m[Object][39m },
02.382 : DEBUG :  Not a cluster d [33m0[39m
    { v: [32m'b'[39m, value: [36m[Object][39m },
02.382 : DEBUG :  Extracting node e Map(7) {
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  ],
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.382 : DEBUG :  Not a cluster e [33m0[39m
02.382 : DEBUG :  Done, no node has children [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.382 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
  edges: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  ],
  edges: [
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
} [90mundefined[39m
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
02.382 : WARN :  Cluster without external connections, without a parent and with children b [33m0[39m
  ],
02.382 : WARN :  Old graph before copy {
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.382 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
02.382 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
02.382 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.382 : WARN :  New list of nodes [ [32m'a'[39m, [32m'b'[39m ]
02.382 : WARN :   Now next level a { data: [33m1[39m }
02.382 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, d: [36m[Object][39m, e: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m, d: [32m'\x00'[39m, e: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, d: {}, e: {} },
    _in: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _preds: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _out: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _sucs: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _edgeObjs: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m2[39m
  }
}
02.382 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
02.397 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.397 : DEBUG :  Opting in, graph
02.397 : DEBUG :  Cluster identified a Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
02.397 : DEBUG :  Cluster identified b Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
02.397 : DEBUG :  Cluster identified c Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
02.397 : DEBUG :  Not a cluster  e Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
02.397 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ] [33m0[39m
02.397 : DEBUG :  Extracting node a Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
02.397 : INFO :  cp  e  to  a  with parent  c
02.397 : DEBUG :  Setting parent e c
02.397 : DEBUG :  Copying Edges []
02.397 : DEBUG :  Removing node e
02.397 : INFO :  cp  c  to  a  with parent  c
02.397 : INFO :  In copy  c root a data { data: [33m3[39m } a
02.397 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.397 : DEBUG :  Copying Edges []
02.397 : DEBUG :  Removing node c
02.397 : DEBUG :  Removing node c
02.397 : INFO :  cp  b  to  a  with parent  b
02.397 : INFO :  In copy  b root a data { data: [33m2[39m } a
02.397 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.397 : DEBUG :  Copying Edges []
02.397 : DEBUG :  Removing node b
02.397 : DEBUG :  Removing node b
02.397 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.397 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.397 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.397 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.397 : DEBUG :  Map(9) {
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
02.397 : WARN :  Cluster identified a  Replacement id in edges:  e
02.397 : WARN :  Cluster identified b  Replacement id in edges:  e
02.397 : WARN :  Cluster identified c  Replacement id in edges:  e
02.397 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
}
02.397 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
02.397 : DEBUG :  Extracting node e Map(9) {
  edges: [],
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.397 : WARN :  Cluster without external connections, without a parent and with children a [33m0[39m
02.397 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
02.397 : DEBUG :  Not a cluster e [33m0[39m
02.397 : DEBUG :  Nodes =  [ [32m'e'[39m, [32m'c'[39m, [32m'b'[39m ] [33m1[39m
02.397 : DEBUG :  Extracting node e Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  nodes: [
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    { v: [32m'a'[39m, value: [36m[Object][39m },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
02.397 : DEBUG :  Not a cluster e [33m1[39m
02.397 : DEBUG :  Extracting node c Map(9) {
  ],
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  edges: [],
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.397 : WARN :  Copying children of  a root a data { data: [33m1[39m } a
02.397 : WARN :  Copying (nodes) clusterId a nodes [ [32m'b'[39m ]
02.397 : WARN :  Copying children of  b root a data { data: [33m2[39m } a
02.397 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'b'[39m ]
02.397 : WARN :  Copying children of  c root a data { data: [33m3[39m } a
02.397 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m, [32m'c'[39m ]
02.397 : WARN :  Setting parent e c
02.397 : WARN :  Setting parent c b
02.397 : WARN :  New graph after copy node: ( a ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  ],
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  edges: [],
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.397 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.397 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.397 : WARN :  New list of nodes [ [32m'a'[39m ]
02.397 : WARN :   Now next level a {
  clusterNode: [33mtrue[39m,
  id: [32m'a'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
02.397 : INFO :  cp  e  to  c  with parent  c
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
02.397 : INFO :  In copy  c root c data { data: [33m3[39m } c
02.397 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
02.397 : DEBUG :  Copying Edges []
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
02.397 : DEBUG :  Removing node e
    _nodes: { e: [36m[Object][39m, c: [36m[Object][39m, b: [36m[Object][39m },
02.397 : DEBUG :  Old graph after copy {
    _parent: { e: [32m'c'[39m, c: [32m'b'[39m, b: [32m'\x00'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, e: {}, c: [36m[Object][39m, b: [36m[Object][39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.397 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _in: { e: {}, c: {}, b: {} },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    _preds: { e: {}, c: {}, b: {} },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _out: { e: {}, c: {}, b: {} },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
    _sucs: { e: {}, c: {}, b: {} },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    _edgeObjs: {},
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
    _edgeLabels: {},
02.397 : INFO :  cp  c  to  b  with parent  b
02.397 : INFO :  In copy  b root b data { data: [33m2[39m } b
    _nodeCount: [33m3[39m
02.397 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.397 : DEBUG :  Copying Edges []
  }
}
02.397 : WARN :  extractor -  [33m1[39m {
02.397 : DEBUG :  Removing node c
02.397 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
02.397 : WARN :  Cluster without external connections, without a parent and with children c [33m1[39m
02.397 : WARN :  Old graph before copy {
}
02.397 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
02.397 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [

    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.397 : WARN :  Copying children of  c root c data { data: [33m3[39m } c
02.397 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m ]
02.397 : WARN :  New graph after copy node: ( c ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'e'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.397 : WARN :  Cluster without external connections, without a parent and with children b [33m1[39m
02.397 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.397 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
02.397 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m ]
02.397 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.397 : WARN :  New list of nodes [ [32m'b'[39m ]
02.397 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
02.397 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
02.408 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.408 : DEBUG :  Opting in, graph
02.408 : DEBUG :  Cluster identified A Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
02.408 : DEBUG :  Cluster identified B Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
02.408 : DEBUG :  Not a cluster  b Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
02.408 : DEBUG :  Not a cluster  c Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
02.408 : DEBUG :  Not a cluster  a Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
02.408 : DEBUG :  Nodes =  [ [32m'A'[39m, [32m'B'[39m, [32m'b'[39m, [32m'c'[39m, [32m'a'[39m ] [33m0[39m
02.408 : DEBUG :  Extracting node A Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m0[39m
02.408 : INFO :  cp  c  to  A  with parent  B
02.408 : DEBUG :  Setting parent c B
02.408 : DEBUG :  Copying Edges [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
02.408 : INFO :  Edge { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
02.408 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} A
02.408 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
02.408 : INFO :  Edge is  { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
02.408 : INFO :  Copying as  b c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} 1
02.408 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
02.408 : INFO :  Edge { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
02.408 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  cssClasses: [32m'flowchart-link LS-a LE-c'[39m
} A
02.408 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
02.408 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
02.408 : INFO :  Copying as  a c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  cssClasses: [32m'flowchart-link LS-a LE-c'[39m
} 2
02.408 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
02.408 : DEBUG :  Removing node c
02.408 : INFO :  cp  B  to  A  with parent  B
02.408 : INFO :  In copy  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
02.408 : DEBUG :  Not Setting parent for node= B cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
02.408 : DEBUG :  Copying Edges []
02.408 : DEBUG :  Removing node B
02.408 : DEBUG :  Removing node B
02.408 : INFO :  cp  b  to  A  with parent  A
02.408 : INFO :  In copy  A root A data {
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
02.408 : WARN :  Cluster identified A  Replacement id in edges:  c
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
02.408 : WARN :  Cluster identified B  Replacement id in edges:  c
02.408 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }  leaves cluster  B
02.408 : WARN :  Descendants of XXX  B :  [ [32m'c'[39m ]
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
02.408 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.408 : DEBUG :  Copying Edges []
02.408 : DEBUG :  Removing node b
02.408 : INFO :  cp  a  to  A  with parent  A
02.408 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
02.408 : WARN :  Edge b -> B: {"v":"b","w":"B","name":"1"}
02.408 : WARN :  Edge b -> B: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-b-B","cssClasses":"flowchart-link LS-b LE-B"}
02.408 : WARN :  Fix XXX Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
02.408 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
02.408 : DEBUG :  Copying Edges []
02.408 : DEBUG :  Removing node a
02.408 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'A'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
}
02.408 : DEBUG :  Extracting node B Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
      type: [32m'group'[39m,
      padding: [33m15[39m
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    }
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.408 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      style: [32m''[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: b B Translating:  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }  ---  {
  id: [32m'c'[39m,
  clusterData: {
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    labelText: [32m'B'[39m,
    rx: [33m0[39m,
    ry: [33m0[39m,
    class: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'B'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
    padding: [33m15[39m
  },
  externalConnections: [33mtrue[39m
      padding: [33m15[39m
    }
  },
}
02.408 : WARN :  Fixing and trying - removing XXX b B 1
02.408 : WARN :  Fix Replacing with XXX b c 1
  [32m'B'[39m => {
    id: [32m'c'[39m,
02.408 : WARN :  Edge a -> c: {"v":"a","w":"c","name":"2"}
02.408 : WARN :  Edge a -> c: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-a-c","cssClasses":"flowchart-link LS-a LE-c"}
02.408 : WARN :  Fix XXX Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
}
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
02.408 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
      id: [32m'A'[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: a c Translating:  { id: [32m'c'[39m, clusterData: { data: [33m1[39m } }  ---  { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
02.408 : WARN :  Fixing and trying - removing XXX a c 2
02.408 : WARN :  Fix Replacing with XXX a c 2
      width: [33m500[39m,
      type: [32m'group'[39m,
02.408 : WARN :  Adjusted Graph {
      padding: [33m15[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    }
  },
  nodes: [
  [32m'B'[39m => {
    id: [32m'c'[39m,
    { v: [32m'A'[39m, value: [36m[Object][39m },
    clusterData: {
      labelStyle: [32m''[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      shape: [32m'rect'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      class: [32m'default'[39m,
      style: [32m''[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  ],
  edges: [
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.408 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.408 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
} [90mundefined[39m
02.408 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
02.408 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
  nodes: [
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.408 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
02.408 : WARN :  Copying children of  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
02.408 : WARN :  Copying (nodes) clusterId A nodes [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
02.408 : WARN :  Copying children of  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
02.408 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
  width: [33m500[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
  type: [32m'group'[39m,
      cssClass: [32m'default'[39m,
  padding: [33m15[39m
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
} A
      type: [32m'group'[39m,
      padding: [33m15[39m
02.408 : WARN :  Copying (nodes) clusterId B nodes [ [32m'c'[39m, [32m'B'[39m ]
    }
02.408 : WARN :  Setting parent c B
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
02.408 : WARN :  New graph after copy node: ( A ) {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
}
02.408 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.408 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.408 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.408 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
02.408 : WARN :  New list of nodes [ [32m'A'[39m ]
02.408 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    shape: [32m'rect'[39m,
    labelText: [32m'A'[39m,
    rx: [33m0[39m,
    ry: [33m0[39m,
    cssClass: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'A'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
    padding: [33m15[39m
  },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, B: [36m[Object][39m, b: [36m[Object][39m, a: [36m[Object][39m },
    _parent: { c: [32m'B'[39m, B: [32m'\x00'[39m, b: [32m'\x00'[39m, a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, B: [36m[Object][39m, b: {}, a: {} },
02.408 : DEBUG :  Extracting node a Map(9) {
    _in: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _preds: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _out: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _sucs: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _edgeObjs: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m4[39m,
    _edgeCount: [33m2[39m
  }
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
}
02.408 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
      width: [33m500[39m,
      type: [32m'group'[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
} [90mundefined[39m
02.408 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mfalse[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
02.408 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
02.408 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
02.408 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
02.408 : WARN :  New list of nodes [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
02.408 : WARN :   Now next level c {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
}
02.408 : WARN :   Now next level B {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  ry: [33m0[39m,
02.408 : DEBUG :  Map(9) {
  class: [32m'default'[39m,
  style: [32m''[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  id: [32m'B'[39m,
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  width: [33m500[39m,
  type: [32m'group'[39m,
  [32m'A'[39m => {
  padding: [33m15[39m
    id: [32m'c'[39m,
}
02.408 : WARN :   Now next level b {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
    clusterData: {
}
      labelStyle: [32m''[39m,
02.408 : WARN :   Now next level a {
  labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
}

    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.408 : DEBUG :  Nodes =  [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ] [33m1[39m
02.408 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
02.408 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.408 : DEBUG :  Extracting node B Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
02.408 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.408 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
02.408 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.408 : DEBUG :  Extracting node a Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
02.408 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
02.408 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

 âœ“ packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js (15 tests) 142ms
 âœ“ packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js (15 tests) 133ms
stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-1 should handle a simple root definition abc122
03.472 : INFO :  Node:  root
03.472 : INFO :  addNode [33m4[39m root root [33m0[39m
03.473 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-2 should handle a hierarchical mindmap definition
03.484 : INFO :  Node:  root
03.484 : INFO :  addNode [33m4[39m root root [33m0[39m
03.484 : TRACE :  Stop NL
03.484 : INFO :  Node:  child1
03.484 : INFO :  addNode [33m6[39m child1 child1 [33m0[39m
03.484 : TRACE :  Stop NL
03.484 : INFO :  Node:  child2
03.484 : INFO :  addNode [33m6[39m child2 child2 [33m0[39m
03.484 : TRACE :  Stop NL
03.484 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > 3 should handle a simple root definition with a shape and without an id abc123
03.488 : TRACE :  Long description: root
03.488 : TRACE :  node end )
03.488 : TRACE :  node found .. (
03.488 : DEBUG :  In get type ( )
03.488 : INFO :  Node:  root
03.488 : INFO :  addNode [33m4[39m root root [33m1[39m
03.488 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-4 should handle a deeper hierarchical mindmap definition
03.490 : INFO :  Node:  root
03.490 : INFO :  addNode [33m4[39m root root [33m0[39m
03.490 : TRACE :  Stop NL
03.490 : INFO :  Node:  child1
03.490 : INFO :  addNode [33m6[39m child1 child1 [33m0[39m
03.490 : TRACE :  Stop NL
03.490 : INFO :  Node:  leaf1
03.490 : INFO :  addNode [33m8[39m leaf1 leaf1 [33m0[39m
03.490 : TRACE :  Stop NL
03.490 : INFO :  Node:  child2
03.490 : INFO :  addNode [33m6[39m child2 child2 [33m0[39m
03.490 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > 5 Multiple roots are illegal
03.494 : INFO :  Node:  root
03.494 : INFO :  addNode [33m4[39m root root [33m0[39m
03.494 : TRACE :  Stop NL
03.494 : INFO :  Node:  fakeRoot
03.494 : INFO :  addNode [33m4[39m fakeRoot fakeRoot [33m0[39m

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-6 real root in wrong place
03.498 : INFO :  Node:  root
03.498 : INFO :  addNode [33m10[39m root root [33m0[39m
03.498 : TRACE :  Stop NL
03.498 : INFO :  Node:  fakeRoot
03.498 : INFO :  addNode [33m8[39m fakeRoot fakeRoot [33m0[39m

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with a node
Found block-beta
.

Lex: NODE_ID id
.

Lex: EOF
Rule: node (NODE_ID separator):  id
Rule: nodeStatement (node)  { id: [32m'id'[39m }
Rule: statement:  {
  id: [32m'id'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a node with a square shape and a label
Found block
.

Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: [32m'[]'[39m, label: [32m'A label'[39m }
Rule: nodeStatement (node)  { id: [32m'id'[39m, label: [32m'A label'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'id'[39m,
  label: [32m'A label'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [32m'A label'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes
Found block
.

Lex: NODE_ID id1
.

Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: [32m'id1'[39m }
.

Lex: EOF
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
Rule: statement:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id1'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id1'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes
Found block
.

Lex: NODE_ID id1
.

Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: [32m'id1'[39m }
.

Lex: NODE_ID id3
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
.

Lex: EOF
Rule: node (NODE_ID separator):  id3
Rule: nodeStatement (node)  { id: [32m'id3'[39m }
Rule: statement:  {
  id: [32m'id3'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id1'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id1'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id3'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a node with a square shape and a label
Found block
.

Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID id2
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: [32m'[]'[39m, label: [32m'A label'[39m }
Rule: nodeStatement (node)  { id: [32m'id'[39m, label: [32m'A label'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lex: EOF
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
Rule: statement:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id'[39m,
  label: [32m'A label'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [32m'A label'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
Found block
.

Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.
Lex: LINK #-->   #
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: [32m'[]'[39m, label: [32m'first'[39m }
Rule: nodeStatement (node)  { id: [32m'id1'[39m, label: [32m'first'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: link:  -->    -->
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: [32m'[]'[39m, label: [32m'second'[39m }
Rule: (nodeStatement link node)  {
  id: [32m'id1'[39m,
  label: [32m'first'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} { edgeTypeStr: [32m'-->   '[39m, label: [32m''[39m } { id: [32m'id2'[39m, label: [32m'second'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }  typestr:  -->
Rule: statement:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m''[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]
Rule: hierarchy:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m''[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-1 should handle a simple root definition abc122
03.483 : INFO :  Node:  root
03.483 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-2 should handle a hierarchical kanban definition
03.496 : INFO :  Node:  root
03.496 : TRACE :  Stop NL
03.496 : INFO :  Node:  child1
03.496 : TRACE :  Stop NL
03.496 : INFO :  Node:  child2
03.496 : TRACE :  Stop NL
03.496 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > 3 should handle a simple root definition with a shape and without an id abc123
03.501 : TRACE :  Long description: root
03.501 : TRACE :  node end )
03.501 : TRACE :  node found .. (
03.501 : DEBUG :  In get type ( )
03.501 : INFO :  Node:  root
03.501 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-7 should handle an id and type for a node definition
03.501 : TRACE :  Long description: The root
03.501 : TRACE :  node end ... ]
03.501 : TRACE :  node found .. root
03.501 : DEBUG :  In get type [ ]
03.500 : INFO :  Node:  root
03.500 : INFO :  addNode [33m4[39m root The root [33m2[39m
03.501 : TRACE :  Stop NL
03.501 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
Found block
.

Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.
Lex: START_LINK --
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: [32m'[]'[39m, label: [32m'first'[39m }
Rule: nodeStatement (node)  { id: [32m'id1'[39m, label: [32m'first'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lex: Starting string
LEX: STR end: a label
LEX: POPPING STR: "
Lex: LINK # -->   #
Rule: LABEL link:  --  a label  -->
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: [32m'[]'[39m, label: [32m'second'[39m }
Rule: (nodeStatement link node)  {
  id: [32m'id1'[39m,
  label: [32m'first'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} { edgeTypeStr: [32m' -->   '[39m, label: [32m'a label'[39m } { id: [32m'id2'[39m, label: [32m'second'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }  typestr:   -->
Rule: statement:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m'a label'[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]
Rule: hierarchy:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m'a label'[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-8 should handle an id and type for a node definition
03.502 : INFO :  Node:  root
03.502 : INFO :  addNode [33m4[39m root root [33m0[39m
03.502 : TRACE :  Stop NL
03.502 : TRACE :  Long description: child1
03.502 : TRACE :  node end )
03.502 : TRACE :  node found .. theId
03.502 : DEBUG :  In get type ( )
03.502 : INFO :  Node:  theId
03.502 : INFO :  addNode [33m6[39m theId child1 [33m1[39m
03.502 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with column statements
Found block
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram without column statements
Found block
.

Lex: NODE_ID block1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with auto column statements
Found block
.

.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [33m-1[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m22[39m }
}
COLUMNS:  [33m-1[39m
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m-1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m-1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-4 should not distinguish between deeper hierarchical levels in the kanban definition
03.503 : INFO :  Node:  root
03.503 : TRACE :  Stop NL
03.503 : INFO :  Node:  child1
03.503 : TRACE :  Stop NL
03.503 : INFO :  Node:  leaf1
03.503 : TRACE :  Stop NL
03.503 : INFO :  Node:  child2
03.503 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-9 should handle an id and type for a node definition
03.505 : TRACE :  Node:  root
03.505 : INFO :  addNode [33m0[39m root root [33m0[39m
03.505 : TRACE :  Stop NL
03.505 : TRACE :  Long description: child1
03.505 : TRACE :  node end )
03.505 : TRACE :  node found .. theId
03.505 : DEBUG :  In get type ( )
03.505 : INFO :  Node:  theId
03.505 : INFO :  addNode [33m6[39m theId child1 [33m1[39m
03.505 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-10 multiple types (circle)
03.508 : TRACE :  Long description: the root
03.508 : TRACE :  node end ))
03.508 : TRACE :  node found .. root
03.508 : DEBUG :  In get type (( ))
03.508 : INFO :  Node:  root
03.508 : INFO :  addNode [33m1[39m root the root [33m3[39m
03.508 : TRACE :  Stop NL
03.508 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > 5 Multiple sections are ok
03.507 : INFO :  Node:  section1
03.507 : TRACE :  Stop NL
03.507 : INFO :  Node:  section2
03.507 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-11 multiple types (cloud)
03.510 : TRACE :  Cloud Bang
03.510 : TRACE :  Long description: the root
03.510 : TRACE :  node end ((
03.510 : TRACE :  node found .. root
03.510 : DEBUG :  In get type ) (
03.509 : INFO :  Node:  root
03.509 : INFO :  addNode [33m1[39m root the root [33m4[39m
03.510 : TRACE :  Stop NL
03.510 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks next to each other
Found block
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12 multiple types (bang)
03.511 : TRACE :  Explosion Bang
03.511 : TRACE :  Long description: the root
03.511 : TRACE :  node end ((
03.511 : TRACE :  node found .. root
03.511 : DEBUG :  In get type )) ((
03.511 : INFO :  Node:  root
03.511 : INFO :  addNode [33m1[39m root the root [33m5[39m
03.511 : TRACE :  Stop NL
03.511 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks on top of each other
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12-a multiple types (hexagon)
03.513 : TRACE :  Long description: the root
03.513 : TRACE :  node end ((
03.513 : TRACE :  node found .. root
03.513 : DEBUG :  In get type {{ }}
03.513 : INFO :  Node:  root
03.513 : INFO :  addNode [33m1[39m root the root [33m6[39m
03.513 : TRACE :  Stop NL
03.513 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-6 real root in wrong place
03.511 : INFO :  Node:  root
03.511 : TRACE :  Stop NL
03.511 : INFO :  Node:  fakeRoot
03.511 : TRACE :  Stop NL
03.511 : INFO :  Node:  realRootWrongPlace

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-13 should be possible to set an icon for the node
03.515 : TRACE :  Long description: The root
03.515 : TRACE :  node end ... ]
03.515 : TRACE :  node found .. root
03.515 : DEBUG :  In get type [ ]
03.515 : INFO :  Node:  root
03.515 : INFO :  addNode [33m4[39m root The root [33m2[39m
03.515 : TRACE :  Stop NL
03.515 : TRACE :  Begin icon
03.515 : TRACE :  end icon
03.515 : TRACE :  Icon:  bomb
03.515 : TRACE :  Stop NL
03.515 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks 2
Found block
.

Found block
.

Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID bBlock
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: [32m'[]'[39m, label: [32m'ABlock'[39m }
Rule: nodeStatement (node)  { id: [32m'aBlock'[39m, label: [32m'ABlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: [32m'[]'[39m, label: [32m'BBlock'[39m }
Rule: nodeStatement (node)  { id: [32m'bBlock'[39m, label: [32m'BBlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'bBlock'[39m,
  label: [32m'BBlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'aBlock'[39m,
  label: [32m'ABlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Lex: EOF
Rule: blockStatement :  block [
  {
    id: [32m'aBlock'[39m,
    label: [32m'ABlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'bBlock'[39m,
    label: [32m'BBlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-5300utt2lld-1'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'aBlock'[39m,
      label: [32m'ABlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'bBlock'[39m,
      label: [32m'BBlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'id-5300utt2lld-1'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-7 should handle an id and type for a node definition
03.516 : TRACE :  Long description: The root
03.516 : TRACE :  node end ... ]
03.516 : TRACE :  node found .. root
03.516 : DEBUG :  In get type [ ]
03.516 : INFO :  Node:  root
03.516 : TRACE :  Stop NL
03.516 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-14 should be possible to set classes for the node
03.518 : TRACE :  Long description: The root
03.518 : TRACE :  node end ... ]
03.518 : TRACE :  node found .. root
03.518 : DEBUG :  In get type [ ]
03.518 : INFO :  Node:  root
03.518 : INFO :  addNode [33m4[39m root The root [33m2[39m
03.518 : TRACE :  Stop NL
03.518 : TRACE :  Stop NL
03.518 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks of compound blocks
Found block
.

Found block
.

Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
.

Found block
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: [32m'[]'[39m, label: [32m'ABlock'[39m }
Rule: nodeStatement (node)  { id: [32m'aBlock'[39m, label: [32m'ABlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
.

Lex: NODE_ID bBlock
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: [32m'[]'[39m, label: [32m'BBlock'[39m }
Rule: nodeStatement (node)  { id: [32m'bBlock'[39m, label: [32m'BBlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'bBlock'[39m,
  label: [32m'BBlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: blockStatement :  block [
  {
    id: [32m'bBlock'[39m,
    label: [32m'BBlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-mbjimsw9s9-2'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'bBlock'[39m,
      label: [32m'BBlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'aBlock'[39m,
  label: [32m'ABlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Lex: EOF
Rule: blockStatement :  block [
  {
    id: [32m'aBlock'[39m,
    label: [32m'ABlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-mbjimsw9s9-2'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m ]
  }
] end

Rule: statement:  {
  id: [32m'id-hy9v8bpyt55-3'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'aBlock'[39m,
      label: [32m'ABlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'id-mbjimsw9s9-2'[39m,
      type: [32m'composite'[39m,
      label: [32m''[39m,
      children: [36m[Array][39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'id-hy9v8bpyt55-3'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks with title
Found block
.

Found id-block
Lex: NODE_ID compoundBlock
Lexa: [
Lex: Starting string
LEX: STR end: Compound block
LEX: POPPING STR: "
Lex: ]
.

COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ Compound block ]
Rule: node (NODE_ID nodeShapeNLabel separator):  compoundBlock { typeStr: [32m'[]'[39m, label: [32m'Compound block'[39m }
Rule: nodeStatement (node)  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: NODE_ID block2
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m3[39m, last_line: [33m3[39m, first_column: [33m12[39m, last_column: [33m21[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Lex: EOF
Rule: id-block statement :  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Rule: statement:  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  type: [32m'composite'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m1[39m },
    {
      id: [32m'block2'[39m,
      label: [32m'Block 2'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'compoundBlock'[39m,
    label: [32m'Compound block'[39m,
    type: [32m'composite'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-8 should handle an id and type for a node definition
03.519 : INFO :  Node:  root
03.519 : TRACE :  Stop NL
03.519 : TRACE :  Long description: child1
03.519 : TRACE :  node end )
03.519 : TRACE :  node found .. theId
03.519 : DEBUG :  In get type ( )
03.519 : INFO :  Node:  theId
03.519 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-9 should handle an id and type for a node definition
03.522 : TRACE :  Node:  root
03.522 : TRACE :  Stop NL
03.522 : TRACE :  Long description: child1
03.522 : TRACE :  node end )
03.522 : TRACE :  node found .. theId
03.522 : DEBUG :  In get type ( )
03.522 : INFO :  Node:  theId
03.522 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-15 should be possible to set both classes and icon for the node
03.520 : TRACE :  Long description: The root
03.520 : TRACE :  node end ... ]
03.520 : TRACE :  node found .. root
03.520 : DEBUG :  In get type [ ]
03.520 : INFO :  Node:  root
03.520 : INFO :  addNode [33m4[39m root The root [33m2[39m
03.520 : TRACE :  Stop NL
03.520 : TRACE :  Stop NL
03.520 : TRACE :  Begin icon
03.520 : TRACE :  end icon
03.520 : TRACE :  Icon:  bomb
03.520 : TRACE :  Stop NL
03.520 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-16 should be possible to set both classes and icon for the node
03.523 : TRACE :  Long description: The root
03.523 : TRACE :  node end ... ]
03.523 : TRACE :  node found .. root
03.523 : DEBUG :  In get type [ ]
03.523 : INFO :  Node:  root
03.523 : INFO :  addNode [33m4[39m root The root [33m2[39m
03.523 : TRACE :  Stop NL
03.523 : TRACE :  Begin icon
03.523 : TRACE :  end icon
03.523 : TRACE :  Icon:  bomb
03.523 : TRACE :  Stop NL
03.523 : TRACE :  Stop NL
03.523 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks mixed with compound blocks
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.


Found block
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block2
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m6[39m, last_line: [33m6[39m, first_column: [33m12[39m, last_column: [33m21[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block3
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 3
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Block 3 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block3 { typeStr: [32m'[]'[39m, label: [32m'Block 3'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block3'[39m,
  label: [32m'Block 3'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block3'[39m,
  label: [32m'Block 3'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Lex: EOF
Rule: blockStatement :  block [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block3'[39m,
    label: [32m'Block 3'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-jtqrddfb8p-5'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m2[39m },
    {
      id: [32m'block2'[39m,
      label: [32m'Block 2'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'block3'[39m,
      label: [32m'Block 3'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-jtqrddfb8p-5'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-17 should be possible to use node syntax in the descriptions
03.527 : TRACE :  Starting NSTR
03.527 : TRACE :  description: String containing []
03.527 : TRACE :  node end ... ]
03.527 : TRACE :  node found .. root
03.527 : DEBUG :  In get type [ ]
03.527 : INFO :  Node:  root
03.527 : INFO :  addNode [33m4[39m root String containing [] [33m2[39m
03.527 : TRACE :  Stop NL
03.527 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-13 should be possible to set an icon for the node
03.526 : TRACE :  Long description: The root
03.526 : TRACE :  node end ... ]
03.526 : TRACE :  node found .. root
03.526 : DEBUG :  In get type [ ]
03.526 : INFO :  Node:  root
03.526 : TRACE :  Stop NL
03.526 : TRACE :  Begin icon
03.526 : TRACE :  end icon
03.526 : TRACE :  Icon:  bomb
03.526 : TRACE :  Stop NL
03.526 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-18 should be possible to use node syntax in the descriptions in children
03.530 : TRACE :  Starting NSTR
03.530 : TRACE :  description: String containing []
03.530 : TRACE :  node end ... ]
03.530 : TRACE :  node found .. root
03.530 : DEBUG :  In get type [ ]
03.530 : INFO :  Node:  root
03.530 : INFO :  addNode [33m4[39m root String containing [] [33m2[39m
03.530 : TRACE :  Stop NL
03.530 : TRACE :  Starting NSTR
03.530 : TRACE :  description: String containing ()
03.530 : TRACE :  node end ... ]
03.530 : TRACE :  node found .. child1
03.530 : DEBUG :  In get type [ ]
03.530 : INFO :  Node:  child1
03.530 : INFO :  addNode [33m6[39m child1 String containing () [33m2[39m
03.530 : TRACE :  Stop NL
03.530 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-14 should be possible to set classes for the node
03.530 : TRACE :  Long description: The root
03.530 : TRACE :  node end ... ]
03.530 : TRACE :  node found .. root
03.530 : DEBUG :  In get type [ ]
03.530 : INFO :  Node:  root
03.530 : TRACE :  Stop NL
03.530 : TRACE :  Stop NL
03.530 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > Arrow blocks
Found block
.

COLUMNS (LEX) 3
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID blockArrow
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (right): dir: right
Lex (ARROW_DIR end): ]>
Rule: dirList:  right
Lex: NODE_ID block2
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ [32m'right'[39m ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: [32m'<[]>'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  directions: [ [32m'right'[39m ]
}
Rule: nodeStatement (node)  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  typeStr: [32m'<[]>'[39m,
  directions: [ [32m'right'[39m ]
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  type: [32m'block_arrow'[39m,
  directions: [ [32m'right'[39m ],
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'blockArrow'[39m,
    label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
    type: [32m'block_arrow'[39m,
    directions: [ [32m'right'[39m ],
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > Arrow blocks with multiple points
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID A
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  1
.

Lex: NODE_ID blockArrow
Rule: node (NODE_ID separator):  A
Rule: nodeStatement (node)  { id: [32m'A'[39m }
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (up): up
Lex (down): down
Lex (ARROW_DIR end): ]>
Rule: dirList:  down
Rule: dirList:  up [ [32m'down'[39m ]
Found block
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ [32m'up'[39m, [32m'down'[39m ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: [32m'<[]>'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ]
}
Rule: nodeStatement (node)  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  typeStr: [32m'<[]>'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ]
}
.

COLUMNS (LEX) 3
.

Lex: NODE_ID B
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m6[39m, last_line: [33m6[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  3
.

Lex: NODE_ID C
Rule: node (NODE_ID separator):  B
Rule: nodeStatement (node)  { id: [32m'B'[39m }
.

Lex: NODE_ID D
Rule: node (NODE_ID separator):  C
Rule: nodeStatement (node)  { id: [32m'C'[39m }
.

Rule: node (NODE_ID separator):  D
Rule: nodeStatement (node)  { id: [32m'D'[39m }
Rule: statement:  {
  id: [32m'D'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'C'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Lex: EOF
Rule: blockStatement :  block [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'B'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'C'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'D'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end
Rule: statement:  {
  id: [32m'id-v0l459az44b-6'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m3[39m },
    {
      id: [32m'B'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'C'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'D'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  type: [32m'block_arrow'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ],
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'A'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'A'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'blockArrow'[39m,
    label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
    type: [32m'block_arrow'[39m,
    directions: [ [32m'up'[39m, [32m'down'[39m ],
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-v0l459az44b-6'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m, [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-19 should be possible to have a child after a class assignment
03.534 : TRACE :  Long description: Root
03.534 : TRACE :  node end )
03.534 : TRACE :  node found .. root
03.534 : DEBUG :  In get type ( )
03.534 : INFO :  Node:  root
03.534 : INFO :  addNode [33m2[39m root Root [33m1[39m
03.534 : TRACE :  Stop NL
03.534 : TRACE :  Long description: Child
03.534 : TRACE :  node end )
03.534 : TRACE :  node found .. Child
03.534 : DEBUG :  In get type ( )
03.534 : INFO :  Node:  Child
03.534 : INFO :  addNode [33m4[39m Child Child [33m1[39m
03.534 : TRACE :  Stop NL
03.534 : TRACE :  Stop NL
03.534 : TRACE :  Long description: a
03.534 : TRACE :  node end )
03.534 : TRACE :  node found .. a
03.534 : DEBUG :  In get type ( )
03.534 : INFO :  Node:  a
03.534 : INFO :  addNode [33m6[39m a a [33m1[39m
03.534 : TRACE :  Stop NL
03.534 : TRACE :  Long description: New Stuff
03.534 : TRACE :  node end ... ]
03.534 : TRACE :  node found .. b
03.534 : DEBUG :  In get type [ ]
03.534 : INFO :  Node:  b
03.534 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
03.534 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-15 should be possible to set both classes and icon for the node
03.534 : TRACE :  Long description: The root
03.534 : TRACE :  node end ... ]
03.534 : TRACE :  node found .. root
03.534 : DEBUG :  In get type [ ]
03.534 : INFO :  Node:  root
03.534 : TRACE :  Stop NL
03.534 : TRACE :  Stop NL
03.534 : TRACE :  Begin icon
03.534 : TRACE :  end icon
03.534 : TRACE :  Icon:  bomb
03.534 : TRACE :  Stop NL
03.534 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-20 should be possible to have meaningless empty rows in a mindmap abc124
03.539 : TRACE :  Long description: Root
03.539 : TRACE :  node end )
03.539 : TRACE :  node found .. root
03.539 : DEBUG :  In get type ( )
03.539 : INFO :  Node:  root
03.539 : INFO :  addNode [33m2[39m root Root [33m1[39m
03.539 : TRACE :  Stop NL
03.539 : TRACE :  Long description: Child
03.539 : TRACE :  node end )
03.539 : TRACE :  node found .. Child
03.539 : DEBUG :  In get type ( )
03.539 : INFO :  Node:  Child
03.539 : INFO :  addNode [33m4[39m Child Child [33m1[39m
03.539 : TRACE :  Stop NL
03.539 : TRACE :  Long description: a
03.539 : TRACE :  node end )
03.539 : TRACE :  SPACELINE
03.539 : TRACE :  node found .. a
03.539 : DEBUG :  In get type ( )
03.539 : INFO :  Node:  a
03.539 : INFO :  addNode [33m6[39m a a [33m1[39m
03.539 : TRACE :  Long description: New Stuff
03.539 : TRACE :  node end ... ]
03.539 : TRACE :  node found .. b
03.539 : DEBUG :  In get type [ ]
03.539 : INFO :  Node:  b
03.539 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
03.539 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-16 should be possible to set both classes and icon for the node
03.539 : TRACE :  Long description: The root
03.539 : TRACE :  node end ... ]
03.539 : TRACE :  node found .. root
03.539 : DEBUG :  In get type [ ]
03.539 : INFO :  Node:  root
03.539 : TRACE :  Stop NL
03.539 : TRACE :  Begin icon
03.539 : TRACE :  end icon
03.539 : TRACE :  Icon:  bomb
03.539 : TRACE :  Stop NL
03.539 : TRACE :  Stop NL
03.539 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks with different widths
Found block
.

COLUMNS (LEX) 3
.

Lex: NODE_ID one
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: One Slot
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID two
Rule: nodeShapeNLabel:  [ One Slot ]
Rule: node (NODE_ID nodeShapeNLabel separator):  one { typeStr: [32m'[]'[39m, label: [32m'One Slot'[39m }
Rule: nodeStatement (node)  { id: [32m'one'[39m, label: [32m'One Slot'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lexa: [
Lex: Starting string
LEX: STR end: Two slots
LEX: POPPING STR: "
Lex: ]
Lex: COLON :2
Rule: nodeShapeNLabel:  [ Two slots ]
Rule: node (NODE_ID nodeShapeNLabel separator):  two { typeStr: [32m'[]'[39m, label: [32m'Two slots'[39m }
.

Lex: EOF
Rule: nodeStatement (abc88 node size)  { id: [32m'two'[39m, label: [32m'Two slots'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m } 2
Rule: statement:  {
  id: [32m'two'[39m,
  label: [32m'Two slots'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'one'[39m,
  label: [32m'One Slot'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'one'[39m,
    label: [32m'One Slot'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'two'[39m,
    label: [32m'Two slots'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > empty blocks
Found block
.

COLUMNS (LEX) 3
.

COLUMNS (LEX) 1
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
.

Lex: NODE_ID middle
Lexa: [
Lex: Starting string
LEX: STR end: In the middle
LEX: POPPING STR: "
Lex: ]
.

COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ In the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  middle { typeStr: [32m'[]'[39m, label: [32m'In the middle'[39m }
Rule: nodeStatement (node)  {
  id: [32m'middle'[39m,
  label: [32m'In the middle'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: EOF
Rule: statement:  {
  id: [32m'id-nl564is7cp-8'[39m,
  type: [32m'space'[39m,
  label: [32m''[39m,
  width: [33m1[39m,
  children: []
}
Rule: statement #2:  {
  id: [32m'middle'[39m,
  label: [32m'In the middle'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id-xz9n7mkl03q-7'[39m,
  type: [32m'space'[39m,
  label: [32m''[39m,
  width: [33m1[39m,
  children: []
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'id-xz9n7mkl03q-7'[39m,
    type: [32m'space'[39m,
    label: [32m''[39m,
    width: [33m1[39m,
    children: []
  },
  {
    id: [32m'middle'[39m,
    label: [32m'In the middle'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-nl564is7cp-8'[39m,
    type: [32m'space'[39m,
    label: [32m''[39m,
    width: [33m1[39m,
    children: []
  }
]

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-17 should be possible to use node syntax in the descriptions
03.545 : TRACE :  Starting NSTR
03.545 : TRACE :  description: String containing []
03.545 : TRACE :  node end ... ]
03.545 : TRACE :  node found .. root
03.545 : DEBUG :  In get type [ ]
03.545 : INFO :  Node:  root
03.545 : TRACE :  Stop NL
03.545 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-21 should be possible to have comments in a mindmap
03.544 : TRACE :  Long description: Root
03.544 : TRACE :  node end )
03.544 : TRACE :  node found .. root
03.544 : DEBUG :  In get type ( )
03.544 : INFO :  Node:  root
03.544 : INFO :  addNode [33m2[39m root Root [33m1[39m
03.544 : TRACE :  Stop NL
03.544 : TRACE :  Long description: Child
03.544 : TRACE :  node end )
03.544 : TRACE :  node found .. Child
03.544 : DEBUG :  In get type ( )
03.544 : INFO :  Node:  Child
03.544 : INFO :  addNode [33m4[39m Child Child [33m1[39m
03.544 : TRACE :  Stop NL
03.544 : TRACE :  Long description: a
03.544 : TRACE :  node end )
03.544 : TRACE :  Found comment

      %% This is a comment
03.544 : TRACE :  node found .. a
03.544 : DEBUG :  In get type ( )
03.544 : INFO :  Node:  a
03.544 : INFO :  addNode [33m6[39m a a [33m1[39m
03.544 : TRACE :  Stop NL2
03.544 : TRACE :  Long description: New Stuff
03.544 : TRACE :  node end ... ]
03.544 : TRACE :  node found .. b
03.544 : DEBUG :  In get type [ ]
03.544 : INFO :  Node:  b
03.544 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
03.544 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-18 should be possible to use node syntax in the descriptions in children
03.548 : TRACE :  Starting NSTR
03.548 : TRACE :  description: String containing []
03.548 : TRACE :  node end ... ]
03.548 : TRACE :  node found .. root
03.548 : DEBUG :  In get type [ ]
03.548 : INFO :  Node:  root
03.548 : TRACE :  Stop NL
03.548 : TRACE :  Starting NSTR
03.548 : TRACE :  description: String containing ()
03.548 : TRACE :  node end ... ]
03.548 : TRACE :  node found .. child1
03.548 : DEBUG :  In get type [ ]
03.548 : INFO :  Node:  child1
03.548 : TRACE :  Stop NL
03.548 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > classDef statements applied to a block
Found block
.

.


Lex: NODE_ID mc
Lexa: [
Lex: Starting string
LEX: STR end: Memcache
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Memcache ]
Rule: node (NODE_ID nodeShapeNLabel separator):  mc { typeStr: [32m'[]'[39m, label: [32m'Memcache'[39m }
Rule: nodeStatement (node)  { id: [32m'mc'[39m, label: [32m'Memcache'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
.

Lex: EOF
Rule: statement:  { type: [32m'applyClass'[39m, id: [32m'mc'[39m, styleClass: [32m'black'[39m }
Rule: statement #2:  {
  id: [32m'mc'[39m,
  label: [32m'Memcache'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'classDef'[39m, id: [32m'black'[39m, css: [32m'color:#ffffff, fill:#000000;'[39m }
Rule: hierarchy:  [
  {
    type: [32m'classDef'[39m,
    id: [32m'black'[39m,
    css: [32m'color:#ffffff, fill:#000000;'[39m
  },
  {
    id: [32m'mc'[39m,
    label: [32m'Memcache'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  { type: [32m'applyClass'[39m, id: [32m'mc'[39m, styleClass: [32m'black'[39m }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-22 should be possible to have comments at the end of a line
03.550 : TRACE :  Long description: Root
03.550 : TRACE :  node end )
03.550 : TRACE :  node found .. root
03.550 : DEBUG :  In get type ( )
03.550 : INFO :  Node:  root
03.550 : INFO :  addNode [33m2[39m root Root [33m1[39m
03.550 : TRACE :  Stop NL
03.550 : TRACE :  Long description: Child
03.550 : TRACE :  node end )
03.550 : TRACE :  node found .. Child
03.550 : DEBUG :  In get type ( )
03.550 : INFO :  Node:  Child
03.550 : INFO :  addNode [33m4[39m Child Child [33m1[39m
03.550 : TRACE :  Stop NL
03.550 : TRACE :  Long description: a
03.550 : TRACE :  node end )
03.550 : TRACE :  Found comment  %% This is a comment
03.550 : TRACE :  node found .. a
03.550 : DEBUG :  In get type ( )
03.550 : INFO :  Node:  a
03.550 : INFO :  addNode [33m6[39m a a [33m1[39m
03.550 : TRACE :  Stop NL2
03.550 : TRACE :  Long description: New Stuff
03.550 : TRACE :  node end ... ]
03.550 : TRACE :  node found .. b
03.550 : DEBUG :  In get type [ ]
03.550 : INFO :  Node:  b
03.550 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
03.550 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > style statements applied to a block
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID B
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m0[39m, last_column: [33m9[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: A wide one in the middle
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ A wide one in the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  B { typeStr: [32m'[]'[39m, label: [32m'A wide one in the middle'[39m }
Rule: nodeStatement (node)  {
  id: [32m'B'[39m,
  label: [32m'A wide one in the middle'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: EOF
Rule: statement:  {
  type: [32m'applyStyles'[39m,
  id: [32m'B'[39m,
  stylesStr: [32m'fill:#f9F,stroke:#333,stroke-width:4px'[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [32m'A wide one in the middle'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'B'[39m,
    label: [32m'A wide one in the middle'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'applyStyles'[39m,
    id: [32m'B'[39m,
    stylesStr: [32m'fill:#f9F,stroke:#333,stroke-width:4px'[39m
  }
]

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-19 should be possible to have a child after a class assignment
03.551 : TRACE :  Long description: Root
03.551 : TRACE :  node end )
03.551 : TRACE :  node found .. root
03.551 : DEBUG :  In get type ( )
03.551 : INFO :  Node:  root
03.551 : TRACE :  Stop NL
03.551 : TRACE :  Long description: Child
03.551 : TRACE :  node end )
03.551 : TRACE :  node found .. Child
03.551 : DEBUG :  In get type ( )
03.551 : INFO :  Node:  Child
03.551 : TRACE :  Stop NL
03.551 : TRACE :  Stop NL
03.551 : TRACE :  Long description: a
03.551 : TRACE :  node end )
03.551 : TRACE :  node found .. a
03.551 : DEBUG :  In get type ( )
03.551 : INFO :  Node:  a
03.551 : TRACE :  Stop NL
03.551 : TRACE :  Long description: New Stuff
03.551 : TRACE :  node end ... ]
03.551 : TRACE :  node found .. b
03.551 : DEBUG :  In get type [ ]
03.551 : INFO :  Node:  b
03.551 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-23 Rows with only spaces should not interfere
03.559 : TRACE :  Node:  root
03.559 : INFO :  addNode [33m0[39m root root [33m0[39m
03.559 : TRACE :  Stop NL
03.559 : TRACE :  SPACELINE
03.559 : INFO :  Node:  A
03.559 : INFO :  addNode [33m1[39m A A [33m0[39m
03.559 : INFO :  Node:  B
03.559 : INFO :  addNode [33m1[39m B B [33m0[39m
03.559 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > should log a warning when block width exceeds column width
Found block-beta
.

COLUMNS (LEX) 1
.

Lex: NODE_ID A
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m2[39m, last_column: [33m11[39m }
}
COLUMNS:  1
Lex: COLON :1
Rule: node (NODE_ID separator):  A
.

Lex: NODE_ID B
Rule: nodeStatement (abc88 node size)  { id: [32m'A'[39m } 1
Lex: COLON :2
Rule: node (NODE_ID separator):  B
.

Lex: NODE_ID C
Rule: nodeStatement (abc88 node size)  { id: [32m'B'[39m } 2
Lex: COLON :3
Rule: node (NODE_ID separator):  C
.

Lex: NODE_ID D
Rule: nodeStatement (abc88 node size)  { id: [32m'C'[39m } 3
Lex: COLON :4
Rule: node (NODE_ID separator):  D
.

Lex: NODE_ID E
Rule: nodeStatement (abc88 node size)  { id: [32m'D'[39m } 4
Lex: COLON :3
Rule: node (NODE_ID separator):  E
.

Lex: NODE_ID F
Rule: nodeStatement (abc88 node size)  { id: [32m'E'[39m } 3
Lex: COLON :2
Rule: node (NODE_ID separator):  F
.

Lex: NODE_ID G
Rule: nodeStatement (abc88 node size)  { id: [32m'F'[39m } 2
Lex: COLON :1
Rule: node (NODE_ID separator):  G
Lex: EOF
Rule: nodeStatement (abc88 node size)  { id: [32m'G'[39m } 1
Rule: statement:  {
  id: [32m'G'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'F'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'E'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m3[39m
}
Rule: statement #2:  {
  id: [32m'D'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m4[39m
}
Rule: statement #2:  {
  id: [32m'C'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m3[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'A'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'A'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'B'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  },
  {
    id: [32m'C'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m3[39m
  },
  {
    id: [32m'D'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m4[39m
  },
  {
    id: [32m'E'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m3[39m
  },
  {
    id: [32m'F'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  },
  {
    id: [32m'G'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-24 Handle rows above the mindmap declarations
03.562 : TRACE :  SPACELINE
03.562 : TRACE :  Node:  root
03.562 : INFO :  addNode [33m0[39m root root [33m0[39m
03.562 : TRACE :  Stop NL
03.562 : TRACE :  SPACELINE
03.562 : INFO :  Node:  A
03.562 : INFO :  addNode [33m1[39m A A [33m0[39m
03.562 : INFO :  Node:  B
03.562 : INFO :  addNode [33m1[39m B B [33m0[39m
03.562 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-20 should be possible to have meaningless empty rows in a kanban abc124
03.561 : TRACE :  Long description: Root
03.561 : TRACE :  node end )
03.561 : TRACE :  node found .. root
03.561 : DEBUG :  In get type ( )
03.561 : INFO :  Node:  root
03.561 : TRACE :  Stop NL
03.561 : TRACE :  Long description: Child
03.561 : TRACE :  node end )
03.561 : TRACE :  node found .. Child
03.561 : DEBUG :  In get type ( )
03.561 : INFO :  Node:  Child
03.561 : TRACE :  Stop NL
03.561 : TRACE :  Long description: a
03.561 : TRACE :  node end )
03.561 : TRACE :  SPACELINE
03.561 : TRACE :  node found .. a
03.561 : DEBUG :  In get type ( )
03.561 : INFO :  Node:  a
03.561 : TRACE :  Long description: New Stuff
03.561 : TRACE :  node end ... ]
03.561 : TRACE :  node found .. b
03.561 : DEBUG :  In get type [ ]
03.561 : INFO :  Node:  b
03.561 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a __proto__ property
Found block
.

Lex: NODE_ID __proto__
Lex: EOF
Rule: node (NODE_ID separator):  __proto__
Rule: nodeStatement (node)  { id: [32m'__proto__'[39m }
Rule: statement:  {
  id: [32m'__proto__'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'__proto__'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Found block
.

Lex: NODE_ID A;
.
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: [32m'A;'[39m }
Lex: EOF
Rule: statement:  {
  type: [32m'classDef'[39m,
  id: [32m'__proto__'[39m,
  css: [32m'color:#ffffff,fill:#000000; class A __proto__'[39m
}
Rule: statement #2:  {
  id: [32m'A;'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'A;'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'classDef'[39m,
    id: [32m'__proto__'[39m,
    css: [32m'color:#ffffff,fill:#000000; class A __proto__'[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a constructor property
Found block
.

Lex: NODE_ID constructor
Lex: EOF
Rule: node (NODE_ID separator):  constructor
Rule: nodeStatement (node)  { id: [32m'constructor'[39m }
Rule: statement:  {
  id: [32m'constructor'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'constructor'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Found block
.

Lex: NODE_ID A;
.
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: [32m'A;'[39m }
Lex: EOF
Rule: statement:  {
  type: [32m'classDef'[39m,
  id: [32m'constructor'[39m,
  css: [32m'color:#ffffff,fill:#000000; class A constructor'[39m
}
Rule: statement #2:  {
  id: [32m'A;'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'A;'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'classDef'[39m,
    id: [32m'constructor'[39m,
    css: [32m'color:#ffffff,fill:#000000; class A constructor'[39m
  }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-25 Handle rows above the mindmap declarations, no space
03.565 : TRACE :  SPACELINE
03.565 : TRACE :  Node:  root
03.565 : INFO :  addNode [33m0[39m root root [33m0[39m
03.565 : TRACE :  Stop NL
03.565 : TRACE :  SPACELINE
03.565 : INFO :  Node:  A
03.565 : INFO :  addNode [33m1[39m A A [33m0[39m
03.565 : INFO :  Node:  B
03.565 : INFO :  addNode [33m1[39m B B [33m0[39m
03.565 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-21 should be possible to have comments in a kanban
03.565 : TRACE :  Long description: Root
03.565 : TRACE :  node end )
03.565 : TRACE :  node found .. root
03.565 : DEBUG :  In get type ( )
03.565 : INFO :  Node:  root
03.565 : TRACE :  Stop NL
03.565 : TRACE :  Long description: Child
03.565 : TRACE :  node end )
03.565 : TRACE :  node found .. Child
03.565 : DEBUG :  In get type ( )
03.565 : INFO :  Node:  Child
03.565 : TRACE :  Stop NL
03.565 : TRACE :  Long description: a
03.565 : TRACE :  node end )
03.565 : TRACE :  Found comment

      %% This is a comment
03.565 : TRACE :  node found .. a
03.565 : DEBUG :  In get type ( )
03.565 : INFO :  Node:  a
03.565 : TRACE :  Stop NL2
03.565 : TRACE :  Long description: New Stuff
03.565 : TRACE :  node end ... ]
03.565 : TRACE :  node found .. b
03.565 : DEBUG :  In get type [ ]
03.565 : INFO :  Node:  b
03.565 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-22 should be possible to have comments at the end of a line
03.570 : TRACE :  Long description: Root
03.570 : TRACE :  node end )
03.570 : TRACE :  node found .. root
03.570 : DEBUG :  In get type ( )
03.570 : INFO :  Node:  root
03.570 : TRACE :  Stop NL
03.570 : TRACE :  Long description: Child
03.570 : TRACE :  node end )
03.570 : TRACE :  node found .. Child
03.570 : DEBUG :  In get type ( )
03.570 : INFO :  Node:  Child
03.570 : TRACE :  Stop NL
03.570 : TRACE :  Long description: a
03.570 : TRACE :  node end )
03.570 : TRACE :  Found comment  %% This is a comment
03.570 : TRACE :  node found .. a
03.570 : DEBUG :  In get type ( )
03.570 : INFO :  Node:  a
03.570 : TRACE :  Stop NL2
03.570 : TRACE :  Long description: New Stuff
03.570 : TRACE :  node end ... ]
03.570 : TRACE :  node found .. b
03.570 : DEBUG :  In get type [ ]
03.570 : INFO :  Node:  b
03.570 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-23 Rows with only spaces should not interfere
03.574 : TRACE :  Node:  root
03.574 : TRACE :  Stop NL
03.574 : TRACE :  SPACELINE
03.574 : INFO :  Node:  A
03.574 : INFO :  Node:  B
03.574 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-24 Handle rows above the kanban declarations
03.578 : TRACE :  SPACELINE
03.578 : TRACE :  Node:  root
03.578 : TRACE :  Stop NL
03.578 : TRACE :  SPACELINE
03.578 : INFO :  Node:  A
03.578 : INFO :  Node:  B
03.578 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-25 Handle rows above the kanban declarations, no space
03.581 : TRACE :  SPACELINE
03.581 : TRACE :  Node:  root
03.581 : TRACE :  Stop NL
03.581 : TRACE :  SPACELINE
03.581 : INFO :  Node:  A
03.581 : INFO :  Node:  B
03.581 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-30 should be possible to set the priority
03.584 : INFO :  Node:  root
03.584 : TRACE :  Stop NL
03.584 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-31 should be possible to set the assignment
03.590 : INFO :  Node:  root
03.590 : TRACE :  Stop NL
03.590 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-32 should be possible to set the icon
03.592 : INFO :  Node:  root
03.592 : TRACE :  Stop NL
03.592 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-33 should be possible to set the icon
03.594 : INFO :  Node:  root
03.594 : TRACE :  Stop NL
03.594 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-34 should be possible to set the metadata using multiple lines
03.596 : INFO :  Node:  root
03.596 : TRACE :  Stop NL
03.596 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-35 should be possible to set the metadata using one line
03.599 : INFO :  Node:  root
03.599 : TRACE :  Stop NL
03.599 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-36 should be possible to set the label using the new syntax
03.601 : INFO :  Node:  root
03.601 : TRACE :  Stop NL
03.601 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-37 should be possible to set the external id
03.603 : INFO :  Node:  root
03.603 : TRACE :  Stop NL
03.603 : TRACE :  Stop EOF

 âœ“ packages/mermaid/src/diagrams/kanban/kanban.spec.ts (30 tests) 134ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraphRenderer.ts (30 tests) 27ms
 âœ“ packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts (26 tests) 106ms
 âœ“ packages/mermaid/src/diagrams/class/classTypes.spec.ts (93 tests) 98ms
 âœ“ packages/mermaid/src/diagrams/block/parser/block.spec.ts (25 tests) 106ms
 âœ“ packages/mermaid/src/diagrams/requirement/parser/requirementDiagram.spec.js (43 tests) 52ms
 âœ“ packages/mermaid/src/rendering-util/handle-markdown-text.spec.ts (19 tests) 51ms
 âœ“ packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts (43 tests) 69ms
 âœ“ packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js (27 tests) 75ms
 âœ“ packages/mermaid/src/utils.spec.ts (53 tests) 137ms
 âœ“ packages/parser/tests/treemap.test.ts (17 tests) 58ms
 âœ“ packages/parser/tests/radar.test.ts (80 tests) 119ms
 âœ“ packages/mermaid/src/diagrams/er/parser/erDiagram.spec.js (611 tests | 1 skipped) 407ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraph.spec.ts (69 tests | 4 skipped) 441ms
 âœ“ packages/mermaid/src/accessibility.spec.ts (20 tests) 240ms
 âœ“ packages/mermaid/src/utils/lineWithOffset.ts (2 tests) 8ms
 âœ“ packages/mermaid/src/diagrams/class/classDiagram.spec.ts (368 tests | 1 skipped) 1247ms
 âœ“ packages/parser/tests/gitGraph.test.ts (27 tests) 44ms
 âœ“ packages/mermaid/src/rendering-util/splitText.spec.ts (35 tests) 54ms
 âœ“ packages/mermaid/src/rendering-util/rendering-elements/nodes.spec.ts (39 tests) 14ms
 âœ“ packages/mermaid/src/diagrams/sequence/sequenceDiagram.spec.js (104 tests) 1136ms
 â¯ packages/mermaid/scripts/docs.spec.ts (0 test)
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/subgraph.spec.js (22 tests | 1 skipped) 107ms
 âœ“ packages/mermaid/src/diagrams/state/stateDiagram-v2.spec.js (31 tests) 205ms
 âœ“ packages/mermaid/src/diagrams/state/stateDiagram.spec.js (30 tests | 1 skipped) 239ms
 âœ“ packages/mermaid/src/diagrams/state/parser/state-style.spec.js (15 tests) 93ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-style.spec.js (24 tests) 86ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-arrows.spec.js (14 tests) 42ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-singlenode.spec.js (148 tests) 255ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-vertice-chaining.spec.js (7 tests) 36ms
 âœ“ packages/parser/tests/pie.test.ts (32 tests) 59ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-node-data.spec.js (31 tests | 1 skipped) 161ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-edges.spec.js (293 tests) 503ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-text.spec.js (342 tests) 552ms
 âœ“ packages/mermaid/src/diagrams/packet/packet.spec.ts (15 tests) 123ms
 âœ“ packages/mermaid/src/diagrams/sequence/svgDraw.spec.js (6 tests) 33ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow.spec.js (25 tests) 87ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraphParser.ts (6 tests) 14ms
 âœ“ packages/mermaid/src/diagrams/timeline/timeline.spec.js (8 tests) 36ms
 âœ“ packages/mermaid/src/diagrams/user-journey/parser/journey.spec.js (7 tests) 29ms
 âœ“ packages/mermaid/src/diagrams/pie/pie.spec.ts (16 tests | 2 skipped) 128ms
 âœ“ packages/mermaid/src/diagrams/radar/radar.spec.ts (19 tests) 436ms
 âœ“ packages/mermaid/src/diagram-api/frontmatter.spec.ts (12 tests) 37ms
 âœ“ packages/mermaid/src/diagrams/flowchart/flowChartShapes.spec.js (11 tests) 21ms
 âœ“ packages/mermaid/src/docs/.vitepress/theme/redirect.spec.ts (28 tests) 23ms
 âœ“ packages/mermaid/src/diagrams/common/common.spec.ts (20 tests) 64ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-lines.spec.js (12 tests) 45ms


Test Files  1 failed | 96 passed | 1 skipped (98)
      Tests  3544 passed | 10 skipped | 2 todo (3556)
   Start at  03:21:48
   Duration  14.28s (transform 25.71s, setup 0ms, collect 157.33s, tests 17.91s, environment 64.98s, prepare 15.20s)

 FAIL  Tests failed. Watching for file changes...
       press h to show help, press q to quit