	github.com/goplus/xgo/ast		coverage: 0.0% of statements
=== RUN   TestErrASTFile
=== RUN   TestErrASTFile/ASTFile:_doesn't_support_keeping_cgo_now_
2025/10/11 16:12:11 ASTFile: doesn't support keeping cgo now
=== RUN   TestErrASTFile/ASTFile:_doesn't_support_keeping_func_body_now_
2025/10/11 16:12:11 ASTFile: doesn't support keeping func body now
--- PASS: TestErrASTFile (0.00s)
    --- PASS: TestErrASTFile/ASTFile:_doesn't_support_keeping_cgo_now_ (0.00s)
    --- PASS: TestErrASTFile/ASTFile:_doesn't_support_keeping_func_body_now_ (0.00s)
=== RUN   TestErrDecl
=== RUN   TestErrDecl/gopDecl:_unknown_decl_-_<nil>_
2025/10/11 16:12:11 gopDecl: unknown decl - <nil>
=== RUN   TestErrDecl/gopGenDecl:_unknown_spec_-_ILLEGAL_
2025/10/11 16:12:11 gopGenDecl: unknown spec - ILLEGAL
--- PASS: TestErrDecl (0.00s)
    --- PASS: TestErrDecl/gopDecl:_unknown_decl_-_<nil>_ (0.00s)
    --- PASS: TestErrDecl/gopGenDecl:_unknown_spec_-_ILLEGAL_ (0.00s)
=== RUN   TestErrExpr
=== RUN   TestErrExpr/gopExpr:_unknown_expr_-_*ast.BadExpr_
2025/10/11 16:12:11 gopExpr: unknown expr - *ast.BadExpr
--- PASS: TestErrExpr (0.00s)
    --- PASS: TestErrExpr/gopExpr:_unknown_expr_-_*ast.BadExpr_ (0.00s)
=== RUN   TestBasic
--- PASS: TestBasic (0.00s)
=== RUN   TestMethod
--- PASS: TestMethod (0.00s)
=== RUN   TestCheckIdent
--- PASS: TestCheckIdent (0.00s)
=== RUN   TestIndexListExpr
--- PASS: TestIndexListExpr (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/ast/fromgo	0.008s	coverage: 100.0% of statements
	github.com/goplus/xgo/ast/fromgo/typeparams		coverage: 0.0% of statements
	github.com/goplus/xgo/ast/gopq		coverage: 0.0% of statements
	github.com/goplus/xgo/ast/goptest		coverage: 0.0% of statements
	github.com/goplus/xgo/ast/mod		coverage: 0.0% of statements
=== RUN   TestErrASTFile
=== RUN   TestErrASTFile/ASTFile:_doesn't_support_keeping_func_body_now_
2025/10/11 16:12:11 ASTFile: doesn't support keeping func body now
--- PASS: TestErrASTFile (0.00s)
    --- PASS: TestErrASTFile/ASTFile:_doesn't_support_keeping_func_body_now_ (0.00s)
=== RUN   TestErrDecl
=== RUN   TestErrDecl/goDecl:_unknown_decl_-_<nil>_
2025/10/11 16:12:11 goDecl: unknown decl - <nil>
=== RUN   TestErrDecl/goGenDecl:_unknown_spec_-_ILLEGAL_
2025/10/11 16:12:11 goGenDecl: unknown spec - ILLEGAL
--- PASS: TestErrDecl (0.00s)
    --- PASS: TestErrDecl/goDecl:_unknown_decl_-_<nil>_ (0.00s)
    --- PASS: TestErrDecl/goGenDecl:_unknown_spec_-_ILLEGAL_ (0.00s)
=== RUN   TestErrExpr
=== RUN   TestErrExpr/goExpr:_unknown_expr_-_*ast.BadExpr_
2025/10/11 16:12:11 goExpr: unknown expr - *ast.BadExpr
--- PASS: TestErrExpr (0.00s)
    --- PASS: TestErrExpr/goExpr:_unknown_expr_-_*ast.BadExpr_ (0.00s)
=== RUN   TestBasic
--- PASS: TestBasic (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/ast/togo	0.010s	coverage: 100.0% of statements
2025/10/11 16:12:17 SetDebug: import=true, match=true, instr=true
=== RUN   TestEmbeddedFieldCast
--- PASS: TestEmbeddedFieldCast (0.00s)
=== RUN   TestNonClosure
--- PASS: TestNonClosure (0.00s)
=== RUN   TestLoadExpr
--- PASS: TestLoadExpr (0.00s)
=== RUN   TestSpriteOf
--- PASS: TestSpriteOf (0.00s)
=== RUN   TestGetGameClass
--- PASS: TestGetGameClass (0.00s)
=== RUN   TestSimplifyPkgPath
--- PASS: TestSimplifyPkgPath (0.00s)
=== RUN   TestCompileLambdaExpr
--- PASS: TestCompileLambdaExpr (0.00s)
=== RUN   TestCompileLambda1
--- PASS: TestCompileLambda1 (0.00s)
=== RUN   TestCompileLambda2
--- PASS: TestCompileLambda2 (0.00s)
=== RUN   TestCompileExpr
--- PASS: TestCompileExpr (0.00s)
=== RUN   TestCompileStmt
2025/10/11 16:12:17 compileStmt failed: unknown - *ast.BadStmt
--- PASS: TestCompileStmt (0.00s)
=== RUN   TestTryGopExec
--- PASS: TestTryGopExec (0.26s)
=== RUN   TestCompileFuncAlias
--- PASS: TestCompileFuncAlias (0.00s)
=== RUN   TestErrStringLit
--- PASS: TestErrStringLit (0.00s)
=== RUN   TestErrPreloadFile
=== RUN   TestErrPreloadFile/unknown_decl
2025/10/11 16:12:17 TODO - cl.preloadFile: unknown decl - *ast.BadDecl
--- PASS: TestErrPreloadFile (0.00s)
    --- PASS: TestErrPreloadFile/unknown_decl (0.00s)
=== RUN   TestErrParseTypeEmbedName
--- PASS: TestErrParseTypeEmbedName (0.00s)
=== RUN   TestGmxCheckProjs
--- PASS: TestGmxCheckProjs (0.00s)
=== RUN   TestGmxCheckProjs2
--- PASS: TestGmxCheckProjs2 (0.00s)
=== RUN   TestNodeInterp
--- PASS: TestNodeInterp (0.00s)
=== RUN   TestMarkAutogen
2025/10/11 16:12:18 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:18 ==> NewOverloadFunc NewRange
2025/10/11 16:12:18 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:18 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:18 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:18 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:18 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:18 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:18 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:18 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:18 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:18 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:18 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:18 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:18 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:18 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:19 NewConstStart [_]
2025/10/11 16:12:19 Val true bool
2025/10/11 16:12:19 EndInit 1
--- PASS: TestMarkAutogen (1.67s)
=== RUN   TestClassNameAndExt
--- PASS: TestClassNameAndExt (0.00s)
=== RUN   TestFileClassType
--- PASS: TestFileClassType (0.00s)
=== RUN   TestErrMultiStarRecv
--- PASS: TestErrMultiStarRecv (0.00s)
=== RUN   TestErrAssign
--- PASS: TestErrAssign (0.00s)
=== RUN   TestErrPanicToRecv
--- PASS: TestErrPanicToRecv (0.00s)
=== RUN   TestCompileErrWrapExpr
--- PASS: TestCompileErrWrapExpr (0.00s)
=== RUN   TestToString
--- PASS: TestToString (0.00s)
=== RUN   TestGetTypeName
--- PASS: TestGetTypeName (0.00s)
=== RUN   TestHandleRecover
--- PASS: TestHandleRecover (0.00s)
=== RUN   TestCheckCommandWithoutArgs
--- PASS: TestCheckCommandWithoutArgs (0.00s)
=== RUN   TestClRangeStmt
2025/10/11 16:12:19 ForRange [_]
2025/10/11 16:12:19 SliceLit <nil> 0 false
2025/10/11 16:12:19 RangeAssignThen
2025/10/11 16:12:19 VBlock
2025/10/11 16:12:19 End // Vblock
2025/10/11 16:12:19 End // ForRange
2025/10/11 16:12:19 ForRange []
2025/10/11 16:12:19 VarRef _
2025/10/11 16:12:19 VarRef _
2025/10/11 16:12:19 SliceLit <nil> 0 false
2025/10/11 16:12:19 RangeAssignThen
2025/10/11 16:12:19 VBlock
2025/10/11 16:12:19 End // Vblock
2025/10/11 16:12:19 End // ForRange
--- PASS: TestClRangeStmt (0.00s)
=== RUN   TestGetStringConst
--- PASS: TestGetStringConst (0.00s)
=== RUN   TestSpxRef
--- PASS: TestSpxRef (0.00s)
=== RUN   TestGmxProject
2025/10/11 16:12:19 ==> InitClass main isProj: true
2025/10/11 16:12:19 Val Sched func()
2025/10/11 16:12:19 Call 0 0 // func()
2025/10/11 16:12:19 ==> MatchFuncCall func() args: 0 flags: 0
--- PASS: TestGmxProject (0.04s)
=== RUN   TestSpxLookup
--- PASS: TestSpxLookup (0.00s)
=== RUN   TestGetGoFile
--- PASS: TestGetGoFile (0.00s)
=== RUN   TestErrNewType
=== RUN   TestErrNewType/bar_redeclared_in_this_block__previous_declaration_at_<TODO>_
2025/10/11 16:12:19 bar redeclared in this block
	previous declaration at <TODO>
--- PASS: TestErrNewType (0.00s)
    --- PASS: TestErrNewType/bar_redeclared_in_this_block__previous_declaration_at_<TODO>_ (0.00s)
=== RUN   TestErrCompileBasicLit
=== RUN   TestErrCompileBasicLit/compileBasicLit:_invalid_syntax_
2025/10/11 16:12:19 compileBasicLit: invalid syntax
--- PASS: TestErrCompileBasicLit (0.00s)
    --- PASS: TestErrCompileBasicLit/compileBasicLit:_invalid_syntax_ (0.00s)
=== RUN   TestClassFileEnd
--- PASS: TestClassFileEnd (0.00s)
=== RUN   TestSpxError
2025/10/11 16:12:19 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:19 ==> NewOverloadFunc NewRange
2025/10/11 16:12:20 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:20 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:20 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:20 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:20 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:20 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:20 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:20 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:20 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:20 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:20 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:20 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:20 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:20 ==> Import github.com/goplus/xgo/cl/internal/spx
2025/10/11 16:12:20 ==> NewTemplateRecvMethod MyGame Main
2025/10/11 16:12:20 ==> NewTemplateRecvMethod MyGame Run
2025/10/11 16:12:20 ==> NewTemplateRecvMethod Sprite OnKey2
2025/10/11 16:12:20 ==> NewOverloadFunc Gopt_Sprite_Clone
2025/10/11 16:12:20 ==> NewTemplateRecvMethod Sprite Clone
2025/10/11 16:12:20 ==> NewOverloadFunc Gopt_Sprite_OnKey
2025/10/11 16:12:20 ==> NewTemplateRecvMethod Sprite OnKey
2025/10/11 16:12:20 ==> NewOverloadMethod MyGame Broadcast
2025/10/11 16:12:20 ==> NewOverloadFunc Rand
2025/10/11 16:12:20 ==> Import github.com/goplus/xgo/cl/internal/spx/pkg
2025/10/11 16:12:20 ==> NewOverloadMethod Vector Add
2025/10/11 16:12:20 ==> InitClass Game isProj: true
2025/10/11 16:12:20 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:20 ==> InitClass Kai isProj: false
2025/10/11 16:12:20 ==> Preload type Game
2025/10/11 16:12:20 ==> Preload method Game.MainEntry
2025/10/11 16:12:20 ==> Preload type Kai
2025/10/11 16:12:20 ==> Preload method Kai.Main
2025/10/11 16:12:20 ==> Load > NewType Game
2025/10/11 16:12:20 NewType Game
2025/10/11 16:12:20 ==> Load > NewType Kai
2025/10/11 16:12:20 NewType Kai
2025/10/11 16:12:20 ==> Load > InitType Game
2025/10/11 16:12:20 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:20 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/10/11 16:12:20 ==> Load method *Game.MainEntry
2025/10/11 16:12:20 ==> Load > InitType Kai
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/10/11 16:12:20 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:20 ==> Load method *Kai.Main
2025/10/11 16:12:20 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Game) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Call 1 0 // func(game any)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *Game, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Kai) func()
2025/10/11 16:12:20 SetComments 0
//line Kai.tspx:2:1
2025/10/11 16:12:20 Val this *Kai
2025/10/11 16:12:20 Member println 1 // *Kai
2025/10/11 16:12:20 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 Val &{0 STRING "hi"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("hi"), any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val Game Game
2025/10/11 16:12:20 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int} => Typ Game
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *Game
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:20 ==> InitClass Game isProj: true
2025/10/11 16:12:20 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:20 ==> InitClass Kai isProj: false
2025/10/11 16:12:20 ==> Preload type Game
2025/10/11 16:12:20 ==> Preload method Game.MainEntry
2025/10/11 16:12:20 ==> Preload type Kai
2025/10/11 16:12:20 ==> Preload method Kai.Main
2025/10/11 16:12:20 ==> Load > NewType Game
2025/10/11 16:12:20 NewType Game
2025/10/11 16:12:20 ==> Load > NewType Kai
2025/10/11 16:12:20 NewType Kai
2025/10/11 16:12:20 ==> Load > InitType Game
2025/10/11 16:12:20 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:20 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/10/11 16:12:20 ==> Load method *Game.MainEntry
2025/10/11 16:12:20 ==> Load > InitType Kai
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/10/11 16:12:20 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; id int}
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; id int}
2025/10/11 16:12:20 ==> Load method *Kai.Main
2025/10/11 16:12:20 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Game) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Call 1 0 // func(game any)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *Game, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Kai) func()
2025/10/11 16:12:20 SetComments 0
//line Kai.tspx:6:1
2025/10/11 16:12:20 Val this *Kai
2025/10/11 16:12:20 Member println 1 // *Kai
2025/10/11 16:12:20 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 Val &{0 STRING "hi"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("hi"), any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val Game Game
2025/10/11 16:12:20 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int} => Typ Game
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *Game
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ClassFile /foo/Game.t4gmx
2025/10/11 16:12:20 ==> Import github.com/goplus/xgo/cl/internal/spx4
2025/10/11 16:12:20 ==> NewTemplateRecvMethod MyGame Main
2025/10/11 16:12:20 ==> NewTemplateRecvMethod MyGame Run
2025/10/11 16:12:20 ==> NewTemplateRecvMethod Sprite OnKey2
2025/10/11 16:12:20 ==> NewOverloadFunc Gopt_Sprite_Clone
2025/10/11 16:12:20 ==> NewTemplateRecvMethod Sprite Clone
2025/10/11 16:12:20 ==> NewOverloadFunc Gopt_Sprite_OnKey
2025/10/11 16:12:20 ==> NewTemplateRecvMethod Sprite OnKey
2025/10/11 16:12:20 ==> NewOverloadMethod MyGame Broadcast
2025/10/11 16:12:20 ==> NewOverloadFunc Rand
2025/10/11 16:12:20 ==> InitClass Game isProj: true
2025/10/11 16:12:20 ==> ClassFile /foo/Kai.t4spx
2025/10/11 16:12:20 ==> InitClass Kai isProj: false
2025/10/11 16:12:20 ==> Preload type Game
2025/10/11 16:12:20 ==> Preload method Game.MainEntry
2025/10/11 16:12:20 ==> Preload type Kai
2025/10/11 16:12:20 ==> Preload method Kai.Main
2025/10/11 16:12:20 ==> Load > NewType Game
2025/10/11 16:12:20 NewType Game
2025/10/11 16:12:20 ==> Load > NewType Kai
2025/10/11 16:12:20 NewType Kai
2025/10/11 16:12:20 ==> Load > InitType Game
2025/10/11 16:12:20 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:20 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai Kai; userScore int}
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai Kai; userScore int}
2025/10/11 16:12:20 ==> Load method *Game.MainEntry
2025/10/11 16:12:20 ==> Load > InitType Kai
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai Kai; userScore int}
2025/10/11 16:12:20 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/10/11 16:12:20 ==> Load method *Kai.Main
2025/10/11 16:12:20 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Game) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx4.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/10/11 16:12:20 DefineVarStart [_xgo_obj0]
2025/10/11 16:12:20 Val 1 int
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 StructLit Kai 2 true
2025/10/11 16:12:20 UnaryOp & flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:20 EndInit 1
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Val _xgo_obj0 *Kai
2025/10/11 16:12:20 Call 2 0 // func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite) args: 2 flags: 0
2025/10/11 16:12:20 ==> MatchType *Game, any
2025/10/11 16:12:20 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx4.Sprite
2025/10/11 16:12:20 ==> AssignableConv *Kai github.com/goplus/xgo/cl/internal/spx4.Sprite false
2025/10/11 16:12:20 ==> ClassFile /foo/Game.t4gmx
2025/10/11 16:12:20 ==> InitClass Game isProj: true
2025/10/11 16:12:20 ==> ClassFile /foo/Greem.t4spx
2025/10/11 16:12:20 ==> InitClass Greem isProj: false
2025/10/11 16:12:20 ==> ClassFile /foo/Kai.t4spx
2025/10/11 16:12:20 ==> InitClass Kai isProj: false
2025/10/11 16:12:20 ==> Preload type Game
2025/10/11 16:12:20 ==> Preload method Game.MainEntry
2025/10/11 16:12:20 ==> Preload type Greem
2025/10/11 16:12:20 ==> Preload method Greem.Main
2025/10/11 16:12:20 ==> Preload type Kai
2025/10/11 16:12:20 ==> Preload method Kai.Main
2025/10/11 16:12:20 ==> Load > NewType Game
2025/10/11 16:12:20 NewType Game
2025/10/11 16:12:20 ==> Load > NewType Greem
2025/10/11 16:12:20 NewType Greem
2025/10/11 16:12:20 ==> Load > NewType Kai
2025/10/11 16:12:20 NewType Kai
2025/10/11 16:12:20 ==> Load > InitType Game
2025/10/11 16:12:20 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/10/11 16:12:20 ==> Load method *Game.MainEntry
2025/10/11 16:12:20 ==> Load > InitType Greem
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/10/11 16:12:20 InitType Greem struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/10/11 16:12:20 ==> LookupParent Greem => type Greem struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/10/11 16:12:20 ==> Load method *Greem.Main
2025/10/11 16:12:20 ==> Load > InitType Kai
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/10/11 16:12:20 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:20 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game; Kai Kai; userScore int}
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game; Kai Kai; userScore int}
2025/10/11 16:12:20 ==> Load method *Kai.Main
2025/10/11 16:12:20 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:20 SetComments 0
//line Game.t4gmx:1:1
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member println 1 // *Game
2025/10/11 16:12:20 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 Val &{0 STRING "hi"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("hi"), any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Game) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx4.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/10/11 16:12:20 DefineVarStart [_xgo_obj0]
2025/10/11 16:12:20 Val 1 int
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 StructLit Greem 2 true
2025/10/11 16:12:20 UnaryOp & flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:20 EndInit 1
2025/10/11 16:12:20 DefineVarStart [_xgo_obj1]
2025/10/11 16:12:20 Val 1 int
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 StructLit Kai 2 true
2025/10/11 16:12:20 UnaryOp & flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:20 EndInit 1
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Val _xgo_obj0 *Greem
2025/10/11 16:12:20 Val _xgo_obj1 *Kai
2025/10/11 16:12:20 Call 3 0 // func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite) args: 3 flags: 0
2025/10/11 16:12:20 ==> MatchType *Game, any
2025/10/11 16:12:20 ==> MatchType *Greem, github.com/goplus/xgo/cl/internal/spx4.Sprite
2025/10/11 16:12:20 ==> AssignableConv *Greem github.com/goplus/xgo/cl/internal/spx4.Sprite false
2025/10/11 16:12:20 ==> ClassFile /foo/Game.t4gmx
2025/10/11 16:12:20 ==> InitClass Game isProj: true
2025/10/11 16:12:20 ==> Preload type Game
2025/10/11 16:12:20 ==> Preload method Game.MainEntry
2025/10/11 16:12:20 ==> Load > NewType Game
2025/10/11 16:12:20 NewType Game
2025/10/11 16:12:20 ==> Load > InitType Game
2025/10/11 16:12:20 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/10/11 16:12:20 ==> Load method *Game.MainEntry
2025/10/11 16:12:20 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:20 SetComments 0
//line Game.t4gmx:1:1
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member println 1 // *Game
2025/10/11 16:12:20 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member backdropName 1 // *Game
2025/10/11 16:12:20 Call 0 0 // func() string
2025/10/11 16:12:20 ==> MatchFuncCall func() string args: 0 flags: 0
2025/10/11 16:12:20 NewClosure func()
2025/10/11 16:12:20 NewVar [_xgo_err]
2025/10/11 16:12:20 VarRef _xgo_err error
2025/10/11 16:12:20 Assign 1 1
2025/10/11 16:12:20 ==> MatchType string, error
2025/10/11 16:12:20 ==> EnsureLoaded error
2025/10/11 16:12:20 ==> AssignableConv string error false
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member Gop_Exec 0 // *Game
2025/10/11 16:12:20 Val println string
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member backdropName 1 // *Game
2025/10/11 16:12:20 Call 0 0 // func() string
2025/10/11 16:12:20 ==> MatchFuncCall func() string args: 0 flags: 0
2025/10/11 16:12:20 NewClosure func()
2025/10/11 16:12:20 NewVar [_xgo_err]
2025/10/11 16:12:20 VarRef _xgo_err error
2025/10/11 16:12:20 Assign 1 1
2025/10/11 16:12:20 ==> MatchType string, error
2025/10/11 16:12:20 ==> EnsureLoaded error
2025/10/11 16:12:20 ==> AssignableConv string error false
2025/10/11 16:12:20 ResetStmt
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Game) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx4.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Call 1 0 // func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *Game, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val Game Game
2025/10/11 16:12:20 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame} => Typ Game
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *Game
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ClassFile /foo/Game.t5gmx
2025/10/11 16:12:20 ==> InitClass Game isProj: true
2025/10/11 16:12:20 ==> ClassFile /foo/Kai.t5spx
2025/10/11 16:12:20 ==> InitClass Kai isProj: false
2025/10/11 16:12:20 ==> Preload type Game
2025/10/11 16:12:20 ==> Preload method Game.MainEntry
2025/10/11 16:12:20 ==> Preload type Kai
2025/10/11 16:12:20 ==> Preload method Kai.Main
2025/10/11 16:12:20 ==> Load > NewType Game
2025/10/11 16:12:20 NewType Game
2025/10/11 16:12:20 ==> Load > NewType Kai
2025/10/11 16:12:20 NewType Kai
2025/10/11 16:12:20 ==> Load > InitType Game
2025/10/11 16:12:20 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:20 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai *Kai}
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai *Kai}
2025/10/11 16:12:20 ==> Load method *Game.MainEntry
2025/10/11 16:12:20 ==> Load > InitType Kai
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai *Kai}
2025/10/11 16:12:20 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/10/11 16:12:20 ==> Load method *Kai.Main
2025/10/11 16:12:20 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Game) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx4.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/10/11 16:12:20 DefineVarStart [_xgo_obj0]
2025/10/11 16:12:20 Val 1 int
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 StructLit Kai 2 true
2025/10/11 16:12:20 UnaryOp & flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:20 EndInit 1
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member Kai -1 // *Game
2025/10/11 16:12:20 Val _xgo_obj0 *Kai
2025/10/11 16:12:20 Assign 1 1
2025/10/11 16:12:20 ==> MatchType *Kai, *Kai
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Val _xgo_obj0 *Kai
2025/10/11 16:12:20 Call 2 0 // func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite) args: 2 flags: 0
2025/10/11 16:12:20 ==> MatchType *Game, any
2025/10/11 16:12:20 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx4.Sprite
2025/10/11 16:12:20 ==> AssignableConv *Kai github.com/goplus/xgo/cl/internal/spx4.Sprite false
--- PASS: TestSpxError (1.53s)
=== RUN   TestSpxBasic
=== RUN   TestSpxBasic/gopSpxTest
2025/10/11 16:12:20 ==> ClassFile /foo/bar.tspx
2025/10/11 16:12:20 ==> InitClass bar isProj: false
2025/10/11 16:12:20 ==> ClassFile /foo/index.tgmx
2025/10/11 16:12:20 ==> InitClass index isProj: true
2025/10/11 16:12:20 ==> Preload type bar
2025/10/11 16:12:20 ==> Preload method bar.Main
2025/10/11 16:12:20 ==> Preload type index
2025/10/11 16:12:20 NewConstDefs
2025/10/11 16:12:20 ==> Preload const [Foo]
2025/10/11 16:12:20 ==> Preload method index.bar
2025/10/11 16:12:20 ==> Preload method index.onInit
2025/10/11 16:12:20 ==> Preload method index.MainEntry
2025/10/11 16:12:20 ==> Load > NewType bar
2025/10/11 16:12:20 NewType bar
2025/10/11 16:12:20 ==> Load > NewType index
2025/10/11 16:12:20 NewType index
2025/10/11 16:12:20 ==> Load const [Foo] <nil>
2025/10/11 16:12:20 NewConst [Foo] 0
2025/10/11 16:12:20 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:20 EndInit 1
2025/10/11 16:12:20 ==> Load > InitType index
2025/10/11 16:12:20 InitType index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> Load method *index.bar
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> Load method *index.onInit
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> Load method *index.MainEntry
2025/10/11 16:12:20 ==> Load > InitType bar
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/10/11 16:12:20 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/10/11 16:12:20 ==> Load method *bar.Main
2025/10/11 16:12:20 NewFunc bar (*index) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc onInit (*index) func()
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member Foo 1 // *index
2025/10/11 16:12:20 Val Foo untyped int
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member bar 1 // *index
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member fmt 2 // *index
2025/10/11 16:12:20 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:20 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:20 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc MainEntry (*index) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*index) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Call 1 0 // func(game any)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *index, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*bar) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val index index
2025/10/11 16:12:20 Val type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ index
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *index
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ASTFile
--- PASS: TestSpxBasic (0.00s)
    --- PASS: TestSpxBasic/gopSpxTest (0.00s)
=== RUN   TestEnvOp
=== RUN   TestEnvOp/gopSpxTest
2025/10/11 16:12:20 ==> ClassFile /foo/bar.tspx
2025/10/11 16:12:20 ==> InitClass bar isProj: false
2025/10/11 16:12:20 ==> ClassFile /foo/index.tgmx
2025/10/11 16:12:20 ==> InitClass index isProj: true
2025/10/11 16:12:20 ==> Preload type bar
2025/10/11 16:12:20 ==> Preload method bar.Main
2025/10/11 16:12:20 ==> Preload type index
2025/10/11 16:12:20 ==> Preload method index.MainEntry
2025/10/11 16:12:20 ==> Load > NewType bar
2025/10/11 16:12:20 NewType bar
2025/10/11 16:12:20 ==> Load > NewType index
2025/10/11 16:12:20 NewType index
2025/10/11 16:12:20 ==> Load > InitType index
2025/10/11 16:12:20 InitType index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> Load method *index.MainEntry
2025/10/11 16:12:20 ==> Load > InitType bar
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/10/11 16:12:20 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/10/11 16:12:20 ==> Load method *bar.Main
2025/10/11 16:12:20 NewFunc MainEntry (*index) func()
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member echo 1 // *index
2025/10/11 16:12:20 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member Gop_Env 0 // *index
2025/10/11 16:12:20 Val PATH string
2025/10/11 16:12:20 Call 1 0 // func(name string) int
2025/10/11 16:12:20 ==> MatchFuncCall func(name string) int args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("PATH"), string
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member Gop_Env 0 // *index
2025/10/11 16:12:20 Val id string
2025/10/11 16:12:20 Call 1 0 // func(name string) int
2025/10/11 16:12:20 ==> MatchFuncCall func(name string) int args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("id"), string
2025/10/11 16:12:20 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:20 ==> MatchType int, any
2025/10/11 16:12:20 ==> MatchType int, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*index) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Call 1 0 // func(game any)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *index, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*bar) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val index index
2025/10/11 16:12:20 Val type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ index
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *index
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ASTFile
--- PASS: TestEnvOp (0.00s)
    --- PASS: TestEnvOp/gopSpxTest (0.00s)
=== RUN   TestSpxGopEnv
=== RUN   TestSpxGopEnv/gopSpxTest
2025/10/11 16:12:20 ==> ClassFile /foo/bar.tspx
2025/10/11 16:12:20 ==> InitClass bar isProj: false
2025/10/11 16:12:20 ==> ClassFile /foo/index.tgmx
2025/10/11 16:12:20 ==> InitClass index isProj: true
2025/10/11 16:12:20 ==> Preload type bar
2025/10/11 16:12:20 ==> Preload method bar.Main
2025/10/11 16:12:20 ==> Preload type index
2025/10/11 16:12:20 ==> Preload method index.MainEntry
2025/10/11 16:12:20 ==> Load > NewType bar
2025/10/11 16:12:20 NewType bar
2025/10/11 16:12:20 ==> Load > NewType index
2025/10/11 16:12:20 NewType index
2025/10/11 16:12:20 ==> Load > InitType index
2025/10/11 16:12:20 InitType index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> Load method *index.MainEntry
2025/10/11 16:12:20 ==> Load > InitType bar
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/10/11 16:12:20 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/10/11 16:12:20 ==> Load method *bar.Main
2025/10/11 16:12:20 NewFunc MainEntry (*index) func()
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member echo 1 // *index
2025/10/11 16:12:20 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member PATH 2 // *index
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member Gop_Env 0 // *index
2025/10/11 16:12:20 Val PATH string
2025/10/11 16:12:20 Call 1 0 // func(name string) int
2025/10/11 16:12:20 ==> MatchFuncCall func(name string) int args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("PATH"), string
2025/10/11 16:12:20 Member string 2 // int
2025/10/11 16:12:20 Val Itoa func(i int) string
2025/10/11 16:12:20 Call 1 0 // func(i int) string
2025/10/11 16:12:20 ==> MatchFuncCall func(i int) string args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType int, int
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType string, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*index) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Call 1 0 // func(game any)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *index, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*bar) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val index index
2025/10/11 16:12:20 Val type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ index
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *index
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ASTFile
--- PASS: TestSpxGopEnv (0.00s)
    --- PASS: TestSpxGopEnv/gopSpxTest (0.00s)
=== RUN   TestSpxGopExec
=== RUN   TestSpxGopExec/gopSpxTest
2025/10/11 16:12:20 ==> ClassFile /foo/bar.tspx
2025/10/11 16:12:20 ==> InitClass bar isProj: false
2025/10/11 16:12:20 ==> ClassFile /foo/index.tgmx
2025/10/11 16:12:20 ==> InitClass index isProj: true
2025/10/11 16:12:20 ==> Preload type bar
2025/10/11 16:12:20 ==> Preload method bar.Main
2025/10/11 16:12:20 ==> Preload type index
2025/10/11 16:12:20 ==> Preload method index.MainEntry
2025/10/11 16:12:20 ==> Load > NewType bar
2025/10/11 16:12:20 NewType bar
2025/10/11 16:12:20 ==> Load > NewType index
2025/10/11 16:12:20 NewType index
2025/10/11 16:12:20 ==> Load > InitType index
2025/10/11 16:12:20 InitType index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> Load method *index.MainEntry
2025/10/11 16:12:20 ==> Load > InitType bar
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/10/11 16:12:20 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/10/11 16:12:20 ==> Load method *bar.Main
2025/10/11 16:12:20 NewFunc MainEntry (*index) func()
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member vim 1 // *index
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member Gop_Exec 0 // *index
2025/10/11 16:12:20 Val &{0 STRING "vim"} *ast.BasicLit
2025/10/11 16:12:20 Val &{0 STRING "a.txt"} *ast.BasicLit
2025/10/11 16:12:20 Call 2 0 // func(name string, args ...any)
2025/10/11 16:12:20 ==> MatchFuncCall func(name string, args ...any) args: 2 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("vim"), string
2025/10/11 16:12:20 ==> MatchType untyped string ("a.txt"), any
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member vim 1 // *index
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member Gop_Exec 0 // *index
2025/10/11 16:12:20 Val vim string
2025/10/11 16:12:20 Call 1 0 // func(name string, args ...any)
2025/10/11 16:12:20 ==> MatchFuncCall func(name string, args ...any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("vim"), string
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member ls 1 // *index
2025/10/11 16:12:20 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(n int)
2025/10/11 16:12:20 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped int (10), int
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member capout 1 // *index
2025/10/11 16:12:20 NewClosure func()
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member ls 1 // *index
2025/10/11 16:12:20 Call 0 0 // func(n int)
2025/10/11 16:12:20 ==> MatchFuncCall func(n int) args: 0 flags: 0
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member Gop_Exec 0 // *index
2025/10/11 16:12:20 Val ls string
2025/10/11 16:12:20 Call 1 0 // func(name string, args ...any)
2025/10/11 16:12:20 ==> MatchFuncCall func(name string, args ...any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("ls"), string
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 Call 1 0 // func(doSth func()) (string, error)
2025/10/11 16:12:20 ==> MatchFuncCall func(doSth func()) (string, error) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType func(), func()
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member capout 1 // *index
2025/10/11 16:12:20 NewClosure func()
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member ls 1 // *index
2025/10/11 16:12:20 Val &{0 STRING "-l"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(n int)
2025/10/11 16:12:20 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("-l"), int
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member Gop_Exec 0 // *index
2025/10/11 16:12:20 Val ls string
2025/10/11 16:12:20 Val &{0 STRING "-l"} *ast.BasicLit
2025/10/11 16:12:20 Call 2 0 // func(name string, args ...any)
2025/10/11 16:12:20 ==> MatchFuncCall func(name string, args ...any) args: 2 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("ls"), string
2025/10/11 16:12:20 ==> MatchType untyped string ("-l"), any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 Call 1 0 // func(doSth func()) (string, error)
2025/10/11 16:12:20 ==> MatchFuncCall func(doSth func()) (string, error) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType func(), func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*index) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Call 1 0 // func(game any)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *index, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*bar) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val index index
2025/10/11 16:12:20 Val type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ index
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *index
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ASTFile
--- PASS: TestSpxGopExec (0.00s)
    --- PASS: TestSpxGopExec/gopSpxTest (0.00s)
=== RUN   TestSpxMethod
=== RUN   TestSpxMethod/gopSpxTest
2025/10/11 16:12:20 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:20 ==> InitClass Game isProj: true
2025/10/11 16:12:20 ==> ClassFile /foo/bar.tspx
2025/10/11 16:12:20 ==> InitClass bar isProj: false
2025/10/11 16:12:20 ==> Preload type Game
2025/10/11 16:12:20 ==> Preload method Game.onInit
2025/10/11 16:12:20 ==> Preload method Game.MainEntry
2025/10/11 16:12:20 ==> Preload type bar
2025/10/11 16:12:20 ==> Preload method bar.onInit
2025/10/11 16:12:20 ==> Preload method bar.Main
2025/10/11 16:12:20 ==> Load > NewType Game
2025/10/11 16:12:20 NewType Game
2025/10/11 16:12:20 ==> Load > NewType bar
2025/10/11 16:12:20 NewType bar
2025/10/11 16:12:20 ==> Load > InitType Game
2025/10/11 16:12:20 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> Load method *Game.onInit
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 ==> Load method *Game.MainEntry
2025/10/11 16:12:20 ==> Load > InitType bar
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:20 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:20 ==> Load method *bar.onInit
2025/10/11 16:12:20 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:20 ==> Load method *bar.Main
2025/10/11 16:12:20 NewFunc onInit (*Game) func()
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member sched 1 // *Game
2025/10/11 16:12:20 Val Sched func()
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member broadcast 1 // *Game
2025/10/11 16:12:20 Val &{0 STRING "msg1"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(msg string) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("msg1"), string
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member TestIntValue -1 // *Game
2025/10/11 16:12:20 VarRef TestIntValue int
2025/10/11 16:12:20 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:20 Assign 1 1
2025/10/11 16:12:20 ==> MatchType untyped int (1), int
2025/10/11 16:12:20 DefineVarStart [x]
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member round 1 // *Game
2025/10/11 16:12:20 Val Round func(x float64) float64
2025/10/11 16:12:20 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(x float64) float64
2025/10/11 16:12:20 ==> MatchFuncCall func(x float64) float64 args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped float (1.2), float64
2025/10/11 16:12:20 EndInit 1
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Game) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Call 1 0 // func(game any)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *Game, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc onInit (*bar) func()
2025/10/11 16:12:20 Val this *bar
2025/10/11 16:12:20 Member setCostume 1 // *bar
2025/10/11 16:12:20 Val &{0 STRING "kai-a"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(costume any)
2025/10/11 16:12:20 ==> MatchFuncCall func(costume any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("kai-a"), any
2025/10/11 16:12:20 Val this *bar
2025/10/11 16:12:20 Member play 1 // *bar
2025/10/11 16:12:20 Val &{0 STRING "recordingWhere"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(media string, wait ...bool)
2025/10/11 16:12:20 ==> MatchFuncCall func(media string, wait ...bool) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("recordingWhere"), string
2025/10/11 16:12:20 Val this *bar
2025/10/11 16:12:20 Member say 1 // *bar
2025/10/11 16:12:20 Val &{0 STRING "Where do you come from?"} *ast.BasicLit
2025/10/11 16:12:20 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:20 Call 2 0 // func(msg string, secs ...float64)
2025/10/11 16:12:20 ==> MatchFuncCall func(msg string, secs ...float64) args: 2 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("Where do you come from?"), string
2025/10/11 16:12:20 ==> MatchType untyped int (2), float64
2025/10/11 16:12:20 Val this *bar
2025/10/11 16:12:20 Member broadcast 1 // *bar
2025/10/11 16:12:20 Val &{0 STRING "msg2"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(msg string) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("msg2"), string
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*bar) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val Game Game
2025/10/11 16:12:20 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *Game
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ASTFile
--- PASS: TestSpxMethod (0.00s)
    --- PASS: TestSpxMethod/gopSpxTest (0.00s)
=== RUN   TestSpxVar
=== RUN   TestSpxVar/gopSpxTest
2025/10/11 16:12:20 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:20 ==> InitClass Game isProj: true
2025/10/11 16:12:20 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:20 ==> InitClass Kai isProj: false
2025/10/11 16:12:20 ==> Preload type Game
2025/10/11 16:12:20 ==> Preload method Game.onInit
2025/10/11 16:12:20 ==> Preload method Game.MainEntry
2025/10/11 16:12:20 ==> Preload type Kai
2025/10/11 16:12:20 ==> Preload method Kai.onInit
2025/10/11 16:12:20 ==> Preload method Kai.onCloned
2025/10/11 16:12:20 ==> Preload method Kai.Main
2025/10/11 16:12:20 ==> Load > NewType Game
2025/10/11 16:12:20 NewType Game
2025/10/11 16:12:20 ==> Load > NewType Kai
2025/10/11 16:12:20 NewType Kai
2025/10/11 16:12:20 ==> Load > InitType Game
2025/10/11 16:12:20 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:20 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:20 ==> Load method *Game.onInit
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:20 ==> Load method *Game.MainEntry
2025/10/11 16:12:20 ==> Load > InitType Kai
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:20 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/10/11 16:12:20 ==> Load method *Kai.onInit
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/10/11 16:12:20 ==> Load method *Kai.onCloned
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/10/11 16:12:20 ==> Load method *Kai.Main
2025/10/11 16:12:20 NewFunc onInit (*Game) func()
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member Kai 2 // *Game
2025/10/11 16:12:20 Member clone 1 // Kai
2025/10/11 16:12:20 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyTemplateRecvMethod args: 0 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 16
2025/10/11 16:12:20 ==> MatchFuncCall func(sprite any) args: 1 flags: 16
2025/10/11 16:12:20 ==> MatchType Kai, any
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member broadcast 1 // *Game
2025/10/11 16:12:20 Val &{0 STRING "msg1"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(msg string) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("msg1"), string
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Game) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Call 1 0 // func(game any)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *Game, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc onInit (*Kai) func()
2025/10/11 16:12:20 Val this *Kai
2025/10/11 16:12:20 Member a -1 // *Kai
2025/10/11 16:12:20 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:20 Assign 1 1
2025/10/11 16:12:20 ==> MatchType untyped int (1), int
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc onCloned (*Kai) func()
2025/10/11 16:12:20 Val this *Kai
2025/10/11 16:12:20 Member say 1 // *Kai
2025/10/11 16:12:20 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(msg string, secs ...float64)
2025/10/11 16:12:20 ==> MatchFuncCall func(msg string, secs ...float64) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("Hi"), string
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Kai) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val Game Game
2025/10/11 16:12:20 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai} => Typ Game
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *Game
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ASTFile
--- PASS: TestSpxVar (0.00s)
    --- PASS: TestSpxVar/gopSpxTest (0.00s)
=== RUN   TestSpxRun
=== RUN   TestSpxRun/gopSpxTest
2025/10/11 16:12:20 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:20 ==> InitClass Kai isProj: false
2025/10/11 16:12:20 ==> ClassFile /foo/index.tgmx
2025/10/11 16:12:20 ==> InitClass index isProj: true
2025/10/11 16:12:20 ==> Preload type Kai
2025/10/11 16:12:20 ==> Preload method Kai.Main
2025/10/11 16:12:20 ==> Preload type index
2025/10/11 16:12:20 ==> Preload var [x]
2025/10/11 16:12:20 ==> Preload method index.MainEntry
2025/10/11 16:12:20 ==> Load > NewType Kai
2025/10/11 16:12:20 NewType Kai
2025/10/11 16:12:20 ==> Load > NewType index
2025/10/11 16:12:20 NewType index
2025/10/11 16:12:20 ==> Load var float64 [x]
2025/10/11 16:12:20 NewVarDefs
2025/10/11 16:12:20 NewVar [x]
2025/10/11 16:12:20 Val Rand func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(int) int args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped float (1.2), int
2025/10/11 16:12:20 ==> MatchFuncCall func(float64) float64 args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped float (1.2), float64
2025/10/11 16:12:20 EndInit 1
2025/10/11 16:12:20 ==> MatchType float64, float64
2025/10/11 16:12:20 ==> Load > InitType index
2025/10/11 16:12:20 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:20 InitType index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; t github.com/goplus/xgo/cl/internal/spx.Sound}
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; t github.com/goplus/xgo/cl/internal/spx.Sound}
2025/10/11 16:12:20 ==> Load method *index.MainEntry
2025/10/11 16:12:20 ==> Load > InitType Kai
2025/10/11 16:12:20 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; t github.com/goplus/xgo/cl/internal/spx.Sound}
2025/10/11 16:12:20 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/10/11 16:12:20 ==> Load method *Kai.Main
2025/10/11 16:12:20 NewFunc MainEntry (*index) func()
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Member run 1 // *index
2025/10/11 16:12:20 Val &{0 STRING "hzip://open.qiniu.us/weather/res.zip"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(game any, resource string) error args: 2 flags: 16
2025/10/11 16:12:20 ==> MatchType *index, any
2025/10/11 16:12:20 ==> MatchType untyped string ("hzip://open.qiniu.us/weather/res.zip"), string
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*index) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:20 Val this *index
2025/10/11 16:12:20 Call 1 0 // func(game any)
2025/10/11 16:12:20 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *index, any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Kai) func()
2025/10/11 16:12:20 Val this *Kai
2025/10/11 16:12:20 Member println 1 // *Kai
2025/10/11 16:12:20 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val index index
2025/10/11 16:12:20 Val type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; t github.com/goplus/xgo/cl/internal/spx.Sound} => Typ index
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *index
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ASTFile
--- PASS: TestSpxRun (0.00s)
    --- PASS: TestSpxRun/gopSpxTest (0.00s)
=== RUN   TestSpx2
=== RUN   TestSpx2/gopSpxTest
2025/10/11 16:12:20 ==> ClassFile /foo/Game.t2gmx
2025/10/11 16:12:20 ==> InitClass Game isProj: true
2025/10/11 16:12:20 ==> ClassFile /foo/Kai.t2spx
2025/10/11 16:12:20 ==> InitClass Kai isProj: false
2025/10/11 16:12:20 ==> Preload type Game
2025/10/11 16:12:20 ==> Preload method Game.MainEntry
2025/10/11 16:12:20 ==> Preload type Kai
2025/10/11 16:12:20 ==> Preload method Kai.onMsg
2025/10/11 16:12:20 ==> Preload method Kai.Main
2025/10/11 16:12:20 ==> Load > NewType Game
2025/10/11 16:12:20 NewType Game
2025/10/11 16:12:20 ==> Load > NewType Kai
2025/10/11 16:12:20 NewType Kai
2025/10/11 16:12:20 ==> Load > InitType Game
2025/10/11 16:12:20 InitType Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/10/11 16:12:20 ==> Load method *Game.MainEntry
2025/10/11 16:12:20 ==> Load > InitType Kai
2025/10/11 16:12:20 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/10/11 16:12:20 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/10/11 16:12:20 ==> Load method *Kai.onMsg
2025/10/11 16:12:20 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/10/11 16:12:20 ==> Load method *Kai.Main
2025/10/11 16:12:20 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member println 1 // *Game
2025/10/11 16:12:20 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:20 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:20 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Game) func()
2025/10/11 16:12:20 Typ github.com/goplus/xgo/cl/internal/spx2.Game
2025/10/11 16:12:20 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx2.Game}
2025/10/11 16:12:20 Val this *Game
2025/10/11 16:12:20 Member Game -1 // *Game
2025/10/11 16:12:20 UnaryOp & flags: 0
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:20 Call 1 0 // func(*github.com/goplus/xgo/cl/internal/spx2.Game)
2025/10/11 16:12:20 ==> MatchFuncCall func(*github.com/goplus/xgo/cl/internal/spx2.Game) args: 1 flags: 0
2025/10/11 16:12:20 ==> MatchType *github.com/goplus/xgo/cl/internal/spx2.Game, *github.com/goplus/xgo/cl/internal/spx2.Game
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc onMsg (*Kai) func(msg string)
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc Main (*Kai) func()
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 NewFunc main func()
2025/10/11 16:12:20 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 Val Game Game
2025/10/11 16:12:20 Val type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game} => Typ Game
2025/10/11 16:12:20 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:20 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:20 Member Main 0 // *Game
2025/10/11 16:12:20 Call 0 0 // func()
2025/10/11 16:12:20 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:20 End // Func
2025/10/11 16:12:20 ==> ASTFile
--- PASS: TestSpx2 (0.02s)
    --- PASS: TestSpx2/gopSpxTest (0.02s)
=== RUN   TestSpxMainEntry
=== RUN   TestSpxMainEntry/Nocode
2025/10/11 16:12:21 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:21 ==> NewOverloadFunc NewRange
2025/10/11 16:12:21 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:21 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:21 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:21 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:21 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:21 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:21 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:21 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:21 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:21 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:21 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:21 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:21 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:21 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:22 ==> ClassFile /foo/Game.t2gmx
2025/10/11 16:12:22 ==> InitClass Game isProj: true
2025/10/11 16:12:22 ==> ClassFile /foo/Kai.t2spx
2025/10/11 16:12:22 ==> InitClass Kai isProj: false
2025/10/11 16:12:22 ==> Preload type Game
2025/10/11 16:12:22 ==> Preload method Game.MainEntry
2025/10/11 16:12:22 ==> Preload type Kai
2025/10/11 16:12:22 ==> Preload method Kai.Main
2025/10/11 16:12:22 ==> Load > NewType Game
2025/10/11 16:12:22 NewType Game
2025/10/11 16:12:22 ==> Load > NewType Kai
2025/10/11 16:12:22 NewType Kai
2025/10/11 16:12:22 ==> Load > InitType Game
2025/10/11 16:12:22 InitType Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/10/11 16:12:22 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/10/11 16:12:22 ==> Load method *Game.MainEntry
2025/10/11 16:12:22 ==> Load > InitType Kai
2025/10/11 16:12:22 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/10/11 16:12:22 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/10/11 16:12:22 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/10/11 16:12:22 ==> Load method *Kai.Main
2025/10/11 16:12:22 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:22 End // Func
2025/10/11 16:12:22 NewFunc Main (*Game) func()
2025/10/11 16:12:22 Typ github.com/goplus/xgo/cl/internal/spx2.Game
2025/10/11 16:12:22 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx2.Game}
2025/10/11 16:12:22 Val this *Game
2025/10/11 16:12:22 Member Game -1 // *Game
2025/10/11 16:12:22 UnaryOp & flags: 0
2025/10/11 16:12:22 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:22 Call 1 0 // func(*github.com/goplus/xgo/cl/internal/spx2.Game)
2025/10/11 16:12:22 ==> MatchFuncCall func(*github.com/goplus/xgo/cl/internal/spx2.Game) args: 1 flags: 0
2025/10/11 16:12:22 ==> MatchType *github.com/goplus/xgo/cl/internal/spx2.Game, *github.com/goplus/xgo/cl/internal/spx2.Game
2025/10/11 16:12:22 End // Func
2025/10/11 16:12:22 NewFunc Main (*Kai) func()
2025/10/11 16:12:22 End // Func
2025/10/11 16:12:22 NewFunc main func()
2025/10/11 16:12:22 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:22 Val Game Game
2025/10/11 16:12:22 Val type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game} => Typ Game
2025/10/11 16:12:22 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:22 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:22 Member Main 0 // *Game
2025/10/11 16:12:22 Call 0 0 // func()
2025/10/11 16:12:22 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:22 End // Func
2025/10/11 16:12:22 ==> ASTFile
=== RUN   TestSpxMainEntry/OnlyGmx
2025/10/11 16:12:22 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:22 ==> NewOverloadFunc NewRange
2025/10/11 16:12:22 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:22 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:22 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:22 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:22 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:22 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:22 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:22 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:22 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:22 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:22 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:22 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:23 ==> ClassFile /foo/Game.t2gmx
2025/10/11 16:12:23 ==> InitClass Game isProj: true
2025/10/11 16:12:23 ==> ClassFile /foo/Kai.t2spx
2025/10/11 16:12:23 ==> InitClass Kai isProj: false
2025/10/11 16:12:23 ==> Preload type Game
2025/10/11 16:12:23 ==> Preload method Game.MainEntry
2025/10/11 16:12:23 ==> Preload type Kai
2025/10/11 16:12:23 ==> Preload method Kai.Main
2025/10/11 16:12:23 ==> Load > NewType Game
2025/10/11 16:12:23 NewType Game
2025/10/11 16:12:23 ==> Load > NewType Kai
2025/10/11 16:12:23 NewType Kai
2025/10/11 16:12:23 ==> Load > InitType Game
2025/10/11 16:12:23 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:23 InitType Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/10/11 16:12:23 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/10/11 16:12:23 ==> Load method *Game.MainEntry
2025/10/11 16:12:23 ==> Load > InitType Kai
2025/10/11 16:12:23 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/10/11 16:12:23 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/10/11 16:12:23 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/10/11 16:12:23 ==> Load method *Kai.Main
2025/10/11 16:12:23 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:23 End // Func
2025/10/11 16:12:23 NewFunc Main (*Game) func()
2025/10/11 16:12:23 Typ github.com/goplus/xgo/cl/internal/spx2.Game
2025/10/11 16:12:23 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx2.Game}
2025/10/11 16:12:23 Val this *Game
2025/10/11 16:12:23 Member Game -1 // *Game
2025/10/11 16:12:23 UnaryOp & flags: 0
2025/10/11 16:12:23 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:23 Call 1 0 // func(*github.com/goplus/xgo/cl/internal/spx2.Game)
2025/10/11 16:12:23 ==> MatchFuncCall func(*github.com/goplus/xgo/cl/internal/spx2.Game) args: 1 flags: 0
2025/10/11 16:12:23 ==> MatchType *github.com/goplus/xgo/cl/internal/spx2.Game, *github.com/goplus/xgo/cl/internal/spx2.Game
2025/10/11 16:12:23 End // Func
2025/10/11 16:12:23 NewFunc Main (*Kai) func()
2025/10/11 16:12:23 End // Func
2025/10/11 16:12:23 NewFunc main func()
2025/10/11 16:12:23 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:23 Val Game Game
2025/10/11 16:12:23 Val type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai} => Typ Game
2025/10/11 16:12:23 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:23 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:23 Member Main 0 // *Game
2025/10/11 16:12:23 Call 0 0 // func()
2025/10/11 16:12:23 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:23 End // Func
2025/10/11 16:12:23 ==> ASTFile
=== RUN   TestSpxMainEntry/KaiAndGmx
2025/10/11 16:12:23 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:23 ==> NewOverloadFunc NewRange
2025/10/11 16:12:24 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:24 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:24 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:24 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:24 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:24 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:24 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:24 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:24 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:24 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:24 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:24 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:24 ==> ClassFile /foo/Game.t2gmx
2025/10/11 16:12:24 ==> InitClass Game isProj: true
2025/10/11 16:12:24 ==> ClassFile /foo/Kai.t2spx
2025/10/11 16:12:24 ==> InitClass Kai isProj: false
2025/10/11 16:12:24 ==> Preload type Game
2025/10/11 16:12:24 ==> Preload method Game.MainEntry
2025/10/11 16:12:24 ==> Preload type Kai
2025/10/11 16:12:24 ==> Preload method Kai.Main
2025/10/11 16:12:24 ==> Preload method Kai.onMsg
2025/10/11 16:12:24 ==> Load > NewType Game
2025/10/11 16:12:24 NewType Game
2025/10/11 16:12:24 ==> Load > NewType Kai
2025/10/11 16:12:24 NewType Kai
2025/10/11 16:12:24 ==> Load > InitType Game
2025/10/11 16:12:24 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:24 InitType Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/10/11 16:12:24 ==> Load method *Game.MainEntry
2025/10/11 16:12:24 ==> Load > InitType Kai
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/10/11 16:12:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.Main
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.onMsg
2025/10/11 16:12:24 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Member println 1 // *Game
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Game) func()
2025/10/11 16:12:24 Typ github.com/goplus/xgo/cl/internal/spx2.Game
2025/10/11 16:12:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx2.Game}
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Member Game -1 // *Game
2025/10/11 16:12:24 UnaryOp & flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:24 Call 1 0 // func(*github.com/goplus/xgo/cl/internal/spx2.Game)
2025/10/11 16:12:24 ==> MatchFuncCall func(*github.com/goplus/xgo/cl/internal/spx2.Game) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType *github.com/goplus/xgo/cl/internal/spx2.Game, *github.com/goplus/xgo/cl/internal/spx2.Game
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Kai) func()
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member println 1 // *Kai
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("Hello"), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc onMsg (*Kai) func(msg string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val Game Game
2025/10/11 16:12:24 Val type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai} => Typ Game
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member Main 0 // *Game
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestSpxMainEntry (3.80s)
    --- PASS: TestSpxMainEntry/Nocode (1.23s)
    --- PASS: TestSpxMainEntry/OnlyGmx (1.29s)
    --- PASS: TestSpxMainEntry/KaiAndGmx (1.28s)
=== RUN   TestSpxGoxBasic
=== RUN   TestSpxGoxBasic/gopSpxTest
2025/10/11 16:12:24 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:24 ==> InitClass Game isProj: true
2025/10/11 16:12:24 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:24 ==> InitClass Kai isProj: false
2025/10/11 16:12:24 ==> Preload type Game
2025/10/11 16:12:24 ==> Preload method Game.onInit
2025/10/11 16:12:24 ==> Preload method Game.MainEntry
2025/10/11 16:12:24 ==> Preload type Kai
2025/10/11 16:12:24 ==> Preload method Kai.onMsg
2025/10/11 16:12:24 ==> Preload method Kai.Main
2025/10/11 16:12:24 ==> Load > NewType Game
2025/10/11 16:12:24 NewType Game
2025/10/11 16:12:24 ==> Load > NewType Kai
2025/10/11 16:12:24 NewType Kai
2025/10/11 16:12:24 ==> Load > InitType Game
2025/10/11 16:12:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> Load method *Game.onInit
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> Load method *Game.MainEntry
2025/10/11 16:12:24 ==> Load > InitType Kai
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.onMsg
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.Main
2025/10/11 16:12:24 NewFunc onInit (*Game) func()
2025/10/11 16:12:24 For
2025/10/11 16:12:24 None
2025/10/11 16:12:24 Then
2025/10/11 16:12:24 Val Sched func()
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 Val SchedNow func()
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 End // For
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Game) func()
2025/10/11 16:12:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Call 1 0 // func(game any)
2025/10/11 16:12:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType *Game, any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc onMsg (*Kai) func(msg string)
2025/10/11 16:12:24 For
2025/10/11 16:12:24 None
2025/10/11 16:12:24 Then
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member say 1 // *Kai
2025/10/11 16:12:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(msg string, secs ...float64)
2025/10/11 16:12:24 ==> MatchFuncCall func(msg string, secs ...float64) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("Hi"), string
2025/10/11 16:12:24 End // For
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Kai) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val Game Game
2025/10/11 16:12:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member Main 0 // *Game
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestSpxGoxBasic (0.00s)
    --- PASS: TestSpxGoxBasic/gopSpxTest (0.00s)
=== RUN   TestSpxClone
=== RUN   TestSpxClone/gopSpxTest
2025/10/11 16:12:24 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:24 ==> InitClass Game isProj: true
2025/10/11 16:12:24 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:24 ==> InitClass Kai isProj: false
2025/10/11 16:12:24 ==> Preload type Game
2025/10/11 16:12:24 ==> Preload method Game.onInit
2025/10/11 16:12:24 ==> Preload method Game.MainEntry
2025/10/11 16:12:24 ==> Preload type Kai
2025/10/11 16:12:24 ==> Preload type info
2025/10/11 16:12:24 ==> Preload method Kai.onInit
2025/10/11 16:12:24 ==> Preload method Kai.onCloned
2025/10/11 16:12:24 ==> Preload method Kai.Main
2025/10/11 16:12:24 ==> Load > NewType Game
2025/10/11 16:12:24 NewType Game
2025/10/11 16:12:24 ==> Load > NewType Kai
2025/10/11 16:12:24 NewType Kai
2025/10/11 16:12:24 ==> Load > InitType Game
2025/10/11 16:12:24 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:24 ==> Load method *Game.onInit
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:24 ==> Load method *Game.MainEntry
2025/10/11 16:12:24 ==> Load > NewType info
2025/10/11 16:12:24 NewType info
2025/10/11 16:12:24 ==> Load > InitType info
2025/10/11 16:12:24 InitType info struct{x int; y int}
2025/10/11 16:12:24 ==> Load > InitType Kai
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/10/11 16:12:24 ==> Load method *Kai.onInit
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/10/11 16:12:24 ==> Load method *Kai.onCloned
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/10/11 16:12:24 ==> Load method *Kai.Main
2025/10/11 16:12:24 NewFunc onInit (*Game) func()
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Member Kai 2 // *Game
2025/10/11 16:12:24 Member clone 1 // Kai
2025/10/11 16:12:24 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 0 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any) args: 1 flags: 16
2025/10/11 16:12:24 ==> MatchType Kai, any
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Member broadcast 1 // *Game
2025/10/11 16:12:24 Val &{0 STRING "msg1"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(msg string) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("msg1"), string
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Game) func()
2025/10/11 16:12:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Call 1 0 // func(game any)
2025/10/11 16:12:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType *Game, any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc onInit (*Kai) func()
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member a -1 // *Kai
2025/10/11 16:12:24 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:24 Assign 1 1
2025/10/11 16:12:24 ==> MatchType untyped int (1), int
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member clone 1 // *Kai
2025/10/11 16:12:24 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 0 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any) args: 1 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member clone 1 // *Kai
2025/10/11 16:12:24 ==> LookupParent info => type info struct{x int; y int}
2025/10/11 16:12:24 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:24 StructLit info 2 false
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any) args: 2 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, data any) args: 2 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType info, any
2025/10/11 16:12:24 ==> EnsureLoaded info
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member clone 1 // *Kai
2025/10/11 16:12:24 ==> LookupParent info => type info struct{x int; y int}
2025/10/11 16:12:24 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:24 StructLit info 2 false
2025/10/11 16:12:24 UnaryOp & flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any) args: 2 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, data any) args: 2 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType *info, any
2025/10/11 16:12:24 ==> EnsureLoaded info
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc onCloned (*Kai) func()
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member say 1 // *Kai
2025/10/11 16:12:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(msg string, secs ...float64)
2025/10/11 16:12:24 ==> MatchFuncCall func(msg string, secs ...float64) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("Hi"), string
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Kai) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val Game Game
2025/10/11 16:12:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai} => Typ Game
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member Main 0 // *Game
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestSpxClone (0.01s)
    --- PASS: TestSpxClone/gopSpxTest (0.01s)
=== RUN   TestSpxErrorSel
2025/10/11 16:12:24 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:24 ==> InitClass Game isProj: true
2025/10/11 16:12:24 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:24 ==> InitClass Kai isProj: false
2025/10/11 16:12:24 ==> Preload type Game
2025/10/11 16:12:24 ==> Preload method Game.MainEntry
2025/10/11 16:12:24 ==> Preload type Kai
2025/10/11 16:12:24 ==> Preload method Kai.Main
2025/10/11 16:12:24 ==> Load > NewType Game
2025/10/11 16:12:24 NewType Game
2025/10/11 16:12:24 ==> Load > NewType Kai
2025/10/11 16:12:24 NewType Kai
2025/10/11 16:12:24 ==> Load > InitType Game
2025/10/11 16:12:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> Load method *Game.MainEntry
2025/10/11 16:12:24 ==> Load > InitType Kai
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.Main
2025/10/11 16:12:24 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:24 SetComments 0
//line Game.tgmx:2:1
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Member println 1 // *Game
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val &{0 STRING "hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("hi"), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Game) func()
2025/10/11 16:12:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Call 1 0 // func(game any)
2025/10/11 16:12:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType *Game, any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Kai) func()
2025/10/11 16:12:24 SetComments 0
//line Kai.tspx:2:1
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member println 1 // *Kai
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member pos 2 // *Kai
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member Gop_Exec 0 // *Kai
2025/10/11 16:12:24 Val println string
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member pos 2 // *Kai
2025/10/11 16:12:24 ResetStmt
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val Game Game
2025/10/11 16:12:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member Main 0 // *Game
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 End // Func
--- PASS: TestSpxErrorSel (0.00s)
=== RUN   TestSpxMethodSel
=== RUN   TestSpxMethodSel/gopSpxTest
2025/10/11 16:12:24 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:24 ==> InitClass Game isProj: true
2025/10/11 16:12:24 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:24 ==> InitClass Kai isProj: false
2025/10/11 16:12:24 ==> Preload type Game
2025/10/11 16:12:24 ==> Preload method Game.MainEntry
2025/10/11 16:12:24 ==> Preload type Kai
2025/10/11 16:12:24 ==> Preload method Kai.onMsg
2025/10/11 16:12:24 ==> Preload method Kai.Main
2025/10/11 16:12:24 ==> Load > NewType Game
2025/10/11 16:12:24 NewType Game
2025/10/11 16:12:24 ==> Load > NewType Kai
2025/10/11 16:12:24 NewType Kai
2025/10/11 16:12:24 ==> Load > InitType Game
2025/10/11 16:12:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> Load method *Game.MainEntry
2025/10/11 16:12:24 ==> Load > InitType Kai
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.onMsg
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.Main
2025/10/11 16:12:24 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Member sendMessage 1 // *Game
2025/10/11 16:12:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(data any)
2025/10/11 16:12:24 ==> MatchFuncCall func(data any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Game) func()
2025/10/11 16:12:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Call 1 0 // func(game any)
2025/10/11 16:12:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType *Game, any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc onMsg (*Kai) func(msg string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Kai) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val Game Game
2025/10/11 16:12:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member Main 0 // *Game
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestSpxMethodSel (0.00s)
    --- PASS: TestSpxMethodSel/gopSpxTest (0.00s)
=== RUN   TestSpxPkgOverload
=== RUN   TestSpxPkgOverload/gopSpxTest
2025/10/11 16:12:24 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:24 ==> InitClass Game isProj: true
2025/10/11 16:12:24 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:24 ==> InitClass Kai isProj: false
2025/10/11 16:12:24 ==> Preload type Game
2025/10/11 16:12:24 ==> Preload method Game.MainEntry
2025/10/11 16:12:24 ==> Preload type Kai
2025/10/11 16:12:24 ==> Preload method Kai.onMsg
2025/10/11 16:12:24 ==> Preload method Kai.Main
2025/10/11 16:12:24 ==> Load > NewType Game
2025/10/11 16:12:24 NewType Game
2025/10/11 16:12:24 ==> Load > NewType Kai
2025/10/11 16:12:24 NewType Kai
2025/10/11 16:12:24 ==> Load > InitType Game
2025/10/11 16:12:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> Load method *Game.MainEntry
2025/10/11 16:12:24 ==> Load > InitType Kai
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.onMsg
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.Main
2025/10/11 16:12:24 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Member println 1 // *Game
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Game) func()
2025/10/11 16:12:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Call 1 0 // func(game any)
2025/10/11 16:12:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType *Game, any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc onMsg (*Kai) func(msg string)
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member position 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped int (100), int
2025/10/11 16:12:24 ==> MatchType untyped int (200), int
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Kai) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val Game Game
2025/10/11 16:12:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member Main 0 // *Game
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestSpxPkgOverload (0.00s)
    --- PASS: TestSpxPkgOverload/gopSpxTest (0.00s)
=== RUN   TestSpxSelection
=== RUN   TestSpxSelection/gopSpxTest
2025/10/11 16:12:24 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:24 ==> InitClass Game isProj: true
2025/10/11 16:12:24 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:24 ==> InitClass Kai isProj: false
2025/10/11 16:12:24 ==> Preload type Game
2025/10/11 16:12:24 ==> Preload method Game.MainEntry
2025/10/11 16:12:24 ==> Preload type Kai
2025/10/11 16:12:24 ==> Preload method Kai.onMsg
2025/10/11 16:12:24 ==> Preload method Kai.Main
2025/10/11 16:12:24 ==> Load > NewType Game
2025/10/11 16:12:24 NewType Game
2025/10/11 16:12:24 ==> Load > NewType Kai
2025/10/11 16:12:24 NewType Kai
2025/10/11 16:12:24 ==> Load > InitType Game
2025/10/11 16:12:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 ==> Load method *Game.MainEntry
2025/10/11 16:12:24 ==> Load > InitType Kai
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.onMsg
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:24 ==> Load method *Kai.Main
2025/10/11 16:12:24 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Member println 1 // *Game
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val &{0 STRING "hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("hi"), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Game) func()
2025/10/11 16:12:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Call 1 0 // func(game any)
2025/10/11 16:12:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType *Game, any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc onMsg (*Kai) func(msg string)
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member fmt 2 // *Kai
2025/10/11 16:12:24 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:24 Val msg string
2025/10/11 16:12:24 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType string, any
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member position 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped int (100), int
2025/10/11 16:12:24 ==> MatchType untyped int (200), int
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member position 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped int (100), int
2025/10/11 16:12:24 ==> MatchType untyped int (200), int
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member position 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member X -1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:24 AssignOp += Gop_AddAssign
2025/10/11 16:12:24 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:24 ==> MatchType untyped int (100), unboundFuncParam{typ: int}
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member println 1 // *Kai
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member position 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member X 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType int, any
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member vector 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped int (100), int
2025/10/11 16:12:24 ==> MatchType untyped int (200), int
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member vector 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped int (100), int
2025/10/11 16:12:24 ==> MatchType untyped int (200), int
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member vector 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member X -1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:24 AssignOp += Gop_AddAssign
2025/10/11 16:12:24 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:24 ==> MatchType untyped int (100), unboundFuncParam{typ: int}
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member vector 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member self 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member X -1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:24 AssignOp += Gop_AddAssign
2025/10/11 16:12:24 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:24 ==> MatchType untyped int (100), unboundFuncParam{typ: int}
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member vector 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member self 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member Y -1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:24 AssignOp += Gop_AddAssign
2025/10/11 16:12:24 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:24 ==> MatchType untyped int (200), unboundFuncParam{typ: int}
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member vector 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member self 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member position 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member X 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member position 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member Y 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType int, int
2025/10/11 16:12:24 ==> MatchType int, int
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member println 1 // *Kai
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member vector 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member X 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType int, any
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member println 1 // *Kai
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member vector 2 // *Kai
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member self 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Member self 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType *github.com/goplus/xgo/cl/internal/spx/pkg.Vector, any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Kai) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val Game Game
2025/10/11 16:12:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member Main 0 // *Game
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestSpxSelection (0.00s)
    --- PASS: TestSpxSelection/gopSpxTest (0.00s)
=== RUN   TestSpxOverload
=== RUN   TestSpxOverload/gopSpxTest
2025/10/11 16:12:24 ==> ClassFile /foo/Game.tgmx
2025/10/11 16:12:24 ==> InitClass Game isProj: true
2025/10/11 16:12:24 ==> ClassFile /foo/Kai.tspx
2025/10/11 16:12:24 ==> InitClass Kai isProj: false
2025/10/11 16:12:24 ==> Preload type Game
2025/10/11 16:12:24 ==> Preload method Game.onInit
2025/10/11 16:12:24 ==> Preload method Game.MainEntry
2025/10/11 16:12:24 ==> Preload type Kai
2025/10/11 16:12:24 ==> Preload type Mesh
2025/10/11 16:12:24 ==> Preload method Mesh.Name
2025/10/11 16:12:24 ==> Preload var [m1]
2025/10/11 16:12:24 ==> Preload var [m2]
2025/10/11 16:12:24 ==> Preload method Kai.Main
2025/10/11 16:12:24 ==> Load > NewType Game
2025/10/11 16:12:24 NewType Game
2025/10/11 16:12:24 ==> Load > NewType Kai
2025/10/11 16:12:24 NewType Kai
2025/10/11 16:12:24 ==> Load > InitType Game
2025/10/11 16:12:24 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:24 ==> Load method *Game.onInit
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:24 ==> Load method *Game.MainEntry
2025/10/11 16:12:24 ==> Load > NewType Mesh
2025/10/11 16:12:24 NewType Mesh
2025/10/11 16:12:24 ==> Load > InitType Mesh
2025/10/11 16:12:24 InitType Mesh struct{}
2025/10/11 16:12:24 ==> LookupParent Mesh => type Mesh struct{}
2025/10/11 16:12:24 ==> Load method *Mesh.Name
2025/10/11 16:12:24 ==> Load var <nil> [m1]
2025/10/11 16:12:24 NewVarDefs
2025/10/11 16:12:24 NewVar [m1]
2025/10/11 16:12:24 ==> LookupParent Mesh => type Mesh struct{}
2025/10/11 16:12:24 StructLit Mesh 0 false
2025/10/11 16:12:24 UnaryOp & flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:24 EndInit 1
2025/10/11 16:12:24 ==> Load var <nil> [m2]
2025/10/11 16:12:24 NewVarDefs
2025/10/11 16:12:24 NewVar [m2]
2025/10/11 16:12:24 ==> LookupParent Mesh => type Mesh struct{}
2025/10/11 16:12:24 StructLit Mesh 0 false
2025/10/11 16:12:24 UnaryOp & flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:24 EndInit 1
2025/10/11 16:12:24 ==> Load > InitType Kai
2025/10/11 16:12:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/10/11 16:12:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/10/11 16:12:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/10/11 16:12:24 ==> Load method *Kai.Main
2025/10/11 16:12:24 NewFunc onInit (*Game) func()
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Member Kai 2 // *Game
2025/10/11 16:12:24 Member onKey 1 // Kai
2025/10/11 16:12:24 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:24 NewClosure func(key string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType Kai, any
2025/10/11 16:12:24 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:24 ==> MatchType func(key string), func()
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType Kai, any
2025/10/11 16:12:24 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:24 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Game) func()
2025/10/11 16:12:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:24 Val this *Game
2025/10/11 16:12:24 Call 1 0 // func(game any)
2025/10/11 16:12:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType *Game, any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Name (*Mesh) func() string
2025/10/11 16:12:24 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:24 Return 1
2025/10/11 16:12:24 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*Kai) func()
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey 1 // *Kai
2025/10/11 16:12:24 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:24 NewClosure func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:24 ==> MatchType func(), func()
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey 1 // *Kai
2025/10/11 16:12:24 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:24 NewClosure func(key string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:24 ==> MatchType func(key string), func()
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:24 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey 1 // *Kai
2025/10/11 16:12:24 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 NewClosure func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, []string
2025/10/11 16:12:24 ==> MatchType func(), func()
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey 1 // *Kai
2025/10/11 16:12:24 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 NewClosure func(key string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, []string
2025/10/11 16:12:24 ==> MatchType func(key string), func()
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, []string
2025/10/11 16:12:24 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey 1 // *Kai
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit <nil> 2 false
2025/10/11 16:12:24 NewClosure func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, x int, y int) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, int
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit <nil> 2 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit []string 2 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit []string 2 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 2 false
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 NewClosure func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchType func(), func()
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey 1 // *Kai
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit <nil> 2 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit <nil> 2 false
2025/10/11 16:12:24 NewClosure func(key string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, x int, y int) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []*Mesh, int
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit []string 2 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit []string 2 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 2 false
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 2 false
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 NewClosure func(key github.com/goplus/xgo/cl/internal/spx.Mesher)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchType func(key github.com/goplus/xgo/cl/internal/spx.Mesher), func()
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchType func(key github.com/goplus/xgo/cl/internal/spx.Mesher), func(key github.com/goplus/xgo/cl/internal/spx.Mesher)
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey 1 // *Kai
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 NewClosure func(key string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 3 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, []string
2025/10/11 16:12:24 ==> MatchType []string, []string
2025/10/11 16:12:24 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey 1 // *Kai
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit <nil> 2 false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit <nil> 2 false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit <nil> 2 false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit <nil> 2 false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit []string 2 false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m1 2 // *Kai
2025/10/11 16:12:24 Val m1 *Mesh
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member m2 2 // *Kai
2025/10/11 16:12:24 Val m2 *Mesh
2025/10/11 16:12:24 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 2 false
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 NewClosure func(key string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 3 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, []string
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key string)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, []string
2025/10/11 16:12:24 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey 1 // *Kai
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member nil 2 // *Kai
2025/10/11 16:12:24 Val nil untyped nil
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member nil 2 // *Kai
2025/10/11 16:12:24 Val nil untyped nil
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member nil 2 // *Kai
2025/10/11 16:12:24 Val nil untyped nil
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member nil 2 // *Kai
2025/10/11 16:12:24 Val nil untyped nil
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/10/11 16:12:24 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []string 1 false
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member nil 2 // *Kai
2025/10/11 16:12:24 Val nil untyped nil
2025/10/11 16:12:24 NewClosure func(key string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 3 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 4 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType []string, []string
2025/10/11 16:12:24 ==> MatchType untyped nil, []string
2025/10/11 16:12:24 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey 1 // *Kai
2025/10/11 16:12:24 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:24 NewClosure func() int
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, x int, y int) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), int
2025/10/11 16:12:24 ==> MatchType func() int, int
2025/10/11 16:12:24 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), []string
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a []string, b []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, x int, y int) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped int (100), int
2025/10/11 16:12:24 ==> MatchType untyped int (200), int
2025/10/11 16:12:24 Val this *Kai
2025/10/11 16:12:24 Member onKey2 1 // *Kai
2025/10/11 16:12:24 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:24 NewClosure func(key string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/10/11 16:12:24 ==> MatchType *Kai, any
2025/10/11 16:12:24 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:24 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val Game Game
2025/10/11 16:12:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai} => Typ Game
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member Main 0 // *Game
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestSpxOverload (0.00s)
    --- PASS: TestSpxOverload/gopSpxTest (0.00s)
=== RUN   TestTestClassFile
=== RUN   TestTestClassFile/gopSpxTest
2025/10/11 16:12:24 ==> ClassFile /foo/Foo_xtest.gox
2025/10/11 16:12:24 ==> Import github.com/goplus/xgo/test
2025/10/11 16:12:24 ==> NewTemplateRecvMethod App TestMain
2025/10/11 16:12:24 ==> NewTemplateRecvMethod Case TestMain
2025/10/11 16:12:24 ==> InitClass Foo isProj: false
2025/10/11 16:12:24 ==> ClassFile /foo/main_xtest.gox
2025/10/11 16:12:24 ==> InitClass main isProj: true
2025/10/11 16:12:24 ==> Preload type caseFoo
2025/10/11 16:12:24 ==> Preload method caseFoo.Main
2025/10/11 16:12:24 ==> Preload type App
2025/10/11 16:12:24 ==> Preload method App.MainEntry
2025/10/11 16:12:24 ==> Load > NewType caseFoo
2025/10/11 16:12:24 NewType caseFoo
2025/10/11 16:12:24 ==> Load > NewType App
2025/10/11 16:12:24 NewType App
2025/10/11 16:12:24 ==> Load > InitType App
2025/10/11 16:12:24 InitType App struct{github.com/goplus/xgo/test.App}
2025/10/11 16:12:24 ==> LookupParent App => type App struct{github.com/goplus/xgo/test.App}
2025/10/11 16:12:24 ==> Load method *App.MainEntry
2025/10/11 16:12:24 ==> Load > InitType caseFoo
2025/10/11 16:12:24 InitType caseFoo struct{github.com/goplus/xgo/test.Case}
2025/10/11 16:12:24 ==> LookupParent caseFoo => type caseFoo struct{github.com/goplus/xgo/test.Case}
2025/10/11 16:12:24 ==> Load method *caseFoo.Main
2025/10/11 16:12:24 NewFunc TestFoo func(t *testing.T)
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val caseFoo caseFoo
2025/10/11 16:12:24 Val type caseFoo struct{github.com/goplus/xgo/test.Case} => Typ caseFoo
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member TestMain 0 // *caseFoo
2025/10/11 16:12:24 Val t *testing.T
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(c interface{initCase(t *testing.T)}, t *testing.T) args: 2 flags: 16
2025/10/11 16:12:24 ==> MatchType *caseFoo, interface{initCase(t *testing.T)}
2025/10/11 16:12:24 ==> MatchType *testing.T, *testing.T
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc TestMain func(m *testing.M)
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val App App
2025/10/11 16:12:24 Val type App struct{github.com/goplus/xgo/test.App} => Typ App
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member TestMain 0 // *App
2025/10/11 16:12:24 Val m *testing.M
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(app interface{initApp(m *testing.M)}, m *testing.M) args: 2 flags: 16
2025/10/11 16:12:24 ==> MatchType *App, interface{initApp(m *testing.M)}
2025/10/11 16:12:24 ==> MatchType *testing.M, *testing.M
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc MainEntry (*App) func()
2025/10/11 16:12:24 Val this *App
2025/10/11 16:12:24 Member println 1 // *App
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*caseFoo) func()
2025/10/11 16:12:24 Val this *caseFoo
2025/10/11 16:12:24 Member t 2 // *caseFoo
2025/10/11 16:12:24 Call 0 0 // func() *testing.T
2025/10/11 16:12:24 ==> MatchFuncCall func() *testing.T args: 0 flags: 0
2025/10/11 16:12:24 Member log 1 // *testing.T
2025/10/11 16:12:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(args ...any)
2025/10/11 16:12:24 ==> MatchFuncCall func(args ...any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:24 Val this *caseFoo
2025/10/11 16:12:24 Member t 2 // *caseFoo
2025/10/11 16:12:24 Call 0 0 // func() *testing.T
2025/10/11 16:12:24 ==> MatchFuncCall func() *testing.T args: 0 flags: 0
2025/10/11 16:12:24 Member run 1 // *testing.T
2025/10/11 16:12:24 Val &{0 STRING "a test"} *ast.BasicLit
2025/10/11 16:12:24 NewClosure func(t *testing.T)
2025/10/11 16:12:24 Val t *testing.T
2025/10/11 16:12:24 Member fatal 1 // *testing.T
2025/10/11 16:12:24 Val &{0 STRING "failed"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(args ...any)
2025/10/11 16:12:24 ==> MatchFuncCall func(args ...any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("failed"), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 2 0 // func(name string, f func(t *testing.T)) bool
2025/10/11 16:12:24 ==> MatchFuncCall func(name string, f func(t *testing.T)) bool args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("a test"), string
2025/10/11 16:12:24 ==> MatchType func(t *testing.T), func(t *testing.T)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile _test
--- PASS: TestTestClassFile (0.38s)
    --- PASS: TestTestClassFile/gopSpxTest (0.38s)
=== RUN   TestTestClassFile2
=== RUN   TestTestClassFile2/gopSpxTest
2025/10/11 16:12:24 ==> ClassFile /foo/foo_xtest.gox
2025/10/11 16:12:24 ==> InitClass foo isProj: false
2025/10/11 16:12:24 ==> Preload type case_foo
2025/10/11 16:12:24 ==> Preload method case_foo.Main
2025/10/11 16:12:24 ==> Preload type main
2025/10/11 16:12:24 ==> Preload method main.Main
2025/10/11 16:12:24 ==> Load > NewType case_foo
2025/10/11 16:12:24 NewType case_foo
2025/10/11 16:12:24 ==> Load > NewType main
2025/10/11 16:12:24 NewType main
2025/10/11 16:12:24 ==> Load > InitType case_foo
2025/10/11 16:12:24 InitType case_foo struct{github.com/goplus/xgo/test.Case}
2025/10/11 16:12:24 ==> LookupParent case_foo => type case_foo struct{github.com/goplus/xgo/test.Case}
2025/10/11 16:12:24 ==> Load method *case_foo.Main
2025/10/11 16:12:24 ==> Load > InitType main
2025/10/11 16:12:24 InitType main struct{}
2025/10/11 16:12:24 ==> LookupParent main => type main struct{}
2025/10/11 16:12:24 ==> Load method *main.Main
2025/10/11 16:12:24 NewFunc Test_foo func(t *testing.T)
2025/10/11 16:12:24 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 Val case_foo case_foo
2025/10/11 16:12:24 Val type case_foo struct{github.com/goplus/xgo/test.Case} => Typ case_foo
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:24 Member TestMain 0 // *case_foo
2025/10/11 16:12:24 Val t *testing.T
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(c interface{initCase(t *testing.T)}, t *testing.T) args: 2 flags: 16
2025/10/11 16:12:24 ==> MatchType *case_foo, interface{initCase(t *testing.T)}
2025/10/11 16:12:24 ==> MatchType *testing.T, *testing.T
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*case_foo) func()
2025/10/11 16:12:24 Val this *case_foo
2025/10/11 16:12:24 Member t 2 // *case_foo
2025/10/11 16:12:24 Call 0 0 // func() *testing.T
2025/10/11 16:12:24 ==> MatchFuncCall func() *testing.T args: 0 flags: 0
2025/10/11 16:12:24 Member log 1 // *testing.T
2025/10/11 16:12:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(args ...any)
2025/10/11 16:12:24 ==> MatchFuncCall func(args ...any) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Main (*main) func()
2025/10/11 16:12:24 Val this *main
2025/10/11 16:12:24 Member println 1 // *main
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile _test
--- PASS: TestTestClassFile2 (0.00s)
    --- PASS: TestTestClassFile2/gopSpxTest (0.00s)
=== RUN   TestGopxNoFunc
2025/10/11 16:12:24 ==> Preload type foo
2025/10/11 16:12:24 ==> Load > NewType foo
2025/10/11 16:12:24 NewType foo
2025/10/11 16:12:24 ==> Load > InitType foo
2025/10/11 16:12:24 InitType foo struct{a int}
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestGopxNoFunc (0.00s)
=== RUN   TestGopxOverload
2025/10/11 16:12:24 ==> Preload type Rect
2025/10/11 16:12:24 ==> Preload method Rect.addString
2025/10/11 16:12:24 ==> Preload method Rect.addInt
2025/10/11 16:12:24 ==> Preload method Rect.add__1
2025/10/11 16:12:24 NewConstDefs
2025/10/11 16:12:24 ==> Preload const [Gopo_Rect_add]
2025/10/11 16:12:24 ==> Load > NewType Rect
2025/10/11 16:12:24 NewType Rect
2025/10/11 16:12:24 ==> Load > InitType Rect
2025/10/11 16:12:24 InitType Rect struct{}
2025/10/11 16:12:24 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Rect.addString
2025/10/11 16:12:24 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Rect.addInt
2025/10/11 16:12:24 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Rect.add__1
2025/10/11 16:12:24 ==> Load const [Gopo_Rect_add] <nil>
2025/10/11 16:12:24 NewConst [Gopo_Rect_add] 0
2025/10/11 16:12:24 Val &{0 STRING ".addInt,,.addString"} *ast.BasicLit
2025/10/11 16:12:24 EndInit 1
2025/10/11 16:12:24 ==> NewOverloadMethod Rect add
2025/10/11 16:12:24 NewFunc addString (*github.com/goplus/xgo/cl.Rect) func(a string, b string) string
2025/10/11 16:12:24 Val a string
2025/10/11 16:12:24 Val b string
2025/10/11 16:12:24 BinaryOp +
2025/10/11 16:12:24 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:24 ==> MatchType string, unboundFuncParam{typ: string}
2025/10/11 16:12:24 Return 1
2025/10/11 16:12:24 ==> MatchType string, string
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc addInt (*github.com/goplus/xgo/cl.Rect) func(a int, b int) int
2025/10/11 16:12:24 Val a int
2025/10/11 16:12:24 Val b int
2025/10/11 16:12:24 BinaryOp +
2025/10/11 16:12:24 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:24 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:24 Return 1
2025/10/11 16:12:24 ==> MatchType int, int
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc add__1 (*github.com/goplus/xgo/cl.Rect) func(a float64, b float64) float64
2025/10/11 16:12:24 Val a float64
2025/10/11 16:12:24 Val b float64
2025/10/11 16:12:24 BinaryOp +
2025/10/11 16:12:24 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:24 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:24 Return 1
2025/10/11 16:12:24 ==> MatchType float64, float64
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestGopxOverload (0.00s)
=== RUN   TestClassFileGopx
2025/10/11 16:12:24 ==> Preload type Rect
2025/10/11 16:12:24 ==> Preload type BaseClass
2025/10/11 16:12:24 ==> Preload type AggClass
2025/10/11 16:12:24 ==> Preload method Rect.Area
2025/10/11 16:12:24 ==> Load > NewType Rect
2025/10/11 16:12:24 NewType Rect
2025/10/11 16:12:24 ==> Load > NewType BaseClass
2025/10/11 16:12:24 NewType BaseClass
2025/10/11 16:12:24 ==> Load > InitType BaseClass
2025/10/11 16:12:24 InitType BaseClass struct{x int; y int}
2025/10/11 16:12:24 ==> Load > NewType AggClass
2025/10/11 16:12:24 NewType AggClass
2025/10/11 16:12:24 ==> Load > InitType AggClass
2025/10/11 16:12:24 InitType AggClass struct{}
2025/10/11 16:12:24 ==> Load > InitType Rect
2025/10/11 16:12:24 ==> LookupParent BaseClass => type github.com/goplus/xgo/cl.BaseClass struct{x int; y int}
2025/10/11 16:12:24 ==> LookupParent AggClass => type github.com/goplus/xgo/cl.AggClass struct{}
2025/10/11 16:12:24 InitType Rect struct{github.com/goplus/xgo/cl.BaseClass; Width float64; Height float64; *github.com/goplus/xgo/cl.AggClass}
2025/10/11 16:12:24 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{github.com/goplus/xgo/cl.BaseClass; Width float64; Height float64; *github.com/goplus/xgo/cl.AggClass}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Rect.Area
2025/10/11 16:12:24 NewFunc Area (*github.com/goplus/xgo/cl.Rect) func() float64
2025/10/11 16:12:24 Val this *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:24 Member Width 2 // *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:24 Val this *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:24 Member Height 2 // *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:24 BinaryOp *
2025/10/11 16:12:24 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:24 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:24 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:24 Return 1
2025/10/11 16:12:24 ==> MatchType float64, float64
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
2025/10/11 16:12:24 ==> Preload type Rect
2025/10/11 16:12:24 ==> Preload method Rect.test
2025/10/11 16:12:24 ==> Load > NewType Rect
2025/10/11 16:12:24 NewType Rect
2025/10/11 16:12:24 ==> Load > InitType Rect
2025/10/11 16:12:24 InitType Rect struct{bytes.Buffer}
2025/10/11 16:12:24 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{bytes.Buffer}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Rect.test
2025/10/11 16:12:24 NewFunc test (*github.com/goplus/xgo/cl.Rect) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
2025/10/11 16:12:24 ==> Preload type Rect
2025/10/11 16:12:24 ==> Preload method Rect.test
2025/10/11 16:12:24 ==> Load > NewType Rect
2025/10/11 16:12:24 NewType Rect
2025/10/11 16:12:24 ==> Load > InitType Rect
2025/10/11 16:12:24 InitType Rect struct{*bytes.Buffer}
2025/10/11 16:12:24 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{*bytes.Buffer}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Rect.test
2025/10/11 16:12:24 NewFunc test (*github.com/goplus/xgo/cl.Rect) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
2025/10/11 16:12:24 ==> Preload type Rect
2025/10/11 16:12:24 ==> Preload method Rect.test
2025/10/11 16:12:24 ==> Load > NewType Rect
2025/10/11 16:12:24 NewType Rect
2025/10/11 16:12:24 ==> Load > InitType Rect
2025/10/11 16:12:24 InitType Rect struct{*bytes.Buffer "spec:\"buffer\""; a int "json:\"a\""; b int}
2025/10/11 16:12:24 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{*bytes.Buffer "spec:\"buffer\""; a int "json:\"a\""; b int}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Rect.test
2025/10/11 16:12:24 NewFunc test (*github.com/goplus/xgo/cl.Rect) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestClassFileGopx (0.00s)
=== RUN   TestClassFileMember
2025/10/11 16:12:24 ==> Preload type Rect
2025/10/11 16:12:24 ==> Preload type Engine
2025/10/11 16:12:24 ==> Preload method Engine.EnterPointerLock
2025/10/11 16:12:24 ==> Preload method Engine.SetEnable
2025/10/11 16:12:24 ==> Preload method Rect.Engine
2025/10/11 16:12:24 ==> Preload method Rect.Test
2025/10/11 16:12:24 ==> Load > NewType Rect
2025/10/11 16:12:24 NewType Rect
2025/10/11 16:12:24 ==> Load > NewType Engine
2025/10/11 16:12:24 NewType Engine
2025/10/11 16:12:24 ==> Load > InitType Engine
2025/10/11 16:12:24 InitType Engine struct{}
2025/10/11 16:12:24 ==> LookupParent Engine => type github.com/goplus/xgo/cl.Engine struct{}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Engine.EnterPointerLock
2025/10/11 16:12:24 ==> LookupParent Engine => type github.com/goplus/xgo/cl.Engine struct{}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Engine.SetEnable
2025/10/11 16:12:24 ==> Load > InitType Rect
2025/10/11 16:12:24 InitType Rect struct{}
2025/10/11 16:12:24 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Rect.Engine
2025/10/11 16:12:24 ==> LookupParent Engine => type github.com/goplus/xgo/cl.Engine struct{}
2025/10/11 16:12:24 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{}
2025/10/11 16:12:24 ==> Load method *github.com/goplus/xgo/cl.Rect.Test
2025/10/11 16:12:24 NewFunc EnterPointerLock (*github.com/goplus/xgo/cl.Engine) func()
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc SetEnable (*github.com/goplus/xgo/cl.Engine) func(b bool)
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Engine (*github.com/goplus/xgo/cl.Rect) func() *github.com/goplus/xgo/cl.Engine
2025/10/11 16:12:24 ==> LookupParent Engine => type github.com/goplus/xgo/cl.Engine struct{}
2025/10/11 16:12:24 StructLit github.com/goplus/xgo/cl.Engine 0 false
2025/10/11 16:12:24 UnaryOp & flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:24 Return 1
2025/10/11 16:12:24 ==> MatchType *github.com/goplus/xgo/cl.Engine, *github.com/goplus/xgo/cl.Engine
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 NewFunc Test (*github.com/goplus/xgo/cl.Rect) func()
2025/10/11 16:12:24 Val this *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:24 Member engine 2 // *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl.Engine
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.Engine args: 0 flags: 0
2025/10/11 16:12:24 Member setEnable 1 // *github.com/goplus/xgo/cl.Engine
2025/10/11 16:12:24 Val this *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:24 Member true 2 // *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:24 Val true untyped bool
2025/10/11 16:12:24 Call 1 0 // func(b bool)
2025/10/11 16:12:24 ==> MatchFuncCall func(b bool) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:24 Val this *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:24 Member engine 2 // *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:24 Call 0 0 // func() *github.com/goplus/xgo/cl.Engine
2025/10/11 16:12:24 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.Engine args: 0 flags: 0
2025/10/11 16:12:24 Member enterPointerLock 1 // *github.com/goplus/xgo/cl.Engine
2025/10/11 16:12:24 Call 0 0 // func()
2025/10/11 16:12:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestClassFileMember (0.00s)
=== RUN   TestTypeDoc
2025/10/11 16:12:24 ==> Preload type A
2025/10/11 16:12:24 ==> Load > NewType A
2025/10/11 16:12:24 NewType A
2025/10/11 16:12:24 ==> Load > InitType A
2025/10/11 16:12:24 InitType A int
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestTypeDoc (0.00s)
=== RUN   TestUnsafe
2025/10/11 16:12:24 ==> Preload func main
2025/10/11 16:12:24 ==> Load func main
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val Sizeof invalid type
2025/10/11 16:12:24 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:24 Call 1 0 // TyInstruction{gogen.unsafeSizeofInstr}
2025/10/11 16:12:24 ==> MatchFuncCall TyInstruction{gogen.unsafeSizeofInstr} args: 1 flags: 0
2025/10/11 16:12:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:24 ==> MatchType uintptr (8), any
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestUnsafe (0.00s)
=== RUN   Test_CastSlice_Issue1240
2025/10/11 16:12:24 ==> Preload type fvec
2025/10/11 16:12:24 ==> Preload type foo
2025/10/11 16:12:24 ==> Preload func main
2025/10/11 16:12:24 ==> Load > NewType fvec
2025/10/11 16:12:24 NewType fvec
2025/10/11 16:12:24 ==> Load > InitType fvec
2025/10/11 16:12:24 InitType fvec []float64
2025/10/11 16:12:24 ==> Load > NewType foo
2025/10/11 16:12:24 NewType foo
2025/10/11 16:12:24 ==> Load > InitType foo
2025/10/11 16:12:24 InitType foo float64
2025/10/11 16:12:24 ==> Load func main
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 DefineVarStart [a]
2025/10/11 16:12:24 Typ []float64
2025/10/11 16:12:24 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:24 SliceLit []float64 2 false
2025/10/11 16:12:24 EndInit 1
2025/10/11 16:12:24 DefineVarStart [b]
2025/10/11 16:12:24 Val fvec github.com/goplus/xgo/cl.fvec
2025/10/11 16:12:24 Val type github.com/goplus/xgo/cl.fvec []float64 => Typ github.com/goplus/xgo/cl.fvec
2025/10/11 16:12:24 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:24 SliceLit github.com/goplus/xgo/cl.fvec 2 false
2025/10/11 16:12:24 EndInit 1
2025/10/11 16:12:24 DefineVarStart [c]
2025/10/11 16:12:24 Val foo github.com/goplus/xgo/cl.foo
2025/10/11 16:12:24 Val type github.com/goplus/xgo/cl.foo float64 => Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:24 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:24 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:24 SliceLit <nil> 2 false
2025/10/11 16:12:24 Call 1 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:24 ==> MatchFuncCall TypeType{typ: github.com/goplus/xgo/cl.foo} args: 1 flags: 0
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:24 EndInit 1
2025/10/11 16:12:24 DefineVarStart [d]
2025/10/11 16:12:24 Val fvec github.com/goplus/xgo/cl.fvec
2025/10/11 16:12:24 Val type github.com/goplus/xgo/cl.fvec []float64 => Typ github.com/goplus/xgo/cl.fvec
2025/10/11 16:12:24 SliceLit github.com/goplus/xgo/cl.fvec 0 false
2025/10/11 16:12:24 EndInit 1
2025/10/11 16:12:24 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 Val a []float64
2025/10/11 16:12:24 Val b github.com/goplus/xgo/cl.fvec
2025/10/11 16:12:24 Val c github.com/goplus/xgo/cl.foo
2025/10/11 16:12:24 Val d github.com/goplus/xgo/cl.fvec
2025/10/11 16:12:24 Call 4 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:24 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 0
2025/10/11 16:12:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 4 flags: 0
2025/10/11 16:12:24 ==> MatchType []float64, any
2025/10/11 16:12:24 ==> MatchType github.com/goplus/xgo/cl.fvec, any
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl.fvec
2025/10/11 16:12:24 ==> MatchType github.com/goplus/xgo/cl.foo, any
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:24 ==> MatchType github.com/goplus/xgo/cl.fvec, any
2025/10/11 16:12:24 ==> EnsureLoaded github.com/goplus/xgo/cl.fvec
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: Test_CastSlice_Issue1240 (0.00s)
=== RUN   TestUnderscoreRedeclared_Issue1197
2025/10/11 16:12:24 ==> Preload func main
2025/10/11 16:12:24 ==> Load func main
2025/10/11 16:12:24 NewFunc main func()
2025/10/11 16:12:24 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:24 NewClosure func() (_ [2]int)
2025/10/11 16:12:24 Return 0
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 Call 0 0 // func() (_ [2]int)
2025/10/11 16:12:24 ==> MatchFuncCall func() (_ [2]int) args: 0 flags: 0
2025/10/11 16:12:24 End // Func
2025/10/11 16:12:24 ==> ASTFile
--- PASS: TestUnderscoreRedeclared_Issue1197 (0.00s)
=== RUN   TestInterfaceBugNilUnderlying_Issue1198
2025/10/11 16:12:25 ==> Preload type Outer
2025/10/11 16:12:25 ==> Preload type impl
2025/10/11 16:12:25 ==> Preload func New
2025/10/11 16:12:25 ==> Preload type Inner
2025/10/11 16:12:25 ==> Preload method impl.DoStuff
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load > NewType Outer
2025/10/11 16:12:25 NewType Outer
2025/10/11 16:12:25 ==> Load > InitType Outer
2025/10/11 16:12:25 ==> Load > NewType Inner
2025/10/11 16:12:25 NewType Inner
2025/10/11 16:12:25 ==> Lookup (LoadSymbol) Inner => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:25 ==> Load > InitType Inner
2025/10/11 16:12:25 InitType Inner interface{DoStuff() error}
2025/10/11 16:12:25 InitType Outer interface{github.com/goplus/xgo/cl.Inner}
2025/10/11 16:12:25 ==> Load > NewType impl
2025/10/11 16:12:25 NewType impl
2025/10/11 16:12:25 ==> Load > InitType impl
2025/10/11 16:12:25 InitType impl struct{}
2025/10/11 16:12:25 ==> LookupParent impl => type github.com/goplus/xgo/cl.impl struct{}
2025/10/11 16:12:25 ==> Load method *github.com/goplus/xgo/cl.impl.DoStuff
2025/10/11 16:12:25 ==> Load func New
2025/10/11 16:12:25 ==> LookupParent Outer => type github.com/goplus/xgo/cl.Outer interface{github.com/goplus/xgo/cl.Inner}
2025/10/11 16:12:25 NewFunc New func() github.com/goplus/xgo/cl.Outer
2025/10/11 16:12:25 ==> LookupParent impl => type github.com/goplus/xgo/cl.impl struct{}
2025/10/11 16:12:25 StructLit github.com/goplus/xgo/cl.impl 0 false
2025/10/11 16:12:25 UnaryOp & flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType *github.com/goplus/xgo/cl.impl, github.com/goplus/xgo/cl.Outer
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.Outer
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 ==> LookupParent Outer => type github.com/goplus/xgo/cl.Outer interface{github.com/goplus/xgo/cl.Inner}
2025/10/11 16:12:25 ==> Load var github.com/goplus/xgo/cl.Outer [outer]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [outer]
2025/10/11 16:12:25 Val New func() github.com/goplus/xgo/cl.Outer
2025/10/11 16:12:25 Call 0 0 // func() github.com/goplus/xgo/cl.Outer
2025/10/11 16:12:25 ==> MatchFuncCall func() github.com/goplus/xgo/cl.Outer args: 0 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> MatchType github.com/goplus/xgo/cl.Outer, github.com/goplus/xgo/cl.Outer
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.Outer
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.Outer
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 NewFunc DoStuff (*github.com/goplus/xgo/cl.impl) func() error
2025/10/11 16:12:25 Val nil untyped nil
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType untyped nil, error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestInterfaceBugNilUnderlying_Issue1198 (0.15s)
=== RUN   TestInterfaceBugNilUnderlying_Issue1196
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Preload type I
2025/10/11 16:12:25 ==> Preload type T
2025/10/11 16:12:25 ==> Preload method T.M
2025/10/11 16:12:25 ==> Preload type A
2025/10/11 16:12:25 ==> Preload type B
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 DefineVarStart [i]
2025/10/11 16:12:25 ==> Load > NewType I
2025/10/11 16:12:25 NewType I
2025/10/11 16:12:25 Val I github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 Val %!v(PANIC=String method: nil underlying) => Typ github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 ==> Load > NewType A
2025/10/11 16:12:25 NewType A
2025/10/11 16:12:25 ==> Lookup (LoadSymbol) A => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:25 ==> Load > InitType A
2025/10/11 16:12:25 ==> Load > NewType T
2025/10/11 16:12:25 NewType T
2025/10/11 16:12:25 ==> Lookup (LoadSymbol) T => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:25 ==> Load > InitType T
2025/10/11 16:12:25 InitType T int
2025/10/11 16:12:25 ==> LookupParent T => type github.com/goplus/xgo/cl.T int
2025/10/11 16:12:25 ==> Load method github.com/goplus/xgo/cl.T.M
2025/10/11 16:12:25 InitType A struct{github.com/goplus/xgo/cl.T}
2025/10/11 16:12:25 StructLit github.com/goplus/xgo/cl.A 0 false
2025/10/11 16:12:25 Call 1 0 // TypeType{typ: github.com/goplus/xgo/cl.I}
2025/10/11 16:12:25 ==> MatchFuncCall TypeType{typ: github.com/goplus/xgo/cl.I} args: 1 flags: 0
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.A
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 ==> Load > InitType I
2025/10/11 16:12:25 InitType I interface{M() int}
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 DefineVarStart [b]
2025/10/11 16:12:25 Val make TyInstruction{gogen.makeInstr}
2025/10/11 16:12:25 ==> LookupParent I => type github.com/goplus/xgo/cl.I interface{M() int}
2025/10/11 16:12:25 Typ chan github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 Call 2 0 // TyInstruction{gogen.makeInstr}
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 2 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val b chan github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 ==> Load > NewType B
2025/10/11 16:12:25 NewType B
2025/10/11 16:12:25 ==> Lookup (LoadSymbol) B => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:25 ==> Load > InitType B
2025/10/11 16:12:25 ==> LookupParent T => type github.com/goplus/xgo/cl.T int
2025/10/11 16:12:25 InitType B struct{github.com/goplus/xgo/cl.T}
2025/10/11 16:12:25 StructLit github.com/goplus/xgo/cl.B 0 false
2025/10/11 16:12:25 Send
2025/10/11 16:12:25 ==> Load var bool [ok]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [ok]
2025/10/11 16:12:25 VarRef i github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 VarRef ok bool
2025/10/11 16:12:25 Val b chan github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 UnaryOp <- flags: 2
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 2
2025/10/11 16:12:25 Assign 2 1
2025/10/11 16:12:25 ==> MatchType github.com/goplus/xgo/cl.I, github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 ==> MatchType bool, bool
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 NewFunc M (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:25 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType untyped int (0), int
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestInterfaceBugNilUnderlying_Issue1196 (0.00s)
=== RUN   TestMyIntInc_Issue1195
2025/10/11 16:12:25 ==> Preload type MyInt
2025/10/11 16:12:25 ==> Preload var [c]
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load > NewType MyInt
2025/10/11 16:12:25 NewType MyInt
2025/10/11 16:12:25 ==> Load > InitType MyInt
2025/10/11 16:12:25 InitType MyInt int
2025/10/11 16:12:25 ==> LookupParent MyInt => type github.com/goplus/xgo/cl.MyInt int
2025/10/11 16:12:25 ==> Load var github.com/goplus/xgo/cl.MyInt [c]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [c]
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 VarRef c github.com/goplus/xgo/cl.MyInt
2025/10/11 16:12:25 IncDec ++
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestMyIntInc_Issue1195 (0.00s)
=== RUN   TestAutoPropMixedName_Issue1194
2025/10/11 16:12:25 ==> Preload type Point
2025/10/11 16:12:25 ==> Preload type Obj
2025/10/11 16:12:25 ==> Preload method Obj.Bbox
2025/10/11 16:12:25 ==> Preload method Obj.Points
2025/10/11 16:12:25 ==> Load > NewType Point
2025/10/11 16:12:25 NewType Point
2025/10/11 16:12:25 ==> Load > InitType Point
2025/10/11 16:12:25 InitType Point struct{Min int; Max int}
2025/10/11 16:12:25 ==> Load > NewType Obj
2025/10/11 16:12:25 NewType Obj
2025/10/11 16:12:25 ==> Load > InitType Obj
2025/10/11 16:12:25 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{Min int; Max int}
2025/10/11 16:12:25 InitType Obj struct{bbox github.com/goplus/xgo/cl.Point}
2025/10/11 16:12:25 ==> LookupParent Obj => type github.com/goplus/xgo/cl.Obj struct{bbox github.com/goplus/xgo/cl.Point}
2025/10/11 16:12:25 ==> Load method *github.com/goplus/xgo/cl.Obj.Bbox
2025/10/11 16:12:25 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{Min int; Max int}
2025/10/11 16:12:25 ==> LookupParent Obj => type github.com/goplus/xgo/cl.Obj struct{bbox github.com/goplus/xgo/cl.Point}
2025/10/11 16:12:25 ==> Load method *github.com/goplus/xgo/cl.Obj.Points
2025/10/11 16:12:25 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:25 NewFunc Bbox (*github.com/goplus/xgo/cl.Obj) func() github.com/goplus/xgo/cl.Point
2025/10/11 16:12:25 Val o *github.com/goplus/xgo/cl.Obj
2025/10/11 16:12:25 Member bbox 2 // *github.com/goplus/xgo/cl.Obj
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType github.com/goplus/xgo/cl.Point, github.com/goplus/xgo/cl.Point
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.Point
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.Point
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 NewFunc Points (*github.com/goplus/xgo/cl.Obj) func() [2]int
2025/10/11 16:12:25 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:25 Val o *github.com/goplus/xgo/cl.Obj
2025/10/11 16:12:25 Member bbox 2 // *github.com/goplus/xgo/cl.Obj
2025/10/11 16:12:25 Member Min 2 // github.com/goplus/xgo/cl.Point
2025/10/11 16:12:25 Val o *github.com/goplus/xgo/cl.Obj
2025/10/11 16:12:25 Member bbox 2 // *github.com/goplus/xgo/cl.Obj
2025/10/11 16:12:25 Member Max 2 // github.com/goplus/xgo/cl.Point
2025/10/11 16:12:25 ArrayLit [2]int 2 false
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType [2]int, [2]int
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestAutoPropMixedName_Issue1194 (0.00s)
=== RUN   TestShiftUntypedInt_Issue1193
2025/10/11 16:12:25 ==> Preload func GetValue
2025/10/11 16:12:25 ==> Load func GetValue
2025/10/11 16:12:25 NewFunc GetValue func(shift uint) uint
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 Val shift uint
2025/10/11 16:12:25 BinaryOp <<
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType uint, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType untyped int, uint
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestShiftUntypedInt_Issue1193 (0.00s)
=== RUN   TestInitFunc
2025/10/11 16:12:25 ==> Preload func init
2025/10/11 16:12:25 ==> Preload func init
2025/10/11 16:12:25 ==> Load func init
2025/10/11 16:12:25 NewFunc init func()
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> Load func init
2025/10/11 16:12:25 NewFunc init func()
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestInitFunc (0.00s)
=== RUN   TestSlogan
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 DefineVarStart [fields]
2025/10/11 16:12:25 Val &{0 STRING "engineering"} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 STRING "STEM education"} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 STRING "data science"} *ast.BasicLit
2025/10/11 16:12:25 SliceLit <nil> 3 false
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val &{0 STRING "The XGo Language for"} *ast.BasicLit
2025/10/11 16:12:25 Val fields []string
2025/10/11 16:12:25 Member join 1 // []string
2025/10/11 16:12:25 Val Join func(elems []string, sep string) string
2025/10/11 16:12:25 Val &{0 STRING ", "} *ast.BasicLit
2025/10/11 16:12:25 Call 2 0 // func(elems []string, sep string) string
2025/10/11 16:12:25 ==> MatchFuncCall func(elems []string, sep string) string args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType []string, []string
2025/10/11 16:12:25 ==> MatchType untyped string (", "), string
2025/10/11 16:12:25 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped string ("The XGo Language for"), any
2025/10/11 16:12:25 ==> MatchType string, any
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestSlogan (0.00s)
=== RUN   TestAssignPrintln
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 DefineVarStart [p]
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val p func(a ...any) (n int, err error)
2025/10/11 16:12:25 Val &{0 STRING "Hello world"} *ast.BasicLit
2025/10/11 16:12:25 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped string ("Hello world"), any
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestAssignPrintln (0.00s)
=== RUN   TestRedefineBuiltin
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Preload const [append]
2025/10/11 16:12:25 ==> Preload const [len]
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Load const [a] <nil>
2025/10/11 16:12:25 NewConst [a] 0
2025/10/11 16:12:25 ==> Load const [append] <nil>
2025/10/11 16:12:25 NewConst [append] 0
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load const [len]
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 Val append untyped int
2025/10/11 16:12:25 Val len untyped int
2025/10/11 16:12:25 BinaryOp +
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (0), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestRedefineBuiltin (0.00s)
=== RUN   TestTypeConvIssue804
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 DefineVarStart [c]
2025/10/11 16:12:25 Val make TyInstruction{gogen.makeInstr}
2025/10/11 16:12:25 Typ chan int
2025/10/11 16:12:25 Call 1 0 // TyInstruction{gogen.makeInstr}
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 1 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 DefineVarStart [d]
2025/10/11 16:12:25 Typ chan<- int
2025/10/11 16:12:25 Val c chan int
2025/10/11 16:12:25 Call 1 0 // TypeType{typ: chan<- int}
2025/10/11 16:12:25 ==> MatchFuncCall TypeType{typ: chan<- int} args: 1 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 DefineVarStart [e]
2025/10/11 16:12:25 Typ <-chan int
2025/10/11 16:12:25 Val c chan int
2025/10/11 16:12:25 Call 1 0 // TypeType{typ: <-chan int}
2025/10/11 16:12:25 ==> MatchFuncCall TypeType{typ: <-chan int} args: 1 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 DefineVarStart [f]
2025/10/11 16:12:25 Val int int
2025/10/11 16:12:25 Val type int => Typ int
2025/10/11 16:12:25 Star
2025/10/11 16:12:25 Val nil untyped nil
2025/10/11 16:12:25 Call 1 0 // TypeType{typ: *int}
2025/10/11 16:12:25 ==> MatchFuncCall TypeType{typ: *int} args: 1 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 DefineVarStart [a]
2025/10/11 16:12:25 Val c chan int
2025/10/11 16:12:25 Val d chan<- int
2025/10/11 16:12:25 BinaryOp ==
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 DefineVarStart [b]
2025/10/11 16:12:25 Val c chan int
2025/10/11 16:12:25 Val e <-chan int
2025/10/11 16:12:25 BinaryOp ==
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestTypeConvIssue804 (0.00s)
=== RUN   TestUntypedFloatIssue798
2025/10/11 16:12:25 ==> Preload func isPow10
2025/10/11 16:12:25 ==> Load func isPow10
2025/10/11 16:12:25 NewFunc isPow10 func(x uint64) bool
2025/10/11 16:12:25 Switch
2025/10/11 16:12:25 Val x uint64
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Case
2025/10/11 16:12:25 Val &{0 FLOAT 1e0} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e1} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e2} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e3} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e4} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e5} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e6} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e7} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e8} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e9} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e10} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e11} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e12} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e13} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e14} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e15} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e16} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e17} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e18} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 FLOAT 1e19} *ast.BasicLit
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Val true untyped bool
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:25 End // Case
2025/10/11 16:12:25 End // Switch
2025/10/11 16:12:25 Val false untyped bool
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType untyped bool (false), bool
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestUntypedFloatIssue798 (0.00s)
=== RUN   TestInterfaceIssue795
2025/10/11 16:12:25 ==> Preload type I
2025/10/11 16:12:25 ==> Preload type T1
2025/10/11 16:12:25 ==> Preload method T1.a
2025/10/11 16:12:25 ==> Preload method T1.b
2025/10/11 16:12:25 ==> Load > NewType I
2025/10/11 16:12:25 NewType I
2025/10/11 16:12:25 ==> Load > InitType I
2025/10/11 16:12:25 ==> LookupParent I => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:25 InitType I interface{a(s string) github.com/goplus/xgo/cl.I; b(s string) string}
2025/10/11 16:12:25 ==> Load > NewType T1
2025/10/11 16:12:25 NewType T1
2025/10/11 16:12:25 ==> Load > InitType T1
2025/10/11 16:12:25 InitType T1 int
2025/10/11 16:12:25 ==> LookupParent T1 => type github.com/goplus/xgo/cl.T1 int
2025/10/11 16:12:25 ==> Load method github.com/goplus/xgo/cl.T1.a
2025/10/11 16:12:25 ==> LookupParent I => type github.com/goplus/xgo/cl.I interface{a(s string) github.com/goplus/xgo/cl.I; b(s string) string}
2025/10/11 16:12:25 ==> LookupParent T1 => type github.com/goplus/xgo/cl.T1 int
2025/10/11 16:12:25 ==> Load method github.com/goplus/xgo/cl.T1.b
2025/10/11 16:12:25 NewFunc a (github.com/goplus/xgo/cl.T1) func(s string) github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 Val t github.com/goplus/xgo/cl.T1
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType github.com/goplus/xgo/cl.T1, github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.I
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 NewFunc b (github.com/goplus/xgo/cl.T1) func(s string) string
2025/10/11 16:12:25 Val s string
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType string, string
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestInterfaceIssue795 (0.00s)
=== RUN   TestChanRecvIssue789
2025/10/11 16:12:25 ==> Preload func foo
2025/10/11 16:12:25 ==> Load func foo
2025/10/11 16:12:25 NewFunc foo func(ch chan int) (int, bool)
2025/10/11 16:12:25 DefineVarStart [x ok]
2025/10/11 16:12:25 Val ch chan int
2025/10/11 16:12:25 UnaryOp <- flags: 2
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 2
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val x int
2025/10/11 16:12:25 Val ok bool
2025/10/11 16:12:25 Return 2
2025/10/11 16:12:25 ==> MatchType int, int
2025/10/11 16:12:25 ==> MatchType bool, bool
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestChanRecvIssue789 (0.00s)
=== RUN   TestNamedChanCloseIssue790
2025/10/11 16:12:25 ==> Preload type XChan
2025/10/11 16:12:25 ==> Preload func foo
2025/10/11 16:12:25 ==> Load > NewType XChan
2025/10/11 16:12:25 NewType XChan
2025/10/11 16:12:25 ==> Load > InitType XChan
2025/10/11 16:12:25 InitType XChan chan int
2025/10/11 16:12:25 ==> Load func foo
2025/10/11 16:12:25 ==> LookupParent XChan => type github.com/goplus/xgo/cl.XChan chan int
2025/10/11 16:12:25 NewFunc foo func(ch github.com/goplus/xgo/cl.XChan)
2025/10/11 16:12:25 Val close TemplateSignature{func(c unboundProxyParam{typ: chan<- TemplateParamType{name: Type}})}
2025/10/11 16:12:25 Val ch github.com/goplus/xgo/cl.XChan
2025/10/11 16:12:25 Call 1 0 // TemplateSignature{func(c unboundProxyParam{typ: chan<- TemplateParamType{name: Type}})}
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(c unboundProxyParam{typ: chan<- TemplateParamType{name: Type}})} args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType chan int, unboundProxyParam{typ: chan<- unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestNamedChanCloseIssue790 (0.00s)
=== RUN   TestUntypedFloatIssue793
2025/10/11 16:12:25 ==> Preload var [a]
2025/10/11 16:12:25 Val &{0 FLOAT 1e1} *ast.BasicLit
2025/10/11 16:12:25 ==> Load var [10]int [a]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [a]
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestUntypedFloatIssue793 (0.00s)
=== RUN   TestUntypedFloatIssue788
2025/10/11 16:12:25 ==> Preload func foo
2025/10/11 16:12:25 ==> Load func foo
2025/10/11 16:12:25 NewFunc foo func(v int) bool
2025/10/11 16:12:25 Val v int
2025/10/11 16:12:25 Val &{0 FLOAT 1.1e5} *ast.BasicLit
2025/10/11 16:12:25 BinaryOp >
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped float (110000), unboundFuncParam{typ: int}
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType untyped bool, bool
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestUntypedFloatIssue788 (0.00s)
=== RUN   TestSwitchCompositeLitIssue801
2025/10/11 16:12:25 ==> Preload type T
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load > NewType T
2025/10/11 16:12:25 NewType T
2025/10/11 16:12:25 ==> Load > InitType T
2025/10/11 16:12:25 InitType T struct{X int}
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 Switch
2025/10/11 16:12:25 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{X int}
2025/10/11 16:12:25 StructLit github.com/goplus/xgo/cl.T 0 false
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Case
2025/10/11 16:12:25 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{X int}
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 StructLit github.com/goplus/xgo/cl.T 1 false
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Val panic func(v interface{})
2025/10/11 16:12:25 Val &{0 STRING "bad"} *ast.BasicLit
2025/10/11 16:12:25 Call 1 0 // func(v interface{})
2025/10/11 16:12:25 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped string ("bad"), interface{}
2025/10/11 16:12:25 End // Case
2025/10/11 16:12:25 End // Switch
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestSwitchCompositeLitIssue801 (0.00s)
=== RUN   TestConstIssue800
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Preload const [h0_0 h0_1]
2025/10/11 16:12:25 ==> Preload const [h1_0 h1_1]
2025/10/11 16:12:25 ==> Load const [h0_0 h0_1] <nil>
2025/10/11 16:12:25 NewConst [h0_0 h0_1] 0
2025/10/11 16:12:25 Val &{0 FLOAT 1.0} *ast.BasicLit
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 BinaryOp +
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (0), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:25 BinaryOp /
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped float (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped float}
2025/10/11 16:12:25 Val &{0 FLOAT 1.0} *ast.BasicLit
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:25 BinaryOp +
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (0), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (2), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:25 BinaryOp /
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped float (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (2), unboundFuncParam{typ: untyped float}
2025/10/11 16:12:25 EndInit 2
2025/10/11 16:12:25 ==> Load const [h1_0 h1_1]
2025/10/11 16:12:25 Val &{0 FLOAT 1.0} *ast.BasicLit
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 BinaryOp +
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:25 BinaryOp /
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped float (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (2), unboundFuncParam{typ: untyped float}
2025/10/11 16:12:25 Val &{0 FLOAT 1.0} *ast.BasicLit
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:25 BinaryOp +
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (2), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:25 BinaryOp /
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped float (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped float}
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestConstIssue800 (0.00s)
=== RUN   TestConstIssue805
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Preload const [n1]
2025/10/11 16:12:25 ==> Preload const [d1]
2025/10/11 16:12:25 ==> Preload const [q1]
2025/10/11 16:12:25 ==> Preload const [r1]
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Preload const [ret1]
2025/10/11 16:12:25 ==> Preload const [ret2]
2025/10/11 16:12:25 ==> Preload const [ret3]
2025/10/11 16:12:25 ==> Load const [n1] <nil>
2025/10/11 16:12:25 NewConst [n1] 0
2025/10/11 16:12:25 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:25 UnaryOp + flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (5), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load const [d1] <nil>
2025/10/11 16:12:25 NewConst [d1] 1
2025/10/11 16:12:25 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:25 UnaryOp + flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load const [q1] <nil>
2025/10/11 16:12:25 NewConst [q1] 2
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 UnaryOp + flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load const [r1] <nil>
2025/10/11 16:12:25 NewConst [r1] 3
2025/10/11 16:12:25 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:25 UnaryOp + flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (2), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load const [ret1] <nil>
2025/10/11 16:12:25 NewConst [ret1] 0
2025/10/11 16:12:25 Val n1 untyped int
2025/10/11 16:12:25 Val d1 untyped int
2025/10/11 16:12:25 BinaryOp /
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (5), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:25 Val q1 untyped int
2025/10/11 16:12:25 BinaryOp !=
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load const [ret2] <nil>
2025/10/11 16:12:25 NewConst [ret2] 1
2025/10/11 16:12:25 Val n1 untyped int
2025/10/11 16:12:25 Val d1 untyped int
2025/10/11 16:12:25 BinaryOp %
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (5), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:25 Val r1 untyped int
2025/10/11 16:12:25 BinaryOp !=
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load const [ret3] <nil>
2025/10/11 16:12:25 NewConst [ret3] 2
2025/10/11 16:12:25 Val n1 untyped int
2025/10/11 16:12:25 Val d1 untyped int
2025/10/11 16:12:25 BinaryOp /
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (5), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:25 Val q1 untyped int
2025/10/11 16:12:25 BinaryOp !=
2025/10/11 16:12:25 Val n1 untyped int
2025/10/11 16:12:25 Val d1 untyped int
2025/10/11 16:12:25 BinaryOp %
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (5), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:25 Val r1 untyped int
2025/10/11 16:12:25 BinaryOp !=
2025/10/11 16:12:25 BinaryOp ||
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped bool (false), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped bool (false), unboundFuncParam{typ: untyped bool}
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestConstIssue805 (0.00s)
=== RUN   TestUntypedNilIssue806
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 Switch
2025/10/11 16:12:25 DefineVarStart [f]
2025/10/11 16:12:25 NewClosure func()
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val f func()
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Case
2025/10/11 16:12:25 Val nil untyped nil
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 End // Case
2025/10/11 16:12:25 End // Switch
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestUntypedNilIssue806 (0.00s)
=== RUN   TestSwitchIssue807
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 Switch
2025/10/11 16:12:25 None
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Case
2025/10/11 16:12:25 Typ interface{}
2025/10/11 16:12:25 Val true untyped bool
2025/10/11 16:12:25 Call 1 0 // TypeType{typ: interface{}}
2025/10/11 16:12:25 ==> MatchFuncCall TypeType{typ: interface{}} args: 1 flags: 0
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 End // Case
2025/10/11 16:12:25 End // Switch
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestSwitchIssue807 (0.00s)
=== RUN   TestUntypedComplexIssue799
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Preload const [ulp1]
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Preload const [ulp2]
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load const [ulp1] <nil>
2025/10/11 16:12:25 NewConst [ulp1] 0
2025/10/11 16:12:25 Val imag func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val &{0 IMAG 1i} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 IMAG 2i} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:25 BinaryOp /
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 2i)), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped complex}
2025/10/11 16:12:25 BinaryOp +
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 1i)), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 0.666667i)), unboundFuncParam{typ: untyped complex}
2025/10/11 16:12:25 Val &{0 IMAG 5i} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:25 BinaryOp /
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 5i)), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped complex}
2025/10/11 16:12:25 BinaryOp -
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 1.66667i)), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 1.66667i)), unboundFuncParam{typ: untyped complex}
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(c untyped complex) untyped float args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 0i)), untyped complex
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load const [ulp2] <nil>
2025/10/11 16:12:25 NewConst [ulp2] 0
2025/10/11 16:12:25 Val imag func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val &{0 IMAG 1i} *ast.BasicLit
2025/10/11 16:12:25 Val complex func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:25 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(r untyped float, i untyped float) untyped complex args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (0), untyped float
2025/10/11 16:12:25 ==> MatchType untyped int (2), untyped float
2025/10/11 16:12:25 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:25 BinaryOp /
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 2i)), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped complex}
2025/10/11 16:12:25 BinaryOp +
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 1i)), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 0.666667i)), unboundFuncParam{typ: untyped complex}
2025/10/11 16:12:25 Val &{0 IMAG 5i} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:25 BinaryOp /
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 5i)), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped complex}
2025/10/11 16:12:25 BinaryOp -
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 1.66667i)), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 1.66667i)), unboundFuncParam{typ: untyped complex}
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(c untyped complex) untyped float args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped complex ((0 + 0i)), untyped complex
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Load const [a] <nil>
2025/10/11 16:12:25 NewConst [a] 0
2025/10/11 16:12:25 Val ulp1 untyped float
2025/10/11 16:12:25 Val ulp2 untyped float
2025/10/11 16:12:25 BinaryOp ==
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestUntypedComplexIssue799 (0.00s)
=== RUN   TestUnderscoreConstAndVar
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Preload const [c0]
2025/10/11 16:12:25 ==> Preload const [_]
2025/10/11 16:12:25 ==> Preload const [_]
2025/10/11 16:12:25 ==> Preload const [_]
2025/10/11 16:12:25 ==> Preload const [c4]
2025/10/11 16:12:25 ==> Preload func i
2025/10/11 16:12:25 ==> Preload var [_]
2025/10/11 16:12:25 ==> Preload var [_]
2025/10/11 16:12:25 ==> Load const [c0] <nil>
2025/10/11 16:12:25 NewConst [c0] 0
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 BinaryOp <<
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (0), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load const [_]
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 BinaryOp <<
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> Load const [_]
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 BinaryOp <<
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (2), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> Load const [_]
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 BinaryOp <<
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (3), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> Load const [c4]
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 Val iota untyped int
2025/10/11 16:12:25 BinaryOp <<
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped int (4), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> Load func i
2025/10/11 16:12:25 NewFunc i func() int
2025/10/11 16:12:25 Val &{0 INT 23} *ast.BasicLit
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType untyped int (23), int
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> Load var <nil> [_]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [_]
2025/10/11 16:12:25 Val i func() int
2025/10/11 16:12:25 Call 0 0 // func() int
2025/10/11 16:12:25 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load var <nil> [_]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [_]
2025/10/11 16:12:25 Val i func() int
2025/10/11 16:12:25 Call 0 0 // func() int
2025/10/11 16:12:25 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestUnderscoreConstAndVar (0.00s)
=== RUN   TestUnderscoreFuncAndMethod
2025/10/11 16:12:25 ==> Preload func _
2025/10/11 16:12:25 ==> Preload type T
2025/10/11 16:12:25 ==> Preload method T._
2025/10/11 16:12:25 ==> Preload method T._
2025/10/11 16:12:25 ==> Load > NewType T
2025/10/11 16:12:25 NewType T
2025/10/11 16:12:25 ==> Load > InitType T
2025/10/11 16:12:25 InitType T struct{_ int; _ int; _ int}
2025/10/11 16:12:25 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{_ int; _ int; _ int}
2025/10/11 16:12:25 ==> Load method github.com/goplus/xgo/cl.T._
2025/10/11 16:12:25 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{_ int; _ int; _ int}
2025/10/11 16:12:25 ==> Load method github.com/goplus/xgo/cl.T._
2025/10/11 16:12:25 ==> Load func _
2025/10/11 16:12:25 NewFunc _ func()
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 NewFunc _ (github.com/goplus/xgo/cl.T) func()
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 NewFunc _ (github.com/goplus/xgo/cl.T) func()
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestUnderscoreFuncAndMethod (0.00s)
=== RUN   TestErrWrapIssue772
2025/10/11 16:12:25 ==> Preload func t
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load func t
2025/10/11 16:12:25 NewFunc t func() (int, int, error)
2025/10/11 16:12:25 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:25 Val nil untyped nil
2025/10/11 16:12:25 Return 3
2025/10/11 16:12:25 ==> MatchType untyped int (0), int
2025/10/11 16:12:25 ==> MatchType untyped int (0), int
2025/10/11 16:12:25 ==> MatchType untyped nil, error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 DefineVarStart [a b]
2025/10/11 16:12:25 Val t func() (int, int, error)
2025/10/11 16:12:25 Call 0 0 // func() (int, int, error)
2025/10/11 16:12:25 ==> MatchFuncCall func() (int, int, error) args: 0 flags: 0
2025/10/11 16:12:25 NewClosure func() (_xgo_ret unboundType{typ: <nil>}, _xgo_ret2 unboundType{typ: <nil>})
2025/10/11 16:12:25 NewVar [_xgo_err]
2025/10/11 16:12:25 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:25 VarRef _xgo_ret2 unboundType{typ: <nil>}
2025/10/11 16:12:25 VarRef _xgo_err error
2025/10/11 16:12:25 Assign 3 1
2025/10/11 16:12:25 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType error, error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 If
2025/10/11 16:12:25 Val _xgo_err error
2025/10/11 16:12:25 Val <nil> <nil>
2025/10/11 16:12:25 BinaryOp !=
2025/10/11 16:12:25 Typ error
2025/10/11 16:12:25 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 VarRef _xgo_err error
2025/10/11 16:12:25 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:25 Val _xgo_err error
2025/10/11 16:12:25 Val t() string
2025/10/11 16:12:25 Val /foo/bar.xgo string
2025/10/11 16:12:25 Val 9 int
2025/10/11 16:12:25 Val main.main string
2025/10/11 16:12:25 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:25 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:25 ==> MatchType error, error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 ==> MatchType untyped string ("t()"), string
2025/10/11 16:12:25 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:25 ==> MatchType untyped int (9), int
2025/10/11 16:12:25 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:25 Assign 1 1
2025/10/11 16:12:25 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 Val panic func(v interface{})
2025/10/11 16:12:25 Val _xgo_err error
2025/10/11 16:12:25 Call 1 0 // func(v interface{})
2025/10/11 16:12:25 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType error, interface{}
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 End // If
2025/10/11 16:12:25 Return 0
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 Call 0 0 // func() (_xgo_ret int, _xgo_ret2 int)
2025/10/11 16:12:25 ==> MatchFuncCall func() (_xgo_ret int, _xgo_ret2 int) args: 0 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val a int
2025/10/11 16:12:25 Val b int
2025/10/11 16:12:25 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType int, any
2025/10/11 16:12:25 ==> MatchType int, any
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestErrWrapIssue772 (0.17s)
=== RUN   TestErrWrapIssue778
2025/10/11 16:12:25 ==> Preload func t
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load func t
2025/10/11 16:12:25 NewFunc t func() error
2025/10/11 16:12:25 Val nil untyped nil
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType untyped nil, error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 Val t func() error
2025/10/11 16:12:25 Call 0 0 // func() error
2025/10/11 16:12:25 ==> MatchFuncCall func() error args: 0 flags: 0
2025/10/11 16:12:25 NewClosure func()
2025/10/11 16:12:25 NewVar [_xgo_err]
2025/10/11 16:12:25 VarRef _xgo_err error
2025/10/11 16:12:25 Assign 1 1
2025/10/11 16:12:25 ==> MatchType error, error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 If
2025/10/11 16:12:25 Val _xgo_err error
2025/10/11 16:12:25 Val <nil> <nil>
2025/10/11 16:12:25 BinaryOp !=
2025/10/11 16:12:25 Typ error
2025/10/11 16:12:25 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 VarRef _xgo_err error
2025/10/11 16:12:25 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:25 Val _xgo_err error
2025/10/11 16:12:25 Val t() string
2025/10/11 16:12:25 Val /foo/bar.xgo string
2025/10/11 16:12:25 Val 9 int
2025/10/11 16:12:25 Val main.main string
2025/10/11 16:12:25 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:25 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:25 ==> MatchType error, error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 ==> MatchType untyped string ("t()"), string
2025/10/11 16:12:25 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:25 ==> MatchType untyped int (9), int
2025/10/11 16:12:25 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:25 Assign 1 1
2025/10/11 16:12:25 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 Val panic func(v interface{})
2025/10/11 16:12:25 Val _xgo_err error
2025/10/11 16:12:25 Call 1 0 // func(v interface{})
2025/10/11 16:12:25 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType error, interface{}
2025/10/11 16:12:25 ==> EnsureLoaded error
2025/10/11 16:12:25 End // If
2025/10/11 16:12:25 Return 0
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 Call 0 0 // func()
2025/10/11 16:12:25 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestErrWrapIssue778 (0.00s)
=== RUN   TestIssue774
=== RUN   TestIssue774/InterfaceTypeAssert
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Preload type AA
2025/10/11 16:12:25 ==> Preload type A
2025/10/11 16:12:25 ==> Preload method A.String
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 ==> Load > NewType AA
2025/10/11 16:12:25 NewType AA
2025/10/11 16:12:25 ==> Lookup (LoadSymbol) AA => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:25 ==> Load var github.com/goplus/xgo/cl.AA [a]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [a]
2025/10/11 16:12:25 ==> Load > NewType A
2025/10/11 16:12:25 NewType A
2025/10/11 16:12:25 ==> Lookup (LoadSymbol) A => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:25 ==> Load > InitType A
2025/10/11 16:12:25 InitType A struct{str string}
2025/10/11 16:12:25 ==> LookupParent A => type github.com/goplus/xgo/cl.A struct{str string}
2025/10/11 16:12:25 ==> Load method *github.com/goplus/xgo/cl.A.String
2025/10/11 16:12:25 Val 0 int
2025/10/11 16:12:25 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:25 StructLit github.com/goplus/xgo/cl.A 2 true
2025/10/11 16:12:25 UnaryOp & flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> MatchType *github.com/goplus/xgo/cl.A, github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 ==> Load > InitType AA
2025/10/11 16:12:25 InitType AA interface{String() string}
2025/10/11 16:12:25 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:25 Val a github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 ==> LookupParent A => type github.com/goplus/xgo/cl.A struct{str string}
2025/10/11 16:12:25 TypeAssert *github.com/goplus/xgo/cl.A false
2025/10/11 16:12:25 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType *github.com/goplus/xgo/cl.A, any
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 NewFunc String (*github.com/goplus/xgo/cl.A) func() string
2025/10/11 16:12:25 Val a *github.com/goplus/xgo/cl.A
2025/10/11 16:12:25 Member str 2 // *github.com/goplus/xgo/cl.A
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType string, string
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
=== RUN   TestIssue774/getInterface
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Preload type AA
2025/10/11 16:12:25 ==> Preload func get
2025/10/11 16:12:25 ==> Preload type A
2025/10/11 16:12:25 ==> Preload method A.String
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 DefineVarStart [a]
2025/10/11 16:12:25 ==> Load func get
2025/10/11 16:12:25 ==> Load > NewType AA
2025/10/11 16:12:25 NewType AA
2025/10/11 16:12:25 ==> Lookup (LoadSymbol) AA => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:25 NewFunc get func() github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 ==> LookupParent AA => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:25 ==> Load var github.com/goplus/xgo/cl.AA [a]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [a]
2025/10/11 16:12:25 Val a github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType github.com/goplus/xgo/cl.AA, github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 ==> Load > InitType AA
2025/10/11 16:12:25 InitType AA interface{String() string}
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 Val get func() github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 Call 0 0 // func() github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 ==> MatchFuncCall func() github.com/goplus/xgo/cl.AA args: 0 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:25 Val a github.com/goplus/xgo/cl.AA
2025/10/11 16:12:25 ==> Load > NewType A
2025/10/11 16:12:25 NewType A
2025/10/11 16:12:25 ==> Lookup (LoadSymbol) A => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:25 TypeAssert *github.com/goplus/xgo/cl.A false
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.A
2025/10/11 16:12:25 ==> Load > InitType A
2025/10/11 16:12:25 InitType A struct{str string}
2025/10/11 16:12:25 ==> LookupParent A => type github.com/goplus/xgo/cl.A struct{str string}
2025/10/11 16:12:25 ==> Load method *github.com/goplus/xgo/cl.A.String
2025/10/11 16:12:25 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType *github.com/goplus/xgo/cl.A, any
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 NewFunc String (*github.com/goplus/xgo/cl.A) func() string
2025/10/11 16:12:25 Val a *github.com/goplus/xgo/cl.A
2025/10/11 16:12:25 Member str 2 // *github.com/goplus/xgo/cl.A
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType string, string
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestIssue774 (0.00s)
    --- PASS: TestIssue774/InterfaceTypeAssert (0.00s)
    --- PASS: TestIssue774/getInterface (0.00s)
=== RUN   TestBlockStmt
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 Block
2025/10/11 16:12:25 NewType T
2025/10/11 16:12:25 InitType T int
2025/10/11 16:12:25 DefineVarStart [t]
2025/10/11 16:12:25 Val T github.com/goplus/xgo/cl.T
2025/10/11 16:12:25 Val type T int => Typ github.com/goplus/xgo/cl.T
2025/10/11 16:12:25 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:25 Call 1 0 // TypeType{typ: github.com/goplus/xgo/cl.T}
2025/10/11 16:12:25 ==> MatchFuncCall TypeType{typ: github.com/goplus/xgo/cl.T} args: 1 flags: 0
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType github.com/goplus/xgo/cl.T, any
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/10/11 16:12:25 End // Block
2025/10/11 16:12:25 Block
2025/10/11 16:12:25 NewType T
2025/10/11 16:12:25 InitType T string
2025/10/11 16:12:25 DefineVarStart [t]
2025/10/11 16:12:25 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val t string
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType string, any
2025/10/11 16:12:25 End // Block
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestBlockStmt (0.00s)
=== RUN   TestConstTypeConvIssue792
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Preload const [dots]
2025/10/11 16:12:25 NewConstDefs
2025/10/11 16:12:25 ==> Preload const [n]
2025/10/11 16:12:25 ==> Load const [dots] <nil>
2025/10/11 16:12:25 NewConst [dots] 0
2025/10/11 16:12:25 Val &{0 STRING ". . . "} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 STRING ". . . . . "} *ast.BasicLit
2025/10/11 16:12:25 BinaryOp +
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped string (". . . "), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType untyped string (". . . . . "), unboundFuncParam{typ: untyped string}
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load const [n] <nil>
2025/10/11 16:12:25 NewConst [n] 0
2025/10/11 16:12:25 Val uint uint
2025/10/11 16:12:25 Val type uint => Typ uint
2025/10/11 16:12:25 Val len TyInstruction{gogen.lenInstr}
2025/10/11 16:12:25 Val dots untyped string
2025/10/11 16:12:25 Call 1 0 // TyInstruction{gogen.lenInstr}
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.lenInstr} args: 1 flags: 0
2025/10/11 16:12:25 Call 1 0 // TypeType{typ: uint}
2025/10/11 16:12:25 ==> MatchFuncCall TypeType{typ: uint} args: 1 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestConstTypeConvIssue792 (0.00s)
=== RUN   TestVarInitTwoValueIssue791
2025/10/11 16:12:25 ==> Preload var [m]
2025/10/11 16:12:25 ==> Preload var [a ok]
2025/10/11 16:12:25 ==> Load var <nil> [m]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [m]
2025/10/11 16:12:25 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 STRING "A"} *ast.BasicLit
2025/10/11 16:12:25 MapLit map[string]string 2
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load var <nil> [a ok]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [a ok]
2025/10/11 16:12:25 Val m map[string]string
2025/10/11 16:12:25 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:25 Index 1 true
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestVarInitTwoValueIssue791 (0.00s)
=== RUN   TestVarAfterMain
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Preload var [i]
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> Load var int [i]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [i]
2025/10/11 16:12:25 Val i int
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType int, any
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
2025/10/11 16:12:25 ==> Preload func f
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Preload var [sink]
2025/10/11 16:12:25 ==> Load func f
2025/10/11 16:12:25 NewFunc f func(v float64) float64
2025/10/11 16:12:25 Val v float64
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType float64, float64
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 ==> Load var float64 [sink]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [sink]
2025/10/11 16:12:25 VarRef sink float64
2025/10/11 16:12:25 Val f func(v float64) float64
2025/10/11 16:12:25 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:25 Call 1 0 // func(v float64) float64
2025/10/11 16:12:25 ==> MatchFuncCall func(v float64) float64 args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (100), float64
2025/10/11 16:12:25 Assign 1 1
2025/10/11 16:12:25 ==> MatchType float64, float64
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestVarAfterMain (0.00s)
=== RUN   TestVarAfterMain2
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Preload var [i]
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> Load var <nil> [i]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [i]
2025/10/11 16:12:25 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val i int
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType int, any
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestVarAfterMain2 (0.00s)
=== RUN   TestVarInMain
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 DefineVarStart [v]
2025/10/11 16:12:25 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:25 SliceLit []uint64 3 false
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> Load var <nil> [n]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [n]
2025/10/11 16:12:25 Val len TyInstruction{gogen.lenInstr}
2025/10/11 16:12:25 Val v []uint64
2025/10/11 16:12:25 Call 1 0 // TyInstruction{gogen.lenInstr}
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.lenInstr} args: 1 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val n int
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType int, any
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestVarInMain (0.00s)
=== RUN   TestSelect
2025/10/11 16:12:25 ==> Preload func consume
2025/10/11 16:12:25 ==> Load func consume
2025/10/11 16:12:25 NewFunc consume func(xchg chan int)
2025/10/11 16:12:25 Select
2025/10/11 16:12:25 CommCase
2025/10/11 16:12:25 DefineVarStart [c]
2025/10/11 16:12:25 Val xchg chan int
2025/10/11 16:12:25 UnaryOp <- flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val c int
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType int, any
2025/10/11 16:12:25 End // CommCase
2025/10/11 16:12:25 CommCase
2025/10/11 16:12:25 Val xchg chan int
2025/10/11 16:12:25 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:25 Send
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val &{0 STRING "send ok"} *ast.BasicLit
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped string ("send ok"), any
2025/10/11 16:12:25 End // CommCase
2025/10/11 16:12:25 CommCase
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped int (0), any
2025/10/11 16:12:25 End // CommCase
2025/10/11 16:12:25 End // Select
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestSelect (0.00s)
=== RUN   TestTypeSwitch
2025/10/11 16:12:25 ==> Preload func bar
2025/10/11 16:12:25 ==> Preload func foo
2025/10/11 16:12:25 ==> Load func bar
2025/10/11 16:12:25 NewFunc bar func(p *interface{})
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> Load func foo
2025/10/11 16:12:25 NewFunc foo func(v interface{})
2025/10/11 16:12:25 TypeSwitch
2025/10/11 16:12:25 Val v interface{}
2025/10/11 16:12:25 TypeAssertThen
2025/10/11 16:12:25 TypeCase
2025/10/11 16:12:25 Val int int
2025/10/11 16:12:25 Val type int => Typ int
2025/10/11 16:12:25 Val string string
2025/10/11 16:12:25 Val type string => Typ string
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Val bar func(p *interface{})
2025/10/11 16:12:25 Val v interface{}
2025/10/11 16:12:25 UnaryOp & flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:25 Call 1 0 // func(p *interface{})
2025/10/11 16:12:25 ==> MatchFuncCall func(p *interface{}) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType *interface{}, *interface{}
2025/10/11 16:12:25 End // TypeCase
2025/10/11 16:12:25 TypeCase
2025/10/11 16:12:25 Val bool bool
2025/10/11 16:12:25 Val type bool => Typ bool
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 ==> Load var bool [x]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [x]
2025/10/11 16:12:25 Val t bool
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> MatchType bool, bool
2025/10/11 16:12:25 End // TypeCase
2025/10/11 16:12:25 TypeCase
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Val bar func(p *interface{})
2025/10/11 16:12:25 Val nil untyped nil
2025/10/11 16:12:25 Call 1 0 // func(p *interface{})
2025/10/11 16:12:25 ==> MatchFuncCall func(p *interface{}) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped nil, *interface{}
2025/10/11 16:12:25 End // TypeCase
2025/10/11 16:12:25 End // TypeSwitch
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestTypeSwitch (0.00s)
=== RUN   TestTypeSwitch2
2025/10/11 16:12:25 ==> Preload func bar
2025/10/11 16:12:25 ==> Preload func foo
2025/10/11 16:12:25 ==> Load func bar
2025/10/11 16:12:25 NewFunc bar func(p *interface{})
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> Load func foo
2025/10/11 16:12:25 NewFunc foo func(v interface{})
2025/10/11 16:12:25 TypeSwitch
2025/10/11 16:12:25 Val bar func(p *interface{})
2025/10/11 16:12:25 Val nil untyped nil
2025/10/11 16:12:25 Call 1 0 // func(p *interface{})
2025/10/11 16:12:25 ==> MatchFuncCall func(p *interface{}) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped nil, *interface{}
2025/10/11 16:12:25 Val v interface{}
2025/10/11 16:12:25 TypeAssertThen
2025/10/11 16:12:25 TypeCase
2025/10/11 16:12:25 Val int int
2025/10/11 16:12:25 Val type int => Typ int
2025/10/11 16:12:25 Val string string
2025/10/11 16:12:25 Val type string => Typ string
2025/10/11 16:12:25 Then
2025/10/11 16:12:25 Val bar func(p *interface{})
2025/10/11 16:12:25 Val v interface{}
2025/10/11 16:12:25 UnaryOp & flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:25 Call 1 0 // func(p *interface{})
2025/10/11 16:12:25 ==> MatchFuncCall func(p *interface{}) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType *interface{}, *interface{}
2025/10/11 16:12:25 End // TypeCase
2025/10/11 16:12:25 End // TypeSwitch
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestTypeSwitch2 (0.00s)
=== RUN   TestTypeAssert
2025/10/11 16:12:25 ==> Preload func foo
2025/10/11 16:12:25 ==> Load func foo
2025/10/11 16:12:25 NewFunc foo func(v interface{})
2025/10/11 16:12:25 DefineVarStart [x]
2025/10/11 16:12:25 Val v interface{}
2025/10/11 16:12:25 TypeAssert int false
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 DefineVarStart [y ok]
2025/10/11 16:12:25 Val v interface{}
2025/10/11 16:12:25 TypeAssert string true
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestTypeAssert (0.00s)
=== RUN   TestInterface
2025/10/11 16:12:25 ==> Preload type Shape
2025/10/11 16:12:25 ==> Preload func foo
2025/10/11 16:12:25 ==> Load > NewType Shape
2025/10/11 16:12:25 NewType Shape
2025/10/11 16:12:25 ==> Load > InitType Shape
2025/10/11 16:12:25 InitType Shape interface{Area() float64}
2025/10/11 16:12:25 ==> Load func foo
2025/10/11 16:12:25 ==> LookupParent Shape => type github.com/goplus/xgo/cl.Shape interface{Area() float64}
2025/10/11 16:12:25 NewFunc foo func(shape github.com/goplus/xgo/cl.Shape)
2025/10/11 16:12:25 Val shape github.com/goplus/xgo/cl.Shape
2025/10/11 16:12:25 Member Area 1 // github.com/goplus/xgo/cl.Shape
2025/10/11 16:12:25 Call 0 0 // func() float64
2025/10/11 16:12:25 ==> MatchFuncCall func() float64 args: 0 flags: 0
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestInterface (0.00s)
=== RUN   TestInterfaceEmbedded
2025/10/11 16:12:25 ==> Preload type Shape
2025/10/11 16:12:25 ==> Preload type Bar
2025/10/11 16:12:25 ==> Load > NewType Shape
2025/10/11 16:12:25 NewType Shape
2025/10/11 16:12:25 ==> Load > InitType Shape
2025/10/11 16:12:25 InitType Shape interface{Area() float64}
2025/10/11 16:12:25 ==> Load > NewType Bar
2025/10/11 16:12:25 NewType Bar
2025/10/11 16:12:25 ==> Load > InitType Bar
2025/10/11 16:12:25 ==> LookupParent Shape => type github.com/goplus/xgo/cl.Shape interface{Area() float64}
2025/10/11 16:12:25 InitType Bar interface{github.com/goplus/xgo/cl.Shape}
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestInterfaceEmbedded (0.00s)
=== RUN   TestInterfaceExample
2025/10/11 16:12:25 ==> Preload type Shape
2025/10/11 16:12:25 ==> Preload type Rect
2025/10/11 16:12:25 ==> Preload method Rect.Area
2025/10/11 16:12:25 ==> Preload type Circle
2025/10/11 16:12:25 ==> Preload method Circle.Area
2025/10/11 16:12:25 ==> Preload func Area
2025/10/11 16:12:25 ==> Preload func main
2025/10/11 16:12:25 ==> Load > NewType Shape
2025/10/11 16:12:25 NewType Shape
2025/10/11 16:12:25 ==> Load > InitType Shape
2025/10/11 16:12:25 InitType Shape interface{Area() float64}
2025/10/11 16:12:25 ==> Load > NewType Rect
2025/10/11 16:12:25 NewType Rect
2025/10/11 16:12:25 ==> Load > InitType Rect
2025/10/11 16:12:25 InitType Rect struct{x float64; y float64; w float64; h float64}
2025/10/11 16:12:25 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{x float64; y float64; w float64; h float64}
2025/10/11 16:12:25 ==> Load method *github.com/goplus/xgo/cl.Rect.Area
2025/10/11 16:12:25 ==> Load > NewType Circle
2025/10/11 16:12:25 NewType Circle
2025/10/11 16:12:25 ==> Load > InitType Circle
2025/10/11 16:12:25 InitType Circle struct{x float64; y float64; r float64}
2025/10/11 16:12:25 ==> LookupParent Circle => type github.com/goplus/xgo/cl.Circle struct{x float64; y float64; r float64}
2025/10/11 16:12:25 ==> Load method *github.com/goplus/xgo/cl.Circle.Area
2025/10/11 16:12:25 ==> Load func Area
2025/10/11 16:12:25 ==> LookupParent Shape => type github.com/goplus/xgo/cl.Shape interface{Area() float64}
2025/10/11 16:12:25 NewFunc Area func(shapes ...github.com/goplus/xgo/cl.Shape) float64
2025/10/11 16:12:25 DefineVarStart [s]
2025/10/11 16:12:25 Val &{0 FLOAT 0.0} *ast.BasicLit
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ForRange [_ shape]
2025/10/11 16:12:25 Val shapes []github.com/goplus/xgo/cl.Shape
2025/10/11 16:12:25 RangeAssignThen
2025/10/11 16:12:25 VBlock
2025/10/11 16:12:25 VarRef s float64
2025/10/11 16:12:25 Val shape github.com/goplus/xgo/cl.Shape
2025/10/11 16:12:25 Member Area 1 // github.com/goplus/xgo/cl.Shape
2025/10/11 16:12:25 Call 0 0 // func() float64
2025/10/11 16:12:25 ==> MatchFuncCall func() float64 args: 0 flags: 0
2025/10/11 16:12:25 AssignOp += Gop_AddAssign
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType refType{typ: float64}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:25 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:25 End // Vblock
2025/10/11 16:12:25 End // ForRange
2025/10/11 16:12:25 Val s float64
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType float64, float64
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> Load func main
2025/10/11 16:12:25 NewFunc main func()
2025/10/11 16:12:25 DefineVarStart [rect]
2025/10/11 16:12:25 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{x float64; y float64; w float64; h float64}
2025/10/11 16:12:25 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:25 StructLit github.com/goplus/xgo/cl.Rect 4 false
2025/10/11 16:12:25 UnaryOp & flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 DefineVarStart [circle]
2025/10/11 16:12:25 ==> LookupParent Circle => type github.com/goplus/xgo/cl.Circle struct{x float64; y float64; r float64}
2025/10/11 16:12:25 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:25 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:25 StructLit github.com/goplus/xgo/cl.Circle 3 false
2025/10/11 16:12:25 UnaryOp & flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 Val Area func(shapes ...github.com/goplus/xgo/cl.Shape) float64
2025/10/11 16:12:25 Val circle *github.com/goplus/xgo/cl.Circle
2025/10/11 16:12:25 Val rect *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:25 Call 2 0 // func(shapes ...github.com/goplus/xgo/cl.Shape) float64
2025/10/11 16:12:25 ==> MatchFuncCall func(shapes ...github.com/goplus/xgo/cl.Shape) float64 args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType *github.com/goplus/xgo/cl.Circle, github.com/goplus/xgo/cl.Shape
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.Shape
2025/10/11 16:12:25 ==> MatchType *github.com/goplus/xgo/cl.Rect, github.com/goplus/xgo/cl.Shape
2025/10/11 16:12:25 ==> EnsureLoaded github.com/goplus/xgo/cl.Shape
2025/10/11 16:12:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:25 ==> MatchType float64, any
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 NewFunc Area (*github.com/goplus/xgo/cl.Rect) func() float64
2025/10/11 16:12:25 Val p *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:25 Member w 2 // *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:25 Val p *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:25 Member h 2 // *github.com/goplus/xgo/cl.Rect
2025/10/11 16:12:25 BinaryOp *
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType float64, float64
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 NewFunc Area (*github.com/goplus/xgo/cl.Circle) func() float64
2025/10/11 16:12:25 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:25 Val p *github.com/goplus/xgo/cl.Circle
2025/10/11 16:12:25 Member r 2 // *github.com/goplus/xgo/cl.Circle
2025/10/11 16:12:25 BinaryOp *
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType untyped float (3.14), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType float64, unboundFuncParam{typ: untyped float}
2025/10/11 16:12:25 Val p *github.com/goplus/xgo/cl.Circle
2025/10/11 16:12:25 Member r 2 // *github.com/goplus/xgo/cl.Circle
2025/10/11 16:12:25 BinaryOp *
2025/10/11 16:12:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:25 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:25 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:25 Return 1
2025/10/11 16:12:25 ==> MatchType float64, float64
2025/10/11 16:12:25 End // Func
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestInterfaceExample (0.00s)
=== RUN   TestEmbeddField
2025/10/11 16:12:25 ==> Preload type BigInt
2025/10/11 16:12:25 ==> Load > NewType BigInt
2025/10/11 16:12:25 NewType BigInt
2025/10/11 16:12:25 ==> Load > InitType BigInt
2025/10/11 16:12:25 InitType BigInt struct{*math/big.Int}
2025/10/11 16:12:25 ==> ASTFile
--- PASS: TestEmbeddField (0.15s)
=== RUN   TestAutoProperty
2025/10/11 16:12:26 PkgHash: unexpected package - github.com/goplus/gogen/token
2025/10/11 16:12:26 ==> Import github.com/goplus/xgo/ast/goptest
2025/10/11 16:12:26 PkgHash: unexpected package - github.com/goplus/gogen/token
2025/10/11 16:12:26 ==> Import github.com/goplus/xgo/ast/gopq
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet UnquotedString
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet UnquotedStringElts
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet Positions
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet EltLen
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet CallExpr
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet Elt
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet CollectOne
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet Ident
2025/10/11 16:12:26 ==> NewOverloadFunc One
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet FuncDecl
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet GenDecl
2025/10/11 16:12:26 ==> NewOverloadMethod NodeSet CompositeLit
2025/10/11 16:12:26 ==> Preload func foo
2025/10/11 16:12:26 ==> Load func foo
2025/10/11 16:12:26 NewFunc foo func(script string)
2025/10/11 16:12:26 DefineVarStart [doc]
2025/10/11 16:12:26 Val New func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error)
2025/10/11 16:12:26 Val script string
2025/10/11 16:12:26 Call 1 0 // func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error)
2025/10/11 16:12:26 ==> MatchFuncCall func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType string, string
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 NewVar [_xgo_err]
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Assign 2 1
2025/10/11 16:12:26 ==> MatchType github.com/goplus/xgo/ast/gopq.NodeSet, unboundType{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val <nil> <nil>
2025/10/11 16:12:26 BinaryOp !=
2025/10/11 16:12:26 Typ error
2025/10/11 16:12:26 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val goptest.New(script) string
2025/10/11 16:12:26 Val /foo/bar.xgo string
2025/10/11 16:12:26 Val 4 int
2025/10/11 16:12:26 Val main.foo string
2025/10/11 16:12:26 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> MatchType untyped string ("goptest.New(script)"), string
2025/10/11 16:12:26 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:26 ==> MatchType untyped int (4), int
2025/10/11 16:12:26 ==> MatchType untyped string ("main.foo"), string
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 Val panic func(v interface{})
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Call 1 0 // func(v interface{})
2025/10/11 16:12:26 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType error, interface{}
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val doc github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Member any 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func() (ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/10/11 16:12:26 ==> MatchFuncCall func() (ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/10/11 16:12:26 Member funcDecl 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadMethod args: 0 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func() github.com/goplus/xgo/ast/gopq.NodeSet args: 0 flags: 0
2025/10/11 16:12:26 Member name 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func() []string
2025/10/11 16:12:26 ==> MatchFuncCall func() []string args: 0 flags: 0
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType []string, any
2025/10/11 16:12:26 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val doc github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Member any 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func() (ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/10/11 16:12:26 ==> MatchFuncCall func() (ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/10/11 16:12:26 Member importSpec 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func() github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 ==> MatchFuncCall func() github.com/goplus/xgo/ast/gopq.NodeSet args: 0 flags: 0
2025/10/11 16:12:26 Member name 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func() []string
2025/10/11 16:12:26 ==> MatchFuncCall func() []string args: 0 flags: 0
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType []string, any
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestAutoProperty (1.42s)
=== RUN   TestSimplifyAutoProperty
2025/10/11 16:12:26 ==> Preload func foo
2025/10/11 16:12:26 ==> Load func foo
2025/10/11 16:12:26 NewFunc foo func(script string)
2025/10/11 16:12:26 DefineVarStart [doc]
2025/10/11 16:12:26 Val New func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error)
2025/10/11 16:12:26 Val script string
2025/10/11 16:12:26 Call 1 0 // func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error)
2025/10/11 16:12:26 ==> MatchFuncCall func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType string, string
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 NewVar [_xgo_err]
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Assign 2 1
2025/10/11 16:12:26 ==> MatchType github.com/goplus/xgo/ast/gopq.NodeSet, unboundType{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val <nil> <nil>
2025/10/11 16:12:26 BinaryOp !=
2025/10/11 16:12:26 Typ error
2025/10/11 16:12:26 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val goptest.New(script) string
2025/10/11 16:12:26 Val /foo/bar.xgo string
2025/10/11 16:12:26 Val 4 int
2025/10/11 16:12:26 Val main.foo string
2025/10/11 16:12:26 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> MatchType untyped string ("goptest.New(script)"), string
2025/10/11 16:12:26 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:26 ==> MatchType untyped int (4), int
2025/10/11 16:12:26 ==> MatchType untyped string ("main.foo"), string
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 Val panic func(v interface{})
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Call 1 0 // func(v interface{})
2025/10/11 16:12:26 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType error, interface{}
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val doc github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Member any 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func() (ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/10/11 16:12:26 ==> MatchFuncCall func() (ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/10/11 16:12:26 Member funcDecl 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadMethod args: 0 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func() github.com/goplus/xgo/ast/gopq.NodeSet args: 0 flags: 0
2025/10/11 16:12:26 Member name 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func() []string
2025/10/11 16:12:26 ==> MatchFuncCall func() []string args: 0 flags: 0
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType []string, any
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val doc github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Member any 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func() (ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/10/11 16:12:26 ==> MatchFuncCall func() (ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/10/11 16:12:26 Member importSpec 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func() github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 ==> MatchFuncCall func() github.com/goplus/xgo/ast/gopq.NodeSet args: 0 flags: 0
2025/10/11 16:12:26 Member name 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/10/11 16:12:26 Call 0 0 // func() []string
2025/10/11 16:12:26 ==> MatchFuncCall func() []string args: 0 flags: 0
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType []string, any
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestSimplifyAutoProperty (0.00s)
=== RUN   TestErrWrapBasic
2025/10/11 16:12:26 ==> Preload func add
2025/10/11 16:12:26 ==> Load func add
2025/10/11 16:12:26 NewFunc add func(x string, y string) (int, error)
2025/10/11 16:12:26 Val Atoi func(s string) (int, error)
2025/10/11 16:12:26 Val x string
2025/10/11 16:12:26 Call 1 0 // func(s string) (int, error)
2025/10/11 16:12:26 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType string, string
2025/10/11 16:12:26 CallInlineClosureStart 0 false
2025/10/11 16:12:26 NewVar [_autoGo_1]
2025/10/11 16:12:26 NewVar [_xgo_err]
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Assign 2 1
2025/10/11 16:12:26 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val <nil> <nil>
2025/10/11 16:12:26 BinaryOp !=
2025/10/11 16:12:26 Typ error
2025/10/11 16:12:26 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val strconv.Atoi(x) string
2025/10/11 16:12:26 Val /foo/bar.xgo string
2025/10/11 16:12:26 Val 5 int
2025/10/11 16:12:26 Val main.add string
2025/10/11 16:12:26 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> MatchType untyped string ("strconv.Atoi(x)"), string
2025/10/11 16:12:26 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:26 ==> MatchType untyped int (5), int
2025/10/11 16:12:26 ==> MatchType untyped string ("main.add"), string
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 ReturnErr true
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 Goto _autoGo_2
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Label _autoGo_2
2025/10/11 16:12:26 Val Atoi func(s string) (int, error)
2025/10/11 16:12:26 Val y string
2025/10/11 16:12:26 Call 1 0 // func(s string) (int, error)
2025/10/11 16:12:26 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType string, string
2025/10/11 16:12:26 CallInlineClosureStart 0 false
2025/10/11 16:12:26 NewVar [_autoGo_3]
2025/10/11 16:12:26 NewVar [_xgo_err]
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Assign 2 1
2025/10/11 16:12:26 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val <nil> <nil>
2025/10/11 16:12:26 BinaryOp !=
2025/10/11 16:12:26 Typ error
2025/10/11 16:12:26 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val strconv.Atoi(y) string
2025/10/11 16:12:26 Val /foo/bar.xgo string
2025/10/11 16:12:26 Val 5 int
2025/10/11 16:12:26 Val main.add string
2025/10/11 16:12:26 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> MatchType untyped string ("strconv.Atoi(y)"), string
2025/10/11 16:12:26 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:26 ==> MatchType untyped int (5), int
2025/10/11 16:12:26 ==> MatchType untyped string ("main.add"), string
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 ReturnErr true
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 Goto _autoGo_4
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Label _autoGo_4
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:26 Val nil untyped nil
2025/10/11 16:12:26 Return 2
2025/10/11 16:12:26 ==> MatchType int, int
2025/10/11 16:12:26 ==> MatchType untyped nil, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestErrWrapBasic (0.00s)
=== RUN   TestErrWrapDefVal
2025/10/11 16:12:26 ==> Preload func addSafe
2025/10/11 16:12:26 ==> Load func addSafe
2025/10/11 16:12:26 NewFunc addSafe func(x string, y string) int
2025/10/11 16:12:26 Val Atoi func(s string) (int, error)
2025/10/11 16:12:26 Val x string
2025/10/11 16:12:26 Call 1 0 // func(s string) (int, error)
2025/10/11 16:12:26 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType string, string
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 NewVar [_xgo_err]
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Assign 2 1
2025/10/11 16:12:26 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val <nil> <nil>
2025/10/11 16:12:26 BinaryOp !=
2025/10/11 16:12:26 Typ error
2025/10/11 16:12:26 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType untyped int (0), unboundType{typ: int}
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret int)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/10/11 16:12:26 Val Atoi func(s string) (int, error)
2025/10/11 16:12:26 Val y string
2025/10/11 16:12:26 Call 1 0 // func(s string) (int, error)
2025/10/11 16:12:26 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType string, string
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 NewVar [_xgo_err]
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Assign 2 1
2025/10/11 16:12:26 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val <nil> <nil>
2025/10/11 16:12:26 BinaryOp !=
2025/10/11 16:12:26 Typ error
2025/10/11 16:12:26 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType untyped int (0), unboundType{typ: int}
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret int)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType int, int
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestErrWrapDefVal (0.00s)
=== RUN   TestErrWrapPanic
2025/10/11 16:12:26 ==> Preload var [ret]
2025/10/11 16:12:26 ==> Load var int [ret]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [ret]
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 NewVar [_xgo_err]
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Assign 2 1
2025/10/11 16:12:26 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val <nil> <nil>
2025/10/11 16:12:26 BinaryOp !=
2025/10/11 16:12:26 Typ error
2025/10/11 16:12:26 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val println("Hi") string
2025/10/11 16:12:26 Val /foo/bar.xgo string
2025/10/11 16:12:26 Val 2 int
2025/10/11 16:12:26 Val main.main string
2025/10/11 16:12:26 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> MatchType untyped string ("println(\"Hi\")"), string
2025/10/11 16:12:26 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:26 ==> MatchType untyped int (2), int
2025/10/11 16:12:26 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 Val panic func(v interface{})
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Call 1 0 // func(v interface{})
2025/10/11 16:12:26 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType error, interface{}
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret int)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType int, int
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestErrWrapPanic (0.00s)
=== RUN   TestErrWrapCommand
2025/10/11 16:12:26 ==> Preload func mkdir
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func mkdir
2025/10/11 16:12:26 NewFunc mkdir func(name string) error
2025/10/11 16:12:26 Val nil untyped nil
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType untyped nil, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 Val mkdir func(name string) error
2025/10/11 16:12:26 Val &{0 STRING "foo"} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(name string) error
2025/10/11 16:12:26 ==> MatchFuncCall func(name string) error args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("foo"), string
2025/10/11 16:12:26 NewClosure func()
2025/10/11 16:12:26 NewVar [_xgo_err]
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val <nil> <nil>
2025/10/11 16:12:26 BinaryOp !=
2025/10/11 16:12:26 Typ error
2025/10/11 16:12:26 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val mkdir "foo" string
2025/10/11 16:12:26 Val /foo/bar.xgo string
2025/10/11 16:12:26 Val 6 int
2025/10/11 16:12:26 Val main.main string
2025/10/11 16:12:26 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> MatchType untyped string ("mkdir \"foo\""), string
2025/10/11 16:12:26 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:26 ==> MatchType untyped int (6), int
2025/10/11 16:12:26 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 Val panic func(v interface{})
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Call 1 0 // func(v interface{})
2025/10/11 16:12:26 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType error, interface{}
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func()
2025/10/11 16:12:26 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestErrWrapCommand (0.00s)
=== RUN   TestErrWrapCall
2025/10/11 16:12:26 ==> Preload func foo
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func foo
2025/10/11 16:12:26 NewFunc foo func() (func(), error)
2025/10/11 16:12:26 Val nil untyped nil
2025/10/11 16:12:26 Val nil untyped nil
2025/10/11 16:12:26 Return 2
2025/10/11 16:12:26 ==> MatchType untyped nil, func()
2025/10/11 16:12:26 ==> MatchType untyped nil, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 Val foo func() (func(), error)
2025/10/11 16:12:26 Call 0 0 // func() (func(), error)
2025/10/11 16:12:26 ==> MatchFuncCall func() (func(), error) args: 0 flags: 0
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 NewVar [_xgo_err]
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Assign 2 1
2025/10/11 16:12:26 ==> MatchType func(), unboundType{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val <nil> <nil>
2025/10/11 16:12:26 BinaryOp !=
2025/10/11 16:12:26 Typ error
2025/10/11 16:12:26 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef _xgo_err error
2025/10/11 16:12:26 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Val foo() string
2025/10/11 16:12:26 Val /foo/bar.xgo string
2025/10/11 16:12:26 Val 6 int
2025/10/11 16:12:26 Val main.main string
2025/10/11 16:12:26 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:26 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:26 ==> MatchType error, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 ==> MatchType untyped string ("foo()"), string
2025/10/11 16:12:26 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:26 ==> MatchType untyped int (6), int
2025/10/11 16:12:26 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 Val panic func(v interface{})
2025/10/11 16:12:26 Val _xgo_err error
2025/10/11 16:12:26 Call 1 0 // func(v interface{})
2025/10/11 16:12:26 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType error, interface{}
2025/10/11 16:12:26 ==> EnsureLoaded error
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret func())
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret func()) args: 0 flags: 0
2025/10/11 16:12:26 Call 0 0 // func()
2025/10/11 16:12:26 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestErrWrapCall (0.00s)
=== RUN   TestMakeAndNew
2025/10/11 16:12:26 ==> Preload var [a]
2025/10/11 16:12:26 ==> Preload var [b]
2025/10/11 16:12:26 ==> Preload var [c]
2025/10/11 16:12:26 ==> Load var *int [a]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [a]
2025/10/11 16:12:26 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:26 Val int int
2025/10/11 16:12:26 Val type int => Typ int
2025/10/11 16:12:26 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType *int, *int
2025/10/11 16:12:26 ==> Load var map[string]int [b]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [b]
2025/10/11 16:12:26 Val make TyInstruction{gogen.makeInstr}
2025/10/11 16:12:26 Typ map[string]int
2025/10/11 16:12:26 Call 1 0 // TyInstruction{gogen.makeInstr}
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 1 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType map[string]int, map[string]int
2025/10/11 16:12:26 ==> Load var []byte [c]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [c]
2025/10/11 16:12:26 Val make TyInstruction{gogen.makeInstr}
2025/10/11 16:12:26 Typ []byte
2025/10/11 16:12:26 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Call 3 0 // TyInstruction{gogen.makeInstr}
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 3 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType []byte, []byte
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestMakeAndNew (0.00s)
=== RUN   TestVarDecl
2025/10/11 16:12:26 ==> Preload var [a]
2025/10/11 16:12:26 ==> Preload var [x y]
2025/10/11 16:12:26 ==> Load var int [a]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [a]
2025/10/11 16:12:26 ==> Load var <nil> [x y]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x y]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 EndInit 2
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestVarDecl (0.00s)
=== RUN   TestUint128Add
2025/10/11 16:12:26 ==> Preload var [x y]
2025/10/11 16:12:26 ==> Preload var [z]
2025/10/11 16:12:26 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x y]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x y]
2025/10/11 16:12:26 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [z]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [z]
2025/10/11 16:12:26 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:26 Val y github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 Typ github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:26 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:26 ==> MatchFuncCall func(u github.com/qiniu/x/xgo/ng.Uint128, n uint64) (v github.com/qiniu/x/xgo/ng.Uint128) args: 2 flags: 64
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, uint64
2025/10/11 16:12:26 ==> MatchFuncCall func(u github.com/qiniu/x/xgo/ng.Uint128, n github.com/qiniu/x/xgo/ng.Uint128) (v github.com/qiniu/x/xgo/ng.Uint128) args: 2 flags: 64
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestUint128Add (0.00s)
=== RUN   TestInt128Add
2025/10/11 16:12:26 ==> Preload var [x y]
2025/10/11 16:12:26 ==> Preload var [z]
2025/10/11 16:12:26 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x y]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x y]
2025/10/11 16:12:26 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [z]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [z]
2025/10/11 16:12:26 Val x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:26 Val y github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 Typ github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:26 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:26 ==> MatchFuncCall func(i github.com/qiniu/x/xgo/ng.Int128, n int64) (v github.com/qiniu/x/xgo/ng.Int128) args: 2 flags: 64
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, int64
2025/10/11 16:12:26 ==> MatchFuncCall func(i github.com/qiniu/x/xgo/ng.Int128, n github.com/qiniu/x/xgo/ng.Int128) (v github.com/qiniu/x/xgo/ng.Int128) args: 2 flags: 64
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestInt128Add (0.00s)
=== RUN   TestBigIntAdd
2025/10/11 16:12:26 ==> Preload var [x y]
2025/10/11 16:12:26 ==> Preload var [z]
2025/10/11 16:12:26 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x y]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x y]
2025/10/11 16:12:26 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [z]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [z]
2025/10/11 16:12:26 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 Val y github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 Typ github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/10/11 16:12:26 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigint, b github.com/qiniu/x/xgo/ng.Bigint) github.com/qiniu/x/xgo/ng.Bigint args: 2 flags: 64
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestBigIntAdd (0.00s)
=== RUN   TestBigIntLit
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Load var <nil> [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 Val NewInt func(x int64) *math/big.Int
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(x int64) *math/big.Int
2025/10/11 16:12:26 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (1), int64
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, int
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigint github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestBigIntLit (0.00s)
=== RUN   TestUint128Lit
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (1), int
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestUint128Lit (0.00s)
=== RUN   TestInt128Lit
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (1), int
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestInt128Lit (0.00s)
=== RUN   TestBigRatLit
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Load var <nil> [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val NewInt func(x int64) *math/big.Int
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(x int64) *math/big.Int
2025/10/11 16:12:26 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (2), int64
2025/10/11 16:12:26 BinaryOp /
2025/10/11 16:12:26 Typ github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 Member Gop_Quo 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.UntypedBigint}
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.UntypedBigint true
2025/10/11 16:12:26 Val NewRat func(a int64, b int64) *math/big.Rat
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Call 2 0 // func(a int64, b int64) *math/big.Rat
2025/10/11 16:12:26 ==> MatchFuncCall func(a int64, b int64) *math/big.Rat args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (1), int64
2025/10/11 16:12:26 ==> MatchType untyped int (2), int64
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.UntypedBigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> AssignableConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.UntypedBigint false
2025/10/11 16:12:26 ==> MatchFuncCall func(x *math/big.Rat) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, *math/big.Rat
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestBigRatLit (0.00s)
=== RUN   TestBigRatLitAdd
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Load var <nil> [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val NewInt func(x int64) *math/big.Int
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(x int64) *math/big.Int
2025/10/11 16:12:26 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (2), int64
2025/10/11 16:12:26 BinaryOp /
2025/10/11 16:12:26 Typ github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 Member Gop_Quo 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.UntypedBigint}
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.UntypedBigint true
2025/10/11 16:12:26 Val NewRat func(a int64, b int64) *math/big.Rat
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Call 2 0 // func(a int64, b int64) *math/big.Rat
2025/10/11 16:12:26 ==> MatchFuncCall func(a int64, b int64) *math/big.Rat args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (1), int64
2025/10/11 16:12:26 ==> MatchType untyped int (2), int64
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 Typ github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.UntypedBigrat}
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (3), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat (0.5), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.UntypedBigrat true
2025/10/11 16:12:26 Val NewRat func(a int64, b int64) *math/big.Rat
2025/10/11 16:12:26 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Call 2 0 // func(a int64, b int64) *math/big.Rat
2025/10/11 16:12:26 ==> MatchFuncCall func(a int64, b int64) *math/big.Rat args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (7), int64
2025/10/11 16:12:26 ==> MatchType untyped int (2), int64
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.UntypedBigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> AssignableConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.UntypedBigint false
2025/10/11 16:12:26 ==> MatchFuncCall func(x *math/big.Rat) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, *math/big.Rat
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestBigRatLitAdd (0.00s)
=== RUN   TestBigRatAdd
2025/10/11 16:12:26 SetDebug: import=true, match=true, instr=true
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Preload var [y]
2025/10/11 16:12:26 ==> Preload var [z]
2025/10/11 16:12:26 ==> Load var <nil> [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val NewInt func(x int64) *math/big.Int
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(x int64) *math/big.Int
2025/10/11 16:12:26 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (2), int64
2025/10/11 16:12:26 BinaryOp /
2025/10/11 16:12:26 Typ github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 Member Gop_Quo 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.UntypedBigint}
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.UntypedBigint true
2025/10/11 16:12:26 Val NewRat func(a int64, b int64) *math/big.Rat
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Call 2 0 // func(a int64, b int64) *math/big.Rat
2025/10/11 16:12:26 ==> MatchFuncCall func(a int64, b int64) *math/big.Rat args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (1), int64
2025/10/11 16:12:26 ==> MatchType untyped int (2), int64
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 Typ github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.UntypedBigrat}
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (3), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat (0.5), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.UntypedBigrat true
2025/10/11 16:12:26 Val NewRat func(a int64, b int64) *math/big.Rat
2025/10/11 16:12:26 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Call 2 0 // func(a int64, b int64) *math/big.Rat
2025/10/11 16:12:26 ==> MatchFuncCall func(a int64, b int64) *math/big.Rat args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (7), int64
2025/10/11 16:12:26 ==> MatchType untyped int (2), int64
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.UntypedBigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> AssignableConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.UntypedBigint false
2025/10/11 16:12:26 ==> MatchFuncCall func(x *math/big.Rat) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, *math/big.Rat
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/10/11 16:12:26 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 ==> Load var <nil> [y]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [y]
2025/10/11 16:12:26 Val x github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 Typ github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigrat}
2025/10/11 16:12:26 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigrat, b github.com/qiniu/x/xgo/ng.Bigrat) github.com/qiniu/x/xgo/ng.Bigrat args: 2 flags: 64
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Bigrat, github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 ==> MatchType untyped int (100), github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (100), int
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigrat true
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> Load var <nil> [z]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [z]
2025/10/11 16:12:26 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:26 Val y github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 Typ github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigrat}
2025/10/11 16:12:26 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigrat, b github.com/qiniu/x/xgo/ng.Bigrat) github.com/qiniu/x/xgo/ng.Bigrat args: 2 flags: 64
2025/10/11 16:12:26 ==> MatchType untyped int (100), github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (100), int
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigrat true
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.Bigrat, github.com/qiniu/x/xgo/ng.Bigrat
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestBigRatAdd (0.00s)
=== RUN   TestTypeConv
2025/10/11 16:12:26 ==> Preload var [a]
2025/10/11 16:12:26 ==> Preload var [b]
2025/10/11 16:12:26 ==> Preload var [c]
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Preload var [y]
2025/10/11 16:12:26 ==> Load var <nil> [a]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [a]
2025/10/11 16:12:26 Typ struct{}
2025/10/11 16:12:26 Star
2025/10/11 16:12:26 Val nil untyped nil
2025/10/11 16:12:26 Call 1 0 // TypeType{typ: *struct{}}
2025/10/11 16:12:26 ==> MatchFuncCall TypeType{typ: *struct{}} args: 1 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> Load var <nil> [b]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [b]
2025/10/11 16:12:26 Typ interface{}
2025/10/11 16:12:26 Val nil untyped nil
2025/10/11 16:12:26 Call 1 0 // TypeType{typ: interface{}}
2025/10/11 16:12:26 ==> MatchFuncCall TypeType{typ: interface{}} args: 1 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> Load var <nil> [c]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [c]
2025/10/11 16:12:26 Typ func()
2025/10/11 16:12:26 Val nil untyped nil
2025/10/11 16:12:26 Call 1 0 // TypeType{typ: func()}
2025/10/11 16:12:26 ==> MatchFuncCall TypeType{typ: func()} args: 1 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> Load var uint32 [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 Val uint32 uint32
2025/10/11 16:12:26 Val type uint32 => Typ uint32
2025/10/11 16:12:26 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // TypeType{typ: uint32}
2025/10/11 16:12:26 ==> MatchFuncCall TypeType{typ: uint32} args: 1 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType uint32 (0), uint32
2025/10/11 16:12:26 ==> Load var *uint32 [y]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [y]
2025/10/11 16:12:26 Val uint32 uint32
2025/10/11 16:12:26 Val type uint32 => Typ uint32
2025/10/11 16:12:26 Star
2025/10/11 16:12:26 Val nil untyped nil
2025/10/11 16:12:26 Call 1 0 // TypeType{typ: *uint32}
2025/10/11 16:12:26 ==> MatchFuncCall TypeType{typ: *uint32} args: 1 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType *uint32, *uint32
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestTypeConv (0.00s)
=== RUN   TestStar
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Preload var [y]
2025/10/11 16:12:26 ==> Load var *uint32 [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 Val uint32 uint32
2025/10/11 16:12:26 Val type uint32 => Typ uint32
2025/10/11 16:12:26 Star
2025/10/11 16:12:26 Val nil untyped nil
2025/10/11 16:12:26 Call 1 0 // TypeType{typ: *uint32}
2025/10/11 16:12:26 ==> MatchFuncCall TypeType{typ: *uint32} args: 1 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType *uint32, *uint32
2025/10/11 16:12:26 ==> Load var uint32 [y]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [y]
2025/10/11 16:12:26 Val x *uint32
2025/10/11 16:12:26 Star
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType uint32, uint32
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestStar (0.00s)
=== RUN   TestLHS
2025/10/11 16:12:26 ==> Preload type T
2025/10/11 16:12:26 ==> Preload func foo
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load > NewType T
2025/10/11 16:12:26 NewType T
2025/10/11 16:12:26 ==> Load > InitType T
2025/10/11 16:12:26 InitType T struct{a int}
2025/10/11 16:12:26 ==> Load func foo
2025/10/11 16:12:26 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{a int}
2025/10/11 16:12:26 NewFunc foo func() *github.com/goplus/xgo/cl.T
2025/10/11 16:12:26 Val nil untyped nil
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType untyped nil, *github.com/goplus/xgo/cl.T
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 Val foo func() *github.com/goplus/xgo/cl.T
2025/10/11 16:12:26 Call 0 0 // func() *github.com/goplus/xgo/cl.T
2025/10/11 16:12:26 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.T args: 0 flags: 0
2025/10/11 16:12:26 Member a -1 // *github.com/goplus/xgo/cl.T
2025/10/11 16:12:26 Val &{0 INT 123} *ast.BasicLit
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType untyped int (123), int
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestLHS (0.00s)
=== RUN   TestSend
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load var chan bool [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 Val x chan bool
2025/10/11 16:12:26 Val true untyped bool
2025/10/11 16:12:26 Send
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestSend (0.00s)
=== RUN   TestIncDec
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load var uint32 [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 VarRef x uint32
2025/10/11 16:12:26 IncDec ++
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestIncDec (0.00s)
=== RUN   TestAssignOp
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load var uint32 [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 VarRef x uint32
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 AssignOp += Gop_AddAssign
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType refType{typ: uint32}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:26 ==> MatchType untyped int (3), unboundFuncParam{typ: uint32}
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestAssignOp (0.00s)
=== RUN   TestBigIntAssignOp
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 AssignOp += Gop_AddAssign
2025/10/11 16:12:26 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Bigint) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 ==> MatchType untyped int (3), github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (3), int
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestBigIntAssignOp (0.00s)
=== RUN   TestBigIntAssignOp2
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [x]
2025/10/11 16:12:26 Val NewInt func(x int64) *math/big.Int
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(x int64) *math/big.Int
2025/10/11 16:12:26 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (3), int64
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, int
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigint github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 AssignOp *= Gop_MulAssign
2025/10/11 16:12:26 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Bigint) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 ==> MatchType untyped int (2), github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (2), int
2025/10/11 16:12:26 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestBigIntAssignOp2 (0.00s)
=== RUN   TestBigIntAssignOp3
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [x]
2025/10/11 16:12:26 Val NewInt func(x int64) *math/big.Int
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(x int64) *math/big.Int
2025/10/11 16:12:26 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (3), int64
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, int
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigint github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 Val NewInt func(x int64) *math/big.Int
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(x int64) *math/big.Int
2025/10/11 16:12:26 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped int (2), int64
2025/10/11 16:12:26 AssignOp *= Gop_MulAssign
2025/10/11 16:12:26 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Bigint) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), int
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:26 ==> AssignableConv github.com/qiniu/x/xgo/ng.UntypedBigint github.com/qiniu/x/xgo/ng.Bigint true
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestBigIntAssignOp3 (0.00s)
=== RUN   TestCompositeLit
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [x]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 SliceLit []float64 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [y]
2025/10/11 16:12:26 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 MapLit map[string]int 4
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [z]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 ArrayLit [-1]int 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 5.1} *ast.BasicLit
2025/10/11 16:12:26 MapLit <nil> 4
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestCompositeLit (0.00s)
=== RUN   TestCompositeLit2
2025/10/11 16:12:26 ==> Preload type foo
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load > NewType foo
2025/10/11 16:12:26 NewType foo
2025/10/11 16:12:26 ==> Load > InitType foo
2025/10/11 16:12:26 InitType foo struct{A int}
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [x]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 StructLit struct{a int} 1 false
2025/10/11 16:12:26 UnaryOp & flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 StructLit struct{a int} 1 false
2025/10/11 16:12:26 UnaryOp & flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 StructLit struct{a int} 1 false
2025/10/11 16:12:26 UnaryOp & flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:26 SliceLit []*struct{a int} 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [y]
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{A int}
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.foo 1 false
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 StructLit struct{a string} 1 false
2025/10/11 16:12:26 MapLit map[github.com/goplus/xgo/cl.foo]struct{a string} 2
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [z]
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{A int}
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.foo 1 false
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.foo 1 false
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.foo 1 false
2025/10/11 16:12:26 ArrayLit [-1]github.com/goplus/xgo/cl.foo 3 false
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestCompositeLit2 (0.00s)
=== RUN   TestCompositeLit3
2025/10/11 16:12:26 ==> Preload type Config
2025/10/11 16:12:26 ==> Preload func foo
2025/10/11 16:12:26 ==> Preload func bar
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load > NewType Config
2025/10/11 16:12:26 NewType Config
2025/10/11 16:12:26 ==> Load > InitType Config
2025/10/11 16:12:26 InitType Config struct{A int}
2025/10/11 16:12:26 ==> Load func foo
2025/10/11 16:12:26 ==> LookupParent Config => type github.com/goplus/xgo/cl.Config struct{A int}
2025/10/11 16:12:26 NewFunc foo func(conf *github.com/goplus/xgo/cl.Config)
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> Load func bar
2025/10/11 16:12:26 ==> LookupParent Config => type github.com/goplus/xgo/cl.Config struct{A int}
2025/10/11 16:12:26 NewFunc bar func(conf ...github.com/goplus/xgo/cl.Config)
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 Val foo func(conf *github.com/goplus/xgo/cl.Config)
2025/10/11 16:12:26 Val 0 int
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.Config 2 true
2025/10/11 16:12:26 UnaryOp & flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:26 Call 1 0 // func(conf *github.com/goplus/xgo/cl.Config)
2025/10/11 16:12:26 ==> MatchFuncCall func(conf *github.com/goplus/xgo/cl.Config) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType *github.com/goplus/xgo/cl.Config, *github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 Val bar func(conf ...github.com/goplus/xgo/cl.Config)
2025/10/11 16:12:26 Val 0 int
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.Config 2 true
2025/10/11 16:12:26 Call 1 0 // func(conf ...github.com/goplus/xgo/cl.Config)
2025/10/11 16:12:26 ==> MatchFuncCall func(conf ...github.com/goplus/xgo/cl.Config) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/goplus/xgo/cl.Config, github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 Val foo func(conf *github.com/goplus/xgo/cl.Config)
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.Config 0 false
2025/10/11 16:12:26 UnaryOp & flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:26 Call 1 0 // func(conf *github.com/goplus/xgo/cl.Config)
2025/10/11 16:12:26 ==> MatchFuncCall func(conf *github.com/goplus/xgo/cl.Config) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType *github.com/goplus/xgo/cl.Config, *github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 Val bar func(conf ...github.com/goplus/xgo/cl.Config)
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.Config 0 false
2025/10/11 16:12:26 Call 1 0 // func(conf ...github.com/goplus/xgo/cl.Config)
2025/10/11 16:12:26 ==> MatchFuncCall func(conf ...github.com/goplus/xgo/cl.Config) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType github.com/goplus/xgo/cl.Config, github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestCompositeLit3 (0.00s)
=== RUN   TestCompositeLit4
2025/10/11 16:12:26 ==> Preload type Result
2025/10/11 16:12:26 ==> Preload func foo
2025/10/11 16:12:26 ==> Load > NewType Result
2025/10/11 16:12:26 NewType Result
2025/10/11 16:12:26 ==> Load > InitType Result
2025/10/11 16:12:26 InitType Result struct{A int}
2025/10/11 16:12:26 ==> Load func foo
2025/10/11 16:12:26 ==> LookupParent Result => type github.com/goplus/xgo/cl.Result struct{A int}
2025/10/11 16:12:26 NewFunc foo func() *github.com/goplus/xgo/cl.Result
2025/10/11 16:12:26 Val 0 int
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.Result 2 true
2025/10/11 16:12:26 UnaryOp & flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType *github.com/goplus/xgo/cl.Result, *github.com/goplus/xgo/cl.Result
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestCompositeLit4 (0.00s)
=== RUN   TestCompositeLit5
2025/10/11 16:12:26 ==> Preload type mymap
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Preload var [y]
2025/10/11 16:12:26 ==> Preload var [z]
2025/10/11 16:12:26 ==> Load > NewType mymap
2025/10/11 16:12:26 NewType mymap
2025/10/11 16:12:26 ==> Load > InitType mymap
2025/10/11 16:12:26 InitType mymap map[float64]string
2025/10/11 16:12:26 ==> Load var <nil> [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:12:26 MapLit <nil> 4
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> Load var map[float64]string [y]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [y]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:12:26 MapLit map[float64]string 4
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType map[float64]string, map[float64]string
2025/10/11 16:12:26 ==> LookupParent mymap => type github.com/goplus/xgo/cl.mymap map[float64]string
2025/10/11 16:12:26 ==> Load var github.com/goplus/xgo/cl.mymap [z]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [z]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:12:26 MapLit github.com/goplus/xgo/cl.mymap 4
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType github.com/goplus/xgo/cl.mymap, github.com/goplus/xgo/cl.mymap
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.mymap
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.mymap
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestCompositeLit5 (0.00s)
=== RUN   TestSliceLit
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [x]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [y]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 1 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [z]
2025/10/11 16:12:26 SliceLit <nil> 0 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
2025/10/11 16:12:26 ==> Preload type vector
2025/10/11 16:12:26 ==> Preload var [x]
2025/10/11 16:12:26 ==> Preload var [y]
2025/10/11 16:12:26 ==> Preload var [z]
2025/10/11 16:12:26 ==> Load > NewType vector
2025/10/11 16:12:26 NewType vector
2025/10/11 16:12:26 ==> Load > InitType vector
2025/10/11 16:12:26 InitType vector []float64
2025/10/11 16:12:26 ==> Load var <nil> [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> Load var []float64 [y]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [y]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 SliceLit []float64 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType []float64, []float64
2025/10/11 16:12:26 ==> LookupParent vector => type github.com/goplus/xgo/cl.vector []float64
2025/10/11 16:12:26 ==> Load var github.com/goplus/xgo/cl.vector [z]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [z]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 SliceLit github.com/goplus/xgo/cl.vector 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType github.com/goplus/xgo/cl.vector, github.com/goplus/xgo/cl.vector
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.vector
2025/10/11 16:12:26 ==> EnsureLoaded github.com/goplus/xgo/cl.vector
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestSliceLit (0.00s)
=== RUN   TestChan
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 Val make TyInstruction{gogen.makeInstr}
2025/10/11 16:12:26 Typ chan int
2025/10/11 16:12:26 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:26 Call 2 0 // TyInstruction{gogen.makeInstr}
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 2 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 Val a chan int
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Send
2025/10/11 16:12:26 ==> Load var int [b]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [b]
2025/10/11 16:12:26 Val a chan int
2025/10/11 16:12:26 UnaryOp <- flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ==> MatchType int, int
2025/10/11 16:12:26 DefineVarStart [x ok]
2025/10/11 16:12:26 Val a chan int
2025/10/11 16:12:26 UnaryOp <- flags: 2
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 2
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestChan (0.00s)
=== RUN   TestKeyValModeLit
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 None
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:12:26 None
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 ArrayLit [-1]float64 6 true
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [b]
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:26 None
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 4.5} *ast.BasicLit
2025/10/11 16:12:26 SliceLit []float64 6 true
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestKeyValModeLit (0.00s)
=== RUN   TestStructLit
2025/10/11 16:12:26 ==> Preload type foo
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load > NewType foo
2025/10/11 16:12:26 NewType foo
2025/10/11 16:12:26 ==> Load > InitType foo
2025/10/11 16:12:26 InitType foo struct{A int; B string "tag1:123"}
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:26 StructLit struct{A int; B string "tag1:123"} 2 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [b]
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{A int; B string "tag1:123"}
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.foo 2 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [c]
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{A int; B string "tag1:123"}
2025/10/11 16:12:26 Val 1 int
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.foo 2 true
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestStructLit (0.00s)
=== RUN   TestStructType
2025/10/11 16:12:26 ==> Preload type bar
2025/10/11 16:12:26 ==> Preload type foo
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load > AliasType bar
2025/10/11 16:12:26 ==> Load > NewType foo
2025/10/11 16:12:26 NewType foo
2025/10/11 16:12:26 ==> Lookup (LoadSymbol) foo => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:26 AliasType bar github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 ==> Load > InitType foo
2025/10/11 16:12:26 ==> LookupParent bar => type github.com/goplus/xgo/cl.bar = github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 InitType foo struct{p *github.com/goplus/xgo/cl.foo; A int; B string "tag1:123"}
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 NewType a
2025/10/11 16:12:26 ==> LookupParent a => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:26 InitType a struct{p *github.com/goplus/xgo/cl.a}
2025/10/11 16:12:26 ==> LookupParent a => type a struct{p *github.com/goplus/xgo/cl.a}
2025/10/11 16:12:26 AliasType b github.com/goplus/xgo/cl.a
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestStructType (0.00s)
=== RUN   TestDeferGo
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:26 Go
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("XGo"), any
2025/10/11 16:12:26 Defer
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestDeferGo (0.00s)
=== RUN   TestFor
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 For
2025/10/11 16:12:26 DefineVarStart [i]
2025/10/11 16:12:26 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp <
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType int, any
2025/10/11 16:12:26 Post
2025/10/11 16:12:26 VarRef i int
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType int, int
2025/10/11 16:12:26 End // For
2025/10/11 16:12:26 For
2025/10/11 16:12:26 None
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val &{0 STRING "loop"} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("loop"), any
2025/10/11 16:12:26 End // For
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestFor (0.00s)
=== RUN   TestRangeStmt
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ForRange [_ x]
2025/10/11 16:12:26 Val a []float64
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 VBlock
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val x float64
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType float64, any
2025/10/11 16:12:26 End // Vblock
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 ForRange [i x]
2025/10/11 16:12:26 Val a []float64
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 VBlock
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Val x float64
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, any
2025/10/11 16:12:26 ==> MatchType float64, any
2025/10/11 16:12:26 End // Vblock
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 ==> Load var int [i]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [i]
2025/10/11 16:12:26 ==> Load var float64 [x]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [x]
2025/10/11 16:12:26 ForRange []
2025/10/11 16:12:26 VarRef _
2025/10/11 16:12:26 VarRef x float64
2025/10/11 16:12:26 Val a []float64
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 ==> MatchType float64, float64
2025/10/11 16:12:26 VBlock
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Val x float64
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, any
2025/10/11 16:12:26 ==> MatchType float64, any
2025/10/11 16:12:26 End // Vblock
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 ForRange []
2025/10/11 16:12:26 VarRef i int
2025/10/11 16:12:26 VarRef x float64
2025/10/11 16:12:26 Val a []float64
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 ==> MatchType int, int
2025/10/11 16:12:26 ==> MatchType float64, float64
2025/10/11 16:12:26 VBlock
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Val x float64
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, any
2025/10/11 16:12:26 ==> MatchType float64, any
2025/10/11 16:12:26 End // Vblock
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 ForRange []
2025/10/11 16:12:26 Val a []float64
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 VBlock
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:26 End // Vblock
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestRangeStmt (0.00s)
=== RUN   TestRangeStmtUDT
2025/10/11 16:12:26 ==> Preload type foo
2025/10/11 16:12:26 ==> Preload method foo.Gop_Enum
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load > NewType foo
2025/10/11 16:12:26 NewType foo
2025/10/11 16:12:26 ==> Load > InitType foo
2025/10/11 16:12:26 InitType foo struct{}
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:26 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Enum
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 ForRange [k v]
2025/10/11 16:12:26 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:26 Val foo github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Val type github.com/goplus/xgo/cl.foo struct{} => Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 VBlock
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val k int
2025/10/11 16:12:26 Val v string
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, any
2025/10/11 16:12:26 ==> MatchType string, any
2025/10/11 16:12:26 End // Vblock
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 NewFunc Gop_Enum (*github.com/goplus/xgo/cl.foo) func(c func(key int, val string))
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestRangeStmtUDT (0.00s)
=== RUN   TestForPhraseUDT
2025/10/11 16:12:26 ==> Preload type foo
2025/10/11 16:12:26 ==> Preload method foo.Gop_Enum
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load > NewType foo
2025/10/11 16:12:26 NewType foo
2025/10/11 16:12:26 ==> Load > InitType foo
2025/10/11 16:12:26 InitType foo struct{}
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:26 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Enum
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 ForRange [_ v]
2025/10/11 16:12:26 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:26 Val foo github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Val type github.com/goplus/xgo/cl.foo struct{} => Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 VBlock
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val v string
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType string, any
2025/10/11 16:12:26 End // Vblock
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 NewFunc Gop_Enum (*github.com/goplus/xgo/cl.foo) func(c func(val string))
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestForPhraseUDT (0.00s)
=== RUN   TestForPhraseUDT2
2025/10/11 16:12:26 ==> Preload type fooIter
2025/10/11 16:12:26 ==> Preload method fooIter.Next
2025/10/11 16:12:26 ==> Preload type foo
2025/10/11 16:12:26 ==> Preload method foo.Gop_Enum
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load > NewType fooIter
2025/10/11 16:12:26 NewType fooIter
2025/10/11 16:12:26 ==> Load > InitType fooIter
2025/10/11 16:12:26 InitType fooIter struct{}
2025/10/11 16:12:26 ==> LookupParent fooIter => type github.com/goplus/xgo/cl.fooIter struct{}
2025/10/11 16:12:26 ==> Load method github.com/goplus/xgo/cl.fooIter.Next
2025/10/11 16:12:26 ==> Load > NewType foo
2025/10/11 16:12:26 NewType foo
2025/10/11 16:12:26 ==> Load > InitType foo
2025/10/11 16:12:26 InitType foo struct{}
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:26 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Enum
2025/10/11 16:12:26 ==> LookupParent fooIter => type github.com/goplus/xgo/cl.fooIter struct{}
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 ForRange [k v]
2025/10/11 16:12:26 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:26 Val foo github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Val type github.com/goplus/xgo/cl.foo struct{} => Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 VBlock
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val k string
2025/10/11 16:12:26 Val v int
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType string, any
2025/10/11 16:12:26 ==> MatchType int, any
2025/10/11 16:12:26 End // Vblock
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Member Gop_Enum 0 // *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Call 0 0 // func() github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 ==> MatchFuncCall func() github.com/goplus/xgo/cl.fooIter args: 0 flags: 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 NewFunc Next (github.com/goplus/xgo/cl.fooIter) func() (key string, val int, ok bool)
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 NewFunc Gop_Enum (*github.com/goplus/xgo/cl.foo) func() github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestForPhraseUDT2 (0.00s)
=== RUN   TestForPhraseUDT3
2025/10/11 16:12:26 ==> Preload type foo
2025/10/11 16:12:26 ==> Preload method foo.Gop_Enum
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load > NewType foo
2025/10/11 16:12:26 NewType foo
2025/10/11 16:12:26 ==> Load > InitType foo
2025/10/11 16:12:26 InitType foo struct{}
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:26 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Enum
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 ForRange [_ v]
2025/10/11 16:12:26 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:26 Val foo github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Val type github.com/goplus/xgo/cl.foo struct{} => Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 Val v string
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType []string, unboundType{typ: <nil>}
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret []string)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret []string) args: 0 flags: 0
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType []string, any
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 NewFunc Gop_Enum (*github.com/goplus/xgo/cl.foo) func(c func(val string))
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestForPhraseUDT3 (0.00s)
=== RUN   TestForPhraseUDT4
2025/10/11 16:12:26 ==> Preload type fooIter
2025/10/11 16:12:26 ==> Preload method fooIter.Next
2025/10/11 16:12:26 ==> Preload type foo
2025/10/11 16:12:26 ==> Preload func newFoo
2025/10/11 16:12:26 ==> Preload method foo.Gop_Enum
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load > NewType fooIter
2025/10/11 16:12:26 NewType fooIter
2025/10/11 16:12:26 ==> Load > InitType fooIter
2025/10/11 16:12:26 ==> Load > NewType foo
2025/10/11 16:12:26 NewType foo
2025/10/11 16:12:26 ==> Lookup (LoadSymbol) foo => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:26 InitType fooIter struct{data *github.com/goplus/xgo/cl.foo; idx int}
2025/10/11 16:12:26 ==> LookupParent fooIter => type github.com/goplus/xgo/cl.fooIter struct{data *github.com/goplus/xgo/cl.foo; idx int}
2025/10/11 16:12:26 ==> Load method *github.com/goplus/xgo/cl.fooIter.Next
2025/10/11 16:12:26 ==> Load > InitType foo
2025/10/11 16:12:26 InitType foo struct{key []int; val []string}
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{key []int; val []string}
2025/10/11 16:12:26 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Enum
2025/10/11 16:12:26 ==> LookupParent fooIter => type github.com/goplus/xgo/cl.fooIter struct{data *github.com/goplus/xgo/cl.foo; idx int}
2025/10/11 16:12:26 ==> Load func newFoo
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{key []int; val []string}
2025/10/11 16:12:26 NewFunc newFoo func() *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{key []int; val []string}
2025/10/11 16:12:26 Val 0 int
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:26 SliceLit []int 2 false
2025/10/11 16:12:26 Val 1 int
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:26 SliceLit []string 2 false
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.foo 4 true
2025/10/11 16:12:26 UnaryOp & flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 ForRange [k v]
2025/10/11 16:12:26 Val newFoo func() *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Call 0 0 // func() *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.foo args: 0 flags: 0
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 VBlock
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val k int
2025/10/11 16:12:26 Val v string
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, any
2025/10/11 16:12:26 ==> MatchType string, any
2025/10/11 16:12:26 End // Vblock
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Member Gop_Enum 0 // *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Call 0 0 // func() *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.fooIter args: 0 flags: 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 NewFunc Next (*github.com/goplus/xgo/cl.fooIter) func() (key int, val string, ok bool)
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val p *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Member idx 2 // *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Val len TyInstruction{gogen.lenInstr}
2025/10/11 16:12:26 Val p *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Member data 2 // *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Member key 2 // *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Call 1 0 // TyInstruction{gogen.lenInstr}
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.lenInstr} args: 1 flags: 0
2025/10/11 16:12:26 BinaryOp <
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef key int
2025/10/11 16:12:26 VarRef val string
2025/10/11 16:12:26 VarRef ok bool
2025/10/11 16:12:26 Val p *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Member data 2 // *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Member key 2 // *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Val p *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Member idx 2 // *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Index 1 false
2025/10/11 16:12:26 Val p *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Member data 2 // *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Member val 2 // *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 Val p *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Member idx 2 // *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Index 1 false
2025/10/11 16:12:26 Val true untyped bool
2025/10/11 16:12:26 Assign 3 3
2025/10/11 16:12:26 ==> MatchType int, int
2025/10/11 16:12:26 ==> MatchType string, string
2025/10/11 16:12:26 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:26 Val p *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 Member idx -1 // *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 IncDec ++
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 NewFunc Gop_Enum (*github.com/goplus/xgo/cl.foo) func() *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 ==> LookupParent fooIter => type github.com/goplus/xgo/cl.fooIter struct{data *github.com/goplus/xgo/cl.foo; idx int}
2025/10/11 16:12:26 Val 0 int
2025/10/11 16:12:26 Val p *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 StructLit github.com/goplus/xgo/cl.fooIter 2 true
2025/10/11 16:12:26 UnaryOp & flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType *github.com/goplus/xgo/cl.fooIter, *github.com/goplus/xgo/cl.fooIter
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestForPhraseUDT4 (0.00s)
=== RUN   TestForPhrase
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [sum]
2025/10/11 16:12:26 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 ForRange [_ x]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 11} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 13} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 17} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 7 false
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val x int
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp >
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef sum int
2025/10/11 16:12:26 Val sum int
2025/10/11 16:12:26 Val x int
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType int, int
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 ForRange [i x]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 11} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 13} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 17} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 7 false
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 VBlock
2025/10/11 16:12:26 VarRef sum int
2025/10/11 16:12:26 Val sum int
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Val x int
2025/10/11 16:12:26 BinaryOp *
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:26 BinaryOp +
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType int, int
2025/10/11 16:12:26 End // Vblock
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val &{0 STRING "sum(5,7,11,13,17):"} *ast.BasicLit
2025/10/11 16:12:26 Val sum int
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("sum(5,7,11,13,17):"), any
2025/10/11 16:12:26 ==> MatchType int, any
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestForPhrase (0.00s)
=== RUN   TestMapComprehension
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [y]
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 ZeroLit // unboundType{typ: <nil>}
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/10/11 16:12:26 ForRange [i x]
2025/10/11 16:12:26 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "3"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "7"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "11"} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 5 false
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 Val x string
2025/10/11 16:12:26 IndexRef 1
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType int, unboundMapElemType{key: string}
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret map[string]int)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret map[string]int) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestMapComprehension (0.00s)
=== RUN   TestMapComprehensionCond
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [z]
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 ZeroLit // unboundType{typ: <nil>}
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/10/11 16:12:26 ForRange [k v]
2025/10/11 16:12:26 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "xsw"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:26 MapLit <nil> 8
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val v int
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp >
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 Val v int
2025/10/11 16:12:26 IndexRef 1
2025/10/11 16:12:26 Val k string
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType string, unboundMapElemType{key: int}
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret map[int]string)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret map[int]string) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestMapComprehensionCond (0.00s)
=== RUN   TestMapComprehensionCond2
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [z]
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 ZeroLit // unboundType{typ: <nil>}
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/10/11 16:12:26 ForRange [k v]
2025/10/11 16:12:26 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "xsw"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:26 MapLit <nil> 8
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 If
2025/10/11 16:12:26 DefineVarStart [t]
2025/10/11 16:12:26 Val v int
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 Val t int
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp >
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 Val t int
2025/10/11 16:12:26 IndexRef 1
2025/10/11 16:12:26 Val k string
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType string, unboundMapElemType{key: int}
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret map[int]string)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret map[int]string) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestMapComprehensionCond2 (0.00s)
=== RUN   TestExistsComprehension
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [hasFive]
2025/10/11 16:12:26 NewClosure func() (_xgo_ok bool)
2025/10/11 16:12:26 ForRange [_ x]
2025/10/11 16:12:26 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "3"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "7"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "11"} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 5 false
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val x string
2025/10/11 16:12:26 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp ==
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 Val true bool
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ok bool)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ok bool) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestExistsComprehension (0.00s)
=== RUN   TestSelectComprehension
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [y]
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 ForRange [i x]
2025/10/11 16:12:26 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "3"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "7"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "11"} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 5 false
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val x string
2025/10/11 16:12:26 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp ==
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret int)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestSelectComprehension (0.00s)
=== RUN   TestSelectComprehensionTwoValue
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [y ok]
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>}, _xgo_ok bool)
2025/10/11 16:12:26 ForRange [i x]
2025/10/11 16:12:26 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "3"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "7"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "11"} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 5 false
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val x string
2025/10/11 16:12:26 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp ==
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Val true bool
2025/10/11 16:12:26 Return 2
2025/10/11 16:12:26 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret int, _xgo_ok bool)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret int, _xgo_ok bool) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestSelectComprehensionTwoValue (0.00s)
=== RUN   TestSelectComprehensionRetTwoValue
2025/10/11 16:12:26 ==> Preload func foo
2025/10/11 16:12:26 ==> Load func foo
2025/10/11 16:12:26 NewFunc foo func() (int, bool)
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>}, _xgo_ok bool)
2025/10/11 16:12:26 ForRange [i x]
2025/10/11 16:12:26 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "3"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "7"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "11"} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 5 false
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val x string
2025/10/11 16:12:26 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp ==
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 Val i int
2025/10/11 16:12:26 Val true bool
2025/10/11 16:12:26 Return 2
2025/10/11 16:12:26 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret int, _xgo_ok bool)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret int, _xgo_ok bool) args: 0 flags: 0
2025/10/11 16:12:26 Return 1
2025/10/11 16:12:26 ==> MatchType int, int
2025/10/11 16:12:26 ==> MatchType bool, bool
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestSelectComprehensionRetTwoValue (0.00s)
=== RUN   TestListComprehension
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [b]
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 ForRange [_ x]
2025/10/11 16:12:26 Val a []float64
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 Val x float64
2025/10/11 16:12:26 Val x float64
2025/10/11 16:12:26 BinaryOp *
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType []float64, unboundType{typ: <nil>}
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret []float64)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret []float64) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestListComprehension (0.00s)
=== RUN   TestListComprehensionMultiLevel
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [arr]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 4.1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 6 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [x]
2025/10/11 16:12:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:26 ForRange [_ b]
2025/10/11 16:12:26 Val arr []float64
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val b float64
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 BinaryOp >
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 ForRange [_ a]
2025/10/11 16:12:26 Val arr []float64
2025/10/11 16:12:26 RangeAssignThen
2025/10/11 16:12:26 If
2025/10/11 16:12:26 Val a float64
2025/10/11 16:12:26 Val b float64
2025/10/11 16:12:26 BinaryOp <
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:26 Val a float64
2025/10/11 16:12:26 Val b float64
2025/10/11 16:12:26 SliceLit <nil> 2 false
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 ==> MatchType []float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType [][]float64, unboundType{typ: <nil>}
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 End // If
2025/10/11 16:12:26 End // ForRange
2025/10/11 16:12:26 Return 0
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 Call 0 0 // func() (_xgo_ret [][]float64)
2025/10/11 16:12:26 ==> MatchFuncCall func() (_xgo_ret [][]float64) args: 0 flags: 0
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val &{0 STRING "x:"} *ast.BasicLit
2025/10/11 16:12:26 Val x [][]float64
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("x:"), any
2025/10/11 16:12:26 ==> MatchType [][]float64, any
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestListComprehensionMultiLevel (0.00s)
=== RUN   TestSliceGet
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 9} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 5 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [b]
2025/10/11 16:12:26 Val a []int
2025/10/11 16:12:26 None
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Slice false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [c]
2025/10/11 16:12:26 Val a []int
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 None
2025/10/11 16:12:26 Slice false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [d]
2025/10/11 16:12:26 Val a []int
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Slice true
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [e]
2025/10/11 16:12:26 Val &{0 STRING "Hello, XGo"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:26 None
2025/10/11 16:12:26 Slice false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestSliceGet (0.00s)
=== RUN   TestIndexGetTwoValue
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "xsw"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:26 MapLit <nil> 8
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [x ok]
2025/10/11 16:12:26 Val a map[string]int
2025/10/11 16:12:26 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:26 Index 1 true
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [y]
2025/10/11 16:12:26 Val a map[string]int
2025/10/11 16:12:26 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:26 Index 1 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestIndexGetTwoValue (0.00s)
=== RUN   TestIndexGet
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 DefineVarStart [b]
2025/10/11 16:12:26 Val a []float64
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Index 1 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestIndexGet (0.00s)
=== RUN   TestIndexRef
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [a]
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:26 SliceLit <nil> 3 false
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 Val a []float64
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 IndexRef 1
2025/10/11 16:12:26 Val &{0 FLOAT 2.1} *ast.BasicLit
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType untyped float (2.1), float64
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestIndexRef (0.00s)
=== RUN   TestIndexArrayPtrIssue784
2025/10/11 16:12:26 ==> Preload type intArr
2025/10/11 16:12:26 ==> Preload func foo
2025/10/11 16:12:26 ==> Load > NewType intArr
2025/10/11 16:12:26 NewType intArr
2025/10/11 16:12:26 ==> Load > InitType intArr
2025/10/11 16:12:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:26 InitType intArr [2]int
2025/10/11 16:12:26 ==> Load func foo
2025/10/11 16:12:26 ==> LookupParent intArr => type github.com/goplus/xgo/cl.intArr [2]int
2025/10/11 16:12:26 NewFunc foo func(a *github.com/goplus/xgo/cl.intArr)
2025/10/11 16:12:26 Val a *github.com/goplus/xgo/cl.intArr
2025/10/11 16:12:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:26 IndexRef 1
2025/10/11 16:12:26 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 ==> MatchType untyped int (10), int
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestIndexArrayPtrIssue784 (0.00s)
=== RUN   TestMemberVal
2025/10/11 16:12:26 ==> Preload func main
2025/10/11 16:12:26 ==> Load func main
2025/10/11 16:12:26 NewFunc main func()
2025/10/11 16:12:26 DefineVarStart [x]
2025/10/11 16:12:26 Val NewReplacer func(oldnew ...string) *strings.Replacer
2025/10/11 16:12:26 Val &{0 STRING "?"} *ast.BasicLit
2025/10/11 16:12:26 Val &{0 STRING "!"} *ast.BasicLit
2025/10/11 16:12:26 Call 2 0 // func(oldnew ...string) *strings.Replacer
2025/10/11 16:12:26 ==> MatchFuncCall func(oldnew ...string) *strings.Replacer args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("?"), string
2025/10/11 16:12:26 ==> MatchType untyped string ("!"), string
2025/10/11 16:12:26 Member Replace 1 // *strings.Replacer
2025/10/11 16:12:26 Val &{0 STRING "hello, world???"} *ast.BasicLit
2025/10/11 16:12:26 Call 1 0 // func(s string) string
2025/10/11 16:12:26 ==> MatchFuncCall func(s string) string args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("hello, world???"), string
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val &{0 STRING "x:"} *ast.BasicLit
2025/10/11 16:12:26 Val x string
2025/10/11 16:12:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:26 ==> MatchType untyped string ("x:"), any
2025/10/11 16:12:26 ==> MatchType string, any
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestMemberVal (0.00s)
=== RUN   TestNamedPtrMemberIssue786
2025/10/11 16:12:26 ==> Preload type foo
2025/10/11 16:12:26 ==> Preload type pfoo
2025/10/11 16:12:26 ==> Preload func bar
2025/10/11 16:12:26 ==> Load > NewType foo
2025/10/11 16:12:26 NewType foo
2025/10/11 16:12:26 ==> Load > InitType foo
2025/10/11 16:12:26 InitType foo struct{req int}
2025/10/11 16:12:26 ==> Load > NewType pfoo
2025/10/11 16:12:26 NewType pfoo
2025/10/11 16:12:26 ==> Load > InitType pfoo
2025/10/11 16:12:26 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{req int}
2025/10/11 16:12:26 InitType pfoo *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 ==> Load func bar
2025/10/11 16:12:26 ==> LookupParent pfoo => type github.com/goplus/xgo/cl.pfoo *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:26 NewFunc bar func(p github.com/goplus/xgo/cl.pfoo)
2025/10/11 16:12:26 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 Val p github.com/goplus/xgo/cl.pfoo
2025/10/11 16:12:26 Member req 2 // github.com/goplus/xgo/cl.pfoo
2025/10/11 16:12:26 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:26 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:26 ==> MatchType int, any
2025/10/11 16:12:26 End // Func
2025/10/11 16:12:26 ==> ASTFile
--- PASS: TestNamedPtrMemberIssue786 (0.00s)
=== RUN   TestMember
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [a]
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 StructLit struct{A int; B string} 2 false
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 DefineVarStart [x]
2025/10/11 16:12:27 Val a *struct{A int; B string}
2025/10/11 16:12:27 Member A 2 // *struct{A int; B string}
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val a *struct{A int; B string}
2025/10/11 16:12:27 Member B -1 // *struct{A int; B string}
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped string ("Hi"), string
2025/10/11 16:12:27 VarRef Usage func()
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped nil, func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestMember (0.17s)
=== RUN   TestElem
2025/10/11 16:12:27 ==> Preload func foo
2025/10/11 16:12:27 ==> Load func foo
2025/10/11 16:12:27 NewFunc foo func(a *int, b int)
2025/10/11 16:12:27 VarRef b int
2025/10/11 16:12:27 Val a *int
2025/10/11 16:12:27 Star
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 Val a *int
2025/10/11 16:12:27 ElemRef
2025/10/11 16:12:27 Val b int
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestElem (0.00s)
=== RUN   TestNamedPtrIssue797
2025/10/11 16:12:27 ==> Preload type Bar
2025/10/11 16:12:27 ==> Preload func foo
2025/10/11 16:12:27 ==> Load > NewType Bar
2025/10/11 16:12:27 NewType Bar
2025/10/11 16:12:27 ==> Load > InitType Bar
2025/10/11 16:12:27 InitType Bar *int
2025/10/11 16:12:27 ==> Load func foo
2025/10/11 16:12:27 ==> LookupParent Bar => type github.com/goplus/xgo/cl.Bar *int
2025/10/11 16:12:27 NewFunc foo func(a github.com/goplus/xgo/cl.Bar)
2025/10/11 16:12:27 ==> Load var int [b]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [b]
2025/10/11 16:12:27 Val a github.com/goplus/xgo/cl.Bar
2025/10/11 16:12:27 Star
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestNamedPtrIssue797 (0.00s)
=== RUN   TestMethod
2025/10/11 16:12:27 ==> Preload type M
2025/10/11 16:12:27 ==> Preload method M.Foo
2025/10/11 16:12:27 ==> Preload method M.Bar
2025/10/11 16:12:27 ==> Load > NewType M
2025/10/11 16:12:27 NewType M
2025/10/11 16:12:27 ==> Load > InitType M
2025/10/11 16:12:27 InitType M int
2025/10/11 16:12:27 ==> LookupParent M => type github.com/goplus/xgo/cl.M int
2025/10/11 16:12:27 ==> Load method github.com/goplus/xgo/cl.M.Foo
2025/10/11 16:12:27 ==> LookupParent M => type github.com/goplus/xgo/cl.M int
2025/10/11 16:12:27 ==> Load method github.com/goplus/xgo/cl.M.Bar
2025/10/11 16:12:27 NewFunc Foo (github.com/goplus/xgo/cl.M) func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "foo"} *ast.BasicLit
2025/10/11 16:12:27 Val m github.com/goplus/xgo/cl.M
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("foo"), any
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.M, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Bar (github.com/goplus/xgo/cl.M) func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "bar"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("bar"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestMethod (0.00s)
=== RUN   TestCmdlineNoEOL
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCmdlineNoEOL (0.00s)
=== RUN   TestImport
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestImport (0.00s)
=== RUN   TestDotImport
2025/10/11 16:12:27 ==> Preload var [a]
2025/10/11 16:12:27 ==> Load var <nil> [a]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [a]
2025/10/11 16:12:27 Val Round func(x float64) float64
2025/10/11 16:12:27 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(x float64) float64
2025/10/11 16:12:27 ==> MatchFuncCall func(x float64) float64 args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped float (1.2), float64
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestDotImport (0.00s)
=== RUN   TestLocalImport
2025/10/11 16:12:27 ==> Preload var [a]
2025/10/11 16:12:27 ==> Load var <nil> [a]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [a]
2025/10/11 16:12:27 Val TestIntValue int
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestLocalImport (0.00s)
=== RUN   TestImportUnused
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestImportUnused (0.00s)
=== RUN   TestImportForceUsed
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestImportForceUsed (0.00s)
=== RUN   TestAnonymousImport
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hello"), any
2025/10/11 16:12:27 Val printf func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "Hello XGo\n"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hello XGo\n"), string
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestAnonymousImport (0.00s)
=== RUN   TestVarAndConst
2025/10/11 16:12:27 NewConstDefs
2025/10/11 16:12:27 ==> Preload const [i]
2025/10/11 16:12:27 ==> Preload const [x]
2025/10/11 16:12:27 ==> Preload var [j]
2025/10/11 16:12:27 ==> Load const [i] <nil>
2025/10/11 16:12:27 NewConst [i] 0
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> Load const [x] float64
2025/10/11 16:12:27 NewConst [x] 1
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType untyped int (1), float64
2025/10/11 16:12:27 ==> Load var int [j]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [j]
2025/10/11 16:12:27 Val i untyped int
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType untyped int (1), int
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestVarAndConst (0.00s)
=== RUN   TestDeclStmt
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 NewConstDefs
2025/10/11 16:12:27 ==> Load const [i] <nil>
2025/10/11 16:12:27 NewConst [i] 0
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> Load const [x] float64
2025/10/11 16:12:27 NewConst [x] 1
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType untyped int (1), float64
2025/10/11 16:12:27 ==> Load var int [j]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [j]
2025/10/11 16:12:27 Val i untyped int
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType untyped int (1), int
2025/10/11 16:12:27 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestDeclStmt (0.00s)
=== RUN   TestIf
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [x]
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 If
2025/10/11 16:12:27 DefineVarStart [t]
2025/10/11 16:12:27 Val false untyped bool
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val t bool
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef x int
2025/10/11 16:12:27 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped int (3), int
2025/10/11 16:12:27 Else
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val t bool
2025/10/11 16:12:27 UnaryOp ! flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef x int
2025/10/11 16:12:27 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped int (5), int
2025/10/11 16:12:27 Else
2025/10/11 16:12:27 VarRef x int
2025/10/11 16:12:27 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped int (7), int
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "x:"} *ast.BasicLit
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("x:"), any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestIf (0.00s)
=== RUN   TestSwitch
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [x]
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Switch
2025/10/11 16:12:27 DefineVarStart [s]
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val s string
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Case
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef x int
2025/10/11 16:12:27 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped int (7), int
2025/10/11 16:12:27 End // Case
2025/10/11 16:12:27 Case
2025/10/11 16:12:27 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "hi"} *ast.BasicLit
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef x int
2025/10/11 16:12:27 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped int (5), int
2025/10/11 16:12:27 End // Case
2025/10/11 16:12:27 Case
2025/10/11 16:12:27 Val &{0 STRING "xsw"} *ast.BasicLit
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef x int
2025/10/11 16:12:27 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped int (3), int
2025/10/11 16:12:27 End // Case
2025/10/11 16:12:27 End // Switch
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "x:"} *ast.BasicLit
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("x:"), any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 DefineVarStart [v]
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Switch
2025/10/11 16:12:27 None
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Case
2025/10/11 16:12:27 Val v string
2025/10/11 16:12:27 Val &{0 STRING "xsw"} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp ==
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef x int
2025/10/11 16:12:27 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped int (3), int
2025/10/11 16:12:27 End // Case
2025/10/11 16:12:27 Case
2025/10/11 16:12:27 Val v string
2025/10/11 16:12:27 Val &{0 STRING "hi"} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp ==
2025/10/11 16:12:27 Val v string
2025/10/11 16:12:27 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp ==
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef x int
2025/10/11 16:12:27 Val &{0 INT 9} *ast.BasicLit
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped int (9), int
2025/10/11 16:12:27 End // Case
2025/10/11 16:12:27 Case
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef x int
2025/10/11 16:12:27 Val &{0 INT 11} *ast.BasicLit
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType untyped int (11), int
2025/10/11 16:12:27 End // Case
2025/10/11 16:12:27 End // Switch
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "x:"} *ast.BasicLit
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("x:"), any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestSwitch (0.00s)
=== RUN   TestSwitchFallthrough
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [v]
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Switch
2025/10/11 16:12:27 Val v string
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Case
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val v string
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, any
2025/10/11 16:12:27 Fallthrough
2025/10/11 16:12:27 End // Case
2025/10/11 16:12:27 Case
2025/10/11 16:12:27 Val &{0 STRING "hi"} *ast.BasicLit
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val v string
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, any
2025/10/11 16:12:27 Fallthrough
2025/10/11 16:12:27 End // Case
2025/10/11 16:12:27 Case
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val v string
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, any
2025/10/11 16:12:27 End // Case
2025/10/11 16:12:27 End // Switch
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestSwitchFallthrough (0.00s)
=== RUN   TestBranchStmt
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [a]
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:27 SliceLit <nil> 3 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Label label
2025/10/11 16:12:27 For
2025/10/11 16:12:27 DefineVarStart [i]
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val i int
2025/10/11 16:12:27 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp <
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val i int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 Break
2025/10/11 16:12:27 Break label
2025/10/11 16:12:27 Continue
2025/10/11 16:12:27 Continue label
2025/10/11 16:12:27 Goto label
2025/10/11 16:12:27 Post
2025/10/11 16:12:27 VarRef i int
2025/10/11 16:12:27 Val i int
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp +
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 End // For
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestBranchStmt (0.00s)
=== RUN   TestReturn
2025/10/11 16:12:27 ==> Preload func foo
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func foo
2025/10/11 16:12:27 NewFunc foo func(format string, args ...interface{}) (int, error)
2025/10/11 16:12:27 Val printf func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val format string
2025/10/11 16:12:27 Val args []interface{}
2025/10/11 16:12:27 Call 2 1 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 1
2025/10/11 16:12:27 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 1
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 ==> MatchType []interface{}, []any
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestReturn (0.00s)
=== RUN   TestReturnExpr
2025/10/11 16:12:27 ==> Preload func foo
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func foo
2025/10/11 16:12:27 NewFunc foo func(format string, args ...interface{}) (int, error)
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType untyped int (0), int
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestReturnExpr (0.00s)
=== RUN   TestClosure
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 NewClosure func(v string)
2025/10/11 16:12:27 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:27 Val v string
2025/10/11 16:12:27 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(v string)
2025/10/11 16:12:27 ==> MatchFuncCall func(v string) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hello"), string
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestClosure (0.00s)
=== RUN   TestFunc
2025/10/11 16:12:27 ==> Preload func foo
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func foo
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 NewFunc foo func(format string, a [10]int, args ...interface{})
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestFunc (0.00s)
=== RUN   TestLambdaExpr
2025/10/11 16:12:27 ==> Preload func Map
2025/10/11 16:12:27 ==> Preload func Map2
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func Map
2025/10/11 16:12:27 NewFunc Map func(c []float64, t func(float64) float64)
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func Map2
2025/10/11 16:12:27 NewFunc Map2 func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val Map func(c []float64, t func(float64) float64)
2025/10/11 16:12:27 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []float64 3 false
2025/10/11 16:12:27 NewClosure func(x float64) float64
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 2 0 // func(c []float64, t func(float64) float64)
2025/10/11 16:12:27 ==> MatchFuncCall func(c []float64, t func(float64) float64) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType []float64, []float64
2025/10/11 16:12:27 ==> MatchType func(x float64) float64, func(float64) float64
2025/10/11 16:12:27 Val Map2 func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:27 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []float64 3 false
2025/10/11 16:12:27 NewClosure func(x float64) (float64, float64)
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 BinaryOp +
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 2 0 // func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:27 ==> MatchFuncCall func(c []float64, t func(float64) (float64, float64)) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType []float64, []float64
2025/10/11 16:12:27 ==> MatchType func(x float64) (float64, float64), func(float64) (float64, float64)
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload type Foo
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load > NewType Foo
2025/10/11 16:12:27 NewType Foo
2025/10/11 16:12:27 ==> Load > InitType Foo
2025/10/11 16:12:27 InitType Foo struct{Plot func(x float64) (float64, float64)}
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [foo]
2025/10/11 16:12:27 ==> LookupParent Foo => type github.com/goplus/xgo/cl.Foo struct{Plot func(x float64) (float64, float64)}
2025/10/11 16:12:27 Val 0 int
2025/10/11 16:12:27 NewClosure func(x float64) (float64, float64)
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.Foo 2 true
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload type Fn
2025/10/11 16:12:27 ==> Preload type Foo
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load > NewType Fn
2025/10/11 16:12:27 NewType Fn
2025/10/11 16:12:27 ==> Load > InitType Fn
2025/10/11 16:12:27 InitType Fn func(x float64) (float64, float64)
2025/10/11 16:12:27 ==> Load > NewType Foo
2025/10/11 16:12:27 NewType Foo
2025/10/11 16:12:27 ==> Load > InitType Foo
2025/10/11 16:12:27 ==> LookupParent Fn => type github.com/goplus/xgo/cl.Fn func(x float64) (float64, float64)
2025/10/11 16:12:27 InitType Foo struct{Plot github.com/goplus/xgo/cl.Fn}
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [foo]
2025/10/11 16:12:27 ==> LookupParent Foo => type github.com/goplus/xgo/cl.Foo struct{Plot github.com/goplus/xgo/cl.Fn}
2025/10/11 16:12:27 Val 0 int
2025/10/11 16:12:27 NewClosure func(x float64) (float64, float64)
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.Foo 2 true
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Fn
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload type Fn
2025/10/11 16:12:27 ==> Preload func Do
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load > NewType Fn
2025/10/11 16:12:27 NewType Fn
2025/10/11 16:12:27 ==> Load > InitType Fn
2025/10/11 16:12:27 InitType Fn func() (int, error)
2025/10/11 16:12:27 ==> Load func Do
2025/10/11 16:12:27 ==> LookupParent Fn => type github.com/goplus/xgo/cl.Fn func() (int, error)
2025/10/11 16:12:27 NewFunc Do func(fn github.com/goplus/xgo/cl.Fn)
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val Do func(fn github.com/goplus/xgo/cl.Fn)
2025/10/11 16:12:27 NewClosure func() (int, error)
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType untyped int (100), int
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 1 0 // func(fn github.com/goplus/xgo/cl.Fn)
2025/10/11 16:12:27 ==> MatchFuncCall func(fn github.com/goplus/xgo/cl.Fn) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType func() (int, error), github.com/goplus/xgo/cl.Fn
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Fn
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload var [fn]
2025/10/11 16:12:27 ==> Load var func(int) (int, error) [fn]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [fn]
2025/10/11 16:12:27 NewClosure func(x int) (int, error)
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType func(x int) (int, error), func(int) (int, error)
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload var [fn]
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load var func(int) (int, error) [fn]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [fn]
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 VarRef fn func(int) (int, error)
2025/10/11 16:12:27 NewClosure func(x int) (int, error)
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType func(x int) (int, error), func(int) (int, error)
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestLambdaExpr (0.00s)
=== RUN   TestLambdaExpr2
2025/10/11 16:12:27 ==> Preload func Do
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func Do
2025/10/11 16:12:27 NewFunc Do func(func())
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val Do func(func())
2025/10/11 16:12:27 NewClosure func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 1 0 // func(func())
2025/10/11 16:12:27 ==> MatchFuncCall func(func()) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType func(), func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload func Do
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func Do
2025/10/11 16:12:27 NewFunc Do func(fn func() (int, error))
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val Do func(fn func() (int, error))
2025/10/11 16:12:27 NewClosure func() (int, error)
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType untyped int (100), int
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 1 0 // func(fn func() (int, error))
2025/10/11 16:12:27 ==> MatchFuncCall func(fn func() (int, error)) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType func() (int, error), func() (int, error)
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload type Foo
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load > NewType Foo
2025/10/11 16:12:27 NewType Foo
2025/10/11 16:12:27 ==> Load > InitType Foo
2025/10/11 16:12:27 InitType Foo struct{Plot func(x float64) (float64, float64)}
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [foo]
2025/10/11 16:12:27 ==> LookupParent Foo => type github.com/goplus/xgo/cl.Foo struct{Plot func(x float64) (float64, float64)}
2025/10/11 16:12:27 Val 0 int
2025/10/11 16:12:27 NewClosure func(x float64) (float64, float64)
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.Foo 2 true
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload type Fn
2025/10/11 16:12:27 ==> Preload type Foo
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load > NewType Fn
2025/10/11 16:12:27 NewType Fn
2025/10/11 16:12:27 ==> Load > InitType Fn
2025/10/11 16:12:27 InitType Fn func(x float64) (float64, float64)
2025/10/11 16:12:27 ==> Load > NewType Foo
2025/10/11 16:12:27 NewType Foo
2025/10/11 16:12:27 ==> Load > InitType Foo
2025/10/11 16:12:27 ==> LookupParent Fn => type github.com/goplus/xgo/cl.Fn func(x float64) (float64, float64)
2025/10/11 16:12:27 InitType Foo struct{Plot github.com/goplus/xgo/cl.Fn}
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [foo]
2025/10/11 16:12:27 ==> LookupParent Foo => type github.com/goplus/xgo/cl.Foo struct{Plot github.com/goplus/xgo/cl.Fn}
2025/10/11 16:12:27 Val 0 int
2025/10/11 16:12:27 NewClosure func(x float64) (float64, float64)
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 Val x float64
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 ==> MatchType float64, float64
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.Foo 2 true
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Fn
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload type Fn
2025/10/11 16:12:27 ==> Preload func Do
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load > NewType Fn
2025/10/11 16:12:27 NewType Fn
2025/10/11 16:12:27 ==> Load > InitType Fn
2025/10/11 16:12:27 InitType Fn func() (int, error)
2025/10/11 16:12:27 ==> Load func Do
2025/10/11 16:12:27 ==> LookupParent Fn => type github.com/goplus/xgo/cl.Fn func() (int, error)
2025/10/11 16:12:27 NewFunc Do func(fn github.com/goplus/xgo/cl.Fn)
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val Do func(fn github.com/goplus/xgo/cl.Fn)
2025/10/11 16:12:27 NewClosure func() (int, error)
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType untyped int (100), int
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 1 0 // func(fn github.com/goplus/xgo/cl.Fn)
2025/10/11 16:12:27 ==> MatchFuncCall func(fn github.com/goplus/xgo/cl.Fn) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType func() (int, error), github.com/goplus/xgo/cl.Fn
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Fn
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload var [fn]
2025/10/11 16:12:27 ==> Load var func(int) (int, error) [fn]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [fn]
2025/10/11 16:12:27 NewClosure func(x int) (int, error)
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType func(x int) (int, error), func(int) (int, error)
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload var [fn]
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load var func(int) (int, error) [fn]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [fn]
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 VarRef fn func(int) (int, error)
2025/10/11 16:12:27 NewClosure func(x int) (int, error)
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType func(x int) (int, error), func(int) (int, error)
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestLambdaExpr2 (0.00s)
=== RUN   TestLambdaExpr3
2025/10/11 16:12:27 ==> Preload func intSeq
2025/10/11 16:12:27 ==> Load func intSeq
2025/10/11 16:12:27 NewFunc intSeq func() func() int
2025/10/11 16:12:27 DefineVarStart [i]
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 NewClosure func() int
2025/10/11 16:12:27 VarRef i int
2025/10/11 16:12:27 IncDec ++
2025/10/11 16:12:27 Val i int
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType func() int, func() int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload func intDouble
2025/10/11 16:12:27 ==> Load func intDouble
2025/10/11 16:12:27 NewFunc intDouble func() func(int) int
2025/10/11 16:12:27 NewClosure func(i int) int
2025/10/11 16:12:27 Val i int
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp *
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType func(i int) int, func(int) int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestLambdaExpr3 (0.00s)
=== RUN   TestUnnamedMainFunc
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [i]
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestUnnamedMainFunc (0.00s)
=== RUN   TestFuncAsParam
2025/10/11 16:12:27 ==> Preload func bar
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func bar
2025/10/11 16:12:27 NewFunc bar func(foo func(string, ...interface{}) (int, error))
2025/10/11 16:12:27 Val foo func(string, ...interface{}) (int, error)
2025/10/11 16:12:27 Val &{0 STRING "Hello, %v!\n"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:27 Call 2 0 // func(string, ...interface{}) (int, error)
2025/10/11 16:12:27 ==> MatchFuncCall func(string, ...interface{}) (int, error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hello, %v!\n"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("XGo"), interface{}
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val bar func(foo func(string, ...interface{}) (int, error))
2025/10/11 16:12:27 Val Printf func(format string, a ...any) (n int, err error)
2025/10/11 16:12:27 Call 1 0 // func(foo func(string, ...interface{}) (int, error))
2025/10/11 16:12:27 ==> MatchFuncCall func(foo func(string, ...interface{}) (int, error)) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType func(format string, a ...any) (n int, err error), func(string, ...interface{}) (int, error)
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestFuncAsParam (0.00s)
=== RUN   TestFuncAsParam2
2025/10/11 16:12:27 ==> Preload func foo
2025/10/11 16:12:27 ==> Preload func printf
2025/10/11 16:12:27 ==> Preload func bar
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func foo
2025/10/11 16:12:27 NewFunc foo func(x string) string
2025/10/11 16:12:27 Val NewReplacer func(oldnew ...string) *strings.Replacer
2025/10/11 16:12:27 Val &{0 STRING "?"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "!"} *ast.BasicLit
2025/10/11 16:12:27 Call 2 0 // func(oldnew ...string) *strings.Replacer
2025/10/11 16:12:27 ==> MatchFuncCall func(oldnew ...string) *strings.Replacer args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("?"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("!"), string
2025/10/11 16:12:27 Member Replace 1 // *strings.Replacer
2025/10/11 16:12:27 Val x string
2025/10/11 16:12:27 Call 1 0 // func(s string) string
2025/10/11 16:12:27 ==> MatchFuncCall func(s string) string args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func printf
2025/10/11 16:12:27 NewFunc printf func(format string, args ...interface{}) (n int, err error)
2025/10/11 16:12:27 VarRef n int
2025/10/11 16:12:27 VarRef err error
2025/10/11 16:12:27 Val Printf func(format string, a ...any) (n int, err error)
2025/10/11 16:12:27 Val format string
2025/10/11 16:12:27 Val args []interface{}
2025/10/11 16:12:27 Call 2 3 // func(format string, a ...any) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 3
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 ==> MatchType []interface{}, []any
2025/10/11 16:12:27 Assign 2 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func bar
2025/10/11 16:12:27 NewFunc bar func(foo func(string, ...interface{}) (int, error))
2025/10/11 16:12:27 Val foo func(string, ...interface{}) (int, error)
2025/10/11 16:12:27 Val &{0 STRING "Hello, %v!\n"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:27 Call 2 0 // func(string, ...interface{}) (int, error)
2025/10/11 16:12:27 ==> MatchFuncCall func(string, ...interface{}) (int, error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hello, %v!\n"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("XGo"), interface{}
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val bar func(foo func(string, ...interface{}) (int, error))
2025/10/11 16:12:27 Val printf func(format string, args ...interface{}) (n int, err error)
2025/10/11 16:12:27 Call 1 0 // func(foo func(string, ...interface{}) (int, error))
2025/10/11 16:12:27 ==> MatchFuncCall func(foo func(string, ...interface{}) (int, error)) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType func(format string, args ...interface{}) (n int, err error), func(string, ...interface{}) (int, error)
2025/10/11 16:12:27 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:27 Val foo func(x string) string
2025/10/11 16:12:27 Val &{0 STRING "Hello, world???"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(x string) string
2025/10/11 16:12:27 ==> MatchFuncCall func(x string) string args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hello, world???"), string
2025/10/11 16:12:27 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, any
2025/10/11 16:12:27 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:27 Val printf func(format string, args ...interface{}) (n int, err error)
2025/10/11 16:12:27 Val &{0 STRING "Hello, %v\n"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:12:27 Call 2 0 // func(format string, args ...interface{}) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(format string, args ...interface{}) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hello, %v\n"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("XGo"), interface{}
2025/10/11 16:12:27 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 ==> MatchType error, any
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestFuncAsParam2 (0.00s)
=== RUN   TestFuncCall
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hello"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestFuncCall (0.00s)
=== RUN   TestFuncCallEllipsis
2025/10/11 16:12:27 ==> Preload func foo
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func foo
2025/10/11 16:12:27 NewFunc foo func(args ...interface{})
2025/10/11 16:12:27 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:27 Val args []interface{}
2025/10/11 16:12:27 Call 1 1 // func(a ...any) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 1
2025/10/11 16:12:27 ==> MatchType []interface{}, []any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestFuncCallEllipsis (0.00s)
=== RUN   TestFuncCallCodeOrder
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Preload func foo
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 ==> Load func foo
2025/10/11 16:12:27 NewFunc foo func(args ...interface{})
2025/10/11 16:12:27 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:27 Val args []interface{}
2025/10/11 16:12:27 Call 1 1 // func(a ...any) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 1
2025/10/11 16:12:27 ==> MatchType []interface{}, []any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Val foo func(args ...interface{})
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 123} *ast.BasicLit
2025/10/11 16:12:27 Call 2 0 // func(args ...interface{})
2025/10/11 16:12:27 ==> MatchFuncCall func(args ...interface{}) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hello"), interface{}
2025/10/11 16:12:27 ==> MatchType untyped int (123), interface{}
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestFuncCallCodeOrder (0.00s)
=== RUN   TestInterfaceMethods
2025/10/11 16:12:27 ==> Preload func foo
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func foo
2025/10/11 16:12:27 NewFunc foo func(v ...interface{Bar()})
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestInterfaceMethods (0.00s)
=== RUN   TestAssignUnderscore
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [_ err]
2025/10/11 16:12:27 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 2 // func(a ...any) (n int, err error)
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 2
2025/10/11 16:12:27 ==> MatchType untyped string ("Hello"), any
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestAssignUnderscore (0.00s)
=== RUN   TestOperator
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [a]
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 DefineVarStart [b]
2025/10/11 16:12:27 Val a string
2025/10/11 16:12:27 Val &{0 STRING "!"} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp +
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped string ("!"), unboundFuncParam{typ: string}
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 DefineVarStart [c]
2025/10/11 16:12:27 Val &{0 INT 13} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 DefineVarStart [d]
2025/10/11 16:12:27 Val c int
2025/10/11 16:12:27 UnaryOp - flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestOperator (0.00s)
=== RUN   TestImportGopPkg
GenGo ../cl/internal/gop-in-go/foo ...
2025/10/11 16:12:27 ==> Preload func ReverseMap
2025/10/11 16:12:27 ==> Preload func TestReverseMap
2025/10/11 16:12:27 ==> Load func ReverseMap
2025/10/11 16:12:27 NewFunc ReverseMap func(m map[string]int) map[int]string
2025/10/11 16:12:27 SetComments 0
//line cl/internal/gop-in-go/foo/foo.xgo:4:1
2025/10/11 16:12:27 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:27 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 ZeroLit // unboundType{typ: <nil>}
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/10/11 16:12:27 ForRange [k v]
2025/10/11 16:12:27 Val m map[string]int
2025/10/11 16:12:27 RangeAssignThen
2025/10/11 16:12:27 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 Val v int
2025/10/11 16:12:27 IndexRef 1
2025/10/11 16:12:27 Val k string
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType string, unboundMapElemType{key: int}
2025/10/11 16:12:27 End // ForRange
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 0 0 // func() (_xgo_ret map[int]string)
2025/10/11 16:12:27 ==> MatchFuncCall func() (_xgo_ret map[int]string) args: 0 flags: 0
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType map[int]string, map[int]string
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func TestReverseMap
2025/10/11 16:12:27 NewFunc TestReverseMap func(t *testing.T)
2025/10/11 16:12:27 SetComments 0
//line cl/internal/gop-in-go/foo/foo_test.xgo:8:1
2025/10/11 16:12:27 DefineVarStart [out]
2025/10/11 16:12:27 Val ReverseMap func(m map[string]int) map[int]string
2025/10/11 16:12:27 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 MapLit map[string]int 2
2025/10/11 16:12:27 Call 1 0 // func(m map[string]int) map[int]string
2025/10/11 16:12:27 ==> MatchFuncCall func(m map[string]int) map[int]string args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType map[string]int, map[string]int
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 SetComments 0
//line cl/internal/gop-in-go/foo/foo_test.xgo:9:1
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val len TyInstruction{gogen.lenInstr}
2025/10/11 16:12:27 Val out map[int]string
2025/10/11 16:12:27 Call 1 0 // TyInstruction{gogen.lenInstr}
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.lenInstr} args: 1 flags: 0
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 Val out map[int]string
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Index 1 false
2025/10/11 16:12:27 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 BinaryOp ||
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped bool, unboundFuncParam{typ: untyped bool}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 SetComments 0
//line cl/internal/gop-in-go/foo/foo_test.xgo:10:1
2025/10/11 16:12:27 Val t *testing.T
2025/10/11 16:12:27 Member Fatal 1 // *testing.T
2025/10/11 16:12:27 Val &{0 STRING "ReverseMap failed:"} *ast.BasicLit
2025/10/11 16:12:27 Val out map[int]string
2025/10/11 16:12:27 Call 2 0 // func(args ...any)
2025/10/11 16:12:27 ==> MatchFuncCall func(args ...any) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("ReverseMap failed:"), any
2025/10/11 16:12:27 ==> MatchType map[int]string, any
2025/10/11 16:12:27 SetComments 0
//line cl/internal/gop-in-go/foo/foo_test.xgo:9:1
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 WriteFile ../cl/internal/gop-in-go/foo/xgo_autogen.go
2025/10/11 16:12:27 ==> ASTFile _test
2025/10/11 16:12:27 WriteFile ../cl/internal/gop-in-go/foo/xgo_autogen_test.go
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [rmap]
2025/10/11 16:12:27 Val ReverseMap func(m map[string]int) map[int]string
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 MapLit map[string]int 4
2025/10/11 16:12:27 Call 1 0 // func(m map[string]int) map[int]string
2025/10/11 16:12:27 ==> MatchFuncCall func(m map[string]int) map[int]string args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType map[string]int, map[string]int
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val rmap map[int]string
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType map[int]string, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestImportGopPkg (0.23s)
=== RUN   TestCallDep
2025/10/11 16:12:27 ==> Preload func TestNew
2025/10/11 16:12:27 ==> Preload type Repo
2025/10/11 16:12:27 ==> Preload func newRepo
2025/10/11 16:12:27 ==> Preload type Result
2025/10/11 16:12:27 ==> Preload func New
2025/10/11 16:12:27 ==> Load func TestNew
2025/10/11 16:12:27 NewFunc TestNew func(t *testing.T)
2025/10/11 16:12:27 DefineVarStart [ret]
2025/10/11 16:12:27 ==> Load func New
2025/10/11 16:12:27 ==> Load > NewType Result
2025/10/11 16:12:27 NewType Result
2025/10/11 16:12:27 ==> Lookup (LoadSymbol) Result => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:27 NewFunc New func() github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 DefineVarStart [repo]
2025/10/11 16:12:27 ==> Load func newRepo
2025/10/11 16:12:27 ==> Load > NewType Repo
2025/10/11 16:12:27 NewType Repo
2025/10/11 16:12:27 ==> Lookup (LoadSymbol) Repo => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:27 NewFunc newRepo func() github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 ==> Load > InitType Repo
2025/10/11 16:12:27 InitType Repo struct{Title string}
2025/10/11 16:12:27 Val 0 int
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.Repo 2 true
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Repo, github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Val newRepo func() github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.Repo args: 0 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> Load > InitType Result
2025/10/11 16:12:27 ==> LookupParent Repo => type github.com/goplus/xgo/cl.Repo struct{Title string}
2025/10/11 16:12:27 InitType Result struct{Repo github.com/goplus/xgo/cl.Repo}
2025/10/11 16:12:27 Val 0 int
2025/10/11 16:12:27 Val repo github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.Result 2 true
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Result, github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Val New func() github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.Result args: 0 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 DefineVarStart [expected]
2025/10/11 16:12:27 ==> LookupParent Result => type github.com/goplus/xgo/cl.Result struct{Repo github.com/goplus/xgo/cl.Repo}
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.Result 0 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val DeepEqual func(x any, y any) bool
2025/10/11 16:12:27 Val ret github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Val expected github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Call 2 0 // func(x any, y any) bool
2025/10/11 16:12:27 ==> MatchFuncCall func(x any, y any) bool args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val t *testing.T
2025/10/11 16:12:27 Member Fatal 1 // *testing.T
2025/10/11 16:12:27 Val &{0 STRING "Test failed:"} *ast.BasicLit
2025/10/11 16:12:27 Val ret github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Val expected github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Call 3 0 // func(args ...any)
2025/10/11 16:12:27 ==> MatchFuncCall func(args ...any) args: 3 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Test failed:"), any
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload func TestNew
2025/10/11 16:12:27 ==> Preload type Repo
2025/10/11 16:12:27 ==> Preload func newRepo
2025/10/11 16:12:27 ==> Preload type Result
2025/10/11 16:12:27 ==> Preload func New
2025/10/11 16:12:27 ==> Load func TestNew
2025/10/11 16:12:27 NewFunc TestNew func(t *testing.T)
2025/10/11 16:12:27 DefineVarStart [ret]
2025/10/11 16:12:27 ==> Load func New
2025/10/11 16:12:27 ==> Load > NewType Result
2025/10/11 16:12:27 NewType Result
2025/10/11 16:12:27 ==> Lookup (LoadSymbol) Result => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:27 NewFunc New func() github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 DefineVarStart [repo]
2025/10/11 16:12:27 ==> Load func newRepo
2025/10/11 16:12:27 ==> Load > NewType Repo
2025/10/11 16:12:27 NewType Repo
2025/10/11 16:12:27 ==> Lookup (LoadSymbol) Repo => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:27 NewFunc newRepo func() github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 ==> Load > InitType Repo
2025/10/11 16:12:27 InitType Repo struct{Title string}
2025/10/11 16:12:27 Val 0 int
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.Repo 2 true
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Repo, github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Val newRepo func() github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.Repo args: 0 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> Load > InitType Result
2025/10/11 16:12:27 ==> LookupParent Repo => type github.com/goplus/xgo/cl.Repo struct{Title string}
2025/10/11 16:12:27 InitType Result struct{Repo github.com/goplus/xgo/cl.Repo}
2025/10/11 16:12:27 Val 0 int
2025/10/11 16:12:27 Val repo github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.Result 2 true
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Result, github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Val New func() github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.Result args: 0 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 DefineVarStart [expected]
2025/10/11 16:12:27 ==> LookupParent Result => type github.com/goplus/xgo/cl.Result struct{Repo github.com/goplus/xgo/cl.Repo}
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.Result 0 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val DeepEqual func(x any, y any) bool
2025/10/11 16:12:27 Val ret github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Val expected github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Call 2 0 // func(x any, y any) bool
2025/10/11 16:12:27 ==> MatchFuncCall func(x any, y any) bool args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val t *testing.T
2025/10/11 16:12:27 Member Fatal 1 // *testing.T
2025/10/11 16:12:27 Val &{0 STRING "Test failed:"} *ast.BasicLit
2025/10/11 16:12:27 Val ret github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Val expected github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 Call 3 0 // func(args ...any)
2025/10/11 16:12:27 ==> MatchFuncCall func(args ...any) args: 3 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Test failed:"), any
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCallDep (0.00s)
=== RUN   TestGoFuncInstr
2025/10/11 16:12:27 ==> Preload func test
2025/10/11 16:12:27 ==> Load func test
2025/10/11 16:12:27 NewFunc test func(s string, p uintptr, q uintptr, rest ...uintptr) int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestGoFuncInstr (0.00s)
=== RUN   TestGoTypeInstr
2025/10/11 16:12:27 ==> Preload type S
2025/10/11 16:12:27 ==> Load > NewType S
2025/10/11 16:12:27 NewType S
2025/10/11 16:12:27 ==> Load > InitType S
2025/10/11 16:12:27 InitType S struct{x int}
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestGoTypeInstr (0.00s)
=== RUN   TestNoEntrypoint
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "init"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("init"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload func init
2025/10/11 16:12:27 ==> Load func init
2025/10/11 16:12:27 NewFunc init func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "init"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("init"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestNoEntrypoint (0.00s)
=== RUN   TestParentExpr
2025/10/11 16:12:27 ==> Preload var [t1]
2025/10/11 16:12:27 ==> Preload var [t2]
2025/10/11 16:12:27 ==> Load var *int [t1]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [t1]
2025/10/11 16:12:27 ==> Load var chan int [t2]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [t2]
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestParentExpr (0.00s)
=== RUN   TestCommandStyle
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 SliceLit <nil> 0 false
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType []interface{}, any
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 MapLit <nil> 0
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType map[string]interface{}, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCommandStyle (0.00s)
=== RUN   TestTypeLoader
2025/10/11 16:12:27 ==> Preload method Point.String
2025/10/11 16:12:27 ==> Preload type Point
2025/10/11 16:12:27 ==> Load > NewType Point
2025/10/11 16:12:27 NewType Point
2025/10/11 16:12:27 ==> Load > InitType Point
2025/10/11 16:12:27 InitType Point struct{X int; Y int}
2025/10/11 16:12:27 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{X int; Y int}
2025/10/11 16:12:27 ==> Load method *github.com/goplus/xgo/cl.Point.String
2025/10/11 16:12:27 NewFunc String (*github.com/goplus/xgo/cl.Point) func() string
2025/10/11 16:12:27 Val Sprintf func(format string, a ...any) string
2025/10/11 16:12:27 Val &{0 STRING "%v-%v"} *ast.BasicLit
2025/10/11 16:12:27 Val p *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Member X 2 // *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Val p *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Member Y 2 // *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Call 3 0 // func(format string, a ...any) string
2025/10/11 16:12:27 ==> MatchFuncCall func(format string, a ...any) string args: 3 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("%v-%v"), string
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestTypeLoader (0.00s)
=== RUN   TestCallPrintln
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val print func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 0 flags: 0
2025/10/11 16:12:27 Val print func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("hello"), any
2025/10/11 16:12:27 Val print func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("hello"), any
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 0 flags: 0
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("hello"), any
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("hello"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCallPrintln (0.00s)
=== RUN   TestAnyAlias
2025/10/11 16:12:27 ==> Preload var [a]
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load var interface{} [a]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [a]
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType untyped int (100), interface{}
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a interface{}
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType interface{}, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestAnyAlias (0.00s)
=== RUN   TestMainEntry
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload func test
2025/10/11 16:12:27 ==> Load func test
2025/10/11 16:12:27 NewFunc test func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("hello"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("hello"), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestMainEntry (0.00s)
=== RUN   TestCommandNotExpr
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val true untyped bool
2025/10/11 16:12:27 UnaryOp ! flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped bool (true), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped bool (false), any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [a]
2025/10/11 16:12:27 Val true untyped bool
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a bool
2025/10/11 16:12:27 UnaryOp ! flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType bool, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 NewClosure func() bool
2025/10/11 16:12:27 Val true untyped bool
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 0 0 // func() bool
2025/10/11 16:12:27 ==> MatchFuncCall func() bool args: 0 flags: 0
2025/10/11 16:12:27 UnaryOp ! flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType bool, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCommandNotExpr (0.00s)
=== RUN   TestCommentLine
2025/10/11 16:12:27 ==> Preload type Point
2025/10/11 16:12:27 ==> Preload method Point.Test
2025/10/11 16:12:27 ==> Preload func testPoint
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load > NewType Point
2025/10/11 16:12:27 NewType Point
2025/10/11 16:12:27 ==> Load > InitType Point
2025/10/11 16:12:27 InitType Point struct{x int; y int}
2025/10/11 16:12:27 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{x int; y int}
2025/10/11 16:12:27 ==> Load method *github.com/goplus/xgo/cl.Point.Test
2025/10/11 16:12:27 ==> Load func testPoint
2025/10/11 16:12:27 NewFunc testPoint func()
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:13:1
2025/10/11 16:12:27 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{x int; y int}
2025/10/11 16:12:27 ==> Load var github.com/goplus/xgo/cl.Point [pt]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [pt]
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:14:1
2025/10/11 16:12:27 Val pt github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Member Test 1 // github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:17:1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("hello"), any
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:18:1
2025/10/11 16:12:27 Val testPoint func()
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Test (*github.com/goplus/xgo/cl.Point) func()
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:8:1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val pt *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Member x 2 // *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Val pt *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Member y 2 // *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCommentLine (0.00s)
=== RUN   TestCommentLineRoot
2025/10/11 16:12:27 ==> Preload type Point
2025/10/11 16:12:27 ==> Preload method Point.Test
2025/10/11 16:12:27 ==> Preload func testPoint
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load > NewType Point
2025/10/11 16:12:27 NewType Point
2025/10/11 16:12:27 ==> Load > InitType Point
2025/10/11 16:12:27 InitType Point struct{x int; y int}
2025/10/11 16:12:27 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{x int; y int}
2025/10/11 16:12:27 ==> Load method *github.com/goplus/xgo/cl.Point.Test
2025/10/11 16:12:27 ==> Load func testPoint
2025/10/11 16:12:27 NewFunc testPoint func()
2025/10/11 16:12:27 SetComments 0
//line ../bar.xgo:13:1
2025/10/11 16:12:27 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{x int; y int}
2025/10/11 16:12:27 ==> Load var github.com/goplus/xgo/cl.Point [pt]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [pt]
2025/10/11 16:12:27 SetComments 0
//line ../bar.xgo:14:1
2025/10/11 16:12:27 Val pt github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Member Test 1 // github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 SetComments 0
//line ../bar.xgo:17:1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("hello"), any
2025/10/11 16:12:27 SetComments 0
//line ../bar.xgo:18:1
2025/10/11 16:12:27 Val testPoint func()
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Test (*github.com/goplus/xgo/cl.Point) func()
2025/10/11 16:12:27 SetComments 0
//line ../bar.xgo:8:1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val pt *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Member x 2 // *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Val pt *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Member y 2 // *github.com/goplus/xgo/cl.Point
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCommentLineRoot (0.00s)
=== RUN   TestRangeScope
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [ar]
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []int 2 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ForRange [k v]
2025/10/11 16:12:27 Val ar []int
2025/10/11 16:12:27 RangeAssignThen
2025/10/11 16:12:27 VBlock
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val k int
2025/10/11 16:12:27 Val v int
2025/10/11 16:12:27 Val ar []int
2025/10/11 16:12:27 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 3 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 ==> MatchType []int, any
2025/10/11 16:12:27 ==> Load var int [k v ar]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [k v ar]
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val ar int
2025/10/11 16:12:27 Val k int
2025/10/11 16:12:27 Val v int
2025/10/11 16:12:27 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 3 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Vblock
2025/10/11 16:12:27 End // ForRange
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestRangeScope (0.00s)
=== RUN   TestSelectScope
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [c1]
2025/10/11 16:12:27 Val make TyInstruction{gogen.makeInstr}
2025/10/11 16:12:27 Typ chan int
2025/10/11 16:12:27 Call 1 0 // TyInstruction{gogen.makeInstr}
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 DefineVarStart [c2]
2025/10/11 16:12:27 Val make TyInstruction{gogen.makeInstr}
2025/10/11 16:12:27 Typ chan int
2025/10/11 16:12:27 Call 1 0 // TyInstruction{gogen.makeInstr}
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 NewClosure func()
2025/10/11 16:12:27 Val c1 chan int
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27 Send
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 Go
2025/10/11 16:12:27 Select
2025/10/11 16:12:27 CommCase
2025/10/11 16:12:27 DefineVarStart [i]
2025/10/11 16:12:27 Val c1 chan int
2025/10/11 16:12:27 UnaryOp <- flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val i int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // CommCase
2025/10/11 16:12:27 CommCase
2025/10/11 16:12:27 DefineVarStart [i]
2025/10/11 16:12:27 Val c2 chan int
2025/10/11 16:12:27 UnaryOp <- flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val i int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // CommCase
2025/10/11 16:12:27 End // Select
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestSelectScope (0.00s)
=== RUN   TestCommentVar
2025/10/11 16:12:27 ==> Preload var [a]
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load var int [a]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [a]
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:4:1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:6:1
2025/10/11 16:12:27 ==> Load var int [b]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [b]
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:8:1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val b int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:10:1
2025/10/11 16:12:27 ==> Load var int [c]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [c]
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:11:1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val c int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload func demo
2025/10/11 16:12:27 ==> Load func demo
2025/10/11 16:12:27 NewFunc demo func()
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:3:1
2025/10/11 16:12:27 ==> Load var int [a]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [a]
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:5:1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:7:1
2025/10/11 16:12:27 ==> Load var int [b]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [b]
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:9:1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val b int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:11:1
2025/10/11 16:12:27 ==> Load var int [c]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [c]
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:12:1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val c int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCommentVar (0.00s)
=== RUN   TestForPhraseScope
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [sum]
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ForRange [_ x]
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 11} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 13} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 17} *ast.BasicLit
2025/10/11 16:12:27 SliceLit <nil> 7 false
2025/10/11 16:12:27 RangeAssignThen
2025/10/11 16:12:27 VBlock
2025/10/11 16:12:27 VarRef sum int
2025/10/11 16:12:27 Val sum int
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 BinaryOp +
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 DefineVarStart [x]
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Vblock
2025/10/11 16:12:27 End // ForRange
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [sum]
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ForRange [_ x]
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 11} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 13} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 17} *ast.BasicLit
2025/10/11 16:12:27 SliceLit <nil> 7 false
2025/10/11 16:12:27 RangeAssignThen
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:27 BinaryOp >
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef sum int
2025/10/11 16:12:27 Val sum int
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 BinaryOp +
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 DefineVarStart [x]
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 End // ForRange
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestForPhraseScope (0.00s)
=== RUN   TestAddress
2025/10/11 16:12:27 ==> Preload type foo
2025/10/11 16:12:27 ==> Preload method foo.ptr
2025/10/11 16:12:27 ==> Preload method foo.clone
2025/10/11 16:12:27 ==> Preload type nested
2025/10/11 16:12:27 ==> Preload func _
2025/10/11 16:12:27 ==> Load > NewType foo
2025/10/11 16:12:27 NewType foo
2025/10/11 16:12:27 ==> Load > InitType foo
2025/10/11 16:12:27 InitType foo struct{c int}
2025/10/11 16:12:27 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/10/11 16:12:27 ==> Load method github.com/goplus/xgo/cl.foo.ptr
2025/10/11 16:12:27 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/10/11 16:12:27 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/10/11 16:12:27 ==> Load method github.com/goplus/xgo/cl.foo.clone
2025/10/11 16:12:27 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/10/11 16:12:27 ==> Load > NewType nested
2025/10/11 16:12:27 NewType nested
2025/10/11 16:12:27 ==> Load > InitType nested
2025/10/11 16:12:27 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/10/11 16:12:27 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/10/11 16:12:27 InitType nested struct{f github.com/goplus/xgo/cl.foo; a [2]github.com/goplus/xgo/cl.foo; s []github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:27 ==> Load func _
2025/10/11 16:12:27 NewFunc _ func()
2025/10/11 16:12:27 DefineVarStart [getNested]
2025/10/11 16:12:27 ==> LookupParent nested => type github.com/goplus/xgo/cl.nested struct{f github.com/goplus/xgo/cl.foo; a [2]github.com/goplus/xgo/cl.foo; s []github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:27 NewClosure func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 ==> LookupParent nested => type github.com/goplus/xgo/cl.nested struct{f github.com/goplus/xgo/cl.foo; a [2]github.com/goplus/xgo/cl.foo; s []github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.nested 0 false
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.nested, github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val getNested func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/10/11 16:12:27 Member f 2 // github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Member c 2 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val getNested func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/10/11 16:12:27 Member a 2 // github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 Index 1 false
2025/10/11 16:12:27 Member c 2 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val getNested func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/10/11 16:12:27 Member s 2 // github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 Index 1 false
2025/10/11 16:12:27 Member c 2 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val getNested func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/10/11 16:12:27 Member f 2 // github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Member ptr 1 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Call 0 0 // func() *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.foo args: 0 flags: 0
2025/10/11 16:12:27 Member c 2 // *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val getNested func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/10/11 16:12:27 Member f 2 // github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Member clone 1 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.foo args: 0 flags: 0
2025/10/11 16:12:27 Member c 2 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val getNested func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/10/11 16:12:27 Member f 2 // github.com/goplus/xgo/cl.nested
2025/10/11 16:12:27 Member clone 1 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Call 0 0 // func() github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 ==> MatchFuncCall func() github.com/goplus/xgo/cl.foo args: 0 flags: 0
2025/10/11 16:12:27 Member ptr 1 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Call 0 0 // func() *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.foo args: 0 flags: 0
2025/10/11 16:12:27 Member c 2 // *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc ptr (github.com/goplus/xgo/cl.foo) func() *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Val f github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc clone (github.com/goplus/xgo/cl.foo) func() github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Val f github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestAddress (0.00s)
=== RUN   TestSliceLitAssign
2025/10/11 16:12:27 ==> Preload var [n]
2025/10/11 16:12:27 ==> Preload var [a]
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load var <nil> [n]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [n]
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> Load var []interface{} [a]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [a]
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []interface{} 3 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType []interface{}, []interface{}
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 VarRef n int
2025/10/11 16:12:27 VarRef a []interface{}
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []interface{} 3 false
2025/10/11 16:12:27 Assign 2 2
2025/10/11 16:12:27 ==> MatchType untyped int (100), int
2025/10/11 16:12:27 ==> MatchType []interface{}, []interface{}
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a []interface{}
2025/10/11 16:12:27 Val n int
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType []interface{}, any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestSliceLitAssign (0.00s)
=== RUN   TestSliceLitReturn
2025/10/11 16:12:27 ==> Preload func anyslice
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func anyslice
2025/10/11 16:12:27 NewFunc anyslice func() (int, []interface{})
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []interface{} 3 false
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType untyped int (100), int
2025/10/11 16:12:27 ==> MatchType []interface{}, []interface{}
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [n a]
2025/10/11 16:12:27 Val anyslice func() (int, []interface{})
2025/10/11 16:12:27 Call 0 2 // func() (int, []interface{})
2025/10/11 16:12:27 ==> MatchFuncCall func() (int, []interface{}) args: 0 flags: 2
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val n int
2025/10/11 16:12:27 Val a []interface{}
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 ==> MatchType []interface{}, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestSliceLitReturn (0.00s)
=== RUN   TestCompositeLitAssign
2025/10/11 16:12:27 ==> Preload var [a]
2025/10/11 16:12:27 ==> Preload var [b]
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load var map[interface{}]interface{} [a]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [a]
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "A"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "B"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "C"} *ast.BasicLit
2025/10/11 16:12:27 MapLit map[interface{}]interface{} 6
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType map[interface{}]interface{}, map[interface{}]interface{}
2025/10/11 16:12:27 ==> Load var map[interface{}]string [b]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [b]
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "A"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "B"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "C"} *ast.BasicLit
2025/10/11 16:12:27 MapLit map[interface{}]string 6
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType map[interface{}]string, map[interface{}]string
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a map[interface{}]interface{}
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType map[interface{}]interface{}, any
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val b map[interface{}]string
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType map[interface{}]string, any
2025/10/11 16:12:27 ==> Load var int [n]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [n]
2025/10/11 16:12:27 VarRef n int
2025/10/11 16:12:27 VarRef a map[interface{}]interface{}
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "A"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "B"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "C"} *ast.BasicLit
2025/10/11 16:12:27 MapLit map[interface{}]interface{} 6
2025/10/11 16:12:27 Assign 2 2
2025/10/11 16:12:27 ==> MatchType untyped int (1), int
2025/10/11 16:12:27 ==> MatchType map[interface{}]interface{}, map[interface{}]interface{}
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a map[interface{}]interface{}
2025/10/11 16:12:27 Val n int
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType map[interface{}]interface{}, any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 VarRef n int
2025/10/11 16:12:27 VarRef b map[interface{}]string
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "A"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "B"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "C"} *ast.BasicLit
2025/10/11 16:12:27 MapLit map[interface{}]string 6
2025/10/11 16:12:27 Assign 2 2
2025/10/11 16:12:27 ==> MatchType untyped int (1), int
2025/10/11 16:12:27 ==> MatchType map[interface{}]string, map[interface{}]string
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val b map[interface{}]string
2025/10/11 16:12:27 Val n int
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType map[interface{}]string, any
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCompositeLitAssign (0.00s)
=== RUN   TestCompositeLitStruct
2025/10/11 16:12:27 ==> Preload type T
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load > NewType T
2025/10/11 16:12:27 NewType T
2025/10/11 16:12:27 ==> Load > InitType T
2025/10/11 16:12:27 InitType T struct{s []interface{}; m map[interface{}]interface{}; fn func(int) int}
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{s []interface{}; m map[interface{}]interface{}; fn func(int) int}
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []interface{} 3 false
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "A"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "B"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "C"} *ast.BasicLit
2025/10/11 16:12:27 MapLit map[interface{}]interface{} 6
2025/10/11 16:12:27 NewClosure func(x int) int
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.T 3 false
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType *github.com/goplus/xgo/cl.T, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{s []interface{}; m map[interface{}]interface{}; fn func(int) int}
2025/10/11 16:12:27 Val 0 int
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []interface{} 3 false
2025/10/11 16:12:27 Val 1 int
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "A"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "B"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "C"} *ast.BasicLit
2025/10/11 16:12:27 MapLit map[interface{}]interface{} 6
2025/10/11 16:12:27 Val 2 int
2025/10/11 16:12:27 NewClosure func(x int) int
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.T 6 true
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType *github.com/goplus/xgo/cl.T, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCompositeLitStruct (0.00s)
=== RUN   TestCompositeLitEx
2025/10/11 16:12:27 ==> Preload var [a]
2025/10/11 16:12:27 ==> Preload var [m]
2025/10/11 16:12:27 ==> Preload var [f]
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load var [][]interface{} [a]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [a]
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []interface{} 3 false
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []interface{} 2 false
2025/10/11 16:12:27 SliceLit [][]interface{} 2 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType [][]interface{}, [][]interface{}
2025/10/11 16:12:27 ==> Load var map[interface{}][]interface{} [m]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [m]
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []interface{} 3 false
2025/10/11 16:12:27 MapLit map[interface{}][]interface{} 2
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType map[interface{}][]interface{}, map[interface{}][]interface{}
2025/10/11 16:12:27 ==> Load var map[interface{}]func(int) int [f]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [f]
2025/10/11 16:12:27 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:27 NewClosure func(x int) int
2025/10/11 16:12:27 Val x int
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 MapLit map[interface{}]func(int) int 2
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 ==> MatchType map[interface{}]func(int) int, map[interface{}]func(int) int
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a [][]interface{}
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType [][]interface{}, any
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val m map[interface{}][]interface{}
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType map[interface{}][]interface{}, any
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val f map[interface{}]func(int) int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType map[interface{}]func(int) int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCompositeLitEx (0.00s)
=== RUN   TestErrWrapNoArgs
2025/10/11 16:12:27 ==> Preload func foo
2025/10/11 16:12:27 ==> Preload func Bar
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func foo
2025/10/11 16:12:27 NewFunc foo func(v ...int) (func(), error)
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType untyped nil, func()
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func Bar
2025/10/11 16:12:27 NewFunc Bar func() (int, error)
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType untyped int (100), int
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val foo func(v ...int) (func(), error)
2025/10/11 16:12:27 Call 0 0 // func(v ...int) (func(), error)
2025/10/11 16:12:27 ==> MatchFuncCall func(v ...int) (func(), error) args: 0 flags: 0
2025/10/11 16:12:27 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:27 NewVar [_xgo_err]
2025/10/11 16:12:27 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Assign 2 1
2025/10/11 16:12:27 ==> MatchType func(), unboundType{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val <nil> <nil>
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 Typ error
2025/10/11 16:12:27 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val foo string
2025/10/11 16:12:27 Val /foo/bar.xgo string
2025/10/11 16:12:27 Val 8 int
2025/10/11 16:12:27 Val main.main string
2025/10/11 16:12:27 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> MatchType untyped string ("foo"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:27 ==> MatchType untyped int (8), int
2025/10/11 16:12:27 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 Val panic func(v interface{})
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Call 1 0 // func(v interface{})
2025/10/11 16:12:27 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType error, interface{}
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 0 0 // func() (_xgo_ret func())
2025/10/11 16:12:27 ==> MatchFuncCall func() (_xgo_ret func()) args: 0 flags: 0
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 Val foo func(v ...int) (func(), error)
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(v ...int) (func(), error)
2025/10/11 16:12:27 ==> MatchFuncCall func(v ...int) (func(), error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped int (1), int
2025/10/11 16:12:27 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:27 NewVar [_xgo_err]
2025/10/11 16:12:27 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Assign 2 1
2025/10/11 16:12:27 ==> MatchType func(), unboundType{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val <nil> <nil>
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 Typ error
2025/10/11 16:12:27 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val foo(1) string
2025/10/11 16:12:27 Val /foo/bar.xgo string
2025/10/11 16:12:27 Val 9 int
2025/10/11 16:12:27 Val main.main string
2025/10/11 16:12:27 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> MatchType untyped string ("foo(1)"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:27 ==> MatchType untyped int (9), int
2025/10/11 16:12:27 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 Val panic func(v interface{})
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Call 1 0 // func(v interface{})
2025/10/11 16:12:27 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType error, interface{}
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 0 0 // func() (_xgo_ret func())
2025/10/11 16:12:27 ==> MatchFuncCall func() (_xgo_ret func()) args: 0 flags: 0
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val foo func(v ...int) (func(), error)
2025/10/11 16:12:27 Call 0 0 // func(v ...int) (func(), error)
2025/10/11 16:12:27 ==> MatchFuncCall func(v ...int) (func(), error) args: 0 flags: 0
2025/10/11 16:12:27 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:27 NewVar [_xgo_err]
2025/10/11 16:12:27 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Assign 2 1
2025/10/11 16:12:27 ==> MatchType func(), unboundType{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val <nil> <nil>
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 Typ error
2025/10/11 16:12:27 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val foo string
2025/10/11 16:12:27 Val /foo/bar.xgo string
2025/10/11 16:12:27 Val 10 int
2025/10/11 16:12:27 Val main.main string
2025/10/11 16:12:27 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> MatchType untyped string ("foo"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:27 ==> MatchType untyped int (10), int
2025/10/11 16:12:27 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 Val panic func(v interface{})
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Call 1 0 // func(v interface{})
2025/10/11 16:12:27 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType error, interface{}
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 0 0 // func() (_xgo_ret func())
2025/10/11 16:12:27 ==> MatchFuncCall func() (_xgo_ret func()) args: 0 flags: 0
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType func(), any
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val Bar func() (int, error)
2025/10/11 16:12:27 Call 0 0 // func() (int, error)
2025/10/11 16:12:27 ==> MatchFuncCall func() (int, error) args: 0 flags: 0
2025/10/11 16:12:27 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:27 NewVar [_xgo_err]
2025/10/11 16:12:27 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Assign 2 1
2025/10/11 16:12:27 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val <nil> <nil>
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 Typ error
2025/10/11 16:12:27 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val bar string
2025/10/11 16:12:27 Val /foo/bar.xgo string
2025/10/11 16:12:27 Val 11 int
2025/10/11 16:12:27 Val main.main string
2025/10/11 16:12:27 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> MatchType untyped string ("bar"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:27 ==> MatchType untyped int (11), int
2025/10/11 16:12:27 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 Val panic func(v interface{})
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Call 1 0 // func(v interface{})
2025/10/11 16:12:27 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType error, interface{}
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 0 0 // func() (_xgo_ret int)
2025/10/11 16:12:27 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestErrWrapNoArgs (0.00s)
=== RUN   TestCommentFunc
2025/10/11 16:12:27 ==> Preload func add
2025/10/11 16:12:27 ==> Preload func addSafe
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func add
2025/10/11 16:12:27 NewFunc add func(x string, y string) (int, error)
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:7:1
2025/10/11 16:12:27 Val Atoi func(s string) (int, error)
2025/10/11 16:12:27 Val x string
2025/10/11 16:12:27 Call 1 0 // func(s string) (int, error)
2025/10/11 16:12:27 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 CallInlineClosureStart 0 false
2025/10/11 16:12:27 NewVar [_autoGo_1]
2025/10/11 16:12:27 NewVar [_xgo_err]
2025/10/11 16:12:27 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Assign 2 1
2025/10/11 16:12:27 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val <nil> <nil>
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 Typ error
2025/10/11 16:12:27 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val strconv.atoi(x) string
2025/10/11 16:12:27 Val /foo/bar.xgo string
2025/10/11 16:12:27 Val 7 int
2025/10/11 16:12:27 Val main.add string
2025/10/11 16:12:27 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> MatchType untyped string ("strconv.atoi(x)"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:27 ==> MatchType untyped int (7), int
2025/10/11 16:12:27 ==> MatchType untyped string ("main.add"), string
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 ReturnErr true
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 Goto _autoGo_2
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Label _autoGo_2
2025/10/11 16:12:27 Val Atoi func(s string) (int, error)
2025/10/11 16:12:27 Val y string
2025/10/11 16:12:27 Call 1 0 // func(s string) (int, error)
2025/10/11 16:12:27 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 CallInlineClosureStart 0 false
2025/10/11 16:12:27 NewVar [_autoGo_3]
2025/10/11 16:12:27 NewVar [_xgo_err]
2025/10/11 16:12:27 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Assign 2 1
2025/10/11 16:12:27 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val <nil> <nil>
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 Typ error
2025/10/11 16:12:27 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val strconv.atoi(y) string
2025/10/11 16:12:27 Val /foo/bar.xgo string
2025/10/11 16:12:27 Val 7 int
2025/10/11 16:12:27 Val main.add string
2025/10/11 16:12:27 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> MatchType untyped string ("strconv.atoi(y)"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:27 ==> MatchType untyped int (7), int
2025/10/11 16:12:27 ==> MatchType untyped string ("main.add"), string
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 ReturnErr true
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 Goto _autoGo_4
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Label _autoGo_4
2025/10/11 16:12:27 BinaryOp +
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:27 Val nil untyped nil
2025/10/11 16:12:27 Return 2
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 ==> MatchType untyped nil, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func addSafe
2025/10/11 16:12:27 NewFunc addSafe func(x string, y string) int
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:11:1
2025/10/11 16:12:27 Val Atoi func(s string) (int, error)
2025/10/11 16:12:27 Val x string
2025/10/11 16:12:27 Call 1 0 // func(s string) (int, error)
2025/10/11 16:12:27 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:27 NewVar [_xgo_err]
2025/10/11 16:12:27 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Assign 2 1
2025/10/11 16:12:27 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val <nil> <nil>
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 Typ error
2025/10/11 16:12:27 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType untyped int (0), unboundType{typ: int}
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 0 0 // func() (_xgo_ret int)
2025/10/11 16:12:27 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/10/11 16:12:27 Val Atoi func(s string) (int, error)
2025/10/11 16:12:27 Val y string
2025/10/11 16:12:27 Call 1 0 // func(s string) (int, error)
2025/10/11 16:12:27 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:27 NewVar [_xgo_err]
2025/10/11 16:12:27 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Assign 2 1
2025/10/11 16:12:27 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val <nil> <nil>
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 Typ error
2025/10/11 16:12:27 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType untyped int (0), unboundType{typ: int}
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 0 0 // func() (_xgo_ret int)
2025/10/11 16:12:27 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/10/11 16:12:27 BinaryOp +
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType int, int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:14:1
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val add func(x string, y string) (int, error)
2025/10/11 16:12:27 Val &{0 STRING "100"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "23"} *ast.BasicLit
2025/10/11 16:12:27 Call 2 0 // func(x string, y string) (int, error)
2025/10/11 16:12:27 ==> MatchFuncCall func(x string, y string) (int, error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("100"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("23"), string
2025/10/11 16:12:27 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:27 NewVar [_xgo_err]
2025/10/11 16:12:27 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Assign 2 1
2025/10/11 16:12:27 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 If
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val <nil> <nil>
2025/10/11 16:12:27 BinaryOp !=
2025/10/11 16:12:27 Typ error
2025/10/11 16:12:27 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 VarRef _xgo_err error
2025/10/11 16:12:27 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Val add("100", "23") string
2025/10/11 16:12:27 Val /foo/bar.xgo string
2025/10/11 16:12:27 Val 14 int
2025/10/11 16:12:27 Val main.main string
2025/10/11 16:12:27 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:27 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:27 ==> MatchType error, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 ==> MatchType untyped string ("add(\"100\", \"23\")"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:27 ==> MatchType untyped int (14), int
2025/10/11 16:12:27 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 Val panic func(v interface{})
2025/10/11 16:12:27 Val _xgo_err error
2025/10/11 16:12:27 Call 1 0 // func(v interface{})
2025/10/11 16:12:27 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType error, interface{}
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 End // If
2025/10/11 16:12:27 Return 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 Call 0 0 // func() (_xgo_ret int)
2025/10/11 16:12:27 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:16:1
2025/10/11 16:12:27 DefineVarStart [sum err]
2025/10/11 16:12:27 Val add func(x string, y string) (int, error)
2025/10/11 16:12:27 Val &{0 STRING "10"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "abc"} *ast.BasicLit
2025/10/11 16:12:27 Call 2 2 // func(x string, y string) (int, error)
2025/10/11 16:12:27 ==> MatchFuncCall func(x string, y string) (int, error) args: 2 flags: 2
2025/10/11 16:12:27 ==> MatchType untyped string ("10"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("abc"), string
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:17:1
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val sum int
2025/10/11 16:12:27 Val err error
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 ==> MatchType error, any
2025/10/11 16:12:27 ==> EnsureLoaded error
2025/10/11 16:12:27 SetComments 0
//line /foo/bar.xgo:19:1
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val addSafe func(x string, y string) int
2025/10/11 16:12:27 Val &{0 STRING "10"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "abc"} *ast.BasicLit
2025/10/11 16:12:27 Call 2 0 // func(x string, y string) int
2025/10/11 16:12:27 ==> MatchFuncCall func(x string, y string) int args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("10"), string
2025/10/11 16:12:27 ==> MatchType untyped string ("abc"), string
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestCommentFunc (0.00s)
=== RUN   TestTestspx
=== RUN   TestTestspx/basic
2025/10/11 16:12:27 Parsing /app/cl/_testspx/basic
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/basic/Game.tgmx
2025/10/11 16:12:27 ==> InitClass Game isProj: true
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/basic/Kai.tspx
2025/10/11 16:12:27 ==> InitClass Kai isProj: false
2025/10/11 16:12:27 ==> Preload type Game
2025/10/11 16:12:27 ==> Preload method Game.onInit
2025/10/11 16:12:27 ==> Preload method Game.MainEntry
2025/10/11 16:12:27 ==> Preload type Kai
2025/10/11 16:12:27 ==> Preload method Kai.onMsg
2025/10/11 16:12:27 ==> Preload method Kai.Main
2025/10/11 16:12:27 ==> Load > NewType Game
2025/10/11 16:12:27 NewType Game
2025/10/11 16:12:27 ==> Load > NewType Kai
2025/10/11 16:12:27 NewType Kai
2025/10/11 16:12:27 ==> Load > InitType Game
2025/10/11 16:12:27 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:27 ==> Load method *Game.onInit
2025/10/11 16:12:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:27 ==> Load method *Game.MainEntry
2025/10/11 16:12:27 ==> Load > InitType Kai
2025/10/11 16:12:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:27 ==> Load method *Kai.onMsg
2025/10/11 16:12:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/10/11 16:12:27 ==> Load method *Kai.Main
2025/10/11 16:12:27 NewFunc onInit (*Game) func()
2025/10/11 16:12:27 For
2025/10/11 16:12:27 None
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val Sched func()
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 Val SchedNow func()
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // For
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Member initGameApp 1 // *Game
2025/10/11 16:12:27 Call 0 0 // func(args ...string)
2025/10/11 16:12:27 ==> MatchFuncCall func(args ...string) args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*Game) func()
2025/10/11 16:12:27 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Call 1 0 // func(game any)
2025/10/11 16:12:27 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType *Game, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc onMsg (*Kai) func(msg string)
2025/10/11 16:12:27 For
2025/10/11 16:12:27 None
2025/10/11 16:12:27 Then
2025/10/11 16:12:27 Val this *Kai
2025/10/11 16:12:27 Member say 1 // *Kai
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(msg string, secs ...float64)
2025/10/11 16:12:27 ==> MatchFuncCall func(msg string, secs ...float64) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hi"), string
2025/10/11 16:12:27 End // For
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*Kai) func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 Val Game Game
2025/10/11 16:12:27 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/10/11 16:12:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:27 Member Main 0 // *Game
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
=== RUN   TestTestspx/init
2025/10/11 16:12:27 Parsing /app/cl/_testspx/init
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/init/init.tspx
2025/10/11 16:12:27 ==> InitClass init isProj: false
2025/10/11 16:12:27 ==> Preload type _init
2025/10/11 16:12:27 ==> Preload method _init.Main
2025/10/11 16:12:27 ==> Load > NewType _init
2025/10/11 16:12:27 NewType _init
2025/10/11 16:12:27 ==> Load > InitType _init
2025/10/11 16:12:27 ==> Load > NewType MyGame
2025/10/11 16:12:27 NewType MyGame
2025/10/11 16:12:27 ==> Lookup (LoadSymbol) MyGame => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:27 ==> Load > InitType MyGame
2025/10/11 16:12:27 InitType MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:27 InitType _init struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *MyGame}
2025/10/11 16:12:27 ==> LookupParent _init => type _init struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *MyGame}
2025/10/11 16:12:27 ==> Load method *_init.Main
2025/10/11 16:12:27 NewFunc Main (*MyGame) func()
2025/10/11 16:12:27 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:27 Val this *MyGame
2025/10/11 16:12:27 Call 1 0 // func(game any)
2025/10/11 16:12:27 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType *MyGame, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*_init) func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 Val MyGame MyGame
2025/10/11 16:12:27 Val type MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ MyGame
2025/10/11 16:12:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:27 Member Main 0 // *MyGame
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
=== RUN   TestTestspx/multiworks
2025/10/11 16:12:27 Parsing /app/cl/_testspx/multiworks
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/multiworks/foo_prompt.gox
2025/10/11 16:12:27 ==> Import github.com/goplus/xgo/cl/internal/mcp
2025/10/11 16:12:27 ==> NewTemplateRecvMethod Game Main
2025/10/11 16:12:27 ==> InitClass foo isProj: false
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/multiworks/hello_tool.gox
2025/10/11 16:12:27 ==> InitClass hello isProj: false
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/multiworks/main_mcp.gox
2025/10/11 16:12:27 ==> InitClass main isProj: true
2025/10/11 16:12:27 ==> Preload type foo
2025/10/11 16:12:27 ==> Preload method foo.Main
2025/10/11 16:12:27 ==> Preload type Tool_hello
2025/10/11 16:12:27 ==> Preload method Tool_hello.Main
2025/10/11 16:12:27 ==> Preload type Game
2025/10/11 16:12:27 ==> Preload method Game.MainEntry
2025/10/11 16:12:27 ==> Load > NewType foo
2025/10/11 16:12:27 NewType foo
2025/10/11 16:12:27 ==> Load > NewType Tool_hello
2025/10/11 16:12:27 NewType Tool_hello
2025/10/11 16:12:27 ==> Load > NewType Game
2025/10/11 16:12:27 NewType Game
2025/10/11 16:12:27 ==> Load > InitType Game
2025/10/11 16:12:27 InitType Game struct{github.com/goplus/xgo/cl/internal/mcp.Game; foo *foo}
2025/10/11 16:12:27 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/mcp.Game; foo *foo}
2025/10/11 16:12:27 ==> Load method *Game.MainEntry
2025/10/11 16:12:27 ==> Load > InitType foo
2025/10/11 16:12:27 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/mcp.Game; foo *foo}
2025/10/11 16:12:27 InitType foo struct{github.com/goplus/xgo/cl/internal/mcp.Prompt; *Game}
2025/10/11 16:12:27 ==> LookupParent foo => type foo struct{github.com/goplus/xgo/cl/internal/mcp.Prompt; *Game}
2025/10/11 16:12:27 ==> Load method *foo.Main
2025/10/11 16:12:27 ==> Load > InitType Tool_hello
2025/10/11 16:12:27 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/mcp.Game; foo *foo}
2025/10/11 16:12:27 InitType Tool_hello struct{github.com/goplus/xgo/cl/internal/mcp.Tool; *Game}
2025/10/11 16:12:27 ==> LookupParent Tool_hello => type Tool_hello struct{github.com/goplus/xgo/cl/internal/mcp.Tool; *Game}
2025/10/11 16:12:27 ==> Load method *Tool_hello.Main
2025/10/11 16:12:27 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Member server 1 // *Game
2025/10/11 16:12:27 Val &{0 STRING "protos"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(name string)
2025/10/11 16:12:27 ==> MatchFuncCall func(name string) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("protos"), string
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*Game) func()
2025/10/11 16:12:27 Typ github.com/goplus/xgo/cl/internal/mcp.Game
2025/10/11 16:12:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/mcp.Game}
2025/10/11 16:12:27 DefineVarStart [_xgo_obj0]
2025/10/11 16:12:27 Val 1 int
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 StructLit Tool_hello 2 true
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 DefineVarStart [_xgo_lst1]
2025/10/11 16:12:27 Val _xgo_obj0 *Tool_hello
2025/10/11 16:12:27 SliceLit []github.com/goplus/xgo/cl/internal/mcp.ToolProto 1 false
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/mcp.ToolProto
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 DefineVarStart [_xgo_obj1]
2025/10/11 16:12:27 Val 1 int
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 StructLit foo 2 true
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Member foo -1 // *Game
2025/10/11 16:12:27 Val _xgo_obj1 *foo
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType *foo, *foo
2025/10/11 16:12:27 DefineVarStart [_xgo_lst2]
2025/10/11 16:12:27 Val _xgo_obj1 *foo
2025/10/11 16:12:27 SliceLit []github.com/goplus/xgo/cl/internal/mcp.PromptProto 1 false
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/mcp.PromptProto
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Val <nil> <nil>
2025/10/11 16:12:27 Val _xgo_lst1 []github.com/goplus/xgo/cl/internal/mcp.ToolProto
2025/10/11 16:12:27 Val _xgo_lst2 []github.com/goplus/xgo/cl/internal/mcp.PromptProto
2025/10/11 16:12:27 Call 4 0 // func(game interface{initGame()}, resources []github.com/goplus/xgo/cl/internal/mcp.ResourceProto, tools []github.com/goplus/xgo/cl/internal/mcp.ToolProto, prompts []github.com/goplus/xgo/cl/internal/mcp.PromptProto)
2025/10/11 16:12:27 ==> MatchFuncCall func(game interface{initGame()}, resources []github.com/goplus/xgo/cl/internal/mcp.ResourceProto, tools []github.com/goplus/xgo/cl/internal/mcp.ToolProto, prompts []github.com/goplus/xgo/cl/internal/mcp.PromptProto) args: 4 flags: 0
2025/10/11 16:12:27 ==> MatchType *Game, interface{initGame()}
2025/10/11 16:12:27 ==> MatchType untyped nil, []github.com/goplus/xgo/cl/internal/mcp.ResourceProto
2025/10/11 16:12:27 ==> MatchType []github.com/goplus/xgo/cl/internal/mcp.ToolProto, []github.com/goplus/xgo/cl/internal/mcp.ToolProto
2025/10/11 16:12:27 ==> MatchType []github.com/goplus/xgo/cl/internal/mcp.PromptProto, []github.com/goplus/xgo/cl/internal/mcp.PromptProto
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*foo) func(_xgo_arg0 *github.com/goplus/xgo/cl/internal/mcp.Tool) string
2025/10/11 16:12:27 Val this *foo
2025/10/11 16:12:27 Member Prompt 0 // *foo
2025/10/11 16:12:27 Member Main 0 // github.com/goplus/xgo/cl/internal/mcp.Prompt
2025/10/11 16:12:27 Val _xgo_arg0 *github.com/goplus/xgo/cl/internal/mcp.Tool
2025/10/11 16:12:27 Call 1 0 // func(*github.com/goplus/xgo/cl/internal/mcp.Tool) string
2025/10/11 16:12:27 ==> MatchFuncCall func(*github.com/goplus/xgo/cl/internal/mcp.Tool) string args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType *github.com/goplus/xgo/cl/internal/mcp.Tool, *github.com/goplus/xgo/cl/internal/mcp.Tool
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType untyped string ("Hi"), string
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*Tool_hello) func(_xgo_arg0 string) int
2025/10/11 16:12:27 Val this *Tool_hello
2025/10/11 16:12:27 Member Tool 0 // *Tool_hello
2025/10/11 16:12:27 Member Main 0 // github.com/goplus/xgo/cl/internal/mcp.Tool
2025/10/11 16:12:27 Val _xgo_arg0 string
2025/10/11 16:12:27 Call 1 0 // func(name string) int
2025/10/11 16:12:27 ==> MatchFuncCall func(name string) int args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 UnaryOp - flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType untyped int (-1), int
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 Val Game Game
2025/10/11 16:12:27 Val type Game struct{github.com/goplus/xgo/cl/internal/mcp.Game; foo *foo} => Typ Game
2025/10/11 16:12:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:27 Member Main 0 // *Game
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
=== RUN   TestTestspx/newobj
2025/10/11 16:12:27 Parsing /app/cl/_testspx/newobj
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/newobj/Kai_spx.gox
2025/10/11 16:12:27 ==> Import github.com/goplus/xgo/cl/internal/spx3
2025/10/11 16:12:27 ==> NewTemplateRecvMethod Game Main
2025/10/11 16:12:27 ==> InitClass Kai isProj: false
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/newobj/main_spx.gox
2025/10/11 16:12:27 ==> InitClass main isProj: true
2025/10/11 16:12:27 ==> Preload type Kai
2025/10/11 16:12:27 ==> Preload method Kai.Main
2025/10/11 16:12:27 ==> Preload type Game
2025/10/11 16:12:27 ==> Preload method Game.MainEntry
2025/10/11 16:12:27 ==> Load > NewType Kai
2025/10/11 16:12:27 NewType Kai
2025/10/11 16:12:27 ==> Load > NewType Game
2025/10/11 16:12:27 NewType Game
2025/10/11 16:12:27 ==> Load > InitType Game
2025/10/11 16:12:27 InitType Game struct{github.com/goplus/xgo/cl/internal/spx3.Game}
2025/10/11 16:12:27 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game}
2025/10/11 16:12:27 ==> Load method *Game.MainEntry
2025/10/11 16:12:27 ==> Load > InitType Kai
2025/10/11 16:12:27 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game}
2025/10/11 16:12:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/10/11 16:12:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/10/11 16:12:27 ==> Load method *Kai.Main
2025/10/11 16:12:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/10/11 16:12:27 NewFunc Classfname (*Kai) func() string
2025/10/11 16:12:27 Val Kai string
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType untyped string ("Kai"), string
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/10/11 16:12:27 NewFunc Classclone (*Kai) func() github.com/goplus/xgo/cl/internal/spx3.Handler
2025/10/11 16:12:27 DefineVarStart [_xgo_ret]
2025/10/11 16:12:27 Val this *Kai
2025/10/11 16:12:27 Elem
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val _xgo_ret Kai
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx3.Handler
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx3.Handler
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:27 DefineVarStart [a]
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Member new 2 // *Game
2025/10/11 16:12:27 Val New func() *github.com/goplus/xgo/cl/internal/spx3.Game
2025/10/11 16:12:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx3.Game
2025/10/11 16:12:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx3.Game args: 0 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val a *github.com/goplus/xgo/cl/internal/spx3.Game
2025/10/11 16:12:27 Member run 1 // *github.com/goplus/xgo/cl/internal/spx3.Game
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 DefineVarStart [b]
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Member new 1 // *Game
2025/10/11 16:12:27 Val New func() *github.com/goplus/xgo/cl/internal/spx3.Game
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Member Sprite 2 // *Game
2025/10/11 16:12:27 Val Sprite github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/10/11 16:12:27 Val type github.com/goplus/xgo/cl/internal/spx3.Sprite struct{} => Typ github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/10/11 16:12:27 Call 1 0 // func() *github.com/goplus/xgo/cl/internal/spx3.Game
2025/10/11 16:12:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx3.Game args: 1 flags: 0
2025/10/11 16:12:27 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Member Sprite 2 // *Game
2025/10/11 16:12:27 Val Sprite github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/10/11 16:12:27 Val type github.com/goplus/xgo/cl/internal/spx3.Sprite struct{} => Typ github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/10/11 16:12:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Member echo 1 // *Game
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val b *github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/10/11 16:12:27 Member name 2 // *github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/10/11 16:12:27 Call 0 0 // func() string
2025/10/11 16:12:27 ==> MatchFuncCall func() string args: 0 flags: 0
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*Game) func()
2025/10/11 16:12:27 Typ github.com/goplus/xgo/cl/internal/spx3.Game
2025/10/11 16:12:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx3.Game}
2025/10/11 16:12:27 DefineVarStart [_xgo_obj0]
2025/10/11 16:12:27 Val 1 int
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 StructLit Kai 2 true
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Val _xgo_obj0 *Kai
2025/10/11 16:12:27 Call 2 0 // func(game interface{initGame()}, workers ...github.com/goplus/xgo/cl/internal/spx3.Handler)
2025/10/11 16:12:27 ==> MatchFuncCall func(game interface{initGame()}, workers ...github.com/goplus/xgo/cl/internal/spx3.Handler) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType *Game, interface{initGame()}
2025/10/11 16:12:27 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx3.Handler
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx3.Handler
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*Kai) func(_xgo_arg0 string)
2025/10/11 16:12:27 Val this *Kai
2025/10/11 16:12:27 Member Sprite 0 // *Kai
2025/10/11 16:12:27 Member Main 0 // github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/10/11 16:12:27 Val _xgo_arg0 string
2025/10/11 16:12:27 Call 1 0 // func(name string)
2025/10/11 16:12:27 ==> MatchFuncCall func(name string) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 Val Game Game
2025/10/11 16:12:27 Val type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game} => Typ Game
2025/10/11 16:12:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:27 Member Main 0 // *Game
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
=== RUN   TestTestspx/nogame
2025/10/11 16:12:27 Parsing /app/cl/_testspx/nogame
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/nogame/bar.tspx
2025/10/11 16:12:27 ==> InitClass bar isProj: false
2025/10/11 16:12:27 ==> Preload type bar
2025/10/11 16:12:27 ==> Preload method bar.Main
2025/10/11 16:12:27 ==> Load > NewType bar
2025/10/11 16:12:27 NewType bar
2025/10/11 16:12:27 ==> Load > InitType bar
2025/10/11 16:12:27 ==> Load > NewType MyGame
2025/10/11 16:12:27 NewType MyGame
2025/10/11 16:12:27 ==> Lookup (LoadSymbol) MyGame => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:27 ==> Load > InitType MyGame
2025/10/11 16:12:27 InitType MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:27 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *MyGame}
2025/10/11 16:12:27 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *MyGame}
2025/10/11 16:12:27 ==> Load method *bar.Main
2025/10/11 16:12:27 NewFunc Main (*MyGame) func()
2025/10/11 16:12:27 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:27 Val this *MyGame
2025/10/11 16:12:27 Call 1 0 // func(game any)
2025/10/11 16:12:27 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType *MyGame, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*bar) func()
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 Val MyGame MyGame
2025/10/11 16:12:27 Val type MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ MyGame
2025/10/11 16:12:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:27 Member Main 0 // *MyGame
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
=== RUN   TestTestspx/singlework
2025/10/11 16:12:27 Parsing /app/cl/_testspx/singlework
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/singlework/Kai_spx.gox
2025/10/11 16:12:27 ==> InitClass Kai isProj: false
2025/10/11 16:12:27 ==> ClassFile /app/cl/_testspx/singlework/main_spx.gox
2025/10/11 16:12:27 ==> InitClass main isProj: true
2025/10/11 16:12:27 ==> Preload type Kai
2025/10/11 16:12:27 ==> Preload method Kai.Main
2025/10/11 16:12:27 ==> Preload type Game
2025/10/11 16:12:27 ==> Preload method Game.MainEntry
2025/10/11 16:12:27 ==> Load > NewType Kai
2025/10/11 16:12:27 NewType Kai
2025/10/11 16:12:27 ==> Load > NewType Game
2025/10/11 16:12:27 NewType Game
2025/10/11 16:12:27 ==> Load > InitType Game
2025/10/11 16:12:27 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:27 InitType Game struct{github.com/goplus/xgo/cl/internal/spx3.Game; Kai Kai}
2025/10/11 16:12:27 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game; Kai Kai}
2025/10/11 16:12:27 ==> Load method *Game.MainEntry
2025/10/11 16:12:27 ==> Load > InitType Kai
2025/10/11 16:12:27 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game; Kai Kai}
2025/10/11 16:12:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/10/11 16:12:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/10/11 16:12:27 ==> Load method *Kai.Main
2025/10/11 16:12:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/10/11 16:12:27 NewFunc Classfname (*Kai) func() string
2025/10/11 16:12:27 Val Kai string
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType untyped string ("Kai"), string
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/10/11 16:12:27 NewFunc Classclone (*Kai) func() github.com/goplus/xgo/cl/internal/spx3.Handler
2025/10/11 16:12:27 DefineVarStart [_xgo_ret]
2025/10/11 16:12:27 Val this *Kai
2025/10/11 16:12:27 Elem
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val _xgo_ret Kai
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 Return 1
2025/10/11 16:12:27 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx3.Handler
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx3.Handler
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc MainEntry (*Game) func()
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Member run 1 // *Game
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*Game) func()
2025/10/11 16:12:27 Typ github.com/goplus/xgo/cl/internal/spx3.Game
2025/10/11 16:12:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx3.Game}
2025/10/11 16:12:27 DefineVarStart [_xgo_obj0]
2025/10/11 16:12:27 Val 1 int
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 StructLit Kai 2 true
2025/10/11 16:12:27 UnaryOp & flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val this *Game
2025/10/11 16:12:27 Val _xgo_obj0 *Kai
2025/10/11 16:12:27 Call 2 0 // func(game interface{initGame()}, workers ...github.com/goplus/xgo/cl/internal/spx3.Handler)
2025/10/11 16:12:27 ==> MatchFuncCall func(game interface{initGame()}, workers ...github.com/goplus/xgo/cl/internal/spx3.Handler) args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType *Game, interface{initGame()}
2025/10/11 16:12:27 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx3.Handler
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx3.Handler
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc Main (*Kai) func(_xgo_arg0 string)
2025/10/11 16:12:27 Val this *Kai
2025/10/11 16:12:27 Member Sprite 0 // *Kai
2025/10/11 16:12:27 Member Main 0 // github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/10/11 16:12:27 Val _xgo_arg0 string
2025/10/11 16:12:27 Call 1 0 // func(name string)
2025/10/11 16:12:27 ==> MatchFuncCall func(name string) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, string
2025/10/11 16:12:27 Val this *Kai
2025/10/11 16:12:27 Member echo 1 // *Kai
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val this *Kai
2025/10/11 16:12:27 Member jwt 2 // *Kai
2025/10/11 16:12:27 Val Token func(v string) string
2025/10/11 16:12:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:27 Call 1 0 // func(v string) string
2025/10/11 16:12:27 ==> MatchFuncCall func(v string) string args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType untyped string ("Hi"), string
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType string, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 Val Game Game
2025/10/11 16:12:27 Val type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game; Kai Kai} => Typ Game
2025/10/11 16:12:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:27 Member Main 0 // *Game
2025/10/11 16:12:27 Call 0 0 // func()
2025/10/11 16:12:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
--- PASS: TestTestspx (0.15s)
    --- PASS: TestTestspx/basic (0.00s)
    --- PASS: TestTestspx/init (0.00s)
    --- PASS: TestTestspx/multiworks (0.05s)
    --- PASS: TestTestspx/newobj (0.09s)
    --- PASS: TestTestspx/nogame (0.00s)
    --- PASS: TestTestspx/singlework (0.00s)
=== RUN   TestTestgop
=== RUN   TestTestgop/append1
2025/10/11 16:12:27 Parsing /app/cl/_testgop/append1
2025/10/11 16:12:27 ==> Preload type foo
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load > NewType foo
2025/10/11 16:12:27 NewType foo
2025/10/11 16:12:27 ==> Load > InitType foo
2025/10/11 16:12:27 InitType foo struct{a []int}
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [a]
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:27 SliceLit <nil> 3 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val a []int
2025/10/11 16:12:27 VarRef a []int
2025/10/11 16:12:27 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType []int, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (4), unboundFuncParam{typ: int}
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType []int, []int
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a []int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType []int, any
2025/10/11 16:12:27 DefineVarStart [f]
2025/10/11 16:12:27 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{a []int}
2025/10/11 16:12:27 Val 0 int
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:27 SliceLit []int 3 false
2025/10/11 16:12:27 StructLit github.com/goplus/xgo/cl.foo 2 true
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val f github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Member a 2 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Val f github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Member a -1 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:12:27 ==> MatchType []int, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (4), unboundFuncParam{typ: int}
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType []int, []int
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val f github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType github.com/goplus/xgo/cl.foo, any
2025/10/11 16:12:27 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:27 DefineVarStart [f2]
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 ArrayLit [2]chan int 0 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val f2 [2]chan int
2025/10/11 16:12:27 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:27 Index 1 false
2025/10/11 16:12:27 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:27 Send
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
=== RUN   TestTestgop/append2
2025/10/11 16:12:27 Parsing /app/cl/_testgop/append2
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [a]
2025/10/11 16:12:27 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:27 SliceLit <nil> 3 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val a []int
2025/10/11 16:12:27 VarRef a []int
2025/10/11 16:12:27 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:27 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 3 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 3 flags: 0
2025/10/11 16:12:27 ==> MatchType []int, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType untyped int (4), unboundFuncParam{typ: int}
2025/10/11 16:12:27 ==> MatchType untyped int (5), unboundFuncParam{typ: int}
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType []int, []int
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a []int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType []int, any
2025/10/11 16:12:27 DefineVarStart [b]
2025/10/11 16:12:27 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 INT 8} *ast.BasicLit
2025/10/11 16:12:27 SliceLit <nil> 2 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val a []int
2025/10/11 16:12:27 VarRef a []int
2025/10/11 16:12:27 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val b []int
2025/10/11 16:12:27 Call 2 1 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 1
2025/10/11 16:12:27 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 1
2025/10/11 16:12:27 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 1
2025/10/11 16:12:27 ==> MatchType []int, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:27 ==> MatchType []int, []unboundFuncParam{typ: int}
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 ==> MatchType []int, []int
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a []int
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType []int, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
=== RUN   TestTestgop/cap
2025/10/11 16:12:27 Parsing /app/cl/_testgop/cap
2025/10/11 16:12:27 ==> Preload func main
2025/10/11 16:12:27 ==> Load func main
2025/10/11 16:12:27 NewFunc main func()
2025/10/11 16:12:27 DefineVarStart [a]
2025/10/11 16:12:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:12:27 Val &{0 STRING "123"} *ast.BasicLit
2025/10/11 16:12:27 SliceLit <nil> 3 false
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 Val a []string
2025/10/11 16:12:27 Member capitalize 2 // []string
2025/10/11 16:12:27 Val Capitalize func(a []string) []string
2025/10/11 16:12:27 Call 1 0 // func(a []string) []string
2025/10/11 16:12:27 ==> MatchFuncCall func(a []string) []string args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType []string, []string
2025/10/11 16:12:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:27 ==> MatchType []string, any
2025/10/11 16:12:27 End // Func
2025/10/11 16:12:27 ==> ASTFile
=== RUN   TestTestgop/domaintext-html
2025/10/11 16:12:27 Parsing /app/cl/_testgop/domaintext-html
2025/10/11 16:12:28 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:28 ==> NewOverloadFunc NewRange
2025/10/11 16:12:28 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:28 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:28 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:28 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:28 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:28 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:28 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:28 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:28 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:28 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:28 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:28 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Mul
xgo: downloading golang.org/x/net v0.34.0
2025/10/11 16:12:30 ==> Preload func main
2025/10/11 16:12:30 ==> Load func main
2025/10/11 16:12:30 NewFunc main func()
2025/10/11 16:12:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:30 Val Parse func(r io.Reader) (*golang.org/x/net/html.Node, error)
2025/10/11 16:12:30 Val NewReader func(s string) *strings.Reader
2025/10/11 16:12:30 Val &{0 STRING `<html><body><h1>hello</h1></body></html>`} *ast.BasicLit
2025/10/11 16:12:30 Call 1 0 // func(s string) *strings.Reader
2025/10/11 16:12:30 ==> MatchFuncCall func(s string) *strings.Reader args: 1 flags: 0
2025/10/11 16:12:30 ==> MatchType untyped string ("<html><body><h1>hello</h1></body></html>"), string
2025/10/11 16:12:30 Call 1 0 // func(r io.Reader) (*golang.org/x/net/html.Node, error)
2025/10/11 16:12:30 ==> MatchFuncCall func(r io.Reader) (*golang.org/x/net/html.Node, error) args: 1 flags: 0
2025/10/11 16:12:30 ==> MatchType *strings.Reader, io.Reader
2025/10/11 16:12:30 ==> EnsureLoaded io.Reader
2025/10/11 16:12:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:30 ==> MatchType *golang.org/x/net/html.Node, any
2025/10/11 16:12:30 ==> MatchType error, any
2025/10/11 16:12:30 ==> EnsureLoaded error
2025/10/11 16:12:30 End // Func
2025/10/11 16:12:30 ==> ASTFile
=== RUN   TestTestgop/domaintext-huh
2025/10/11 16:12:30 Parsing /app/cl/_testgop/domaintext-huh
2025/10/11 16:12:30 ==> Preload func main
2025/10/11 16:12:30 ==> Load func main
2025/10/11 16:12:30 NewFunc main func()
2025/10/11 16:12:30 DefineVarStart [form]
2025/10/11 16:12:30 Val New func(string, string, int) github.com/goplus/xgo/cl/internal/huh.Form
2025/10/11 16:12:30 Val <form id="test">
</form>
 string
2025/10/11 16:12:30 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:30 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:30 Call 3 0 // func(string, string, int) github.com/goplus/xgo/cl/internal/huh.Form
2025/10/11 16:12:30 ==> MatchFuncCall func(string, string, int) github.com/goplus/xgo/cl/internal/huh.Form args: 3 flags: 0
2025/10/11 16:12:30 ==> MatchType untyped string ("<form id=\"test\">\n</form>\n"), string
2025/10/11 16:12:30 ==> MatchType untyped string ("1"), string
2025/10/11 16:12:30 ==> MatchType untyped int (2), int
2025/10/11 16:12:30 EndInit 1
2025/10/11 16:12:30 Val form github.com/goplus/xgo/cl/internal/huh.Form
2025/10/11 16:12:30 Member run 1 // github.com/goplus/xgo/cl/internal/huh.Form
2025/10/11 16:12:30 Call 0 0 // func()
2025/10/11 16:12:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:30 End // Func
2025/10/11 16:12:30 ==> ASTFile
=== RUN   TestTestgop/domaintext-json
2025/10/11 16:12:30 Parsing /app/cl/_testgop/domaintext-json
2025/10/11 16:12:30 ==> Preload func main
2025/10/11 16:12:30 ==> Load func main
2025/10/11 16:12:30 NewFunc main func()
2025/10/11 16:12:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:30 Val New func(text string) (ret any, err error)
2025/10/11 16:12:30 Val &{0 STRING `{"a":1, "b":2}`} *ast.BasicLit
2025/10/11 16:12:30 Call 1 0 // func(text string) (ret any, err error)
2025/10/11 16:12:30 ==> MatchFuncCall func(text string) (ret any, err error) args: 1 flags: 0
2025/10/11 16:12:30 ==> MatchType untyped string ("{\"a\":1, \"b\":2}"), string
2025/10/11 16:12:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:30 ==> MatchType any, any
2025/10/11 16:12:30 ==> MatchType error, any
2025/10/11 16:12:30 ==> EnsureLoaded error
2025/10/11 16:12:30 End // Func
2025/10/11 16:12:30 ==> ASTFile
=== RUN   TestTestgop/domaintext-md
2025/10/11 16:12:30 Parsing /app/cl/_testgop/domaintext-md
2025/10/11 16:12:31 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:31 ==> NewOverloadFunc NewRange
2025/10/11 16:12:31 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:31 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:31 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:31 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:31 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:31 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:31 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:31 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:31 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:31 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:31 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Rem
xgo: downloading github.com/xushiwei/markdown v0.1.0
2025/10/11 16:12:35 ==> Preload func main
2025/10/11 16:12:35 ==> Load func main
2025/10/11 16:12:35 NewFunc main func()
2025/10/11 16:12:35 DefineVarStart [md]
2025/10/11 16:12:35 Val New func(text string) *github.com/xushiwei/markdown.Markdown
2025/10/11 16:12:35 Val &{0 STRING `
# Title

Hello world
`} *ast.BasicLit
2025/10/11 16:12:35 Call 1 0 // func(text string) *github.com/xushiwei/markdown.Markdown
2025/10/11 16:12:35 ==> MatchFuncCall func(text string) *github.com/xushiwei/markdown.Markdown args: 1 flags: 0
2025/10/11 16:12:35 ==> MatchType untyped string ("\n# Title\n\nHello world\n"), string
2025/10/11 16:12:35 EndInit 1
2025/10/11 16:12:35 Val md *github.com/xushiwei/markdown.Markdown
2025/10/11 16:12:35 Member convert 1 // *github.com/xushiwei/markdown.Markdown
2025/10/11 16:12:35 Val Stdout *os.File
2025/10/11 16:12:35 Call 1 0 // func(writer io.Writer, opts ...github.com/yuin/goldmark/parser.ParseOption) error
2025/10/11 16:12:35 ==> MatchFuncCall func(writer io.Writer, opts ...github.com/yuin/goldmark/parser.ParseOption) error args: 1 flags: 0
2025/10/11 16:12:35 ==> MatchType *os.File, io.Writer
2025/10/11 16:12:35 ==> EnsureLoaded io.Writer
2025/10/11 16:12:35 End // Func
2025/10/11 16:12:35 ==> ASTFile
=== RUN   TestTestgop/domaintext-regexp
2025/10/11 16:12:35 Parsing /app/cl/_testgop/domaintext-regexp
2025/10/11 16:12:35 ==> Preload func main
2025/10/11 16:12:35 ==> Load func main
2025/10/11 16:12:35 NewFunc main func()
2025/10/11 16:12:35 DefineVarStart [re err]
2025/10/11 16:12:36 Val New func(text string) (*regexp.Regexp, error)
2025/10/11 16:12:36 Val &{0 STRING `^[a-z]+\[[0-9]+\]$`} *ast.BasicLit
2025/10/11 16:12:36 Call 1 0 // func(text string) (*regexp.Regexp, error)
2025/10/11 16:12:36 ==> MatchFuncCall func(text string) (*regexp.Regexp, error) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("^[a-z]+\\[[0-9]+\\]$"), string
2025/10/11 16:12:36 EndInit 1
2025/10/11 16:12:36 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val re *regexp.Regexp
2025/10/11 16:12:36 Member matchString 1 // *regexp.Regexp
2025/10/11 16:12:36 Val &{0 STRING "adam[23]"} *ast.BasicLit
2025/10/11 16:12:36 Call 1 0 // func(s string) bool
2025/10/11 16:12:36 ==> MatchFuncCall func(s string) bool args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("adam[23]"), string
2025/10/11 16:12:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType bool, any
2025/10/11 16:12:36 VarRef _
2025/10/11 16:12:36 Val err error
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/domaintext-tpl
2025/10/11 16:12:36 Parsing /app/cl/_testgop/domaintext-tpl
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 DefineVarStart [cl err]
2025/10/11 16:12:36 Val NewEx func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/10/11 16:12:36 Val &{0 STRING `expr = INT % ("+" | "-")`} *ast.BasicLit
2025/10/11 16:12:36 Val cl/_testgop/domaintext-tpl/in.xgo string
2025/10/11 16:12:36 Val 1 int
2025/10/11 16:12:36 Val 15 int
2025/10/11 16:12:36 Call 4 0 // func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/10/11 16:12:36 ==> MatchFuncCall func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error) args: 4 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("expr = INT % (\"+\" | \"-\")"), any
2025/10/11 16:12:36 ==> MatchType untyped string ("cl/_testgop/domaintext-tpl/in.xgo"), string
2025/10/11 16:12:36 ==> MatchType untyped int (1), int
2025/10/11 16:12:36 ==> MatchType untyped int (15), int
2025/10/11 16:12:36 EndInit 1
2025/10/11 16:12:36 Val cl github.com/goplus/xgo/tpl.Compiler
2025/10/11 16:12:36 Member parseExpr 1 // github.com/goplus/xgo/tpl.Compiler
2025/10/11 16:12:36 Val &{0 STRING "1+2"} *ast.BasicLit
2025/10/11 16:12:36 Val nil untyped nil
2025/10/11 16:12:36 Call 2 0 // func(x string, conf *github.com/goplus/xgo/tpl.Config) (result any, err error)
2025/10/11 16:12:36 ==> MatchFuncCall func(x string, conf *github.com/goplus/xgo/tpl.Config) (result any, err error) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("1+2"), string
2025/10/11 16:12:36 ==> MatchType untyped nil, *github.com/goplus/xgo/tpl.Config
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/tpl.Config
2025/10/11 16:12:36 VarRef _
2025/10/11 16:12:36 Val err error
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/domaintpl
2025/10/11 16:12:36 Parsing /app/cl/_testgop/domaintpl
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val NewEx func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/10/11 16:12:36 Val &{0 STRING `
file = stmts => {
	return self
}

stmts = *(stmt ";") => {
	return [n.([]any)[0] for n in self]
}

stmt = varStmt | constStmt | outputStmt | inputStmt | ifStmt | whileStmt | untilStmt | assignStmt

varStmt = "DECLARE" namelist ":" typeExpr

constStmt = "CONSTANT" IDENT "<-" expr

assignStmt = IDENT "<-" expr

outputStmt = "OUTPUT" exprlist

inputStmt = "INPUT" namelist

ifStmt = "IF" expr "THEN" ";" stmts ?("ELSE" ";" stmts) "ENDIF"

whileStmt = "WHILE" expr "DO" ";" stmts "ENDWHILE"

untilStmt = "REPEAT" ";" stmts "UNTIL" expr

typeExpr = "INTEGER" | "REAL" | "STRING" | "BOOLEAN"

expr = binaryExpr2 % ("<" | "<=" | ">" | ">=" | "=" | "<>")

binaryExpr2 = binaryExpr1 % ("+" | "-")

binaryExpr1 = operand % ("*" | "/")

operand = basicLit | ident | parenExpr | unaryExpr

unaryExpr = "-" operand

basicLit = INT | FLOAT | STRING

ident = IDENT

parenExpr = "(" expr ")"

exprlist = expr % ","

namelist = IDENT % ","
`} *ast.BasicLit
2025/10/11 16:12:36 Val cl/_testgop/domaintpl/in.xgo string
2025/10/11 16:12:36 Val 1 int
2025/10/11 16:12:36 Val 4 int
2025/10/11 16:12:36 Val file string
2025/10/11 16:12:36 NewClosure func(self interface{}) interface{}
2025/10/11 16:12:36 Val self interface{}
2025/10/11 16:12:36 Return 1
2025/10/11 16:12:36 ==> MatchType interface{}, interface{}
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 Val stmts string
2025/10/11 16:12:36 NewClosure func(self []interface{}) interface{}
2025/10/11 16:12:36 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:36 ForRange [_ n]
2025/10/11 16:12:36 Val self []interface{}
2025/10/11 16:12:36 RangeAssignThen
2025/10/11 16:12:36 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:36 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:36 Val n interface{}
2025/10/11 16:12:36 TypeAssert []interface{} false
2025/10/11 16:12:36 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:36 Index 1 false
2025/10/11 16:12:36 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType interface{}, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 ==> MatchType []interface{}, unboundType{typ: <nil>}
2025/10/11 16:12:36 End // ForRange
2025/10/11 16:12:36 Return 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 Call 0 0 // func() (_xgo_ret []interface{})
2025/10/11 16:12:36 ==> MatchFuncCall func() (_xgo_ret []interface{}) args: 0 flags: 0
2025/10/11 16:12:36 Return 1
2025/10/11 16:12:36 ==> MatchType []interface{}, interface{}
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 Call 8 0 // func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/10/11 16:12:36 ==> MatchFuncCall func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error) args: 8 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("\nfile = stmts => {\n\treturn self\n}\n\nstmts = *(stmt \";\") => {\...), any
2025/10/11 16:12:36 ==> MatchType untyped string ("cl/_testgop/domaintpl/in.xgo"), string
2025/10/11 16:12:36 ==> MatchType untyped int (1), int
2025/10/11 16:12:36 ==> MatchType untyped int (4), int
2025/10/11 16:12:36 ==> MatchType untyped string ("file"), any
2025/10/11 16:12:36 ==> MatchType func(self interface{}) interface{}, any
2025/10/11 16:12:36 ==> MatchType untyped string ("stmts"), any
2025/10/11 16:12:36 ==> MatchType func(self []interface{}) interface{}, any
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/enumlines-rdr
2025/10/11 16:12:36 Parsing /app/cl/_testgop/enumlines-rdr
2025/10/11 16:12:36 ==> Preload var [r]
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load var io.Reader [r]
2025/10/11 16:12:36 NewVarDefs
2025/10/11 16:12:36 NewVar [r]
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 ForRange [_ line]
2025/10/11 16:12:36 Val lines func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val r io.Reader
2025/10/11 16:12:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(r io.Reader) github.com/qiniu/x/osx.LineReader args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType io.Reader, io.Reader
2025/10/11 16:12:36 ==> EnsureLoaded io.Reader
2025/10/11 16:12:36 ==> EnsureLoaded io.Reader
2025/10/11 16:12:36 RangeAssignThen
2025/10/11 16:12:36 VBlock
2025/10/11 16:12:36 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val line string
2025/10/11 16:12:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType string, any
2025/10/11 16:12:36 End // Vblock
2025/10/11 16:12:36 End // ForRange
2025/10/11 16:12:36 Member Gop_Enum 0 // github.com/qiniu/x/osx.LineReader
2025/10/11 16:12:36 Call 0 0 // func() github.com/qiniu/x/osx.LineIter
2025/10/11 16:12:36 ==> MatchFuncCall func() github.com/qiniu/x/osx.LineIter args: 0 flags: 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/enumlines-stdin
2025/10/11 16:12:36 Parsing /app/cl/_testgop/enumlines-stdin
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 ForRange [_ line]
2025/10/11 16:12:36 Val Stdin *os.File
2025/10/11 16:12:36 RangeAssignThen
2025/10/11 16:12:36 VBlock
2025/10/11 16:12:36 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val line string
2025/10/11 16:12:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType string, any
2025/10/11 16:12:36 End // Vblock
2025/10/11 16:12:36 End // ForRange
2025/10/11 16:12:36 Member Gop_Enum 0 // *os.File
2025/10/11 16:12:36 Val EnumLines func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/10/11 16:12:36 Call 1 0 // func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/10/11 16:12:36 ==> MatchFuncCall func(r io.Reader) github.com/qiniu/x/osx.LineIter args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType *os.File, io.Reader
2025/10/11 16:12:36 ==> EnsureLoaded io.Reader
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/errwrap1
2025/10/11 16:12:36 Parsing /app/cl/_testgop/errwrap1
2025/10/11 16:12:36 ==> Preload func F
2025/10/11 16:12:36 ==> Preload func F2
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func F
2025/10/11 16:12:36 NewFunc F func() (a int8, b int16, err error)
2025/10/11 16:12:36 VarRef a int8
2025/10/11 16:12:36 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 ==> MatchType untyped int (1), int8
2025/10/11 16:12:36 Return 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func F2
2025/10/11 16:12:36 NewFunc F2 func() (err error)
2025/10/11 16:12:36 DefineVarStart [c d]
2025/10/11 16:12:36 Val F func() (a int8, b int16, err error)
2025/10/11 16:12:36 Call 0 0 // func() (a int8, b int16, err error)
2025/10/11 16:12:36 ==> MatchFuncCall func() (a int8, b int16, err error) args: 0 flags: 0
2025/10/11 16:12:36 NewClosure func() (_xgo_ret unboundType{typ: <nil>}, _xgo_ret2 unboundType{typ: <nil>})
2025/10/11 16:12:36 NewVar [_xgo_err]
2025/10/11 16:12:36 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:36 VarRef _xgo_ret2 unboundType{typ: <nil>}
2025/10/11 16:12:36 VarRef _xgo_err error
2025/10/11 16:12:36 Assign 3 1
2025/10/11 16:12:36 ==> MatchType int8, unboundType{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType int16, unboundType{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType error, error
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 If
2025/10/11 16:12:36 Val _xgo_err error
2025/10/11 16:12:36 Val <nil> <nil>
2025/10/11 16:12:36 BinaryOp !=
2025/10/11 16:12:36 Typ error
2025/10/11 16:12:36 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:36 Then
2025/10/11 16:12:36 VarRef _xgo_err error
2025/10/11 16:12:36 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:36 Val _xgo_err error
2025/10/11 16:12:36 Val F() string
2025/10/11 16:12:36 Val cl/_testgop/errwrap1/in.xgo string
2025/10/11 16:12:36 Val 7 int
2025/10/11 16:12:36 Val main.F2 string
2025/10/11 16:12:36 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:36 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:36 ==> MatchType error, error
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 ==> MatchType untyped string ("F()"), string
2025/10/11 16:12:36 ==> MatchType untyped string ("cl/_testgop/errwrap1/in.xgo"), string
2025/10/11 16:12:36 ==> MatchType untyped int (7), int
2025/10/11 16:12:36 ==> MatchType untyped string ("main.F2"), string
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 Val panic func(v interface{})
2025/10/11 16:12:36 Val _xgo_err error
2025/10/11 16:12:36 Call 1 0 // func(v interface{})
2025/10/11 16:12:36 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType error, interface{}
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 End // If
2025/10/11 16:12:36 Return 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 Call 0 0 // func() (_xgo_ret int8, _xgo_ret2 int16)
2025/10/11 16:12:36 ==> MatchFuncCall func() (_xgo_ret int8, _xgo_ret2 int16) args: 0 flags: 0
2025/10/11 16:12:36 EndInit 1
2025/10/11 16:12:36 VarRef _
2025/10/11 16:12:36 Val c int8
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 VarRef _
2025/10/11 16:12:36 Val d int16
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 Return 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val F2 func() (err error)
2025/10/11 16:12:36 Call 0 0 // func() (err error)
2025/10/11 16:12:36 ==> MatchFuncCall func() (err error) args: 0 flags: 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/errwrap2
2025/10/11 16:12:36 Parsing /app/cl/_testgop/errwrap2
2025/10/11 16:12:36 ==> Preload func F
2025/10/11 16:12:36 ==> Preload func F2
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func F
2025/10/11 16:12:36 NewFunc F func() (a int8, b int16, err error)
2025/10/11 16:12:36 VarRef a int8
2025/10/11 16:12:36 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 ==> MatchType untyped int (1), int8
2025/10/11 16:12:36 Return 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func F2
2025/10/11 16:12:36 NewFunc F2 func() (err error)
2025/10/11 16:12:36 DefineVarStart [c d]
2025/10/11 16:12:36 Val F func() (a int8, b int16, err error)
2025/10/11 16:12:36 Call 0 0 // func() (a int8, b int16, err error)
2025/10/11 16:12:36 ==> MatchFuncCall func() (a int8, b int16, err error) args: 0 flags: 0
2025/10/11 16:12:36 CallInlineClosureStart 0 false
2025/10/11 16:12:36 NewVar [_autoGo_1]
2025/10/11 16:12:36 NewVar [_autoGo_2]
2025/10/11 16:12:36 NewVar [_xgo_err]
2025/10/11 16:12:36 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:36 VarRef _xgo_ret2 unboundType{typ: <nil>}
2025/10/11 16:12:36 VarRef _xgo_err error
2025/10/11 16:12:36 Assign 3 1
2025/10/11 16:12:36 ==> MatchType int8, unboundType{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType int16, unboundType{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType error, error
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 If
2025/10/11 16:12:36 Val _xgo_err error
2025/10/11 16:12:36 Val <nil> <nil>
2025/10/11 16:12:36 BinaryOp !=
2025/10/11 16:12:36 Typ error
2025/10/11 16:12:36 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:36 Then
2025/10/11 16:12:36 VarRef _xgo_err error
2025/10/11 16:12:36 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:36 Val _xgo_err error
2025/10/11 16:12:36 Val F() string
2025/10/11 16:12:36 Val cl/_testgop/errwrap2/in.xgo string
2025/10/11 16:12:36 Val 7 int
2025/10/11 16:12:36 Val main.F2 string
2025/10/11 16:12:36 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:36 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:36 ==> MatchType error, error
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 ==> MatchType untyped string ("F()"), string
2025/10/11 16:12:36 ==> MatchType untyped string ("cl/_testgop/errwrap2/in.xgo"), string
2025/10/11 16:12:36 ==> MatchType untyped int (7), int
2025/10/11 16:12:36 ==> MatchType untyped string ("main.F2"), string
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:36 ==> EnsureLoaded error
2025/10/11 16:12:36 Val _xgo_err error
2025/10/11 16:12:36 ReturnErr true
2025/10/11 16:12:36 End // If
2025/10/11 16:12:36 Return 0
2025/10/11 16:12:36 Goto _autoGo_3
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 Label _autoGo_3
2025/10/11 16:12:36 EndInit 2
2025/10/11 16:12:36 VarRef _
2025/10/11 16:12:36 Val c int8
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 VarRef _
2025/10/11 16:12:36 Val d int16
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 Return 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val F2 func() (err error)
2025/10/11 16:12:36 Call 0 0 // func() (err error)
2025/10/11 16:12:36 ==> MatchFuncCall func() (err error) args: 0 flags: 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/fatal
2025/10/11 16:12:36 Parsing /app/cl/_testgop/fatal
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 DefineVarStart [f err]
2025/10/11 16:12:36 Val Open func(name string) (*os.File, error)
2025/10/11 16:12:36 Val &{0 STRING "hello.txt"} *ast.BasicLit
2025/10/11 16:12:36 Call 1 2 // func(name string) (*os.File, error)
2025/10/11 16:12:36 ==> MatchFuncCall func(name string) (*os.File, error) args: 1 flags: 2
2025/10/11 16:12:36 ==> MatchType untyped string ("hello.txt"), string
2025/10/11 16:12:36 EndInit 1
2025/10/11 16:12:36 If
2025/10/11 16:12:36 Val err error
2025/10/11 16:12:36 Val nil untyped nil
2025/10/11 16:12:36 BinaryOp !=
2025/10/11 16:12:36 Typ error
2025/10/11 16:12:36 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:36 Then
2025/10/11 16:12:36 Val errorln func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val &{0 STRING "[WARN] an error"} *ast.BasicLit
2025/10/11 16:12:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(args ...any) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("[WARN] an error"), any
2025/10/11 16:12:36 Val fatal func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val Concat func(parts ...string) string
2025/10/11 16:12:36 Val &{0 STRING "open file failed: "} *ast.BasicLit
2025/10/11 16:12:36 Val err error
2025/10/11 16:12:36 Member string 2 // error
2025/10/11 16:12:36 Member error 2 // error
2025/10/11 16:12:36 Call 0 0 // func() string
2025/10/11 16:12:36 ==> MatchFuncCall func() string args: 0 flags: 0
2025/10/11 16:12:36 Call 2 0 // func(parts ...string) string
2025/10/11 16:12:36 ==> MatchFuncCall func(parts ...string) string args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("open file failed: "), string
2025/10/11 16:12:36 ==> MatchType string, string
2025/10/11 16:12:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(args ...any) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType string, any
2025/10/11 16:12:36 End // If
2025/10/11 16:12:36 Val f *os.File
2025/10/11 16:12:36 Member close 1 // *os.File
2025/10/11 16:12:36 Call 0 0 // func() error
2025/10/11 16:12:36 ==> MatchFuncCall func() error args: 0 flags: 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/implicit-cast-2439
2025/10/11 16:12:36 Parsing /app/cl/_testgop/implicit-cast-2439
2025/10/11 16:12:36 ==> Preload type BasePtr
2025/10/11 16:12:36 ==> Preload type Base
2025/10/11 16:12:36 ==> Preload func Walk
2025/10/11 16:12:36 ==> Preload func WalkPtr
2025/10/11 16:12:36 ==> Preload type T
2025/10/11 16:12:36 ==> Preload func f
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load > NewType BasePtr
2025/10/11 16:12:36 NewType BasePtr
2025/10/11 16:12:36 ==> Load > InitType BasePtr
2025/10/11 16:12:36 InitType BasePtr struct{}
2025/10/11 16:12:36 ==> Load > NewType Base
2025/10/11 16:12:36 NewType Base
2025/10/11 16:12:36 ==> Load > InitType Base
2025/10/11 16:12:36 ==> LookupParent BasePtr => type github.com/goplus/xgo/cl.BasePtr struct{}
2025/10/11 16:12:36 InitType Base struct{*github.com/goplus/xgo/cl.BasePtr}
2025/10/11 16:12:36 ==> Load func Walk
2025/10/11 16:12:36 ==> LookupParent Base => type github.com/goplus/xgo/cl.Base struct{*github.com/goplus/xgo/cl.BasePtr}
2025/10/11 16:12:36 NewFunc Walk func(p *github.com/goplus/xgo/cl.Base)
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func WalkPtr
2025/10/11 16:12:36 ==> LookupParent BasePtr => type github.com/goplus/xgo/cl.BasePtr struct{}
2025/10/11 16:12:36 NewFunc WalkPtr func(p *github.com/goplus/xgo/cl.BasePtr)
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load > NewType T
2025/10/11 16:12:36 NewType T
2025/10/11 16:12:36 ==> Load > InitType T
2025/10/11 16:12:36 ==> LookupParent Base => type github.com/goplus/xgo/cl.Base struct{*github.com/goplus/xgo/cl.BasePtr}
2025/10/11 16:12:36 InitType T struct{github.com/goplus/xgo/cl.Base}
2025/10/11 16:12:36 ==> Load func f
2025/10/11 16:12:36 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{github.com/goplus/xgo/cl.Base}
2025/10/11 16:12:36 NewFunc f func() *github.com/goplus/xgo/cl.T
2025/10/11 16:12:36 StructLit github.com/goplus/xgo/cl.T 0 false
2025/10/11 16:12:36 UnaryOp & flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:36 Return 1
2025/10/11 16:12:36 ==> MatchType *github.com/goplus/xgo/cl.T, *github.com/goplus/xgo/cl.T
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val Walk func(p *github.com/goplus/xgo/cl.Base)
2025/10/11 16:12:36 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:36 Val T github.com/goplus/xgo/cl.T
2025/10/11 16:12:36 Val type github.com/goplus/xgo/cl.T struct{github.com/goplus/xgo/cl.Base} => Typ github.com/goplus/xgo/cl.T
2025/10/11 16:12:36 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:36 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:36 Call 1 0 // func(p *github.com/goplus/xgo/cl.Base)
2025/10/11 16:12:36 ==> MatchFuncCall func(p *github.com/goplus/xgo/cl.Base) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType *github.com/goplus/xgo/cl.T, *github.com/goplus/xgo/cl.Base
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Base
2025/10/11 16:12:36 Val WalkPtr func(p *github.com/goplus/xgo/cl.BasePtr)
2025/10/11 16:12:36 Val f func() *github.com/goplus/xgo/cl.T
2025/10/11 16:12:36 Call 0 0 // func() *github.com/goplus/xgo/cl.T
2025/10/11 16:12:36 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.T args: 0 flags: 0
2025/10/11 16:12:36 Call 1 0 // func(p *github.com/goplus/xgo/cl.BasePtr)
2025/10/11 16:12:36 ==> MatchFuncCall func(p *github.com/goplus/xgo/cl.BasePtr) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType *github.com/goplus/xgo/cl.T, *github.com/goplus/xgo/cl.BasePtr
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.BasePtr
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/kwargs1
2025/10/11 16:12:36 Parsing /app/cl/_testgop/kwargs1
2025/10/11 16:12:36 ==> Preload type Options
2025/10/11 16:12:36 ==> Preload func PlaySound
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load > NewType Options
2025/10/11 16:12:36 NewType Options
2025/10/11 16:12:36 ==> Load > InitType Options
2025/10/11 16:12:36 InitType Options struct{Loop bool; async bool}
2025/10/11 16:12:36 ==> Load func PlaySound
2025/10/11 16:12:36 ==> LookupParent Options => type github.com/goplus/xgo/cl.Options struct{Loop bool; async bool}
2025/10/11 16:12:36 NewFunc PlaySound func(path string, options *github.com/goplus/xgo/cl.Options)
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val PlaySound func(path string, options *github.com/goplus/xgo/cl.Options)
2025/10/11 16:12:36 Val &{0 STRING "1.mp3"} *ast.BasicLit
2025/10/11 16:12:36 Val 0 int
2025/10/11 16:12:36 Val true untyped bool
2025/10/11 16:12:36 StructLit github.com/goplus/xgo/cl.Options 2 true
2025/10/11 16:12:36 UnaryOp & flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:36 Call 2 0 // func(path string, options *github.com/goplus/xgo/cl.Options)
2025/10/11 16:12:36 ==> MatchFuncCall func(path string, options *github.com/goplus/xgo/cl.Options) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("1.mp3"), string
2025/10/11 16:12:36 ==> MatchType *github.com/goplus/xgo/cl.Options, *github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 Val PlaySound func(path string, options *github.com/goplus/xgo/cl.Options)
2025/10/11 16:12:36 Val &{0 STRING "2.mp3"} *ast.BasicLit
2025/10/11 16:12:36 Val 0 int
2025/10/11 16:12:36 Val false untyped bool
2025/10/11 16:12:36 Val 1 int
2025/10/11 16:12:36 Val true untyped bool
2025/10/11 16:12:36 StructLit github.com/goplus/xgo/cl.Options 4 true
2025/10/11 16:12:36 UnaryOp & flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:36 Call 2 0 // func(path string, options *github.com/goplus/xgo/cl.Options)
2025/10/11 16:12:36 ==> MatchFuncCall func(path string, options *github.com/goplus/xgo/cl.Options) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("2.mp3"), string
2025/10/11 16:12:36 ==> MatchType *github.com/goplus/xgo/cl.Options, *github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/kwargs2
2025/10/11 16:12:36 Parsing /app/cl/_testgop/kwargs2
2025/10/11 16:12:36 ==> Preload type Options
2025/10/11 16:12:36 ==> Preload func PlaySound
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load > NewType Options
2025/10/11 16:12:36 NewType Options
2025/10/11 16:12:36 ==> Load > InitType Options
2025/10/11 16:12:36 InitType Options struct{Loop bool; async bool}
2025/10/11 16:12:36 ==> Load func PlaySound
2025/10/11 16:12:36 ==> LookupParent Options => type github.com/goplus/xgo/cl.Options struct{Loop bool; async bool}
2025/10/11 16:12:36 NewFunc PlaySound func(path string, options github.com/goplus/xgo/cl.Options)
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val PlaySound func(path string, options github.com/goplus/xgo/cl.Options)
2025/10/11 16:12:36 Val &{0 STRING "1.mp3"} *ast.BasicLit
2025/10/11 16:12:36 Val 0 int
2025/10/11 16:12:36 Val true untyped bool
2025/10/11 16:12:36 StructLit github.com/goplus/xgo/cl.Options 2 true
2025/10/11 16:12:36 Call 2 0 // func(path string, options github.com/goplus/xgo/cl.Options)
2025/10/11 16:12:36 ==> MatchFuncCall func(path string, options github.com/goplus/xgo/cl.Options) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("1.mp3"), string
2025/10/11 16:12:36 ==> MatchType github.com/goplus/xgo/cl.Options, github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 Val PlaySound func(path string, options github.com/goplus/xgo/cl.Options)
2025/10/11 16:12:36 Val &{0 STRING "2.mp3"} *ast.BasicLit
2025/10/11 16:12:36 Val 0 int
2025/10/11 16:12:36 Val false untyped bool
2025/10/11 16:12:36 Val 1 int
2025/10/11 16:12:36 Val true untyped bool
2025/10/11 16:12:36 StructLit github.com/goplus/xgo/cl.Options 4 true
2025/10/11 16:12:36 Call 2 0 // func(path string, options github.com/goplus/xgo/cl.Options)
2025/10/11 16:12:36 ==> MatchFuncCall func(path string, options github.com/goplus/xgo/cl.Options) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("2.mp3"), string
2025/10/11 16:12:36 ==> MatchType github.com/goplus/xgo/cl.Options, github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/kwargs3
2025/10/11 16:12:36 Parsing /app/cl/_testgop/kwargs3
2025/10/11 16:12:36 ==> Preload type Options
2025/10/11 16:12:36 ==> Preload func PlaySound
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load > NewType Options
2025/10/11 16:12:36 NewType Options
2025/10/11 16:12:36 ==> Load > InitType Options
2025/10/11 16:12:36 InitType Options map[string]bool
2025/10/11 16:12:36 ==> Load func PlaySound
2025/10/11 16:12:36 ==> LookupParent Options => type github.com/goplus/xgo/cl.Options map[string]bool
2025/10/11 16:12:36 NewFunc PlaySound func(options github.com/goplus/xgo/cl.Options, paths ...string)
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val PlaySound func(options github.com/goplus/xgo/cl.Options, paths ...string)
2025/10/11 16:12:36 Val &{0 STRING "loop"} *ast.BasicLit
2025/10/11 16:12:36 Val false untyped bool
2025/10/11 16:12:36 MapLit github.com/goplus/xgo/cl.Options 2
2025/10/11 16:12:36 Val &{0 STRING "1.mp3"} *ast.BasicLit
2025/10/11 16:12:36 Val &{0 STRING "foo.wav"} *ast.BasicLit
2025/10/11 16:12:36 Call 3 0 // func(options github.com/goplus/xgo/cl.Options, paths ...string)
2025/10/11 16:12:36 ==> MatchFuncCall func(options github.com/goplus/xgo/cl.Options, paths ...string) args: 3 flags: 0
2025/10/11 16:12:36 ==> MatchType github.com/goplus/xgo/cl.Options, github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> MatchType untyped string ("1.mp3"), string
2025/10/11 16:12:36 ==> MatchType untyped string ("foo.wav"), string
2025/10/11 16:12:36 Val PlaySound func(options github.com/goplus/xgo/cl.Options, paths ...string)
2025/10/11 16:12:36 Val &{0 STRING "loop"} *ast.BasicLit
2025/10/11 16:12:36 Val true untyped bool
2025/10/11 16:12:36 Val &{0 STRING "async"} *ast.BasicLit
2025/10/11 16:12:36 Val true untyped bool
2025/10/11 16:12:36 MapLit github.com/goplus/xgo/cl.Options 4
2025/10/11 16:12:36 Val &{0 STRING "2.mp3"} *ast.BasicLit
2025/10/11 16:12:36 Call 2 0 // func(options github.com/goplus/xgo/cl.Options, paths ...string)
2025/10/11 16:12:36 ==> MatchFuncCall func(options github.com/goplus/xgo/cl.Options, paths ...string) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType github.com/goplus/xgo/cl.Options, github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/10/11 16:12:36 ==> MatchType untyped string ("2.mp3"), string
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/kwargs4
2025/10/11 16:12:36 Parsing /app/cl/_testgop/kwargs4
2025/10/11 16:12:36 ==> Preload func PlaySound
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func PlaySound
2025/10/11 16:12:36 NewFunc PlaySound func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options)
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val PlaySound func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options)
2025/10/11 16:12:36 Val &{0 STRING "1.mp3"} *ast.BasicLit
2025/10/11 16:12:36 Val 0 int
2025/10/11 16:12:36 Val true untyped bool
2025/10/11 16:12:36 StructLit github.com/goplus/xgo/cl/internal/testutil.Options 2 true
2025/10/11 16:12:36 UnaryOp & flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:36 Call 2 0 // func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options)
2025/10/11 16:12:36 ==> MatchFuncCall func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("1.mp3"), string
2025/10/11 16:12:36 ==> MatchType *github.com/goplus/xgo/cl/internal/testutil.Options, *github.com/goplus/xgo/cl/internal/testutil.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/testutil.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/testutil.Options
2025/10/11 16:12:36 Val PlaySound func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options)
2025/10/11 16:12:36 Val &{0 STRING "2.mp3"} *ast.BasicLit
2025/10/11 16:12:36 Val 0 int
2025/10/11 16:12:36 Val false untyped bool
2025/10/11 16:12:36 Val 1 int
2025/10/11 16:12:36 Val true untyped bool
2025/10/11 16:12:36 StructLit github.com/goplus/xgo/cl/internal/testutil.Options 4 true
2025/10/11 16:12:36 UnaryOp & flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:36 Call 2 0 // func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options)
2025/10/11 16:12:36 ==> MatchFuncCall func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("2.mp3"), string
2025/10/11 16:12:36 ==> MatchType *github.com/goplus/xgo/cl/internal/testutil.Options, *github.com/goplus/xgo/cl/internal/testutil.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/testutil.Options
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/testutil.Options
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/optparam
2025/10/11 16:12:36 Parsing /app/cl/_testgop/optparam
2025/10/11 16:12:36 ==> Preload func basic
2025/10/11 16:12:36 ==> Preload func multiple
2025/10/11 16:12:36 ==> Preload func allOptional
2025/10/11 16:12:36 ==> Preload func withVariadic
2025/10/11 16:12:36 ==> Preload type Server
2025/10/11 16:12:36 ==> Preload method Server.handle
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func basic
2025/10/11 16:12:36 NewFunc basic func(a int, b int)
2025/10/11 16:12:36 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val a int
2025/10/11 16:12:36 Val b int
2025/10/11 16:12:36 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType int, any
2025/10/11 16:12:36 ==> MatchType int, any
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func multiple
2025/10/11 16:12:36 NewFunc multiple func(name string, age int, active bool)
2025/10/11 16:12:36 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val name string
2025/10/11 16:12:36 Val age int
2025/10/11 16:12:36 Val active bool
2025/10/11 16:12:36 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 3 flags: 0
2025/10/11 16:12:36 ==> MatchType string, any
2025/10/11 16:12:36 ==> MatchType int, any
2025/10/11 16:12:36 ==> MatchType bool, any
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func allOptional
2025/10/11 16:12:36 NewFunc allOptional func(x int, y string)
2025/10/11 16:12:36 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val x int
2025/10/11 16:12:36 Val y string
2025/10/11 16:12:36 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType int, any
2025/10/11 16:12:36 ==> MatchType string, any
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func withVariadic
2025/10/11 16:12:36 NewFunc withVariadic func(a int, b ...string)
2025/10/11 16:12:36 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val a int
2025/10/11 16:12:36 Val b []string
2025/10/11 16:12:36 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType int, any
2025/10/11 16:12:36 ==> MatchType []string, any
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load > NewType Server
2025/10/11 16:12:36 NewType Server
2025/10/11 16:12:36 ==> Load > InitType Server
2025/10/11 16:12:36 InitType Server struct{}
2025/10/11 16:12:36 ==> LookupParent Server => type github.com/goplus/xgo/cl.Server struct{}
2025/10/11 16:12:36 ==> Load method *github.com/goplus/xgo/cl.Server.handle
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val basic func(a int, b int)
2025/10/11 16:12:36 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:36 Val &{0 INT 20} *ast.BasicLit
2025/10/11 16:12:36 Call 2 0 // func(a int, b int)
2025/10/11 16:12:36 ==> MatchFuncCall func(a int, b int) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped int (10), int
2025/10/11 16:12:36 ==> MatchType untyped int (20), int
2025/10/11 16:12:36 Val multiple func(name string, age int, active bool)
2025/10/11 16:12:36 Val &{0 STRING "Alice"} *ast.BasicLit
2025/10/11 16:12:36 Val &{0 INT 30} *ast.BasicLit
2025/10/11 16:12:36 Val true untyped bool
2025/10/11 16:12:36 Call 3 0 // func(name string, age int, active bool)
2025/10/11 16:12:36 ==> MatchFuncCall func(name string, age int, active bool) args: 3 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("Alice"), string
2025/10/11 16:12:36 ==> MatchType untyped int (30), int
2025/10/11 16:12:36 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:36 Val allOptional func(x int, y string)
2025/10/11 16:12:36 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:36 Val &{0 STRING "test"} *ast.BasicLit
2025/10/11 16:12:36 Call 2 0 // func(x int, y string)
2025/10/11 16:12:36 ==> MatchFuncCall func(x int, y string) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped int (100), int
2025/10/11 16:12:36 ==> MatchType untyped string ("test"), string
2025/10/11 16:12:36 Val withVariadic func(a int, b ...string)
2025/10/11 16:12:36 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:36 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:36 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:12:36 Call 3 0 // func(a int, b ...string)
2025/10/11 16:12:36 ==> MatchFuncCall func(a int, b ...string) args: 3 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped int (5), int
2025/10/11 16:12:36 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:36 ==> MatchType untyped string ("world"), string
2025/10/11 16:12:36 DefineVarStart [s]
2025/10/11 16:12:36 ==> LookupParent Server => type github.com/goplus/xgo/cl.Server struct{}
2025/10/11 16:12:36 StructLit github.com/goplus/xgo/cl.Server 0 false
2025/10/11 16:12:36 EndInit 1
2025/10/11 16:12:36 Val s github.com/goplus/xgo/cl.Server
2025/10/11 16:12:36 Member handle 1 // github.com/goplus/xgo/cl.Server
2025/10/11 16:12:36 Val &{0 STRING "request"} *ast.BasicLit
2025/10/11 16:12:36 Val &{0 INT 42} *ast.BasicLit
2025/10/11 16:12:36 Call 2 0 // func(req string, opts int)
2025/10/11 16:12:36 ==> MatchFuncCall func(req string, opts int) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("request"), string
2025/10/11 16:12:36 ==> MatchType untyped int (42), int
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 NewFunc handle (*github.com/goplus/xgo/cl.Server) func(req string, opts int)
2025/10/11 16:12:36 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val req string
2025/10/11 16:12:36 Val opts int
2025/10/11 16:12:36 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType string, any
2025/10/11 16:12:36 ==> MatchType int, any
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/optparam2
2025/10/11 16:12:36 Parsing /app/cl/_testgop/optparam2
2025/10/11 16:12:36 ==> Preload func returnValue
2025/10/11 16:12:36 ==> Preload func useInExpression
2025/10/11 16:12:36 ==> Preload func simpleNested
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func returnValue
2025/10/11 16:12:36 NewFunc returnValue func(x int) int
2025/10/11 16:12:36 Val x int
2025/10/11 16:12:36 Return 1
2025/10/11 16:12:36 ==> MatchType int, int
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func useInExpression
2025/10/11 16:12:36 NewFunc useInExpression func(a int, b int) int
2025/10/11 16:12:36 DefineVarStart [result]
2025/10/11 16:12:36 Val a int
2025/10/11 16:12:36 Val b int
2025/10/11 16:12:36 BinaryOp +
2025/10/11 16:12:36 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:36 EndInit 1
2025/10/11 16:12:36 Val result int
2025/10/11 16:12:36 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:36 BinaryOp *
2025/10/11 16:12:36 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:36 Return 1
2025/10/11 16:12:36 ==> MatchType int, int
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func simpleNested
2025/10/11 16:12:36 NewFunc simpleNested func(outer int)
2025/10/11 16:12:36 DefineVarStart [f]
2025/10/11 16:12:36 NewClosure func()
2025/10/11 16:12:36 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val outer int
2025/10/11 16:12:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType int, any
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 EndInit 1
2025/10/11 16:12:36 Val f func()
2025/10/11 16:12:36 Call 0 0 // func()
2025/10/11 16:12:36 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val returnValue func(x int) int
2025/10/11 16:12:36 Val &{0 INT 42} *ast.BasicLit
2025/10/11 16:12:36 Call 1 0 // func(x int) int
2025/10/11 16:12:36 ==> MatchFuncCall func(x int) int args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped int (42), int
2025/10/11 16:12:36 Val useInExpression func(a int, b int) int
2025/10/11 16:12:36 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:36 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:36 Call 2 0 // func(a int, b int) int
2025/10/11 16:12:36 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped int (10), int
2025/10/11 16:12:36 ==> MatchType untyped int (5), int
2025/10/11 16:12:36 Val simpleNested func(outer int)
2025/10/11 16:12:36 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:36 Call 1 0 // func(outer int)
2025/10/11 16:12:36 ==> MatchFuncCall func(outer int) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped int (100), int
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/rangeexpr
2025/10/11 16:12:36 Parsing /app/cl/_testgop/rangeexpr
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:36 ForRange [_ x]
2025/10/11 16:12:36 Val newRange func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:36 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:36 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:36 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(start int, end int, step int) *github.com/qiniu/x/xgo.IntRange args: 3 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped int (0), int
2025/10/11 16:12:36 ==> MatchType untyped int (3), int
2025/10/11 16:12:36 ==> MatchType untyped int (1), int
2025/10/11 16:12:36 RangeAssignThen
2025/10/11 16:12:36 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:36 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:36 Val x int
2025/10/11 16:12:36 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 ==> MatchType []int, unboundType{typ: <nil>}
2025/10/11 16:12:36 End // ForRange
2025/10/11 16:12:36 Member Gop_Enum 0 // *github.com/qiniu/x/xgo.IntRange
2025/10/11 16:12:36 Call 0 0 // func() *github.com/qiniu/x/xgo.intRangeIter
2025/10/11 16:12:36 ==> MatchFuncCall func() *github.com/qiniu/x/xgo.intRangeIter args: 0 flags: 0
2025/10/11 16:12:36 Return 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 Call 0 0 // func() (_xgo_ret []int)
2025/10/11 16:12:36 ==> MatchFuncCall func() (_xgo_ret []int) args: 0 flags: 0
2025/10/11 16:12:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType []int, any
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/repeatuntil
2025/10/11 16:12:36 Parsing /app/cl/_testgop/repeatuntil
2025/10/11 16:12:36 ==> Preload func RepeatUntil
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func RepeatUntil
2025/10/11 16:12:36 NewFunc RepeatUntil func(cond func() bool, body func())
2025/10/11 16:12:36 For
2025/10/11 16:12:36 Val cond func() bool
2025/10/11 16:12:36 Call 0 0 // func() bool
2025/10/11 16:12:36 ==> MatchFuncCall func() bool args: 0 flags: 0
2025/10/11 16:12:36 UnaryOp ! flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 Then
2025/10/11 16:12:36 Val body func()
2025/10/11 16:12:36 Call 0 0 // func()
2025/10/11 16:12:36 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:36 End // For
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 DefineVarStart [x]
2025/10/11 16:12:36 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:36 EndInit 1
2025/10/11 16:12:36 Val RepeatUntil func(cond func() bool, body func())
2025/10/11 16:12:36 Val x int
2025/10/11 16:12:36 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:36 BinaryOp >=
2025/10/11 16:12:36 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:36 NewClosure func() bool
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 NewClosure func()
2025/10/11 16:12:36 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val x int
2025/10/11 16:12:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType int, any
2025/10/11 16:12:36 VarRef x int
2025/10/11 16:12:36 IncDec ++
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 Call 2 0 // func(cond func() bool, body func())
2025/10/11 16:12:36 ==> MatchFuncCall func(cond func() bool, body func()) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType func() bool, func() bool
2025/10/11 16:12:36 ==> MatchType func(), func()
2025/10/11 16:12:36 Val RepeatUntil func(cond func() bool, body func())
2025/10/11 16:12:36 NewClosure func() bool
2025/10/11 16:12:36 Val false untyped bool
2025/10/11 16:12:36 Return 1
2025/10/11 16:12:36 ==> MatchType untyped bool (false), bool
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 NewClosure func()
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 Call 2 0 // func(cond func() bool, body func())
2025/10/11 16:12:36 ==> MatchFuncCall func(cond func() bool, body func()) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType func() bool, func() bool
2025/10/11 16:12:36 ==> MatchType func(), func()
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
=== RUN   TestTestgop/unit
2025/10/11 16:12:36 Parsing /app/cl/_testgop/unit
2025/10/11 16:12:36 ==> Preload func Wait
2025/10/11 16:12:36 ==> Preload func Step
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func Wait
2025/10/11 16:12:36 NewFunc Wait func(time.Duration)
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func Step
2025/10/11 16:12:36 NewFunc Step func(github.com/goplus/xgo/cl/internal/unit.Distance)
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val Wait func(time.Duration)
2025/10/11 16:12:36 ValWithUnit 0.5 time.Duration s
2025/10/11 16:12:36 Val &{0xc000a1a020 time.Duration 500 0xc000a8ff40} *internal.Elem
2025/10/11 16:12:36 Call 1 0 // func(time.Duration)
2025/10/11 16:12:36 ==> MatchFuncCall func(time.Duration) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType time.Duration (500), time.Duration
2025/10/11 16:12:36 Val Wait func(time.Duration)
2025/10/11 16:12:36 ValWithUnit 1 time.Duration m
2025/10/11 16:12:36 Val &{0xc000a1a300 time.Duration 60000000000 0xc000a1a0e0} *internal.Elem
2025/10/11 16:12:36 Call 1 0 // func(time.Duration)
2025/10/11 16:12:36 ==> MatchFuncCall func(time.Duration) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType time.Duration (60000000000), time.Duration
2025/10/11 16:12:36 Val Step func(github.com/goplus/xgo/cl/internal/unit.Distance)
2025/10/11 16:12:36 ValWithUnit 1 github.com/goplus/xgo/cl/internal/unit.Distance m
2025/10/11 16:12:36 Val &{0xc000a1a3a0 github.com/goplus/xgo/cl/internal/unit.Distance 1000 0xc000a1a380} *internal.Elem
2025/10/11 16:12:36 Call 1 0 // func(github.com/goplus/xgo/cl/internal/unit.Distance)
2025/10/11 16:12:36 ==> MatchFuncCall func(github.com/goplus/xgo/cl/internal/unit.Distance) args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType github.com/goplus/xgo/cl/internal/unit.Distance (1000), github.com/goplus/xgo/cl/internal/unit.Distance
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/unit.Distance
2025/10/11 16:12:36 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/unit.Distance
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
--- PASS: TestTestgop (9.36s)
    --- PASS: TestTestgop/append1 (0.00s)
    --- PASS: TestTestgop/append2 (0.00s)
    --- PASS: TestTestgop/cap (0.00s)
    --- PASS: TestTestgop/domaintext-html (2.64s)
    --- PASS: TestTestgop/domaintext-huh (0.05s)
    --- PASS: TestTestgop/domaintext-json (0.22s)
    --- PASS: TestTestgop/domaintext-md (5.45s)
    --- PASS: TestTestgop/domaintext-regexp (0.16s)
    --- PASS: TestTestgop/domaintext-tpl (0.47s)
    --- PASS: TestTestgop/domaintpl (0.00s)
    --- PASS: TestTestgop/enumlines-rdr (0.13s)
    --- PASS: TestTestgop/enumlines-stdin (0.00s)
    --- PASS: TestTestgop/errwrap1 (0.00s)
    --- PASS: TestTestgop/errwrap2 (0.00s)
    --- PASS: TestTestgop/fatal (0.00s)
    --- PASS: TestTestgop/implicit-cast-2439 (0.00s)
    --- PASS: TestTestgop/kwargs1 (0.00s)
    --- PASS: TestTestgop/kwargs2 (0.00s)
    --- PASS: TestTestgop/kwargs3 (0.00s)
    --- PASS: TestTestgop/kwargs4 (0.03s)
    --- PASS: TestTestgop/optparam (0.00s)
    --- PASS: TestTestgop/optparam2 (0.00s)
    --- PASS: TestTestgop/rangeexpr (0.00s)
    --- PASS: TestTestgop/repeatuntil (0.00s)
    --- PASS: TestTestgop/unit (0.18s)
=== RUN   TestTestc
=== RUN   TestTestc/hello
2025/10/11 16:12:36 Parsing /app/cl/_testc/hello
2025/10/11 16:12:36 PkgHash: unexpected package - github.com/goplus/lib/c
2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 Val Printf func(format *int8, __llgo_va_list ...any) int32
2025/10/11 16:12:36 Val Str func(string) *int8
2025/10/11 16:12:36 Val Hello, world!
 string
2025/10/11 16:12:36 Call 1 0 // func(string) *int8
2025/10/11 16:12:36 ==> MatchFuncCall func(string) *int8 args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("Hello, world!\n"), string
2025/10/11 16:12:36 Call 1 0 // func(format *int8, __llgo_va_list ...any) int32
2025/10/11 16:12:36 ==> MatchFuncCall func(format *int8, __llgo_va_list ...any) int32 args: 1 flags: 0
2025/10/11 16:12:36 ==> MatchType *int8, *int8
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 ==> ASTFile
--- PASS: TestTestc (0.03s)
    --- PASS: TestTestc/hello (0.03s)
=== RUN   TestTestpy
=== RUN   TestTestpy/hello
2025/10/11 16:12:36 Parsing /app/cl/_testpy/hello
2025/10/11 16:12:37 PkgHash: unexpected package - github.com/goplus/lib/py/std
2025/10/11 16:12:37 PkgHash: unexpected package - github.com/goplus/lib/c
2025/10/11 16:12:37 PkgHash: unexpected package - github.com/goplus/lib/py
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val Print func(__llgo_va_list ...interface{}) *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 PkgHash: unexpected package - github.com/goplus/lib/py
2025/10/11 16:12:37 PkgHash: unexpected package - github.com/goplus/lib/c
2025/10/11 16:12:37 Val Str func(s string) *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 Val Hello, World! string
2025/10/11 16:12:37 Call 1 0 // func(s string) *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 ==> MatchFuncCall func(s string) *github.com/goplus/lib/py.Object args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("Hello, World!"), string
2025/10/11 16:12:37 Call 1 0 // func(__llgo_va_list ...interface{}) *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 ==> MatchFuncCall func(__llgo_va_list ...interface{}) *github.com/goplus/lib/py.Object args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/lib/py.Object, interface{}
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
=== RUN   TestTestpy/pycall
2025/10/11 16:12:37 Parsing /app/cl/_testpy/pycall
2025/10/11 16:12:37 PkgHash: unexpected package - github.com/goplus/lib/py/math
2025/10/11 16:12:37 PkgHash: unexpected package - github.com/goplus/lib/c
2025/10/11 16:12:37 PkgHash: unexpected package - github.com/goplus/lib/py
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val Sqrt func(x *github.com/goplus/lib/py.Object) *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 Val Float func(v float64) *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(v float64) *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 ==> MatchFuncCall func(v float64) *github.com/goplus/lib/py.Object args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (2), float64
2025/10/11 16:12:37 Call 1 0 // func(x *github.com/goplus/lib/py.Object) *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 ==> MatchFuncCall func(x *github.com/goplus/lib/py.Object) *github.com/goplus/lib/py.Object args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/lib/py.Object, *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val Printf func(format *int8, __llgo_va_list ...any) int32
2025/10/11 16:12:37 Val Str func(string) *int8
2025/10/11 16:12:37 Val sqrt(2) = %f
 string
2025/10/11 16:12:37 Call 1 0 // func(string) *int8
2025/10/11 16:12:37 ==> MatchFuncCall func(string) *int8 args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("sqrt(2) = %f\n"), string
2025/10/11 16:12:37 Val x *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 Member float64 2 // *github.com/goplus/lib/py.Object
2025/10/11 16:12:37 Call 0 0 // func() float64
2025/10/11 16:12:37 ==> MatchFuncCall func() float64 args: 0 flags: 0
2025/10/11 16:12:37 Call 2 0 // func(format *int8, __llgo_va_list ...any) int32
2025/10/11 16:12:37 ==> MatchFuncCall func(format *int8, __llgo_va_list ...any) int32 args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType *int8, *int8
2025/10/11 16:12:37 ==> MatchType float64, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestTestpy (0.19s)
    --- PASS: TestTestpy/hello (0.13s)
    --- PASS: TestTestpy/pycall (0.06s)
=== RUN   TestArrowOp
2025/10/11 16:12:37 ==> Preload type foo
2025/10/11 16:12:37 ==> Preload method foo.->
2025/10/11 16:12:37 ==> Preload method foo.<>
2025/10/11 16:12:37 ==> Load > NewType foo
2025/10/11 16:12:37 NewType foo
2025/10/11 16:12:37 ==> Load > InitType foo
2025/10/11 16:12:37 InitType foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.->
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.<>
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 NewFunc Gop_PointTo (github.com/goplus/xgo/cl.foo) func(b github.com/goplus/xgo/cl.foo)
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a -> b"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a -> b"), any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc Gop_PointBi (github.com/goplus/xgo/cl.foo) func(b github.com/goplus/xgo/cl.foo)
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a <> b"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a <> b"), any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestArrowOp (0.00s)
=== RUN   TestMapLit
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func(map[string]string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val foo func(map[string]string)
2025/10/11 16:12:37 MapLit map[string]string 0
2025/10/11 16:12:37 Call 1 0 // func(map[string]string)
2025/10/11 16:12:37 ==> MatchFuncCall func(map[string]string) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType map[string]string, map[string]string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestMapLit (0.00s)
=== RUN   TestMayBuiltinDelete
2025/10/11 16:12:37 ==> Preload func Delete
2025/10/11 16:12:37 ==> Preload func Foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func Delete
2025/10/11 16:12:37 NewFunc Delete func(a int)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func Foo
2025/10/11 16:12:37 NewFunc Foo func(m map[string]int)
2025/10/11 16:12:37 Val Delete func(a int)
2025/10/11 16:12:37 Val m map[string]int
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(a int)
2025/10/11 16:12:37 ==> MatchFuncCall func(a int) args: 2 flags: 0
2025/10/11 16:12:37 Val delete TemplateSignature{func(m unboundProxyParam{typ: map[TemplateParamType{name: Key}]TemplateParamType{name: Elem}}, key TemplateParamType{name: Key})}
2025/10/11 16:12:37 Val m map[string]int
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // TemplateSignature{func(m unboundProxyParam{typ: map[TemplateParamType{name: Key}]TemplateParamType{name: Elem}}, key TemplateParamType{name: Key})}
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(m unboundProxyParam{typ: map[TemplateParamType{name: Key}]TemplateParamType{name: Elem}}, key TemplateParamType{name: Key})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType map[string]int, unboundProxyParam{typ: map[unboundFuncParam{typ: <nil>}]unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), unboundFuncParam{typ: string}
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val Delete func(a int)
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(a int)
2025/10/11 16:12:37 ==> MatchFuncCall func(a int) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (10), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestMayBuiltinDelete (0.00s)
=== RUN   TestVargCommand
2025/10/11 16:12:37 ==> Preload type foo
2025/10/11 16:12:37 ==> Preload method foo.Ls
2025/10/11 16:12:37 ==> Preload var [f]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType foo
2025/10/11 16:12:37 NewType foo
2025/10/11 16:12:37 ==> Load > InitType foo
2025/10/11 16:12:37 InitType foo int
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo int
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.Ls
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo int
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.foo [f]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [f]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val f github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member ls 1 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Call 0 0 // func(args ...string)
2025/10/11 16:12:37 ==> MatchFuncCall func(args ...string) args: 0 flags: 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc Ls (github.com/goplus/xgo/cl.foo) func(args ...string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestVargCommand (0.00s)
=== RUN   TestCommandInPkg
2025/10/11 16:12:37 ==> Preload func Ls
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func Ls
2025/10/11 16:12:37 NewFunc Ls func(args ...string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val Ls func(args ...string)
2025/10/11 16:12:37 Call 0 0 // func(args ...string)
2025/10/11 16:12:37 ==> MatchFuncCall func(args ...string) args: 0 flags: 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestCommandInPkg (0.00s)
=== RUN   TestFuncAlias
2025/10/11 16:12:37 ==> Preload func Foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func Foo
2025/10/11 16:12:37 NewFunc Foo func(a ...int)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val Foo func(a ...int)
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(a ...int)
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...int) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 Val Foo func(a ...int)
2025/10/11 16:12:37 Call 0 0 // func(a ...int)
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...int) args: 0 flags: 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestFuncAlias (0.00s)
=== RUN   TestOverloadOp
2025/10/11 16:12:37 ==> Preload type foo
2025/10/11 16:12:37 ==> Preload method foo.+
2025/10/11 16:12:37 ==> Preload method foo.-
2025/10/11 16:12:37 ==> Preload func -
2025/10/11 16:12:37 ==> Preload func ++
2025/10/11 16:12:37 ==> Preload method foo.!=
2025/10/11 16:12:37 ==> Preload var [a b]
2025/10/11 16:12:37 ==> Preload var [c]
2025/10/11 16:12:37 ==> Preload var [d]
2025/10/11 16:12:37 ==> Preload var [e]
2025/10/11 16:12:37 ==> Load > NewType foo
2025/10/11 16:12:37 NewType foo
2025/10/11 16:12:37 ==> Load > InitType foo
2025/10/11 16:12:37 InitType foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.foo.+
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.-
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.!=
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load func -
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load func ++
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.foo [a b]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a b]
2025/10/11 16:12:37 ==> Load var <nil> [c]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [c]
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val b github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 BinaryOp -
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member Gop_Sub 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:37 ==> MatchFuncCall func(github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) github.com/goplus/xgo/cl.foo args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load var <nil> [d]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [d]
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 UnaryOp - flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func() args: 1 flags: 32
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load var <nil> [e]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [e]
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val b github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 BinaryOp !=
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member Gop_NE 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:37 ==> MatchFuncCall func(github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) bool args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 NewFunc Gop_Add (*github.com/goplus/xgo/cl.foo) func(b *github.com/goplus/xgo/cl.foo) *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a + b"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a + b"), any
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.foo 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc Gop_Sub (github.com/goplus/xgo/cl.foo) func(b github.com/goplus/xgo/cl.foo) github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a - b"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a - b"), any
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.foo 0 false
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc Gop_NE (github.com/goplus/xgo/cl.foo) func(b github.com/goplus/xgo/cl.foo) bool
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a!=b"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a!=b"), any
2025/10/11 16:12:37 Val true untyped bool
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc Gop_Neg (github.com/goplus/xgo/cl.foo) func()
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "-a"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("-a"), any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc Gop_Inc (github.com/goplus/xgo/cl.foo) func()
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a++"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a++"), any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverloadOp (0.00s)
=== RUN   TestOverloadOp2
2025/10/11 16:12:37 ==> Preload type foo
2025/10/11 16:12:37 ==> Preload method foo.mulInt
2025/10/11 16:12:37 ==> Preload method foo.mulFoo
2025/10/11 16:12:37 ==> Preload func intMulFoo
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [Gopo__foo__Gop_Mul]
2025/10/11 16:12:37 ==> Preload var [a b]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType foo
2025/10/11 16:12:37 NewType foo
2025/10/11 16:12:37 ==> Load > InitType foo
2025/10/11 16:12:37 InitType foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.mulInt
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.mulFoo
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load func intMulFoo
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 NewFunc intMulFoo func(a int, b github.com/goplus/xgo/cl.foo) (ret github.com/goplus/xgo/cl.foo)
2025/10/11 16:12:37 Return 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load const [Gopo__foo__Gop_Mul] <nil>
2025/10/11 16:12:37 NewConst [Gopo__foo__Gop_Mul] 0
2025/10/11 16:12:37 Val &{0 STRING ".mulInt,.mulFoo,intMulFoo"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> NewOverloadMethod foo Gop_Mul
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.foo [a b]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a b]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp *
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member Gop_Mul 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.foo, b int) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> MatchType untyped int (10), int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, any
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val b github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 BinaryOp *
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member Gop_Mul 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.foo, b int) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, int
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, any
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 BinaryOp *
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member Gop_Mul 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.foo, b int) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType untyped int (10), github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/goplus/xgo/cl.foo false
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType untyped int (10), github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/goplus/xgo/cl.foo false
2025/10/11 16:12:37 ==> MatchFuncCall func(a int, b github.com/goplus/xgo/cl.foo) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType untyped int (10), int
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc mulInt (github.com/goplus/xgo/cl.foo) func(b int) (ret github.com/goplus/xgo/cl.foo)
2025/10/11 16:12:37 Return 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc mulFoo (github.com/goplus/xgo/cl.foo) func(b github.com/goplus/xgo/cl.foo) (ret github.com/goplus/xgo/cl.foo)
2025/10/11 16:12:37 Return 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverloadOp2 (0.00s)
=== RUN   TestOverloadMethod
2025/10/11 16:12:37 ==> Preload type foo
2025/10/11 16:12:37 ==> Preload method foo.mulInt
2025/10/11 16:12:37 ==> Preload method foo.mulFoo
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [Gopo_foo_mul]
2025/10/11 16:12:37 ==> Preload var [a b]
2025/10/11 16:12:37 ==> Preload var [c]
2025/10/11 16:12:37 ==> Preload var [d]
2025/10/11 16:12:37 ==> Load > NewType foo
2025/10/11 16:12:37 NewType foo
2025/10/11 16:12:37 ==> Load > InitType foo
2025/10/11 16:12:37 InitType foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.foo.mulInt
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.foo.mulFoo
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load const [Gopo_foo_mul] <nil>
2025/10/11 16:12:37 NewConst [Gopo_foo_mul] 0
2025/10/11 16:12:37 Val &{0 STRING ".mulInt,.mulFoo"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> NewOverloadMethod foo mul
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.foo [a b]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a b]
2025/10/11 16:12:37 ==> Load var <nil> [c]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [c]
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member mul 1 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(b int) *github.com/goplus/xgo/cl.foo args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load var <nil> [d]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [d]
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member mul 1 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val c *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(b int) *github.com/goplus/xgo/cl.foo args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.foo, int
2025/10/11 16:12:37 ==> MatchFuncCall func(b *github.com/goplus/xgo/cl.foo) *github.com/goplus/xgo/cl.foo args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 NewFunc mulInt (*github.com/goplus/xgo/cl.foo) func(b int) *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "mulInt"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("mulInt"), any
2025/10/11 16:12:37 Val a *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc mulFoo (*github.com/goplus/xgo/cl.foo) func(b *github.com/goplus/xgo/cl.foo) *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "mulFoo"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("mulFoo"), any
2025/10/11 16:12:37 Val a *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverloadMethod (0.00s)
=== RUN   TestOverloadFunc
2025/10/11 16:12:37 ==> Preload func add__0
2025/10/11 16:12:37 ==> Preload func add__1
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func add__0
2025/10/11 16:12:37 NewFunc add__0 func(a int, b int) int
2025/10/11 16:12:37 Val a int
2025/10/11 16:12:37 Val b int
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func add__1
2025/10/11 16:12:37 NewFunc add__1 func(a string, b string) string
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Val b string
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType string, unboundFuncParam{typ: string}
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType string, string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> NewOverloadFunc add
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType untyped int (7), int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "World"} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("Hello"), int
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("Hello"), string
2025/10/11 16:12:37 ==> MatchType untyped string ("World"), string
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType string, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverloadFunc (0.00s)
=== RUN   TestOverloadFunc2
2025/10/11 16:12:37 ==> Preload func mulInt
2025/10/11 16:12:37 ==> Preload func mulFloat
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [Gopo_mul]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func mulInt
2025/10/11 16:12:37 NewFunc mulInt func(a int, b int) int
2025/10/11 16:12:37 Val a int
2025/10/11 16:12:37 Val b int
2025/10/11 16:12:37 BinaryOp *
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func mulFloat
2025/10/11 16:12:37 NewFunc mulFloat func(a float64, b float64) float64
2025/10/11 16:12:37 Val a float64
2025/10/11 16:12:37 Val b float64
2025/10/11 16:12:37 BinaryOp *
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType float64, float64
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load const [Gopo_mul] <nil>
2025/10/11 16:12:37 NewConst [Gopo_mul] 0
2025/10/11 16:12:37 Val &{0 STRING "mulInt,mulFloat"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> NewOverloadFunc mul
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val mul func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType untyped int (7), int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val mul func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (1.2), int
2025/10/11 16:12:37 ==> MatchFuncCall func(a float64, b float64) float64 args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (1.2), float64
2025/10/11 16:12:37 ==> MatchType untyped float (3.14), float64
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType float64, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverloadFunc2 (0.00s)
=== RUN   TestOverloadFunc3
2025/10/11 16:12:37 ==> Preload func addInt
2025/10/11 16:12:37 ==> Preload func addFloat
2025/10/11 16:12:37 ==> Preload func add__0
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [Gopo_add]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func add__0
2025/10/11 16:12:37 NewFunc add__0 func(a string, b string) string
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Val b string
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType string, unboundFuncParam{typ: string}
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType string, string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func addInt
2025/10/11 16:12:37 NewFunc addInt func(a int, b int) int
2025/10/11 16:12:37 Val a int
2025/10/11 16:12:37 Val b int
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func addFloat
2025/10/11 16:12:37 NewFunc addFloat func(a float64, b float64) float64
2025/10/11 16:12:37 Val a float64
2025/10/11 16:12:37 Val b float64
2025/10/11 16:12:37 BinaryOp *
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType float64, float64
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load const [Gopo_add] <nil>
2025/10/11 16:12:37 NewConst [Gopo_add] 0
2025/10/11 16:12:37 Val &{0 STRING ",addInt,addFloat"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> NewOverloadFunc add
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType untyped int (7), int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (1.2), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (1.2), int
2025/10/11 16:12:37 ==> MatchFuncCall func(a float64, b float64) float64 args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (1.2), float64
2025/10/11 16:12:37 ==> MatchType untyped float (3.14), float64
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType float64, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverloadFunc3 (0.00s)
=== RUN   TestOverload
2025/10/11 16:12:37 ==> Import github.com/goplus/xgo/cl/internal/overload/foo
2025/10/11 16:12:37 ==> NewOverloadMethod N OnKey
2025/10/11 16:12:37 ==> NewOverloadFunc OnKey
2025/10/11 16:12:37 ==> NewOverloadFunc Test
2025/10/11 16:12:37 ==> Preload type Mesh
2025/10/11 16:12:37 ==> Preload method Mesh.Name
2025/10/11 16:12:37 ==> Preload var [m1]
2025/10/11 16:12:37 ==> Preload var [m2]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType Mesh
2025/10/11 16:12:37 NewType Mesh
2025/10/11 16:12:37 ==> Load > InitType Mesh
2025/10/11 16:12:37 InitType Mesh struct{}
2025/10/11 16:12:37 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.Mesh.Name
2025/10/11 16:12:37 ==> Load var <nil> [m1]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [m1]
2025/10/11 16:12:37 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.Mesh 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load var <nil> [m2]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [m2]
2025/10/11 16:12:37 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.Mesh 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 NewClosure func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchType func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchType func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher), func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType untyped nil, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func() int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType func() int, int
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType untyped int (200), int
2025/10/11 16:12:37 DefineVarStart [n]
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl/internal/overload/foo.N 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 NewClosure func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchType func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchType func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher), func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType untyped nil, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func() int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType func() int, int
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType untyped int (200), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc Name (*github.com/goplus/xgo/cl.Mesh) func() string
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverload (0.06s)
=== RUN   TestMixedOverload
2025/10/11 16:12:37 ==> Preload type Mesh
2025/10/11 16:12:37 ==> Preload method Mesh.Name
2025/10/11 16:12:37 ==> Preload var [m1]
2025/10/11 16:12:37 ==> Preload var [m2]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload type Mesher
2025/10/11 16:12:37 ==> Preload type N
2025/10/11 16:12:37 ==> Preload method N.OnKey__0
2025/10/11 16:12:37 ==> Preload method N.OnKey__1
2025/10/11 16:12:37 ==> Preload method N.OnKey__2
2025/10/11 16:12:37 ==> Preload method N.OnKey__3
2025/10/11 16:12:37 ==> Preload method N.OnKey__4
2025/10/11 16:12:37 ==> Preload method N.OnKey__5
2025/10/11 16:12:37 ==> Preload method N.OnKey__6
2025/10/11 16:12:37 ==> Preload method N.OnKey__7
2025/10/11 16:12:37 ==> Preload method N.OnKey__8
2025/10/11 16:12:37 ==> Preload func OnKey__0
2025/10/11 16:12:37 ==> Preload func OnKey__1
2025/10/11 16:12:37 ==> Preload func OnKey__2
2025/10/11 16:12:37 ==> Preload func OnKey__3
2025/10/11 16:12:37 ==> Preload func OnKey__4
2025/10/11 16:12:37 ==> Preload func OnKey__5
2025/10/11 16:12:37 ==> Preload func OnKey__6
2025/10/11 16:12:37 ==> Preload func OnKey__7
2025/10/11 16:12:37 ==> Preload func OnKey__8
2025/10/11 16:12:37 ==> Preload func OnKey__9
2025/10/11 16:12:37 ==> Preload func OnKey__a
2025/10/11 16:12:37 ==> Load func OnKey__a
2025/10/11 16:12:37 ==> Load func OnKey__7
2025/10/11 16:12:37 ==> Load > NewType Mesher
2025/10/11 16:12:37 ==> Lookup (LoadSymbol) Mesher => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:37 ==> Load > InitType Mesher
2025/10/11 16:12:37 ==> Load func OnKey__1
2025/10/11 16:12:37 ==> Load func OnKey__2
2025/10/11 16:12:37 ==> Load func OnKey__4
2025/10/11 16:12:37 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/10/11 16:12:37 ==> Load func OnKey__5
2025/10/11 16:12:37 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/10/11 16:12:37 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/10/11 16:12:37 ==> Load func OnKey__0
2025/10/11 16:12:37 ==> Load func OnKey__3
2025/10/11 16:12:37 ==> Load func OnKey__6
2025/10/11 16:12:37 ==> Load func OnKey__8
2025/10/11 16:12:37 ==> Load > NewType N
2025/10/11 16:12:37 ==> Load > InitType N
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__0
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__1
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__2
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__3
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__4
2025/10/11 16:12:37 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__5
2025/10/11 16:12:37 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/10/11 16:12:37 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__6
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__7
2025/10/11 16:12:37 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__8
2025/10/11 16:12:37 ==> Load func OnKey__9
2025/10/11 16:12:37 ==> NewOverloadMethod N OnKey
2025/10/11 16:12:37 ==> NewOverloadFunc OnKey
2025/10/11 16:12:37 ==> Load > NewType Mesh
2025/10/11 16:12:37 NewType Mesh
2025/10/11 16:12:37 ==> Load > InitType Mesh
2025/10/11 16:12:37 InitType Mesh struct{}
2025/10/11 16:12:37 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.Mesh.Name
2025/10/11 16:12:37 ==> Load var <nil> [m1]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [m1]
2025/10/11 16:12:37 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.Mesh 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load var <nil> [m2]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [m2]
2025/10/11 16:12:37 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.Mesh 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 NewClosure func(key github.com/goplus/xgo/cl.Mesher)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchType func(key github.com/goplus/xgo/cl.Mesher), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchType func(key github.com/goplus/xgo/cl.Mesher), func(key github.com/goplus/xgo/cl.Mesher)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType untyped nil, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func() int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType func() int, int
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType untyped int (200), int
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func() string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func() string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func() string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func(x int) int
2025/10/11 16:12:37 Val x int
2025/10/11 16:12:37 Val x int
2025/10/11 16:12:37 BinaryOp *
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewClosure func(x int) int
2025/10/11 16:12:37 Val x int
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp *
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 4 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:37 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:37 ==> MatchType func(x int) int, func(x int) int
2025/10/11 16:12:37 ==> MatchType func(x int) int, func(x int) int
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func() string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 Call 5 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:37 ==> MatchType func() string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, v ...int) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:37 ==> MatchType func() string, string
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 Call 5 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:37 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:37 ==> MatchType untyped int (1), func(x int) int
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, v ...int) args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:37 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 ==> MatchType untyped int (2), int
2025/10/11 16:12:37 ==> MatchType untyped int (3), int
2025/10/11 16:12:37 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func() string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 3 false
2025/10/11 16:12:37 Call 3 1 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:37 ==> MatchType func() string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, v ...int) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:37 ==> MatchType func() string, string
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 3 false
2025/10/11 16:12:37 Call 3 1 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:37 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:37 ==> MatchType []int, []func(x int) int
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, b string, v ...int) args: 3 flags: 1
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:37 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:37 ==> MatchType []int, []int
2025/10/11 16:12:37 DefineVarStart [n]
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.N 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 NewClosure func(key github.com/goplus/xgo/cl.Mesher)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchType func(key github.com/goplus/xgo/cl.Mesher), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchType func(key github.com/goplus/xgo/cl.Mesher), func(key github.com/goplus/xgo/cl.Mesher)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []string 2 false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []string 1 false
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType untyped nil, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func() int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType func() int, int
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> MatchType untyped int (200), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc Name (*github.com/goplus/xgo/cl.Mesh) func() string
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestMixedOverload (0.01s)
=== RUN   TestMixedOverloadOp
2025/10/11 16:12:37 ==> Preload var [a b]
2025/10/11 16:12:37 ==> Preload var [c]
2025/10/11 16:12:37 ==> Preload var [d]
2025/10/11 16:12:37 ==> Preload var [e]
2025/10/11 16:12:37 ==> Preload type foo
2025/10/11 16:12:37 ==> Preload method foo.Gop_Add
2025/10/11 16:12:37 ==> Preload method foo.Gop_Sub
2025/10/11 16:12:37 ==> Preload method foo.Gop_NE
2025/10/11 16:12:37 ==> Preload method foo.Gop_Neg
2025/10/11 16:12:37 ==> Preload method foo.Gop_Inc
2025/10/11 16:12:37 ==> Load > NewType foo
2025/10/11 16:12:37 ==> Load > InitType foo
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Add
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.Gop_Sub
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.Gop_NE
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.Gop_Neg
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.Gop_Inc
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.foo [a b]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a b]
2025/10/11 16:12:37 ==> Load var <nil> [c]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [c]
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val b github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 BinaryOp -
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member Gop_Sub 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:37 ==> MatchFuncCall func(github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) github.com/goplus/xgo/cl.foo args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load var <nil> [d]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [d]
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 UnaryOp - flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.foo args: 1 flags: 32
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load var <nil> [e]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [e]
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val b github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 BinaryOp !=
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member Gop_NE 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:37 ==> MatchFuncCall func(github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) bool args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestMixedOverloadOp (0.00s)
=== RUN   TestMixedVector3
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload var [b]
2025/10/11 16:12:37 ==> Preload var [c]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload type Vector3
2025/10/11 16:12:37 ==> Preload method Vector3.Gop_Add__0
2025/10/11 16:12:37 ==> Preload method Vector3.Gop_Add__1
2025/10/11 16:12:37 ==> Preload method Vector3.Gop_Add__2
2025/10/11 16:12:37 ==> Preload method Vector3.Gop_AddAssign
2025/10/11 16:12:37 ==> Preload method Vector3.Gop_Rcast__0
2025/10/11 16:12:37 ==> Preload method Vector3.Gop_Rcast__1
2025/10/11 16:12:37 ==> Preload func Vector3_Cast__0
2025/10/11 16:12:37 ==> Preload func Vector3_Cast__1
2025/10/11 16:12:37 ==> Preload func Vector3_Init__0
2025/10/11 16:12:37 ==> Preload func Vector3_Init__1
2025/10/11 16:12:37 ==> Load func Vector3_Cast__0
2025/10/11 16:12:37 ==> Load > NewType Vector3
2025/10/11 16:12:37 ==> Lookup (LoadSymbol) Vector3 => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:37 ==> Load > InitType Vector3
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.Vector3.Gop_Add__0
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.Vector3.Gop_Add__1
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.Vector3.Gop_Add__2
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.Vector3.Gop_AddAssign
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.Vector3.Gop_Rcast__0
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.Vector3.Gop_Rcast__1
2025/10/11 16:12:37 ==> Load func Vector3_Cast__1
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> Load func Vector3_Init__0
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> Load func Vector3_Init__1
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> NewOverloadFunc Vector3_Init
2025/10/11 16:12:37 ==> NewOverloadMethod Vector3 Gop_Add
2025/10/11 16:12:37 ==> NewOverloadMethod Vector3 Gop_Rcast
2025/10/11 16:12:37 ==> NewOverloadFunc Vector3_Cast
2025/10/11 16:12:37 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.Vector3 [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 ==> Load var int [b]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [b]
2025/10/11 16:12:37 ==> Load var float64 [c]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [c]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 VarRef _
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Val b int
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Member Gop_Add 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n int) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 VarRef _
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Member Gop_Add 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n int) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 VarRef _
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Val c float64
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Member Gop_Add 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n int) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchType float64, int
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n float64) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchType float64, float64
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 VarRef _
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Member Gop_Add 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n int) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType untyped int (100), github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/goplus/xgo/cl.Vector3 true
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, int
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n float64) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType untyped int (100), github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/goplus/xgo/cl.Vector3 true
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, float64
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n github.com/goplus/xgo/cl.Vector3) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType untyped int (100), github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/goplus/xgo/cl.Vector3 true
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 VarRef _
2025/10/11 16:12:37 Val Vector3 github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Val type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64} => Typ github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Val b int
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: github.com/goplus/xgo/cl.Vector3} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 Typ github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Member Gop_Add 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n int) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, int
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n float64) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, float64
2025/10/11 16:12:37 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n github.com/goplus/xgo/cl.Vector3) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 VarRef _
2025/10/11 16:12:37 Val b int
2025/10/11 16:12:37 Val int int
2025/10/11 16:12:37 Val type int => Typ int
2025/10/11 16:12:37 Val a github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: int}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: int} args: 1 flags: 0
2025/10/11 16:12:37 Val &{a github.com/goplus/xgo/cl.Vector3 <nil> a} *internal.Elem
2025/10/11 16:12:37 Member Gop_Rcast__0 0 // github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 VarRef a github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Val b int
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall func(n github.com/goplus/xgo/cl.Vector3) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: github.com/goplus/xgo/cl.Vector3}, *github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchType int, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 ==> AssignableConv int github.com/goplus/xgo/cl.Vector3 true
2025/10/11 16:12:37 VarRef a github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 Val c float64
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall func(n github.com/goplus/xgo/cl.Vector3) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: github.com/goplus/xgo/cl.Vector3}, *github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchType float64, github.com/goplus/xgo/cl.Vector3
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType float64, int
2025/10/11 16:12:37 ==> MatchFuncCall func(x float64) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType float64, float64
2025/10/11 16:12:37 ==> AssignableConv float64 github.com/goplus/xgo/cl.Vector3 true
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestMixedVector3 (0.00s)
=== RUN   TestMixedInterfaceOverload
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload type N
2025/10/11 16:12:37 ==> Preload method N.OnKey__0
2025/10/11 16:12:37 ==> Preload method N.OnKey__1
2025/10/11 16:12:37 ==> Preload method N.OnKey__2
2025/10/11 16:12:37 ==> Preload method N.OnKey__3
2025/10/11 16:12:37 ==> Preload type I
2025/10/11 16:12:37 ==> Load > NewType N
2025/10/11 16:12:37 ==> Load > InitType N
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N[T interface{}] struct{v T}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N[T interface{}].OnKey__0
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N[T interface{}] struct{v T}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N[T interface{}].OnKey__1
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N[T interface{}] struct{v T}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N[T interface{}].OnKey__2
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N[T interface{}] struct{v T}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N[T interface{}].OnKey__3
2025/10/11 16:12:37 ==> Load > NewType I
2025/10/11 16:12:37 ==> Load > InitType I
2025/10/11 16:12:37 ==> NewOverloadMethod I OnKey
2025/10/11 16:12:37 ==> NewOverloadMethod N OnKey
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [n]
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N[T interface{}] struct{v T}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.N[int] 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N[int]
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N[int]
2025/10/11 16:12:37 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("1"), string
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 DefineVarStart [keys]
2025/10/11 16:12:37 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N[int]
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N[int]
2025/10/11 16:12:37 Val keys []string
2025/10/11 16:12:37 Val keys []string
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val key string
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType string, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N[int]
2025/10/11 16:12:37 Member onKey 1 // *github.com/goplus/xgo/cl.N[int]
2025/10/11 16:12:37 Val keys []string
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val keys []string
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(), func()
2025/10/11 16:12:37 ==> LookupParent I => type github.com/goplus/xgo/cl.I interface{OnKey__0(a string, fn func()); OnKey__1(a string, fn func(key string)); OnKey__2(a []string, fn func()); OnKey__3(a []string, fn func(key string))}
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.I [i]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [i]
2025/10/11 16:12:37 Val n *github.com/goplus/xgo/cl.N[int]
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.N[int], github.com/goplus/xgo/cl.I
2025/10/11 16:12:37 Val i github.com/goplus/xgo/cl.I
2025/10/11 16:12:37 Member onKey 1 // github.com/goplus/xgo/cl.I
2025/10/11 16:12:37 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val key string
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType string, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("1"), string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("1"), string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 Val i github.com/goplus/xgo/cl.I
2025/10/11 16:12:37 Member onKey 1 // github.com/goplus/xgo/cl.I
2025/10/11 16:12:37 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 NewClosure func(key string)
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val key string
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType string, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func()
2025/10/11 16:12:37 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType []string, []string
2025/10/11 16:12:37 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestMixedInterfaceOverload (0.00s)
=== RUN   TestMixedOverloadCommand
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload func Test__0
2025/10/11 16:12:37 ==> Preload func Test__1
2025/10/11 16:12:37 ==> Preload type N
2025/10/11 16:12:37 ==> Preload method N.Test__0
2025/10/11 16:12:37 ==> Preload method N.Test__1
2025/10/11 16:12:37 ==> Load > NewType N
2025/10/11 16:12:37 ==> Load > InitType N
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.Test__0
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.N.Test__1
2025/10/11 16:12:37 ==> Load func Test__0
2025/10/11 16:12:37 ==> Load func Test__1
2025/10/11 16:12:37 ==> NewOverloadMethod N Test
2025/10/11 16:12:37 ==> NewOverloadFunc Test
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:37 Val Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.N [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 Val n github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member test 1 // github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:37 Val n github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Member test 1 // github.com/goplus/xgo/cl.N
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestMixedOverloadCommand (0.00s)
=== RUN   TestOverloadNamed
2025/10/11 16:12:37 ==> Import github.com/goplus/xgo/cl/internal/overload/bar
2025/10/11 16:12:37 ==> NewOverloadFunc Gopt_Player_Gopx_OnCmd
2025/10/11 16:12:37 ==> NewTemplateRecvMethod Player Gopx_OnCmd
2025/10/11 16:12:37 ==> AliasMethod github.com/goplus/xgo/cl/internal/overload/bar.Player Gopx_OnCmd => OnCmd
2025/10/11 16:12:37 ==> NewOverloadFunc Gopx_Var_Cast
2025/10/11 16:12:37 ==> AliasFunc Gopx_Var_Cast => Var_Cast
2025/10/11 16:12:37 ==> NewOverloadNamed Var
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload var [b]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int] [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any] [b]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [b]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [c]
2025/10/11 16:12:37 Val Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val string string
2025/10/11 16:12:37 Val type string => Typ string
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/10/11 16:12:37 ==> MatchFuncCall func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:37 boundTypeParams: bar.Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 DefineVarStart [d]
2025/10/11 16:12:37 Val Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val M map[string]any
2025/10/11 16:12:37 Val type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any => Typ map[string]any
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/10/11 16:12:37 ==> MatchFuncCall func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:37 boundTypeParams: bar.Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:37 ==> MatchFuncCall func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T] args: 1 flags: 8
2025/10/11 16:12:37 boundTypeParams: bar.Gopx_Var_Cast__1 sig: func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T] args: 1 flags: 8
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverloadNamed (0.04s)
=== RUN   TestMixedOverloadNamed
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload var [b]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload type M
2025/10/11 16:12:37 ==> Preload type basetype
2025/10/11 16:12:37 ==> Preload type Var__0
2025/10/11 16:12:37 ==> Preload type Var__1
2025/10/11 16:12:37 ==> Preload func Gopx_Var_Cast__0
2025/10/11 16:12:37 ==> Preload func Gopx_Var_Cast__1
2025/10/11 16:12:37 ==> Load > AliasType M
2025/10/11 16:12:37 ==> Load > NewType Var__0
2025/10/11 16:12:37 ==> Load > InitType Var__0
2025/10/11 16:12:37 ==> Load > NewType basetype
2025/10/11 16:12:37 ==> Lookup (LoadSymbol) basetype => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:37 ==> Load > InitType basetype
2025/10/11 16:12:37 ==> Load > NewType Var__1
2025/10/11 16:12:37 ==> Load > InitType Var__1
2025/10/11 16:12:37 ==> Load func Gopx_Var_Cast__0
2025/10/11 16:12:37 ==> LookupParent basetype => type github.com/goplus/xgo/cl.basetype interface{interface{string | int | bool | float64}}
2025/10/11 16:12:37 ==> LookupParent Var__0 => type github.com/goplus/xgo/cl.Var__0[T github.com/goplus/xgo/cl.basetype] struct{val T}
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Var__0[T github.com/goplus/xgo/cl.basetype]
2025/10/11 16:12:37 ==> Load func Gopx_Var_Cast__1
2025/10/11 16:12:37 ==> LookupParent Var__1 => type github.com/goplus/xgo/cl.Var__1[T map[string]interface{}] struct{val T}
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Var__1[T map[string]interface{}]
2025/10/11 16:12:37 ==> NewOverloadFunc Gopx_Var_Cast
2025/10/11 16:12:37 ==> AliasFunc Gopx_Var_Cast => Var_Cast
2025/10/11 16:12:37 ==> NewOverloadNamed Var
2025/10/11 16:12:37 ==> LookupParent Var => type github.com/goplus/xgo/cl.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.Var__0[int] [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 ==> LookupParent Var => type github.com/goplus/xgo/cl.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> LookupParent M => type github.com/goplus/xgo/cl.M = map[string]interface{}
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.Var__1[map[string]interface{}] [b]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [b]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [c]
2025/10/11 16:12:37 Val Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val type github.com/goplus/xgo/cl.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val string string
2025/10/11 16:12:37 Val type string => Typ string
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/10/11 16:12:37 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.basetype]() *github.com/goplus/xgo/cl.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:37 boundTypeParams: Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl.basetype]() *github.com/goplus/xgo/cl.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 DefineVarStart [d]
2025/10/11 16:12:37 Val Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val type github.com/goplus/xgo/cl.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val M map[string]interface{}
2025/10/11 16:12:37 Val type github.com/goplus/xgo/cl.M = map[string]interface{} => Typ map[string]interface{}
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/10/11 16:12:37 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.basetype]() *github.com/goplus/xgo/cl.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:37 boundTypeParams: Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl.basetype]() *github.com/goplus/xgo/cl.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:37 ==> MatchFuncCall func[T map[string]interface{}]() *github.com/goplus/xgo/cl.Var__1[T] args: 1 flags: 8
2025/10/11 16:12:37 boundTypeParams: Gopx_Var_Cast__1 sig: func[T map[string]interface{}]() *github.com/goplus/xgo/cl.Var__1[T] args: 1 flags: 8
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestMixedOverloadNamed (0.00s)
=== RUN   TestStringLitBasic
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "$"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("$"), any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestStringLitBasic (0.00s)
=== RUN   TestStringLitVar
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "Hi, "} *ast.BasicLit
2025/10/11 16:12:37 Val Concat func(parts ...string) string
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 Val x int
2025/10/11 16:12:37 Member string 2 // int
2025/10/11 16:12:37 Val Itoa func(i int) string
2025/10/11 16:12:37 Call 1 0 // func(i int) string
2025/10/11 16:12:37 ==> MatchFuncCall func(i int) string args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 Call 3 0 // func(parts ...string) string
2025/10/11 16:12:37 ==> MatchFuncCall func(parts ...string) string args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:37 ==> MatchType string, string
2025/10/11 16:12:37 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("Hi, "), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType string, unboundFuncParam{typ: untyped string}
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType string, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestStringLitVar (0.00s)
=== RUN   TestFileOpen
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 ForRange [_ line]
2025/10/11 16:12:37 Val open func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "foo.txt"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(name string) (*os.File, error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("foo.txt"), string
2025/10/11 16:12:37 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:37 NewVar [_xgo_err]
2025/10/11 16:12:37 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:37 VarRef _xgo_err error
2025/10/11 16:12:37 Assign 2 1
2025/10/11 16:12:37 ==> MatchType *os.File, unboundType{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType error, error
2025/10/11 16:12:37 ==> EnsureLoaded error
2025/10/11 16:12:37 ==> EnsureLoaded error
2025/10/11 16:12:37 If
2025/10/11 16:12:37 Val _xgo_err error
2025/10/11 16:12:37 Val <nil> <nil>
2025/10/11 16:12:37 BinaryOp !=
2025/10/11 16:12:37 Typ error
2025/10/11 16:12:37 Member Gop_NE 0 // TypeType{typ: error}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 VarRef _xgo_err error
2025/10/11 16:12:37 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:37 Val _xgo_err error
2025/10/11 16:12:37 Val open("foo.txt") string
2025/10/11 16:12:37 Val /foo/bar.xgo string
2025/10/11 16:12:37 Val 2 int
2025/10/11 16:12:37 Val main.main string
2025/10/11 16:12:37 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/10/11 16:12:37 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/10/11 16:12:37 ==> MatchType error, error
2025/10/11 16:12:37 ==> EnsureLoaded error
2025/10/11 16:12:37 ==> EnsureLoaded error
2025/10/11 16:12:37 ==> MatchType untyped string ("open(\"foo.txt\")"), string
2025/10/11 16:12:37 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/10/11 16:12:37 ==> MatchType untyped int (2), int
2025/10/11 16:12:37 ==> MatchType untyped string ("main.main"), string
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/10/11 16:12:37 ==> EnsureLoaded error
2025/10/11 16:12:37 Val panic func(v interface{})
2025/10/11 16:12:37 Val _xgo_err error
2025/10/11 16:12:37 Call 1 0 // func(v interface{})
2025/10/11 16:12:37 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType error, interface{}
2025/10/11 16:12:37 ==> EnsureLoaded error
2025/10/11 16:12:37 End // If
2025/10/11 16:12:37 Return 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 0 0 // func() (_xgo_ret *os.File)
2025/10/11 16:12:37 ==> MatchFuncCall func() (_xgo_ret *os.File) args: 0 flags: 0
2025/10/11 16:12:37 RangeAssignThen
2025/10/11 16:12:37 VBlock
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val line string
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType string, any
2025/10/11 16:12:37 End // Vblock
2025/10/11 16:12:37 End // ForRange
2025/10/11 16:12:37 Member Gop_Enum 0 // *os.File
2025/10/11 16:12:37 Val EnumLines func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/10/11 16:12:37 Call 1 0 // func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/10/11 16:12:37 ==> MatchFuncCall func(r io.Reader) github.com/qiniu/x/osx.LineIter args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType *os.File, io.Reader
2025/10/11 16:12:37 ==> EnsureLoaded io.Reader
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestFileOpen (0.00s)
=== RUN   TestMixedGo
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload var [b]
2025/10/11 16:12:37 ==> Preload var [c]
2025/10/11 16:12:37 ==> Preload var [d]
2025/10/11 16:12:37 ==> Preload var [e]
2025/10/11 16:12:37 ==> Preload var [x]
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [n]
2025/10/11 16:12:37 ==> Preload func f
2025/10/11 16:12:37 ==> Preload type foo
2025/10/11 16:12:37 ==> Preload method foo._
2025/10/11 16:12:37 ==> Preload method foo.Str
2025/10/11 16:12:37 ==> Preload method foo.Bar
2025/10/11 16:12:37 ==> Preload type foo2
2025/10/11 16:12:37 ==> Preload type foo3
2025/10/11 16:12:37 ==> Load > NewType foo
2025/10/11 16:12:37 ==> Load > InitType foo
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{v int}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo._
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{v int}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.foo.Str
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{v int}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.foo.Bar
2025/10/11 16:12:37 ==> Load > AliasType foo2
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{v int}
2025/10/11 16:12:37 ==> Load > NewType foo3
2025/10/11 16:12:37 ==> Load > InitType foo3
2025/10/11 16:12:37 ==> LookupParent foo2 => type github.com/goplus/xgo/cl.foo2 = github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> Load const [n] <nil>
2025/10/11 16:12:37 NewConst [n] 0
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val n untyped int
2025/10/11 16:12:37 ==> Load var [10]int [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 ==> Load var string [b]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [b]
2025/10/11 16:12:37 ==> Load func f
2025/10/11 16:12:37 Val f func(v int) string
2025/10/11 16:12:37 Val n untyped int
2025/10/11 16:12:37 Call 1 0 // func(v int) string
2025/10/11 16:12:37 ==> MatchFuncCall func(v int) string args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (10), int
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType string, string
2025/10/11 16:12:37 ==> LookupParent foo2 => type github.com/goplus/xgo/cl.foo2 = github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.foo [c]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [c]
2025/10/11 16:12:37 ==> Load var int [d]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [d]
2025/10/11 16:12:37 Val c github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member v 2 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 ==> Load var <nil> [e]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [e]
2025/10/11 16:12:37 ==> LookupParent foo3 => type github.com/goplus/xgo/cl.foo3 struct{v int}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.foo3 0 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load var string [x]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [x]
2025/10/11 16:12:37 Val c github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member str 2 // github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Call 0 0 // func() string
2025/10/11 16:12:37 ==> MatchFuncCall func() string args: 0 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType string, string
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload type T
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload type Point
2025/10/11 16:12:37 ==> Load > NewType Point
2025/10/11 16:12:37 ==> Load > InitType Point
2025/10/11 16:12:37 ==> Load > NewType T
2025/10/11 16:12:37 NewType T
2025/10/11 16:12:37 ==> Load > InitType T
2025/10/11 16:12:37 InitType T struct{}
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.T 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{X int; Y int}
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 20} *ast.BasicLit
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.Point 2 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.T, any
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.Point, any
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Point
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestMixedGo (0.00s)
=== RUN   TestTypeAsParamsFunc
2025/10/11 16:12:37 ==> Preload var [tbl]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload type basetype
2025/10/11 16:12:37 ==> Preload func Gopx_Row__0
2025/10/11 16:12:37 ==> Preload func Gopx_Row__1
2025/10/11 16:12:37 ==> Preload func Gopx_Col
2025/10/11 16:12:37 ==> Preload type Table
2025/10/11 16:12:37 ==> Preload func Gopt_Table_Gopx_Col__0
2025/10/11 16:12:37 ==> Preload func Gopt_Table_Gopx_Col__1
2025/10/11 16:12:37 ==> Load > NewType basetype
2025/10/11 16:12:37 ==> Load > InitType basetype
2025/10/11 16:12:37 ==> Load func Gopx_Row__0
2025/10/11 16:12:37 ==> LookupParent basetype => type github.com/goplus/xgo/cl.basetype interface{interface{int | string}}
2025/10/11 16:12:37 ==> Load > NewType Table
2025/10/11 16:12:37 ==> Load > InitType Table
2025/10/11 16:12:37 ==> Load func Gopx_Row__1
2025/10/11 16:12:37 ==> Load func Gopt_Table_Gopx_Col__0
2025/10/11 16:12:37 ==> LookupParent basetype => type github.com/goplus/xgo/cl.basetype interface{interface{int | string}}
2025/10/11 16:12:37 ==> LookupParent Table => type github.com/goplus/xgo/cl.Table struct{}
2025/10/11 16:12:37 ==> Load func Gopt_Table_Gopx_Col__1
2025/10/11 16:12:37 ==> LookupParent Table => type github.com/goplus/xgo/cl.Table struct{}
2025/10/11 16:12:37 ==> Load func Gopx_Col
2025/10/11 16:12:37 ==> AliasFunc Gopx_Col => Col
2025/10/11 16:12:37 ==> NewOverloadFunc Gopt_Table_Gopx_Col
2025/10/11 16:12:37 ==> NewTemplateRecvMethod Table Gopx_Col
2025/10/11 16:12:37 ==> AliasMethod github.com/goplus/xgo/cl.Table Gopx_Col => Col
2025/10/11 16:12:37 ==> NewOverloadFunc Gopx_Row
2025/10/11 16:12:37 ==> AliasFunc Gopx_Row => Row
2025/10/11 16:12:37 ==> LookupParent Table => type github.com/goplus/xgo/cl.Table struct{}
2025/10/11 16:12:37 ==> Load var *github.com/goplus/xgo/cl.Table [tbl]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [tbl]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val Col func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val string string
2025/10/11 16:12:37 Val type string => Typ string
2025/10/11 16:12:37 Val &{0 STRING "name"} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func[T interface{}](name string) args: 2 flags: 8
2025/10/11 16:12:37 boundTypeParams: Gopx_Col sig: func[T interface{}](name string) args: 2 flags: 8
2025/10/11 16:12:37 ==> MatchType untyped string ("name"), string
2025/10/11 16:12:37 Val Col func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val int int
2025/10/11 16:12:37 Val type int => Typ int
2025/10/11 16:12:37 Val &{0 STRING "age"} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func[T interface{}](name string) args: 2 flags: 8
2025/10/11 16:12:37 boundTypeParams: Gopx_Col sig: func[T interface{}](name string) args: 2 flags: 8
2025/10/11 16:12:37 ==> MatchType untyped string ("age"), string
2025/10/11 16:12:37 Val Row func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val string string
2025/10/11 16:12:37 Val type string => Typ string
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 8
2025/10/11 16:12:37 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.basetype](name string) args: 2 flags: 8
2025/10/11 16:12:37 boundTypeParams: Gopx_Row__0 sig: func[T github.com/goplus/xgo/cl.basetype](name string) args: 2 flags: 8
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func[Array interface{}](v int) args: 2 flags: 8
2025/10/11 16:12:37 boundTypeParams: Gopx_Row__1 sig: func[Array interface{}](v int) args: 2 flags: 8
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 Val tbl *github.com/goplus/xgo/cl.Table
2025/10/11 16:12:37 Member col 1 // *github.com/goplus/xgo/cl.Table
2025/10/11 16:12:37 Val string string
2025/10/11 16:12:37 Val type string => Typ string
2025/10/11 16:12:37 Val &{0 STRING "foo"} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 8
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 24
2025/10/11 16:12:37 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.basetype](p *github.com/goplus/xgo/cl.Table, name string) args: 3 flags: 24
2025/10/11 16:12:37 boundTypeParams: Gopt_Table_Gopx_Col__0 sig: func[T github.com/goplus/xgo/cl.basetype](p *github.com/goplus/xgo/cl.Table, name string) args: 3 flags: 24
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.Table, *github.com/goplus/xgo/cl.Table
2025/10/11 16:12:37 ==> MatchType untyped string ("foo"), string
2025/10/11 16:12:37 Val tbl *github.com/goplus/xgo/cl.Table
2025/10/11 16:12:37 Member col 1 // *github.com/goplus/xgo/cl.Table
2025/10/11 16:12:37 Val int int
2025/10/11 16:12:37 Val type int => Typ int
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 8
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 24
2025/10/11 16:12:37 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.basetype](p *github.com/goplus/xgo/cl.Table, name string) args: 3 flags: 24
2025/10/11 16:12:37 boundTypeParams: Gopt_Table_Gopx_Col__0 sig: func[T github.com/goplus/xgo/cl.basetype](p *github.com/goplus/xgo/cl.Table, name string) args: 3 flags: 24
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.Table, *github.com/goplus/xgo/cl.Table
2025/10/11 16:12:37 ==> MatchType untyped int (100), string
2025/10/11 16:12:37 ==> MatchFuncCall func[Array interface{}](p *github.com/goplus/xgo/cl.Table, v int) args: 3 flags: 24
2025/10/11 16:12:37 boundTypeParams: Gopt_Table_Gopx_Col__1 sig: func[Array interface{}](p *github.com/goplus/xgo/cl.Table, v int) args: 3 flags: 24
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.Table, *github.com/goplus/xgo/cl.Table
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestTypeAsParamsFunc (0.00s)
=== RUN   TestYaptest
2025/10/11 16:12:37 ==> Preload var [c]
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Import github.com/goplus/xgo/cl/internal/test
2025/10/11 16:12:37 ==> NewTemplateRecvMethod Case MatchAny
2025/10/11 16:12:37 ==> NewTemplateRecvMethod Case MatchTBase
2025/10/11 16:12:37 ==> NewOverloadFunc Gopt_Case_Match
2025/10/11 16:12:37 ==> NewTemplateRecvMethod Case Match
2025/10/11 16:12:37 ==> Preload type Class
2025/10/11 16:12:37 ==> Load > NewType Class
2025/10/11 16:12:37 ==> Load > InitType Class
2025/10/11 16:12:37 ==> LookupParent Class => type github.com/goplus/xgo/cl.Class struct{github.com/goplus/xgo/cl/internal/test.Case}
2025/10/11 16:12:37 ==> Load var github.com/goplus/xgo/cl.Class [c]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [c]
2025/10/11 16:12:37 ==> Load var int [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val c github.com/goplus/xgo/cl.Class
2025/10/11 16:12:37 Member match 1 // github.com/goplus/xgo/cl.Class
2025/10/11 16:12:37 Val a int
2025/10/11 16:12:37 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/10/11 16:12:37 ==> MatchFuncCall func[T github.com/goplus/xgo/cl/internal/test.basetype](t github.com/goplus/xgo/cl/internal/test.CaseT, got T, expected T, name ...string) args: 3 flags: 16
2025/10/11 16:12:37 ==> InferFunc func(t github.com/goplus/xgo/cl/internal/test.CaseT, got int, expected int, name ...string)
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Class, github.com/goplus/xgo/cl/internal/test.CaseT
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Class
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/test.CaseT
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 ==> MatchType untyped string ("b"), int
2025/10/11 16:12:37 ==> MatchFuncCall func(t github.com/goplus/xgo/cl/internal/test.CaseT, got any, expected any, name ...string) args: 3 flags: 16
2025/10/11 16:12:37 ==> MatchType github.com/goplus/xgo/cl.Class, github.com/goplus/xgo/cl/internal/test.CaseT
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.Class
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/test.CaseT
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 ==> MatchType untyped string ("b"), any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestYaptest (0.23s)
=== RUN   TestRangeExpr
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 For
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ==> MatchType untyped int (0), int
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 For
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestRangeExpr (0.01s)
=== RUN   TestRangeExpr2
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 For
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestRangeExpr2 (0.00s)
=== RUN   TestRangeExpr3
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 For
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestRangeExpr3 (0.00s)
=== RUN   TestRangeExpr4
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 For
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ==> MatchType untyped int (0), int
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestRangeExpr4 (0.00s)
=== RUN   TestRangeExpr5
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [_xgo_k]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val _xgo_k int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef _xgo_k int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestRangeExpr5 (0.00s)
=== RUN   TestRangeExpr6
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [_xgo_k]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val _xgo_k int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef _xgo_k int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestRangeExpr6 (0.00s)
=== RUN   TestRangeExpr8
2025/10/11 16:12:37 ==> Preload type T
2025/10/11 16:12:37 ==> Preload method T.start
2025/10/11 16:12:37 ==> Preload method T.end
2025/10/11 16:12:37 ==> Preload method T.step
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType T
2025/10/11 16:12:37 NewType T
2025/10/11 16:12:37 ==> Load > InitType T
2025/10/11 16:12:37 InitType T struct{}
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.start
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.end
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.step
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [t]
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.T 0 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i _xgo_end _xgo_step]
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member start 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member end 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member step 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 EndInit 3
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val _xgo_end int
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val _xgo_step int
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc start (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (0), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc end (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (3), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc step (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload type T
2025/10/11 16:12:37 ==> Preload method T.start
2025/10/11 16:12:37 ==> Preload method T.end
2025/10/11 16:12:37 ==> Preload method T.step
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType T
2025/10/11 16:12:37 NewType T
2025/10/11 16:12:37 ==> Load > InitType T
2025/10/11 16:12:37 InitType T struct{}
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.start
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.end
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.step
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [t]
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.T 0 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i _xgo_end _xgo_step]
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member start 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member end 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member step 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 EndInit 3
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val _xgo_end int
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val _xgo_step int
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc start (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (0), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc end (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (3), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc step (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestRangeExpr8 (0.00s)
=== RUN   TestRangeExpr9
2025/10/11 16:12:37 ==> Preload type T
2025/10/11 16:12:37 ==> Preload method T.start
2025/10/11 16:12:37 ==> Preload method T.end
2025/10/11 16:12:37 ==> Preload method T.step
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType T
2025/10/11 16:12:37 NewType T
2025/10/11 16:12:37 ==> Load > InitType T
2025/10/11 16:12:37 InitType T struct{}
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.start
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.end
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.step
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [t]
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.T 0 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [_xgo_k _xgo_end _xgo_step]
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member start 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member end 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member step 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 EndInit 3
2025/10/11 16:12:37 Val _xgo_k int
2025/10/11 16:12:37 Val _xgo_end int
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val _xgo_k int
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef _xgo_k int
2025/10/11 16:12:37 Val _xgo_step int
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc start (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (0), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc end (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (3), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc step (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
2025/10/11 16:12:37 ==> Preload type T
2025/10/11 16:12:37 ==> Preload method T.start
2025/10/11 16:12:37 ==> Preload method T.end
2025/10/11 16:12:37 ==> Preload method T.step
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType T
2025/10/11 16:12:37 NewType T
2025/10/11 16:12:37 ==> Load > InitType T
2025/10/11 16:12:37 InitType T struct{}
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.start
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.end
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 ==> Load method github.com/goplus/xgo/cl.T.step
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [t]
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.T 0 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [_xgo_k _xgo_end _xgo_step]
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member start 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member end 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 Val t github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member step 1 // github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Call 0 0 // func() int
2025/10/11 16:12:37 ==> MatchFuncCall func() int args: 0 flags: 0
2025/10/11 16:12:37 EndInit 3
2025/10/11 16:12:37 Val _xgo_k int
2025/10/11 16:12:37 Val _xgo_end int
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val _xgo_k int
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef _xgo_k int
2025/10/11 16:12:37 Val _xgo_step int
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc start (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (0), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc end (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (3), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc step (github.com/goplus/xgo/cl.T) func() int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestRangeExpr9 (0.00s)
=== RUN   TestRangeExpr10
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [_xgo_k]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val _xgo_k int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("Hi"), any
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef _xgo_k int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestRangeExpr10 (0.00s)
=== RUN   Test_RangeExpressionIf_Issue1243
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 For
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 If
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp %
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp ==
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 End // If
2025/10/11 16:12:37 Post
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/10/11 16:12:37 End // For
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: Test_RangeExpressionIf_Issue1243 (0.00s)
=== RUN   TestStaticMethod
2025/10/11 16:12:37 ==> Preload type foo
2025/10/11 16:12:37 ==> Preload static method foo.New
2025/10/11 16:12:37 ==> Preload static method foo._add
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func Gops_foo_New
2025/10/11 16:12:37 ==> Load > NewType foo
2025/10/11 16:12:37 NewType foo
2025/10/11 16:12:37 ==> Lookup (LoadSymbol) foo => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:37 NewFunc Gops_foo_New func(a int) *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 Val foo github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val %!v(PANIC=String method: nil underlying) => Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> Load > InitType foo
2025/10/11 16:12:37 InitType foo int
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func Gops__foo___add
2025/10/11 16:12:37 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo int
2025/10/11 16:12:37 NewFunc Gops__foo___add func() *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 Val foo github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val type github.com/goplus/xgo/cl.foo int => Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> NewStaticMethod foo _add
2025/10/11 16:12:37 ==> NewStaticMethod foo New
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val foo github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Val type github.com/goplus/xgo/cl.foo int => Typ github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 Member new 1 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(a int) *github.com/goplus/xgo/cl.foo
2025/10/11 16:12:37 ==> MatchFuncCall func(a int) *github.com/goplus/xgo/cl.foo args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (100), int
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestStaticMethod (0.00s)
=== RUN   TestOverlodOptions
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload type PlayOptions
2025/10/11 16:12:37 ==> Preload type Game
2025/10/11 16:12:37 ==> Preload method Game.Play__0
2025/10/11 16:12:37 ==> Preload method Game.Play__1
2025/10/11 16:12:37 ==> Load > NewType Game
2025/10/11 16:12:37 ==> Load > InitType Game
2025/10/11 16:12:37 ==> LookupParent Game => type github.com/goplus/xgo/cl.Game struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.Game.Play__0
2025/10/11 16:12:37 ==> Load > NewType PlayOptions
2025/10/11 16:12:37 ==> Lookup (LoadSymbol) PlayOptions => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:37 ==> Load > InitType PlayOptions
2025/10/11 16:12:37 ==> LookupParent Game => type github.com/goplus/xgo/cl.Game struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.Game.Play__1
2025/10/11 16:12:37 ==> LookupParent PlayOptions => type github.com/goplus/xgo/cl.PlayOptions struct{Action int; Wait bool; Loop bool}
2025/10/11 16:12:37 ==> NewOverloadMethod Game Play
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [g]
2025/10/11 16:12:37 ==> LookupParent Game => type github.com/goplus/xgo/cl.Game struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.Game 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val g *github.com/goplus/xgo/cl.Game
2025/10/11 16:12:37 Member play 1 // *github.com/goplus/xgo/cl.Game
2025/10/11 16:12:37 Val &{0 STRING "work"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "work"} *ast.BasicLit
2025/10/11 16:12:37 Val 0 int
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 Val 2 int
2025/10/11 16:12:37 Val true untyped bool
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.PlayOptions 4 true
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(options *github.com/goplus/xgo/cl.PlayOptions) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(name string, options *github.com/goplus/xgo/cl.PlayOptions) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("work"), string
2025/10/11 16:12:37 ==> MatchType *github.com/goplus/xgo/cl.PlayOptions, *github.com/goplus/xgo/cl.PlayOptions
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.PlayOptions
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.PlayOptions
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverlodOptions (0.00s)
=== RUN   TestEmbedField
2025/10/11 16:12:37 ==> Preload type Info
2025/10/11 16:12:37 ==> Preload type T
2025/10/11 16:12:37 ==> Preload func demo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType Info
2025/10/11 16:12:37 NewType Info
2025/10/11 16:12:37 ==> Load > InitType Info
2025/10/11 16:12:37 InitType Info struct{id int}
2025/10/11 16:12:37 ==> Load > NewType T
2025/10/11 16:12:37 NewType T
2025/10/11 16:12:37 ==> Load > InitType T
2025/10/11 16:12:37 ==> LookupParent Info => type github.com/goplus/xgo/cl.Info struct{id int}
2025/10/11 16:12:37 InitType T struct{github.com/goplus/xgo/cl.Info; id string}
2025/10/11 16:12:37 ==> Load func demo
2025/10/11 16:12:37 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{github.com/goplus/xgo/cl.Info; id string}
2025/10/11 16:12:37 NewFunc demo func(t *github.com/goplus/xgo/cl.T)
2025/10/11 16:12:37 Val t *github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Member id -1 // *github.com/goplus/xgo/cl.T
2025/10/11 16:12:37 Val &{0 STRING "0"} *ast.BasicLit
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ==> MatchType untyped string ("0"), string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestEmbedField (0.00s)
=== RUN   TestOverloadUntyped
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload type specialObj
2025/10/11 16:12:37 ==> Preload type SpriteName
2025/10/11 16:12:37 ==> Preload type SpriteImpl
2025/10/11 16:12:37 ==> Preload method SpriteImpl.turn
2025/10/11 16:12:37 ==> Preload method SpriteImpl.TurnTo__0
2025/10/11 16:12:37 ==> Preload method SpriteImpl.TurnTo__1
2025/10/11 16:12:37 ==> Preload method SpriteImpl.TurnTo__2
2025/10/11 16:12:37 ==> Preload method SpriteImpl.TurnTo__3
2025/10/11 16:12:37 ==> Load > NewType specialObj
2025/10/11 16:12:37 ==> Load > InitType specialObj
2025/10/11 16:12:37 ==> Load > NewType SpriteName
2025/10/11 16:12:37 ==> Load > InitType SpriteName
2025/10/11 16:12:37 ==> Load > NewType SpriteImpl
2025/10/11 16:12:37 ==> Load > InitType SpriteImpl
2025/10/11 16:12:37 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.turn
2025/10/11 16:12:37 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.TurnTo__0
2025/10/11 16:12:37 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/10/11 16:12:37 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.TurnTo__1
2025/10/11 16:12:37 ==> LookupParent SpriteName => type github.com/goplus/xgo/cl.SpriteName string
2025/10/11 16:12:37 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.TurnTo__2
2025/10/11 16:12:37 ==> LookupParent specialObj => type github.com/goplus/xgo/cl.specialObj int
2025/10/11 16:12:37 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.TurnTo__3
2025/10/11 16:12:37 ==> NewOverloadMethod SpriteImpl TurnTo
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [p]
2025/10/11 16:12:37 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.SpriteImpl 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val p *github.com/goplus/xgo/cl.SpriteImpl
2025/10/11 16:12:37 Member turnTo 1 // *github.com/goplus/xgo/cl.SpriteImpl
2025/10/11 16:12:37 Val &{0 FLOAT 180.0} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(sprite *github.com/goplus/xgo/cl.SpriteImpl) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (180), *github.com/goplus/xgo/cl.SpriteImpl
2025/10/11 16:12:37 ==> MatchFuncCall func(sprite github.com/goplus/xgo/cl.SpriteName) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (180), github.com/goplus/xgo/cl.SpriteName
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.SpriteName
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/goplus/xgo/cl.SpriteName false
2025/10/11 16:12:37 ==> MatchFuncCall func(obj github.com/goplus/xgo/cl.specialObj) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (180), github.com/goplus/xgo/cl.specialObj
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.specialObj
2025/10/11 16:12:37 Val p *github.com/goplus/xgo/cl.SpriteImpl
2025/10/11 16:12:37 Member turnTo 1 // *github.com/goplus/xgo/cl.SpriteImpl
2025/10/11 16:12:37 Val &{0 FLOAT 180.1} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(sprite *github.com/goplus/xgo/cl.SpriteImpl) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (180.1), *github.com/goplus/xgo/cl.SpriteImpl
2025/10/11 16:12:37 ==> MatchFuncCall func(sprite github.com/goplus/xgo/cl.SpriteName) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (180.1), github.com/goplus/xgo/cl.SpriteName
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.SpriteName
2025/10/11 16:12:37 ==> AssignableConv untyped float github.com/goplus/xgo/cl.SpriteName false
2025/10/11 16:12:37 ==> MatchFuncCall func(obj github.com/goplus/xgo/cl.specialObj) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (180.1), github.com/goplus/xgo/cl.specialObj
2025/10/11 16:12:37 ==> EnsureLoaded github.com/goplus/xgo/cl.specialObj
2025/10/11 16:12:37 ==> MatchFuncCall func(degree float64) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (180.1), float64
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverloadUntyped (0.00s)
=== RUN   TestOverloadUntyped2
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload type SpriteImpl
2025/10/11 16:12:37 ==> Preload method SpriteImpl.Rand__0
2025/10/11 16:12:37 ==> Preload method SpriteImpl.Rand__1
2025/10/11 16:12:37 ==> Load > NewType SpriteImpl
2025/10/11 16:12:37 ==> Load > InitType SpriteImpl
2025/10/11 16:12:37 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.Rand__0
2025/10/11 16:12:37 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/10/11 16:12:37 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.Rand__1
2025/10/11 16:12:37 ==> NewOverloadMethod SpriteImpl Rand
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [p]
2025/10/11 16:12:37 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/10/11 16:12:37 StructLit github.com/goplus/xgo/cl.SpriteImpl 0 false
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val p *github.com/goplus/xgo/cl.SpriteImpl
2025/10/11 16:12:37 Member rand 1 // *github.com/goplus/xgo/cl.SpriteImpl
2025/10/11 16:12:37 Val &{0 FLOAT 1.0} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 FLOAT 2.0} *ast.BasicLit
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(from int, to int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped float (1), int
2025/10/11 16:12:37 ==> MatchType untyped float (2), int
2025/10/11 16:12:37 Val p *github.com/goplus/xgo/cl.SpriteImpl
2025/10/11 16:12:37 Member rand 1 // *github.com/goplus/xgo/cl.SpriteImpl
2025/10/11 16:12:37 Val float64 float64
2025/10/11 16:12:37 Val type float64 => Typ float64
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: float64}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: float64} args: 1 flags: 0
2025/10/11 16:12:37 Val float64 float64
2025/10/11 16:12:37 Val type float64 => Typ float64
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: float64}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: float64} args: 1 flags: 0
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(from int, to int) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType float64 (1), int
2025/10/11 16:12:37 ==> MatchFuncCall func(from float64, to float64) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType float64 (1), float64
2025/10/11 16:12:37 ==> MatchType float64 (2), float64
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestOverloadUntyped2 (0.00s)
=== RUN   TestSliceType
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 2 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val a []interface{}
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 IndexRef 1
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 SliceLit <nil> 3 false
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ==> MatchType []int, interface{}
2025/10/11 16:12:37 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val a []interface{}
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType []interface{}, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestSliceType (0.00s)
=== RUN   TestMapLitType
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var interface{} [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val &{0 STRING "Monday"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "Tuesday"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 MapLit <nil> 4
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType map[string]int, interface{}
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val a interface{}
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType interface{}, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestMapLitType (0.00s)
=== RUN   TestErrTplLit
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:1:1
2025/10/11 16:12:37 Val NewEx func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/10/11 16:12:37 Val &{0 STRING `a = INT => { return }`} *ast.BasicLit
2025/10/11 16:12:37 Val bar.xgo string
2025/10/11 16:12:37 Val 1 int
2025/10/11 16:12:37 Val 4 int
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 NewClosure func(self interface{}) interface{}
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:1:1
2025/10/11 16:12:37 Return 0
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:1:1
2025/10/11 16:12:37 Call 6 0 // func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/10/11 16:12:37 ==> MatchFuncCall func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error) args: 6 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("a = INT => { return }"), any
2025/10/11 16:12:37 ==> MatchType untyped string ("bar.xgo"), string
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 ==> MatchType untyped int (4), int
2025/10/11 16:12:37 ==> MatchType untyped string ("a"), any
2025/10/11 16:12:37 ==> MatchType func(self interface{}) interface{}, any
2025/10/11 16:12:37 End // Func
--- PASS: TestErrTplLit (0.00s)
=== RUN   TestErrSendStmt
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var chan int [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Val a chan int
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrSendStmt (0.00s)
=== RUN   TestErrVargCommand
2025/10/11 16:12:37 ==> Preload func Ls
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func Ls
2025/10/11 16:12:37 NewFunc Ls func(int)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 Val Ls func(int)
2025/10/11 16:12:37 Call 0 0 // func(int)
2025/10/11 16:12:37 ==> MatchFuncCall func(int) args: 0 flags: 0
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload type foo
2025/10/11 16:12:37 ==> Preload method foo.Ls
2025/10/11 16:12:37 ==> Preload var [f]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType foo
2025/10/11 16:12:37 NewType foo
2025/10/11 16:12:37 ==> Load > InitType foo
2025/10/11 16:12:37 InitType foo int
2025/10/11 16:12:37 ==> LookupParent foo => type foo int
2025/10/11 16:12:37 ==> Load method foo.Ls
2025/10/11 16:12:37 ==> LookupParent foo => type foo int
2025/10/11 16:12:37 ==> Load var foo [f]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [f]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:8:1
2025/10/11 16:12:37 Val f foo
2025/10/11 16:12:37 Member ls 1 // foo
2025/10/11 16:12:37 Call 0 0 // func(int)
2025/10/11 16:12:37 ==> MatchFuncCall func(int) args: 0 flags: 0
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc Ls (foo) func(int)
2025/10/11 16:12:37 End // Func
--- PASS: TestErrVargCommand (0.00s)
=== RUN   TestErrUnsafe
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrUnsafe (0.00s)
=== RUN   TestErrLambdaExpr
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func(func(int, int))
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:7:1
2025/10/11 16:12:37 Val foo func(func(int, int))
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func(func(int, int))
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:7:1
2025/10/11 16:12:37 Val foo func(func(int, int))
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload type Foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType Foo
2025/10/11 16:12:37 NewType Foo
2025/10/11 16:12:37 ==> Load > InitType Foo
2025/10/11 16:12:37 InitType Foo struct{Plot int}
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 DefineVarStart [foo]
2025/10/11 16:12:37 ==> LookupParent Foo => type Foo struct{Plot int}
2025/10/11 16:12:37 Val 0 int
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload type Foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType Foo
2025/10/11 16:12:37 NewType Foo
2025/10/11 16:12:37 ==> Load > InitType Foo
2025/10/11 16:12:37 InitType Foo struct{Plot int}
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 DefineVarStart [foo]
2025/10/11 16:12:37 ==> LookupParent Foo => type Foo struct{Plot int}
2025/10/11 16:12:37 Val 0 int
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func(int)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Val foo func(int)
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func(func())
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Val foo func(func())
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload type Foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType Foo
2025/10/11 16:12:37 NewType Foo
2025/10/11 16:12:37 ==> Load > InitType Foo
2025/10/11 16:12:37 InitType Foo struct{Plot func() int}
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 DefineVarStart [foo]
2025/10/11 16:12:37 ==> LookupParent Foo => type Foo struct{Plot func() int}
2025/10/11 16:12:37 Val 0 int
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [foo]
2025/10/11 16:12:37 ==> Load var func() [foo]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [foo]
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload var [foo]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var func() [foo]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [foo]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 VarRef foo func()
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [foo foo1]
2025/10/11 16:12:37 ==> Load var func() [foo foo1]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [foo foo1]
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload var [foo]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var func() [foo]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [foo]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 VarRef _
2025/10/11 16:12:37 VarRef foo func()
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func intSeq
2025/10/11 16:12:37 ==> Load func intSeq
2025/10/11 16:12:37 NewFunc intSeq func() int
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func intSeq
2025/10/11 16:12:37 ==> Load func intSeq
2025/10/11 16:12:37 NewFunc intSeq func() func() string
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 NewClosure func() string
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 IncDec ++
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:6:1
2025/10/11 16:12:37 Val i int
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType int, string
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType func() string, func() string
2025/10/11 16:12:37 End // Func
--- PASS: TestErrLambdaExpr (0.00s)
=== RUN   TestErrErrWrap
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrErrWrap (0.00s)
=== RUN   TestErrVar
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load var <nil> [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), any
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load var <nil> [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 EndInit 2
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func(v map[int]invalid type)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [bar]
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load var <nil> [bar]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [bar]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 ==> LookupParent bar => var bar int
2025/10/11 16:12:37 NewFunc foo func(v map[int]invalid type)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [foo]
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [foo]
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrVar (0.01s)
=== RUN   TestErrImport
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:8:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func(t *invalid type)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func(t invalid type)
2025/10/11 16:12:37 End // Func
--- PASS: TestErrImport (0.34s)
=== RUN   TestErrConst
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [a]
2025/10/11 16:12:37 ==> Load var int [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [a]
2025/10/11 16:12:37 ==> Preload const [b c]
2025/10/11 16:12:37 ==> Load const [a] <nil>
2025/10/11 16:12:37 NewConst [a] 0
2025/10/11 16:12:37 Val iota untyped int
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load const [b c]
2025/10/11 16:12:37 Val iota untyped int
--- PASS: TestErrConst (0.00s)
=== RUN   TestErrNewVar
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var int [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
--- PASS: TestErrNewVar (0.00s)
=== RUN   TestErrDefineVar
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped string ("Hi"), int
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrDefineVar (0.00s)
=== RUN   TestErrAssignMismatchT
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var string [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 SliceLit []string 0 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType []string, string
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var string [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 ArrayLit [2]string 0 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType [2]string, string
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var string [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 MapLit map[int]string 0
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType map[int]string, string
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload type T
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load > NewType T
2025/10/11 16:12:37 NewType T
2025/10/11 16:12:37 ==> Load > InitType T
2025/10/11 16:12:37 InitType T struct{}
2025/10/11 16:12:37 ==> Load var string [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 ==> LookupParent T => type T struct{}
2025/10/11 16:12:37 StructLit T 0 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType T, string
2025/10/11 16:12:37 ==> EnsureLoaded T
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var string [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 NewClosure func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType func(), string
2025/10/11 16:12:37 ResetInit
--- PASS: TestErrAssignMismatchT (0.00s)
=== RUN   TestErrAssign
2025/10/11 16:12:37 ==> Preload func bar
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func bar
2025/10/11 16:12:37 NewFunc bar func() (n int, err error)
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Return 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:7:1
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:8:1
2025/10/11 16:12:37 VarRef x int
2025/10/11 16:12:37 Val bar func() (n int, err error)
2025/10/11 16:12:37 Call 0 0 // func() (n int, err error)
2025/10/11 16:12:37 ==> MatchFuncCall func() (n int, err error) args: 0 flags: 0
2025/10/11 16:12:37 Assign 1 1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 VarRef x int
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 Assign 1 2
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrAssign (0.00s)
=== RUN   TestErrReturn
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func() (int, error)
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func() (int, error)
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 Return 3
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func() (int, error)
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 Return 2
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 ==> MatchType untyped string ("Hi"), error
2025/10/11 16:12:37 ==> EnsureLoaded error
2025/10/11 16:12:37 ==> AssignableConv untyped string error false
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func bar
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func bar
2025/10/11 16:12:37 NewFunc bar func() (v byte)
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Return 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func() (int, error)
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:8:1
2025/10/11 16:12:37 Val bar func() (v byte)
2025/10/11 16:12:37 Call 0 0 // func() (v byte)
2025/10/11 16:12:37 ==> MatchFuncCall func() (v byte) args: 0 flags: 0
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func bar
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func bar
2025/10/11 16:12:37 NewFunc bar func() (n int, err error)
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Return 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func() (v byte)
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:8:1
2025/10/11 16:12:37 Val bar func() (n int, err error)
2025/10/11 16:12:37 Call 0 0 // func() (n int, err error)
2025/10/11 16:12:37 ==> MatchFuncCall func() (n int, err error) args: 0 flags: 0
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func bar
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func bar
2025/10/11 16:12:37 NewFunc bar func() (n int, v byte)
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Return 0
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func() (int, error)
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:8:1
2025/10/11 16:12:37 Val bar func() (n int, v byte)
2025/10/11 16:12:37 Call 0 0 // func() (n int, v byte)
2025/10/11 16:12:37 ==> MatchFuncCall func() (n int, v byte) args: 0 flags: 0
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType int, int
2025/10/11 16:12:37 ==> MatchType byte, error
2025/10/11 16:12:37 ==> EnsureLoaded error
2025/10/11 16:12:37 ==> AssignableConv byte error false
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func() byte
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Return 0
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrReturn (0.00s)
=== RUN   TestErrForRange
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 ==> Load var []string [b]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [b]
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 ForRange []
2025/10/11 16:12:37 VarRef _
2025/10/11 16:12:37 VarRef a int
2025/10/11 16:12:37 Val b []string
2025/10/11 16:12:37 RangeAssignThen
2025/10/11 16:12:37 ==> MatchType string, int
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // ForRange
2025/10/11 16:12:37 End // Func
--- PASS: TestErrForRange (0.00s)
=== RUN   TestErrInitFunc
2025/10/11 16:12:37 ==> Preload func init
2025/10/11 16:12:37 ==> Load func init
--- PASS: TestErrInitFunc (0.00s)
=== RUN   TestErrRecv
2025/10/11 16:12:37 ==> Preload type a
2025/10/11 16:12:37 ==> Preload method a.foo
2025/10/11 16:12:37 ==> Load > NewType a
2025/10/11 16:12:37 NewType a
2025/10/11 16:12:37 ==> Load > InitType a
2025/10/11 16:12:37 InitType a *int
2025/10/11 16:12:37 ==> LookupParent a => type a *int
2025/10/11 16:12:37 ==> Load method a.foo
2025/10/11 16:12:37 ==> Preload method error.foo
2025/10/11 16:12:37 ==> Load method error.foo
--- PASS: TestErrRecv (0.00s)
=== RUN   TestErrEnvOp
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{<nil> invalid type <nil> <nil>} *internal.Elem
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType invalid type, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val &{<nil> invalid type <nil> <nil>} *internal.Elem
2025/10/11 16:12:37 End // Func
--- PASS: TestErrEnvOp (0.00s)
=== RUN   TestErrStringLit
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 SliceLit <nil> 0 false
2025/10/11 16:12:37 Member string 2 // []interface{}
2025/10/11 16:12:37 Member error 2 // []interface{}
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType []interface{}, any
2025/10/11 16:12:37 End // Func
--- PASS: TestErrStringLit (0.00s)
=== RUN   TestErrStructLit
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 StructLit struct{x int; y string} 1 false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val x int
2025/10/11 16:12:37 StructLit struct{x int; y string} 2 false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrStructLit (0.00s)
=== RUN   TestErrArray
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var int [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 Val n int
--- PASS: TestErrArray (0.00s)
=== RUN   TestErrArrayLit
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 ArrayLit [10]int 2 true
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 9} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 None
2025/10/11 16:12:37 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:37 ArrayLit [10]int 4 true
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 ArrayLit [1]int 2 false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 12} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 ArrayLit [10]int 2 true
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Val &{0 STRING "!"} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped string ("!"), unboundFuncParam{typ: string}
2025/10/11 16:12:37 ArrayLit [10]int 1 false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 ArrayLit [10]int 2 true
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrArrayLit (0.00s)
=== RUN   TestErrSliceLit
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []int 2 true
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 SliceLit []int 1 false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 SliceLit []int 2 true
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrSliceLit (0.00s)
=== RUN   TestErrMapLit
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func(map[string]string)
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Val foo func(map[string]string)
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 MapLit map[string]string 2
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (2), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 MapLit map[string]int 2
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "Go"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "+"} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("Go"), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped string ("+"), unboundFuncParam{typ: untyped string}
2025/10/11 16:12:37 MapLit map[string]int 2
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [v]
2025/10/11 16:12:37 ==> Load var interface{} [v]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [v]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 None
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 MapLit <nil> 4
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload var [v]
2025/10/11 16:12:37 ==> Load var map[int]int [v]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [v]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 None
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 MapLit map[int]int 4
2025/10/11 16:12:37 ResetInit
--- PASS: TestErrMapLit (0.00s)
=== RUN   TestErrSlice
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var *byte [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val a *byte
2025/10/11 16:12:37 Val x int
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Slice false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val true untyped bool
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val a bool
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Slice false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:37 Slice true
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrSlice (0.00s)
=== RUN   TestErrIndex
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b ok]
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Index 1 true
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val true untyped bool
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val a bool
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Index 1 false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrIndex (0.00s)
=== RUN   TestErrIndexRef
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 IndexRef 1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrIndexRef (0.00s)
=== RUN   TestErrStar
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 ElemRef
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Star
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrStar (0.00s)
=== RUN   TestErrMember
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [b]
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Member x 2 // string
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrMember (0.00s)
=== RUN   TestErrMemberRef
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Val a string
2025/10/11 16:12:37 Member x -1 // string
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload type aaa
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType aaa
2025/10/11 16:12:37 NewType aaa
2025/10/11 16:12:37 ==> Load > InitType aaa
2025/10/11 16:12:37 InitType aaa byte
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val aaa aaa
2025/10/11 16:12:37 Val type aaa byte => Typ aaa
2025/10/11 16:12:37 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: aaa}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: aaa} args: 1 flags: 0
2025/10/11 16:12:37 ==> EnsureLoaded aaa
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 Val a aaa
2025/10/11 16:12:37 Member x -1 // aaa
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload type aaa
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load > NewType aaa
2025/10/11 16:12:37 NewType aaa
2025/10/11 16:12:37 ==> Load > InitType aaa
2025/10/11 16:12:37 InitType aaa struct{x int; y string}
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 ==> LookupParent aaa => type aaa struct{x int; y string}
2025/10/11 16:12:37 StructLit aaa 0 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 Val a aaa
2025/10/11 16:12:37 Member z -1 // aaa
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 StructLit struct{x int; y string} 0 false
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Val a struct{x int; y string}
2025/10/11 16:12:37 Member z -1 // struct{x int; y string}
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrMemberRef (0.00s)
=== RUN   TestErrLabel
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:1:1
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Label foo
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [i]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 Label foo
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 VarRef i int
2025/10/11 16:12:37 IncDec ++
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:1:1
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:1:1
2025/10/11 16:12:37 DefineVarStart [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Break
2025/10/11 16:12:37 End // Func
--- PASS: TestErrLabel (0.00s)
=== RUN   TestErrBranchStmt
2025/10/11 16:12:37 ==> Preload func foo
2025/10/11 16:12:37 ==> Load func foo
2025/10/11 16:12:37 NewFunc foo func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // Func
--- PASS: TestErrBranchStmt (0.00s)
=== RUN   TestErrNoEntrypoint
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:1:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:1:1
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func init
2025/10/11 16:12:37 ==> Load func init
2025/10/11 16:12:37 NewFunc init func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrNoEntrypoint (0.00s)
=== RUN   TestErrTypeRedefine
2025/10/11 16:12:37 ==> Preload method Point.String
2025/10/11 16:12:37 ==> Preload type Point
2025/10/11 16:12:37 ==> Preload type Point
2025/10/11 16:12:37 ==> Load > NewType Point
2025/10/11 16:12:37 NewType Point
2025/10/11 16:12:37 ==> Load > InitType Point
2025/10/11 16:12:37 InitType Point struct{X int; Y int}
2025/10/11 16:12:37 ==> LookupParent Point => type Point struct{X int; Y int}
2025/10/11 16:12:37 ==> Load method *Point.String
2025/10/11 16:12:37 NewFunc String (*Point) func() string
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Val Sprintf func(format string, a ...any) string
2025/10/11 16:12:37 Val &{0 STRING "%v-%v"} *ast.BasicLit
2025/10/11 16:12:37 Val p *Point
2025/10/11 16:12:37 Member X 2 // *Point
2025/10/11 16:12:37 Val p *Point
2025/10/11 16:12:37 Member Y 2 // *Point
2025/10/11 16:12:37 Call 3 0 // func(format string, a ...any) string
2025/10/11 16:12:37 ==> MatchFuncCall func(format string, a ...any) string args: 3 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("%v-%v"), string
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 ==> MatchType int, any
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType string, string
2025/10/11 16:12:37 End // Func
--- PASS: TestErrTypeRedefine (0.00s)
=== RUN   TestErrSwitchDuplicate
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var int [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Switch
2025/10/11 16:12:37 Val n int
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // Switch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var int [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Switch
2025/10/11 16:12:37 Val n int
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val int int
2025/10/11 16:12:37 Val type int => Typ int
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: int}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: int} args: 1 flags: 0
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // Switch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var int [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Switch
2025/10/11 16:12:37 Val n int
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 INT 50} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 50} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (50), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (50), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // Switch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var interface{} [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Switch
2025/10/11 16:12:37 Val n interface{}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val uint uint
2025/10/11 16:12:37 Val type uint => Typ uint
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: uint}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: uint} args: 1 flags: 0
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val int int
2025/10/11 16:12:37 Val type int => Typ int
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: int}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: int} args: 1 flags: 0
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // Switch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var interface{} [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Switch
2025/10/11 16:12:37 Val n interface{}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 FLOAT 100.0} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 FLOAT 100.0} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // Switch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [v]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var interface{} [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 ==> Load const [v] <nil>
2025/10/11 16:12:37 NewConst [v] 0
2025/10/11 16:12:37 Val &{0 FLOAT 100.0} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Switch
2025/10/11 16:12:37 Val n interface{}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 FLOAT 100.0} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val v untyped float
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // Switch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [v]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var interface{} [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 ==> Load const [v] <nil>
2025/10/11 16:12:37 NewConst [v] 0
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Switch
2025/10/11 16:12:37 Val n interface{}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val v untyped string
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // Switch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var int [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Switch
2025/10/11 16:12:37 Val n int
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Val &{0 INT 50} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 50} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp +
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (50), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (50), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // Switch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var interface{} [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Switch
2025/10/11 16:12:37 Val n interface{}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // Switch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var interface{} [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Switch
2025/10/11 16:12:37 Val n interface{}
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 Case
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 End // Case
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // Switch
2025/10/11 16:12:37 End // Func
--- PASS: TestErrSwitchDuplicate (0.01s)
=== RUN   TestErrTypeSwitchDuplicate
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var interface{} [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped int (100), interface{}
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 TypeSwitch
2025/10/11 16:12:37 Val n interface{}
2025/10/11 16:12:37 TypeAssertThen
2025/10/11 16:12:37 TypeCase
2025/10/11 16:12:37 Val int int
2025/10/11 16:12:37 Val type int => Typ int
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // TypeCase
2025/10/11 16:12:37 TypeCase
2025/10/11 16:12:37 Val int int
2025/10/11 16:12:37 Val type int => Typ int
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // TypeCase
2025/10/11 16:12:37 TypeCase
2025/10/11 16:12:37 Val int int
2025/10/11 16:12:37 Val type int => Typ int
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 End // TypeCase
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // TypeSwitch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var interface{} [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped int (100), interface{}
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 TypeSwitch
2025/10/11 16:12:37 Val n interface{}
2025/10/11 16:12:37 TypeAssertThen
2025/10/11 16:12:37 TypeCase
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // TypeCase
2025/10/11 16:12:37 TypeCase
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // TypeCase
2025/10/11 16:12:37 TypeCase
2025/10/11 16:12:37 Val nil untyped nil
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 End // TypeCase
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // TypeSwitch
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [n]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var interface{} [n]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [n]
2025/10/11 16:12:37 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped int (100), interface{}
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 TypeSwitch
2025/10/11 16:12:37 Val n interface{}
2025/10/11 16:12:37 TypeAssertThen
2025/10/11 16:12:37 TypeCase
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 End // TypeCase
2025/10/11 16:12:37 TypeCase
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 End // TypeCase
2025/10/11 16:12:37 TypeCase
2025/10/11 16:12:37 Then
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:5:1
2025/10/11 16:12:37 End // TypeCase
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 End // TypeSwitch
2025/10/11 16:12:37 End // Func
--- PASS: TestErrTypeSwitchDuplicate (0.00s)
=== RUN   TestErrAutoProperty
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:4:1
2025/10/11 16:12:37 DefineVarStart [n err]
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrAutoProperty (0.00s)
=== RUN   TestFiledsNameRedecl
2025/10/11 16:12:37 ==> Preload type Id
2025/10/11 16:12:37 ==> Preload type A
2025/10/11 16:12:37 ==> Load > NewType Id
2025/10/11 16:12:37 NewType Id
2025/10/11 16:12:37 ==> Load > InitType Id
2025/10/11 16:12:37 InitType Id struct{}
2025/10/11 16:12:37 ==> Load > NewType A
2025/10/11 16:12:37 NewType A
2025/10/11 16:12:37 ==> Load > InitType A
2025/10/11 16:12:37 ==> LookupParent Id => type Id struct{}
2025/10/11 16:12:37 InitType A struct{Id int; name string}
--- PASS: TestFiledsNameRedecl (0.00s)
=== RUN   TestErrImportPkg
--- PASS: TestErrImportPkg (0.02s)
=== RUN   TestErrClassFileGopx
2025/10/11 16:12:37 ==> Preload type Rect
2025/10/11 16:12:37 ==> Preload type A
2025/10/11 16:12:37 ==> Preload method Rect.Main
2025/10/11 16:12:37 ==> Load > NewType Rect
2025/10/11 16:12:37 NewType Rect
2025/10/11 16:12:37 ==> Load > NewType A
2025/10/11 16:12:37 NewType A
2025/10/11 16:12:37 ==> Load > InitType A
2025/10/11 16:12:37 InitType A struct{}
2025/10/11 16:12:37 ==> Load > InitType Rect
2025/10/11 16:12:37 ==> LookupParent A => type A struct{}
2025/10/11 16:12:37 ==> LookupParent A => type A struct{}
2025/10/11 16:12:37 InitType Rect struct{A; i int}
2025/10/11 16:12:37 ==> LookupParent Rect => type Rect struct{A; i int}
2025/10/11 16:12:37 ==> Load method *Rect.Main
2025/10/11 16:12:37 NewFunc Main (*Rect) func()
2025/10/11 16:12:37 SetComments 0
//line Rect.gox:8:1
2025/10/11 16:12:37 Val this *Rect
2025/10/11 16:12:37 Member println 1 // *Rect
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("hello"), any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 Val Rect Rect
2025/10/11 16:12:37 Val type Rect struct{A; i int} => Typ Rect
2025/10/11 16:12:37 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:37 Member Main 0 // *Rect
2025/10/11 16:12:37 Call 0 0 // func()
2025/10/11 16:12:37 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:37 End // Func
--- PASS: TestErrClassFileGopx (0.00s)
=== RUN   TestErrVarInFunc
2025/10/11 16:12:37 ==> Preload func set
2025/10/11 16:12:37 ==> Preload func test
2025/10/11 16:12:37 ==> Load func set
2025/10/11 16:12:37 NewFunc set func(name string, v int) string
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Val name string
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType string, string
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func test
2025/10/11 16:12:37 NewFunc test func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:6:1
2025/10/11 16:12:37 ==> Load var <nil> [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val set func(name string, v int) string
2025/10/11 16:12:37 Val &{0 STRING "box"} *ast.BasicLit
2025/10/11 16:12:37 Call 1 0 // func(name string, v int) string
2025/10/11 16:12:37 ==> MatchFuncCall func(name string, v int) string args: 1 flags: 0
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:7:1
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrVarInFunc (0.00s)
=== RUN   TestErrInt128
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 127} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <<
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (127), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped int (170141183460469231731687303715884105728), github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val int128 github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:37 Val type int128 = github.com/qiniu/x/xgo/ng.Int128 => Typ github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 127} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <<
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (127), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Int128} args: 1 flags: 0
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val int128 github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:37 Val type int128 = github.com/qiniu/x/xgo/ng.Int128 => Typ github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 UnaryOp - flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 Val &{0 INT 127} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <<
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (-1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (127), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp -
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (-170141183460469231731687303715884105728), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Int128} args: 1 flags: 0
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [b]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load const [b] <nil>
2025/10/11 16:12:37 NewConst [b] 0
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 UnaryOp - flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 Val &{0 INT 127} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <<
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (-1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (127), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp -
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (-170141183460469231731687303715884105728), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped int}
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val int128 github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:37 Val type int128 = github.com/qiniu/x/xgo/ng.Int128 => Typ github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:37 Val b untyped int
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Int128} args: 1 flags: 0
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrInt128 (0.00s)
=== RUN   TestErrUint128
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 128} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <<
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (128), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped int (340282366920938463463374607431768211456), github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val uint128 github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val type uint128 = github.com/qiniu/x/xgo/ng.Uint128 => Typ github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 128} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <<
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (128), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128} args: 1 flags: 0
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 UnaryOp - flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped int (-1), github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val uint128 github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val type uint128 = github.com/qiniu/x/xgo/ng.Uint128 => Typ github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 UnaryOp - flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128} args: 1 flags: 0
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [b]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load const [b] <nil>
2025/10/11 16:12:37 NewConst [b] 0
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 UnaryOp - flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 DefineVarStart [a]
2025/10/11 16:12:37 Val uint128 github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val type uint128 = github.com/qiniu/x/xgo/ng.Uint128 => Typ github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val b untyped int
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128} args: 1 flags: 0
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrUint128 (0.00s)
=== RUN   TestErrCompileFunc
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:2:1
2025/10/11 16:12:37 Val printf func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "%+v\n"} *ast.BasicLit
2025/10/11 16:12:37 Val int32 int32
2025/10/11 16:12:37 Val type int32 => Typ int32
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("%+v\n"), string
2025/10/11 16:12:37 ==> MatchType TypeType{typ: int32}, any
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestErrCompileFunc (0.00s)
=== RUN   TestToTypeError
2025/10/11 16:12:37 ==> Preload type a
2025/10/11 16:12:37 ==> Load > NewType a
2025/10/11 16:12:37 NewType a
2025/10/11 16:12:37 ==> Load > InitType a
2025/10/11 16:12:37 InitType a invalid type
--- PASS: TestToTypeError (0.00s)
=== RUN   TestCompileExprError
2025/10/11 16:12:37 ==> Preload func Foo
2025/10/11 16:12:37 ==> Preload func _
2025/10/11 16:12:37 ==> Load func Foo
2025/10/11 16:12:37 NewFunc Foo func()
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Load func _
2025/10/11 16:12:37 NewFunc _ func()
2025/10/11 16:12:37 SetComments 0
//line bar.go:4:1
2025/10/11 16:12:37 Val Foo func()
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload func _
2025/10/11 16:12:37 ==> Load func _
2025/10/11 16:12:37 NewFunc _ func()
2025/10/11 16:12:37 SetComments 0
//line bar.go:3:1
2025/10/11 16:12:37 ResetStmt
2025/10/11 16:12:37 End // Func
--- PASS: TestCompileExprError (0.00s)
=== RUN   TestOverloadFuncDecl
2025/10/11 16:12:37 NewConstDefs
2025/10/11 16:12:37 ==> Preload const [Gopo_mul]
2025/10/11 16:12:37 ==> Load const [Gopo_mul] <nil>
2025/10/11 16:12:37 NewConst [Gopo_mul] 0
2025/10/11 16:12:37 Val &{0 STRING "println"} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
--- PASS: TestOverloadFuncDecl (0.00s)
=== RUN   TestCompositeLitError
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var [][]int [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:37 SliceLit []int 3 false
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val a [][]int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType [][]int, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var []int [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val a []int
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType []int, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load var []func(int) string [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 NewClosure func(x int) string
2025/10/11 16:12:37 Val x int
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType int, string
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 SetComments 0
//line bar.xgo:3:1
2025/10/11 16:12:37 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val a []func(int) string
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType []func(int) string, any
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var map[interface{}]int [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val &{0 STRING "A"} *ast.BasicLit
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var map[interface{}]func(int) string [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val &{0 STRING "A"} *ast.BasicLit
2025/10/11 16:12:37 NewClosure func(x int) string
2025/10/11 16:12:37 Val x int
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType int, string
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var <nil> [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 ResetInit
2025/10/11 16:12:37 ==> Preload var [a]
2025/10/11 16:12:37 ==> Load var <nil> [a]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [a]
2025/10/11 16:12:37 Val 0 int
2025/10/11 16:12:37 ResetInit
--- PASS: TestCompositeLitError (0.00s)
=== RUN   TestUint128_run
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 Block
2025/10/11 16:12:37 ==> Load var string [name]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [name]
2025/10/11 16:12:37 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [age]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [age]
2025/10/11 16:12:37 Val Sscanf func(str string, format string, a ...any) (n int, err error)
2025/10/11 16:12:37 Val &{0 STRING "Kim is 22 years old"} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 STRING "%s is %d years old"} *ast.BasicLit
2025/10/11 16:12:37 Val name string
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 Val age github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 UnaryOp & flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:37 Call 4 0 // func(str string, format string, a ...any) (n int, err error)
2025/10/11 16:12:37 ==> MatchFuncCall func(str string, format string, a ...any) (n int, err error) args: 4 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("Kim is 22 years old"), string
2025/10/11 16:12:37 ==> MatchType untyped string ("%s is %d years old"), string
2025/10/11 16:12:37 ==> MatchType *string, any
2025/10/11 16:12:37 ==> MatchType *github.com/qiniu/x/xgo/ng.Uint128, any
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val name string
2025/10/11 16:12:37 Val age github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType string, any
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/10/11 16:12:37 End // Block
2025/10/11 16:12:37 Block
2025/10/11 16:12:37 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/10/11 16:12:37 ==> Load var <nil> [y]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [y]
2025/10/11 16:12:37 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 UnaryOp + flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func() (v github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 32
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 VarRef x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 IncDec ++
2025/10/11 16:12:37 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Uint128}, *github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 VarRef x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:37 AssignOp += Gop_AddAssign
2025/10/11 16:12:37 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Uint128) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Uint128}, *github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> MatchType untyped int (10), github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (10), int
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val y github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/10/11 16:12:37 End // Block
2025/10/11 16:12:37 Block
2025/10/11 16:12:37 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <<
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (36893488147419103232), int
2025/10/11 16:12:37 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/10/11 16:12:37 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:37 NewClosure func() *math/big.Int
2025/10/11 16:12:37 DefineVarStart [v _]
2025/10/11 16:12:37 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 Typ math/big.Int
2025/10/11 16:12:37 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:37 Member SetString 0 // *math/big.Int
2025/10/11 16:12:37 Val 36893488147419103232 string
2025/10/11 16:12:37 Val 10 int
2025/10/11 16:12:37 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/10/11 16:12:37 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("36893488147419103232"), string
2025/10/11 16:12:37 ==> MatchType untyped int (10), int
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val v *math/big.Int
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType *math/big.Int, *math/big.Int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 0 0 // func() *math/big.Int
2025/10/11 16:12:37 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/10/11 16:12:37 ==> Load var <nil> [y]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [y]
2025/10/11 16:12:37 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val &{0 INT 63} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp >>
2025/10/11 16:12:37 Typ github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/10/11 16:12:37 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Uint128, n uint) github.com/qiniu/x/xgo/ng.Uint128 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> MatchType untyped int (63), uint
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> Load var <nil> [z]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [z]
2025/10/11 16:12:37 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp >>
2025/10/11 16:12:37 Typ github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/10/11 16:12:37 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Uint128, n uint) github.com/qiniu/x/xgo/ng.Uint128 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> MatchType untyped int (65), uint
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val y github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val z github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/10/11 16:12:37 End // Block
2025/10/11 16:12:37 Block
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val uint128 github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val type uint128 = github.com/qiniu/x/xgo/ng.Uint128 => Typ github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <<
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128} args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v int) github.com/qiniu/x/xgo/ng.Uint128 args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (36893488147419103232), int
2025/10/11 16:12:37 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/10/11 16:12:37 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Uint128 args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:37 NewClosure func() *math/big.Int
2025/10/11 16:12:37 DefineVarStart [v _]
2025/10/11 16:12:37 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 Typ math/big.Int
2025/10/11 16:12:37 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:37 Member SetString 0 // *math/big.Int
2025/10/11 16:12:37 Val 36893488147419103232 string
2025/10/11 16:12:37 Val 10 int
2025/10/11 16:12:37 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/10/11 16:12:37 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("36893488147419103232"), string
2025/10/11 16:12:37 ==> MatchType untyped int (10), int
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val v *math/big.Int
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType *math/big.Int, *math/big.Int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 0 0 // func() *math/big.Int
2025/10/11 16:12:37 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/10/11 16:12:37 Val uint128 github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val type uint128 = github.com/qiniu/x/xgo/ng.Uint128 => Typ github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Call 0 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128} args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v int) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v uint64) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v uint32) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v uint16) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v uint8) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v int64) (out github.com/qiniu/x/xgo/ng.Uint128) args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v int64) (out github.com/qiniu/x/xgo/ng.Uint128, inRange bool) args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v *math/big.Int) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v *math/big.Int) (out github.com/qiniu/x/xgo/ng.Uint128, inRange bool) args: 0 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func() github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128 (36893488147419103232), any
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/10/11 16:12:37 End // Block
2025/10/11 16:12:37 Block
2025/10/11 16:12:37 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), int
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/10/11 16:12:37 Val printf func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val &{0 STRING "%4d\n"} *ast.BasicLit
2025/10/11 16:12:37 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("%4d\n"), string
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/10/11 16:12:37 End // Block
2025/10/11 16:12:37 Block
2025/10/11 16:12:37 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [x]
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp <<
2025/10/11 16:12:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (36893488147419103232), int
2025/10/11 16:12:37 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/10/11 16:12:37 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:37 NewClosure func() *math/big.Int
2025/10/11 16:12:37 DefineVarStart [v _]
2025/10/11 16:12:37 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 Typ math/big.Int
2025/10/11 16:12:37 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:37 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:37 Member SetString 0 // *math/big.Int
2025/10/11 16:12:37 Val 36893488147419103232 string
2025/10/11 16:12:37 Val 10 int
2025/10/11 16:12:37 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/10/11 16:12:37 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType untyped string ("36893488147419103232"), string
2025/10/11 16:12:37 ==> MatchType untyped int (10), int
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val v *math/big.Int
2025/10/11 16:12:37 Return 1
2025/10/11 16:12:37 ==> MatchType *math/big.Int, *math/big.Int
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 Call 0 0 // func() *math/big.Int
2025/10/11 16:12:37 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/10/11 16:12:37 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/10/11 16:12:37 ==> Load var <nil> [y]
2025/10/11 16:12:37 NewVarDefs
2025/10/11 16:12:37 NewVar [y]
2025/10/11 16:12:37 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp >>
2025/10/11 16:12:37 Typ github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/10/11 16:12:37 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Uint128, n uint) github.com/qiniu/x/xgo/ng.Uint128 args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> MatchType untyped int (2), uint
2025/10/11 16:12:37 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:37 BinaryOp -
2025/10/11 16:12:37 Typ github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Member Gop_Sub 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchFuncCall func(u github.com/qiniu/x/xgo/ng.Uint128, n uint64) (v github.com/qiniu/x/xgo/ng.Uint128) args: 2 flags: 64
2025/10/11 16:12:37 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 ==> MatchType untyped int (1), uint64
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 DefineVarStart [v1 ok1]
2025/10/11 16:12:37 Val int64 int64
2025/10/11 16:12:37 Val type int64 => Typ int64
2025/10/11 16:12:37 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Call 1 2 // TypeType{typ: int64}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/10/11 16:12:37 Val &{x github.com/qiniu/x/xgo/ng.Uint128 <nil> x} *internal.Elem
2025/10/11 16:12:37 Member Gop_Rcast__4 0 // github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Call 0 2 // func() (out int64, inRange bool)
2025/10/11 16:12:37 ==> MatchFuncCall func() (out int64, inRange bool) args: 0 flags: 2
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 DefineVarStart [v2 ok2]
2025/10/11 16:12:37 Val int64 int64
2025/10/11 16:12:37 Val type int64 => Typ int64
2025/10/11 16:12:37 Val y github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Call 1 2 // TypeType{typ: int64}
2025/10/11 16:12:37 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/10/11 16:12:37 Val &{y github.com/qiniu/x/xgo/ng.Uint128 <nil> y} *internal.Elem
2025/10/11 16:12:37 Member Gop_Rcast__4 0 // github.com/qiniu/x/xgo/ng.Uint128
2025/10/11 16:12:37 Call 0 2 // func() (out int64, inRange bool)
2025/10/11 16:12:37 ==> MatchFuncCall func() (out int64, inRange bool) args: 0 flags: 2
2025/10/11 16:12:37 EndInit 1
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val v1 int64
2025/10/11 16:12:37 Val ok1 bool
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int64, any
2025/10/11 16:12:37 ==> MatchType bool, any
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 Val v2 int64
2025/10/11 16:12:37 Val ok2 bool
2025/10/11 16:12:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:37 ==> MatchType int64, any
2025/10/11 16:12:37 ==> MatchType bool, any
2025/10/11 16:12:37 End // Block
2025/10/11 16:12:37 End // Func
2025/10/11 16:12:37 ==> ASTFile
--- PASS: TestUint128_run (0.44s)
=== RUN   TestInt128_run
2025/10/11 16:12:38 ==> Preload func main
2025/10/11 16:12:38 ==> Load func main
2025/10/11 16:12:38 NewFunc main func()
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var string [name]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [name]
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [age]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [age]
2025/10/11 16:12:38 Val Sscanf func(str string, format string, a ...any) (n int, err error)
2025/10/11 16:12:38 Val &{0 STRING "Kim is 22 years old"} *ast.BasicLit
2025/10/11 16:12:38 Val &{0 STRING "%s is %d years old"} *ast.BasicLit
2025/10/11 16:12:38 Val name string
2025/10/11 16:12:38 UnaryOp & flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:38 Val age github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 UnaryOp & flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:38 Call 4 0 // func(str string, format string, a ...any) (n int, err error)
2025/10/11 16:12:38 ==> MatchFuncCall func(str string, format string, a ...any) (n int, err error) args: 4 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped string ("Kim is 22 years old"), string
2025/10/11 16:12:38 ==> MatchType untyped string ("%s is %d years old"), string
2025/10/11 16:12:38 ==> MatchType *string, any
2025/10/11 16:12:38 ==> MatchType *github.com/qiniu/x/xgo/ng.Int128, any
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val name string
2025/10/11 16:12:38 Val age github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType string, any
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [x]
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), int
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/10/11 16:12:38 ==> Load var <nil> [y]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [y]
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 UnaryOp + flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func() (v github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 32
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 VarRef x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 IncDec ++
2025/10/11 16:12:38 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Int128}, *github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 VarRef x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:38 AssignOp += Gop_AddAssign
2025/10/11 16:12:38 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Int128) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Int128}, *github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchType untyped int (10), github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (10), int
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Val y github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [x]
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp <<
2025/10/11 16:12:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), int
2025/10/11 16:12:38 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/10/11 16:12:38 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:38 NewClosure func() *math/big.Int
2025/10/11 16:12:38 DefineVarStart [v _]
2025/10/11 16:12:38 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 Typ math/big.Int
2025/10/11 16:12:38 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:38 Member SetString 0 // *math/big.Int
2025/10/11 16:12:38 Val 36893488147419103232 string
2025/10/11 16:12:38 Val 10 int
2025/10/11 16:12:38 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/10/11 16:12:38 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped string ("36893488147419103232"), string
2025/10/11 16:12:38 ==> MatchType untyped int (10), int
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 Val v *math/big.Int
2025/10/11 16:12:38 Return 1
2025/10/11 16:12:38 ==> MatchType *math/big.Int, *math/big.Int
2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 Call 0 0 // func() *math/big.Int
2025/10/11 16:12:38 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/10/11 16:12:38 ==> Load var <nil> [y]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [y]
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Val &{0 INT 63} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp >>
2025/10/11 16:12:38 Typ github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/10/11 16:12:38 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Int128, n uint) github.com/qiniu/x/xgo/ng.Int128 args: 2 flags: 64
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchType untyped int (63), uint
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> Load var <nil> [z]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [z]
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp >>
2025/10/11 16:12:38 Typ github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/10/11 16:12:38 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Int128, n uint) github.com/qiniu/x/xgo/ng.Int128 args: 2 flags: 64
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchType untyped int (65), uint
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val y github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Val z github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val int128 github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Val type int128 = github.com/qiniu/x/xgo/ng.Int128 => Typ github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp <<
2025/10/11 16:12:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/10/11 16:12:38 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Int128} args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int) github.com/qiniu/x/xgo/ng.Int128 args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), int
2025/10/11 16:12:38 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/10/11 16:12:38 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:38 NewClosure func() *math/big.Int
2025/10/11 16:12:38 DefineVarStart [v _]
2025/10/11 16:12:38 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 Typ math/big.Int
2025/10/11 16:12:38 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:38 Member SetString 0 // *math/big.Int
2025/10/11 16:12:38 Val 36893488147419103232 string
2025/10/11 16:12:38 Val 10 int
2025/10/11 16:12:38 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/10/11 16:12:38 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped string ("36893488147419103232"), string
2025/10/11 16:12:38 ==> MatchType untyped int (10), int
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 Val v *math/big.Int
2025/10/11 16:12:38 Return 1
2025/10/11 16:12:38 ==> MatchType *math/big.Int, *math/big.Int
2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 Call 0 0 // func() *math/big.Int
2025/10/11 16:12:38 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/10/11 16:12:38 Val int128 github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Val type int128 = github.com/qiniu/x/xgo/ng.Int128 => Typ github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 0 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/10/11 16:12:38 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Int128} args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Int128) args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int64) (out github.com/qiniu/x/xgo/ng.Int128) args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v uint64) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int32) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int16) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int8) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.Uint128) (out github.com/qiniu/x/xgo/ng.Int128) args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v *math/big.Int) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v *math/big.Int) (out github.com/qiniu/x/xgo/ng.Int128, inRange bool) args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func() github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128 (36893488147419103232), any
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [x]
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), int
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/10/11 16:12:38 Val printf func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val &{0 STRING "%4d\n"} *ast.BasicLit
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped string ("%4d\n"), string
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [x]
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp <<
2025/10/11 16:12:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), int
2025/10/11 16:12:38 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/10/11 16:12:38 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:38 NewClosure func() *math/big.Int
2025/10/11 16:12:38 DefineVarStart [v _]
2025/10/11 16:12:38 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 Typ math/big.Int
2025/10/11 16:12:38 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:38 Member SetString 0 // *math/big.Int
2025/10/11 16:12:38 Val 36893488147419103232 string
2025/10/11 16:12:38 Val 10 int
2025/10/11 16:12:38 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/10/11 16:12:38 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped string ("36893488147419103232"), string
2025/10/11 16:12:38 ==> MatchType untyped int (10), int
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 Val v *math/big.Int
2025/10/11 16:12:38 Return 1
2025/10/11 16:12:38 ==> MatchType *math/big.Int, *math/big.Int
2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 Call 0 0 // func() *math/big.Int
2025/10/11 16:12:38 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/10/11 16:12:38 ==> Load var <nil> [y]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [y]
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp >>
2025/10/11 16:12:38 Typ github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/10/11 16:12:38 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Int128, n uint) github.com/qiniu/x/xgo/ng.Int128 args: 2 flags: 64
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchType untyped int (2), uint
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp -
2025/10/11 16:12:38 Typ github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Member Gop_Sub 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/10/11 16:12:38 ==> MatchFuncCall func(i github.com/qiniu/x/xgo/ng.Int128, n int64) (v github.com/qiniu/x/xgo/ng.Int128) args: 2 flags: 64
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchType untyped int (1), int64
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 DefineVarStart [v1 ok1]
2025/10/11 16:12:38 Val int64 int64
2025/10/11 16:12:38 Val type int64 => Typ int64
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 1 2 // TypeType{typ: int64}
2025/10/11 16:12:38 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/10/11 16:12:38 Val &{x github.com/qiniu/x/xgo/ng.Int128 <nil> x} *internal.Elem
2025/10/11 16:12:38 Member Gop_Rcast__3 0 // github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 0 2 // func() (out int64, inRange bool)
2025/10/11 16:12:38 ==> MatchFuncCall func() (out int64, inRange bool) args: 0 flags: 2
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 DefineVarStart [v2 ok2]
2025/10/11 16:12:38 Val int64 int64
2025/10/11 16:12:38 Val type int64 => Typ int64
2025/10/11 16:12:38 Val y github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 1 2 // TypeType{typ: int64}
2025/10/11 16:12:38 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/10/11 16:12:38 Val &{y github.com/qiniu/x/xgo/ng.Int128 <nil> y} *internal.Elem
2025/10/11 16:12:38 Member Gop_Rcast__3 0 // github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 0 2 // func() (out int64, inRange bool)
2025/10/11 16:12:38 ==> MatchFuncCall func() (out int64, inRange bool) args: 0 flags: 2
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val v1 int64
2025/10/11 16:12:38 Val ok1 bool
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType int64, any
2025/10/11 16:12:38 ==> MatchType bool, any
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val v2 int64
2025/10/11 16:12:38 Val ok2 bool
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType int64, any
2025/10/11 16:12:38 ==> MatchType bool, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [x]
2025/10/11 16:12:38 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> MatchType untyped int (0), github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (0), int
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/10/11 16:12:38 VarRef x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 IncDec --
2025/10/11 16:12:38 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Int128}, *github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Int128
2025/10/11 16:12:38 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 ==> ASTFile
--- PASS: TestInt128_run (0.38s)
=== RUN   TestBigint_run
2025/10/11 16:12:38 ==> Preload func main
2025/10/11 16:12:38 ==> Load func main
2025/10/11 16:12:38 NewFunc main func()
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [x]
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), int
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/10/11 16:12:38 ==> Load var <nil> [y]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [y]
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 UnaryOp + flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func() github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 32
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 IncDec ++
2025/10/11 16:12:38 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:12:38 AssignOp += Gop_AddAssign
2025/10/11 16:12:38 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Bigint) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchType untyped int (10), github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (10), int
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Val y github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [x]
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp <<
2025/10/11 16:12:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), int
2025/10/11 16:12:38 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/10/11 16:12:38 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:38 NewClosure func() *math/big.Int
2025/10/11 16:12:38 DefineVarStart [v _]
2025/10/11 16:12:38 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 Typ math/big.Int
2025/10/11 16:12:38 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:38 Member SetString 0 // *math/big.Int
2025/10/11 16:12:38 Val 36893488147419103232 string
2025/10/11 16:12:38 Val 10 int
2025/10/11 16:12:38 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/10/11 16:12:38 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped string ("36893488147419103232"), string
2025/10/11 16:12:38 ==> MatchType untyped int (10), int
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 Val v *math/big.Int
2025/10/11 16:12:38 Return 1
2025/10/11 16:12:38 ==> MatchType *math/big.Int, *math/big.Int
2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 Call 0 0 // func() *math/big.Int
2025/10/11 16:12:38 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/10/11 16:12:38 ==> Load var <nil> [y]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [y]
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Val &{0 INT 63} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp >>
2025/10/11 16:12:38 Typ github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/10/11 16:12:38 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigint, n uint) github.com/qiniu/x/xgo/ng.Bigint args: 2 flags: 64
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchType untyped int (63), uint
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> Load var <nil> [z]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [z]
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp >>
2025/10/11 16:12:38 Typ github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/10/11 16:12:38 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigint, n uint) github.com/qiniu/x/xgo/ng.Bigint args: 2 flags: 64
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchType untyped int (65), uint
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val y github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Val z github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val bigint github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Val type bigint = github.com/qiniu/x/xgo/ng.Bigint => Typ github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp <<
2025/10/11 16:12:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/10/11 16:12:38 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint} args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), int
2025/10/11 16:12:38 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/10/11 16:12:38 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:38 NewClosure func() *math/big.Int
2025/10/11 16:12:38 DefineVarStart [v _]
2025/10/11 16:12:38 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 Typ math/big.Int
2025/10/11 16:12:38 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:38 Member SetString 0 // *math/big.Int
2025/10/11 16:12:38 Val 36893488147419103232 string
2025/10/11 16:12:38 Val 10 int
2025/10/11 16:12:38 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/10/11 16:12:38 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped string ("36893488147419103232"), string
2025/10/11 16:12:38 ==> MatchType untyped int (10), int
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 Val v *math/big.Int
2025/10/11 16:12:38 Return 1
2025/10/11 16:12:38 ==> MatchType *math/big.Int, *math/big.Int
2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 Call 0 0 // func() *math/big.Int
2025/10/11 16:12:38 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/10/11 16:12:38 Val bigint github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Val type bigint = github.com/qiniu/x/xgo/ng.Bigint => Typ github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Call 0 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/10/11 16:12:38 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint} args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x int64) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x uint64) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x uint) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x *math/big.Int) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x *math/big.Rat) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func() github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [x]
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), int
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/10/11 16:12:38 Val printf func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val &{0 STRING "%4d\n"} *ast.BasicLit
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped string ("%4d\n"), string
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [x]
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 Val &{0 INT 65} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp <<
2025/10/11 16:12:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), int
2025/10/11 16:12:38 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/10/11 16:12:38 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/10/11 16:12:38 NewClosure func() *math/big.Int
2025/10/11 16:12:38 DefineVarStart [v _]
2025/10/11 16:12:38 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 Typ math/big.Int
2025/10/11 16:12:38 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:38 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:38 Member SetString 0 // *math/big.Int
2025/10/11 16:12:38 Val 36893488147419103232 string
2025/10/11 16:12:38 Val 10 int
2025/10/11 16:12:38 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/10/11 16:12:38 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped string ("36893488147419103232"), string
2025/10/11 16:12:38 ==> MatchType untyped int (10), int
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 Val v *math/big.Int
2025/10/11 16:12:38 Return 1
2025/10/11 16:12:38 ==> MatchType *math/big.Int, *math/big.Int
2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 Call 0 0 // func() *math/big.Int
2025/10/11 16:12:38 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/10/11 16:12:38 ==> Load var <nil> [y]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [y]
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp >>
2025/10/11 16:12:38 Typ github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/10/11 16:12:38 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigint, n uint) github.com/qiniu/x/xgo/ng.Bigint args: 2 flags: 64
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchType untyped int (2), uint
2025/10/11 16:12:38 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:38 BinaryOp -
2025/10/11 16:12:38 Typ github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Member Gop_Sub 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/10/11 16:12:38 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigint, b github.com/qiniu/x/xgo/ng.Bigint) github.com/qiniu/x/xgo/ng.Bigint args: 2 flags: 64
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (1), int
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 DefineVarStart [v1 ok1]
2025/10/11 16:12:38 Val int64 int64
2025/10/11 16:12:38 Val type int64 => Typ int64
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Call 1 2 // TypeType{typ: int64}
2025/10/11 16:12:38 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/10/11 16:12:38 Val &{x github.com/qiniu/x/xgo/ng.Bigint <nil> x} *internal.Elem
2025/10/11 16:12:38 Member Gop_Rcast__1 0 // github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Call 0 2 // func() (int64, bool)
2025/10/11 16:12:38 ==> MatchFuncCall func() (int64, bool) args: 0 flags: 2
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 DefineVarStart [v2 ok2]
2025/10/11 16:12:38 Val int64 int64
2025/10/11 16:12:38 Val type int64 => Typ int64
2025/10/11 16:12:38 Val y github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Call 1 2 // TypeType{typ: int64}
2025/10/11 16:12:38 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/10/11 16:12:38 Val &{y github.com/qiniu/x/xgo/ng.Bigint <nil> y} *internal.Elem
2025/10/11 16:12:38 Member Gop_Rcast__1 0 // github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Call 0 2 // func() (int64, bool)
2025/10/11 16:12:38 ==> MatchFuncCall func() (int64, bool) args: 0 flags: 2
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val v1 int64
2025/10/11 16:12:38 Val ok1 bool
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType int64, any
2025/10/11 16:12:38 ==> MatchType bool, any
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val v2 int64
2025/10/11 16:12:38 Val ok2 bool
2025/10/11 16:12:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType int64, any
2025/10/11 16:12:38 ==> MatchType bool, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 Block
2025/10/11 16:12:38 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/10/11 16:12:38 NewVarDefs
2025/10/11 16:12:38 NewVar [x]
2025/10/11 16:12:38 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:38 EndInit 1
2025/10/11 16:12:38 ==> MatchType untyped int (0), github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType untyped int (0), int
2025/10/11 16:12:38 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/10/11 16:12:38 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 IncDec --
2025/10/11 16:12:38 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/10/11 16:12:38 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:38 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:38 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/10/11 16:12:38 End // Block
2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 ==> ASTFile
--- PASS: TestBigint_run (0.40s)
=== RUN   TestTypeParams
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Preload method Data.foo
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[X, Y interface{}] struct{v X}
2025/10/11 16:12:39 ==> Load method *github.com/goplus/xgo/cl.Data[X, Y interface{}].foo
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 DefineVarStart [v]
2025/10/11 16:12:39 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[X, Y interface{}] struct{v X}
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.Data[int, float64] 1 false
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 Val v github.com/goplus/xgo/cl.Data[int, float64]
2025/10/11 16:12:39 Member foo 1 // github.com/goplus/xgo/cl.Data[int, float64]
2025/10/11 16:12:39 Call 0 0 // func()
2025/10/11 16:12:39 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 ==> ASTFile
--- PASS: TestTypeParams (0.00s)
=== RUN   TestTypeParamsFunc
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload type Number
2025/10/11 16:12:39 ==> Preload func Sum
2025/10/11 16:12:39 ==> Preload func At
2025/10/11 16:12:39 ==> Preload func Loader
2025/10/11 16:12:39 ==> Preload func Add
2025/10/11 16:12:39 ==> Preload type Int
2025/10/11 16:12:39 ==> Preload var [MyInts]
2025/10/11 16:12:39 ==> Load > NewType Int
2025/10/11 16:12:39 ==> Load > InitType Int
2025/10/11 16:12:39 ==> Load > NewType Number
2025/10/11 16:12:39 ==> Load > InitType Number
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 VarRef _
2025/10/11 16:12:39 ==> Load func At
2025/10/11 16:12:39 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/10/11 16:12:39 Typ []int
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType inferFuncType{typ: func[T interface{interface{~[]E}}, E interface{}](x T, i int) E, targs: [[]int]}
2025/10/11 16:12:39 Assign 1 1
2025/10/11 16:12:39 VarRef _
2025/10/11 16:12:39 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/10/11 16:12:39 Typ []int
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 2 false
2025/10/11 16:12:39 ==> InferType func(x []int, i int) int
2025/10/11 16:12:39 Assign 1 1
2025/10/11 16:12:39 VarRef _
2025/10/11 16:12:39 ==> Load func Sum
2025/10/11 16:12:39 ==> LookupParent Number => type github.com/goplus/xgo/cl.Number interface{interface{~int | ~uint | float64}}
2025/10/11 16:12:39 Val Sum func[T github.com/goplus/xgo/cl.Number](vec []T) T
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType func(vec []int) int
2025/10/11 16:12:39 Assign 1 1
2025/10/11 16:12:39 VarRef _
2025/10/11 16:12:39 ==> Load func Loader
2025/10/11 16:12:39 Val Loader func[T1, T2 interface{}](p1 T1, p2 T2) T1
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Star
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 2 false
2025/10/11 16:12:39 ==> InferType func(p1 *int, p2 int) *int
2025/10/11 16:12:39 Assign 1 1
2025/10/11 16:12:39 VarRef _
2025/10/11 16:12:39 ==> Load func Add
2025/10/11 16:12:39 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 Val string string
2025/10/11 16:12:39 Val type string => Typ string
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 2 false
2025/10/11 16:12:39 ==> InferType func(v1 string, v2 ...int) (sum int)
2025/10/11 16:12:39 Assign 1 1
2025/10/11 16:12:39 ==> Load var int [s1]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [s1]
2025/10/11 16:12:39 Val Sum func[T github.com/goplus/xgo/cl.Number](vec []T) T
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 3 false
2025/10/11 16:12:39 Call 1 0 // func[T github.com/goplus/xgo/cl.Number](vec []T) T
2025/10/11 16:12:39 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.Number](vec []T) T args: 1 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(vec []int) int
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [s2]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [s2]
2025/10/11 16:12:39 Val Sum func[T github.com/goplus/xgo/cl.Number](vec []T) T
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType func(vec []int) int
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 3 false
2025/10/11 16:12:39 Call 1 0 // func(vec []int) int
2025/10/11 16:12:39 ==> MatchFuncCall func(vec []int) int args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [v1]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [v1]
2025/10/11 16:12:39 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 3 false
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/10/11 16:12:39 ==> MatchFuncCall func[T interface{interface{~[]E}}, E interface{}](x T, i int) E args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(x []int, i int) int
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [v2]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [v2]
2025/10/11 16:12:39 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/10/11 16:12:39 Typ []int
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType inferFuncType{typ: func[T interface{interface{~[]E}}, E interface{}](x T, i int) E, targs: [[]int]}
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 3 false
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // inferFuncType{typ: func[T interface{interface{~[]E}}, E interface{}](x T, i int) E, targs: [[]int]}
2025/10/11 16:12:39 ==> MatchFuncCall inferFuncType{typ: func[T interface{interface{~[]E}}, E interface{}](x T, i int) E, targs: [[]int]} args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(x []int, i int) int
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [v3]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [v3]
2025/10/11 16:12:39 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/10/11 16:12:39 Typ []int
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 2 false
2025/10/11 16:12:39 ==> InferType func(x []int, i int) int
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 3 false
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func(x []int, i int) int
2025/10/11 16:12:39 ==> MatchFuncCall func(x []int, i int) int args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [n1]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [n1]
2025/10/11 16:12:39 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Call 4 0 // func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 ==> MatchFuncCall func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2) args: 4 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(v1 string, v2 ...int) (sum int)
2025/10/11 16:12:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 ==> MatchType untyped int (2), int
2025/10/11 16:12:39 ==> MatchType untyped int (3), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [n2]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [n2]
2025/10/11 16:12:39 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 Val string string
2025/10/11 16:12:39 Val type string => Typ string
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]}
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Call 4 0 // inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]}
2025/10/11 16:12:39 ==> MatchFuncCall inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]} args: 4 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(v1 string, v2 ...int) (sum int)
2025/10/11 16:12:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 ==> MatchType untyped int (2), int
2025/10/11 16:12:39 ==> MatchType untyped int (3), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [n3]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [n3]
2025/10/11 16:12:39 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 Val string string
2025/10/11 16:12:39 Val type string => Typ string
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 2 false
2025/10/11 16:12:39 ==> InferType func(v1 string, v2 ...int) (sum int)
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Call 4 0 // func(v1 string, v2 ...int) (sum int)
2025/10/11 16:12:39 ==> MatchFuncCall func(v1 string, v2 ...int) (sum int) args: 4 flags: 0
2025/10/11 16:12:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 ==> MatchType untyped int (2), int
2025/10/11 16:12:39 ==> MatchType untyped int (3), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [n4]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [n4]
2025/10/11 16:12:39 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 3 false
2025/10/11 16:12:39 Call 2 1 // func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 ==> MatchFuncCall func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2) args: 2 flags: 1
2025/10/11 16:12:39 ==> InferFunc func(v1 string, v2 ...int) (sum int)
2025/10/11 16:12:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [n5]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [n5]
2025/10/11 16:12:39 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 3 false
2025/10/11 16:12:39 Call 2 1 // func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 ==> MatchFuncCall func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2) args: 2 flags: 1
2025/10/11 16:12:39 ==> InferFunc func(v1 string, v2 ...int) (sum int)
2025/10/11 16:12:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [n6]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [n6]
2025/10/11 16:12:39 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 Val string string
2025/10/11 16:12:39 Val type string => Typ string
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]}
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 ==> Load var <nil> [MyInts]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [MyInts]
2025/10/11 16:12:39 ==> LookupParent Int => type github.com/goplus/xgo/cl.Int []int
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit github.com/goplus/xgo/cl.Int 4 false
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 Val MyInts github.com/goplus/xgo/cl.Int
2025/10/11 16:12:39 Call 2 1 // inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]}
2025/10/11 16:12:39 ==> MatchFuncCall inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]} args: 2 flags: 1
2025/10/11 16:12:39 ==> InferFunc func(v1 string, v2 ...int) (sum int)
2025/10/11 16:12:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:39 ==> MatchType github.com/goplus/xgo/cl.Int, []int
2025/10/11 16:12:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var int [n7]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [n7]
2025/10/11 16:12:39 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 Val string string
2025/10/11 16:12:39 Val type string => Typ string
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 2 false
2025/10/11 16:12:39 ==> InferType func(v1 string, v2 ...int) (sum int)
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 3 false
2025/10/11 16:12:39 Call 2 1 // func(v1 string, v2 ...int) (sum int)
2025/10/11 16:12:39 ==> MatchFuncCall func(v1 string, v2 ...int) (sum int) args: 2 flags: 1
2025/10/11 16:12:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 ==> Load var *int [p1]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [p1]
2025/10/11 16:12:39 Val Loader func[T1, T2 interface{}](p1 T1, p2 T2) T1
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Star
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType inferFuncType{typ: func[T1, T2 interface{}](p1 T1, p2 T2) T1, targs: [*int]}
2025/10/11 16:12:39 Val nil untyped nil
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // inferFuncType{typ: func[T1, T2 interface{}](p1 T1, p2 T2) T1, targs: [*int]}
2025/10/11 16:12:39 ==> MatchFuncCall inferFuncType{typ: func[T1, T2 interface{}](p1 T1, p2 T2) T1, targs: [*int]} args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(p1 *int, p2 int) *int
2025/10/11 16:12:39 ==> MatchType untyped nil, *int
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType *int, *int
2025/10/11 16:12:39 ==> Load var *int [p2]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [p2]
2025/10/11 16:12:39 Val Loader func[T1, T2 interface{}](p1 T1, p2 T2) T1
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Star
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 2 false
2025/10/11 16:12:39 ==> InferType func(p1 *int, p2 int) *int
2025/10/11 16:12:39 Val nil untyped nil
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func(p1 *int, p2 int) *int
2025/10/11 16:12:39 ==> MatchFuncCall func(p1 *int, p2 int) *int args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType untyped nil, *int
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 ==> MatchType *int, *int
2025/10/11 16:12:39 ==> Load var func(p1 *int, p2 int) *int [fn1]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [fn1]
2025/10/11 16:12:39 VarRef fn1 func(p1 *int, p2 int) *int
2025/10/11 16:12:39 Val Loader func[T1, T2 interface{}](p1 T1, p2 T2) T1
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Star
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 2 false
2025/10/11 16:12:39 ==> InferType func(p1 *int, p2 int) *int
2025/10/11 16:12:39 Assign 1 1
2025/10/11 16:12:39 ==> MatchType func(p1 *int, p2 int) *int, func(p1 *int, p2 int) *int
2025/10/11 16:12:39 Val fn1 func(p1 *int, p2 int) *int
2025/10/11 16:12:39 Val nil untyped nil
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func(p1 *int, p2 int) *int
2025/10/11 16:12:39 ==> MatchFuncCall func(p1 *int, p2 int) *int args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType untyped nil, *int
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 ==> ASTFile
--- PASS: TestTypeParamsFunc (0.00s)
=== RUN   TestTypeParamsType
2025/10/11 16:12:39 ==> Preload type DataString
2025/10/11 16:12:39 ==> Preload type SliceString
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Preload method Data.Set
2025/10/11 16:12:39 ==> Preload method Data.Set2
2025/10/11 16:12:39 ==> Preload type sliceOf
2025/10/11 16:12:39 ==> Preload type Slice
2025/10/11 16:12:39 ==> Preload method Slice.Append
2025/10/11 16:12:39 ==> Preload method Slice.Append2
2025/10/11 16:12:39 ==> Preload type DataInt
2025/10/11 16:12:39 ==> Preload type SliceInt
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/10/11 16:12:39 ==> Load method *github.com/goplus/xgo/cl.Data[T interface{}].Set
2025/10/11 16:12:39 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/10/11 16:12:39 ==> Load method *github.com/goplus/xgo/cl.Data[T interface{}].Set2
2025/10/11 16:12:39 ==> Load > NewType sliceOf
2025/10/11 16:12:39 ==> Load > InitType sliceOf
2025/10/11 16:12:39 ==> Load > NewType Slice
2025/10/11 16:12:39 ==> Load > InitType Slice
2025/10/11 16:12:39 ==> LookupParent sliceOf => type github.com/goplus/xgo/cl.sliceOf[E interface{}] interface{interface{~[]E}}
2025/10/11 16:12:39 ==> EnsureLoaded github.com/goplus/xgo/cl.sliceOf[E interface{}]
2025/10/11 16:12:39 ==> LookupParent Slice => type github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] struct{Data S}
2025/10/11 16:12:39 ==> Load method *github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}].Append
2025/10/11 16:12:39 ==> LookupParent Slice => type github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] struct{Data S}
2025/10/11 16:12:39 ==> Load method *github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}].Append2
2025/10/11 16:12:39 ==> Load > AliasType DataInt
2025/10/11 16:12:39 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/10/11 16:12:39 ==> Load > AliasType SliceInt
2025/10/11 16:12:39 ==> LookupParent Slice => type github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] struct{Data S}
2025/10/11 16:12:39 ==> Load > AliasType DataString
2025/10/11 16:12:39 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/10/11 16:12:39 AliasType DataString github.com/goplus/xgo/cl.Data[string]
2025/10/11 16:12:39 ==> Load > AliasType SliceString
2025/10/11 16:12:39 ==> LookupParent Slice => type github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] struct{Data S}
2025/10/11 16:12:39 AliasType SliceString github.com/goplus/xgo/cl.Slice[[]string, string]
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> LookupParent DataInt => type github.com/goplus/xgo/cl.DataInt[T interface{}] = github.com/goplus/xgo/cl.Data[int]
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.Data[int] 1 false
2025/10/11 16:12:39 Member v 2 // github.com/goplus/xgo/cl.Data[int]
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType int, any
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> LookupParent DataString => type github.com/goplus/xgo/cl.DataString[T interface{}] = github.com/goplus/xgo/cl.Data[string]
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.Data[string] 1 false
2025/10/11 16:12:39 Member v 2 // github.com/goplus/xgo/cl.Data[string]
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType string, any
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/10/11 16:12:39 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.Data[int] 1 false
2025/10/11 16:12:39 Member v 2 // github.com/goplus/xgo/cl.Data[int]
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType int, any
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.Data[string] 1 false
2025/10/11 16:12:39 Member v 2 // github.com/goplus/xgo/cl.Data[string]
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType string, any
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.Data[struct{X int; Y int}] 0 false
2025/10/11 16:12:39 Member v 2 // github.com/goplus/xgo/cl.Data[struct{X int; Y int}]
2025/10/11 16:12:39 Member X 2 // struct{X int; Y int}
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType int, any
2025/10/11 16:12:39 DefineVarStart [v1]
2025/10/11 16:12:39 ==> LookupParent SliceInt => type github.com/goplus/xgo/cl.SliceInt[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] = github.com/goplus/xgo/cl.Slice[[]int, int]
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.Slice[[]int, int] 0 false
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 DefineVarStart [v2]
2025/10/11 16:12:39 ==> LookupParent SliceString => type github.com/goplus/xgo/cl.SliceString[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] = github.com/goplus/xgo/cl.Slice[[]string, string]
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.Slice[[]string, string] 0 false
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 DefineVarStart [v3]
2025/10/11 16:12:39 ==> LookupParent Slice => type github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] struct{Data S}
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.Slice[[]int, int] 0 false
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 Val v3 github.com/goplus/xgo/cl.Slice[[]int, int]
2025/10/11 16:12:39 Member Append 1 // github.com/goplus/xgo/cl.Slice[[]int, int]
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 4 false
2025/10/11 16:12:39 Call 1 1 // func(t ...int) []int
2025/10/11 16:12:39 ==> MatchFuncCall func(t ...int) []int args: 1 flags: 1
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 Val v3 github.com/goplus/xgo/cl.Slice[[]int, int]
2025/10/11 16:12:39 Member Append2 1 // github.com/goplus/xgo/cl.Slice[[]int, int]
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 4 false
2025/10/11 16:12:39 Call 1 1 // func(t ...int) []int
2025/10/11 16:12:39 ==> MatchFuncCall func(t ...int) []int args: 1 flags: 1
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 ==> ASTFile
--- PASS: TestTypeParamsType (0.00s)
=== RUN   TestTypeParamsComparable
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func Index
2025/10/11 16:12:39 ==> Preload var [IndexInt]
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 DefineVarStart [v1]
2025/10/11 16:12:39 ==> Load var <nil> [IndexInt]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [IndexInt]
2025/10/11 16:12:39 ==> Load func Index
2025/10/11 16:12:39 Val Index func[T comparable](s []T, x T) int
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType func(s []int, x int) int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 Val IndexInt func(s []int, x int) int
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 4 false
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func(s []int, x int) int
2025/10/11 16:12:39 ==> MatchFuncCall func(s []int, x int) int args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 DefineVarStart [v2]
2025/10/11 16:12:39 Val Index func[T comparable](s []T, x T) int
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 4 false
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func[T comparable](s []T, x T) int
2025/10/11 16:12:39 ==> MatchFuncCall func[T comparable](s []T, x T) int args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(s []int, x int) int
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 DefineVarStart [v3]
2025/10/11 16:12:39 Val Index func[T comparable](s []T, x T) int
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType func(s []int, x int) int
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 4 false
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func(s []int, x int) int
2025/10/11 16:12:39 ==> MatchFuncCall func(s []int, x int) int args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 DefineVarStart [v4]
2025/10/11 16:12:39 Val Index func[T comparable](s []T, x T) int
2025/10/11 16:12:39 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 STRING "c"} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 STRING "d"} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 4 false
2025/10/11 16:12:39 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func[T comparable](s []T, x T) int
2025/10/11 16:12:39 ==> MatchFuncCall func[T comparable](s []T, x T) int args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(s []string, x string) int
2025/10/11 16:12:39 ==> MatchType []string, []string
2025/10/11 16:12:39 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 ==> ASTFile
--- PASS: TestTypeParamsComparable (0.00s)
=== RUN   TestTypeParamsErrorInstantiate
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload type Number
2025/10/11 16:12:39 ==> Preload func Sum
2025/10/11 16:12:39 ==> Preload var [SumInt]
2025/10/11 16:12:39 ==> Load > NewType Number
2025/10/11 16:12:39 ==> Load > InitType Number
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line b.xgo:2:1
2025/10/11 16:12:39 ==> Load func Sum
2025/10/11 16:12:39 ==> LookupParent Number => type Number interface{interface{~int | float64}}
2025/10/11 16:12:39 Val Sum func[T Number](vec []T) T
2025/10/11 16:12:39 Val uint uint
2025/10/11 16:12:39 Val type uint => Typ uint
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
--- PASS: TestTypeParamsErrorInstantiate (0.00s)
=== RUN   TestTypeParamsErrorMatch
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func At
2025/10/11 16:12:39 ==> Preload var [AtInt]
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line b.xgo:2:1
2025/10/11 16:12:39 VarRef _
2025/10/11 16:12:39 ==> Load func At
2025/10/11 16:12:39 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType inferFuncType{typ: func[T interface{interface{~[]E}}, E interface{}](x T, i int) E, targs: [int]}
2025/10/11 16:12:39 Assign 1 1
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
--- PASS: TestTypeParamsErrorMatch (0.00s)
=== RUN   TestTypeParamsErrInferFunc
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func Loader
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line b.xgo:2:1
2025/10/11 16:12:39 VarRef _
2025/10/11 16:12:39 ==> Load func Loader
2025/10/11 16:12:39 Val Loader func[T1, T2 interface{}](p1 T1, p2 T2) T1
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType inferFuncType{typ: func[T1, T2 interface{}](p1 T1, p2 T2) T1, targs: [int]}
2025/10/11 16:12:39 Assign 1 1
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
--- PASS: TestTypeParamsErrInferFunc (0.00s)
=== RUN   TestTypeParamsErrArgumentsParameters1
2025/10/11 16:12:39 ==> Preload var [v]
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 ==> EnsureLoaded Data[T1, T2 interface{}]
2025/10/11 16:12:39 ==> Load var <nil> [v]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [v]
--- PASS: TestTypeParamsErrArgumentsParameters1 (0.00s)
=== RUN   TestTypeParamsErrArgumentsParameters2
2025/10/11 16:12:39 ==> Preload var [v]
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 ==> EnsureLoaded Data[T1, T2 interface{}]
2025/10/11 16:12:39 ==> Load var <nil> [v]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [v]
--- PASS: TestTypeParamsErrArgumentsParameters2 (0.00s)
=== RUN   TestTypeParamsErrArgumentsParameters3
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func Test
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line b.xgo:2:1
2025/10/11 16:12:39 ==> Load func Test
2025/10/11 16:12:39 Val Test func[T1, T2 interface{}](t1 T1, t2 T2)
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 3 false
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
--- PASS: TestTypeParamsErrArgumentsParameters3 (0.00s)
=== RUN   TestTypeParamsErrCallArguments1
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func Test
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line b.xgo:2:1
2025/10/11 16:12:39 ==> Load func Test
2025/10/11 16:12:39 Val Test func[T1, T2 interface{}](t1 T1, t2 T2)
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 1 0 // func[T1, T2 interface{}](t1 T1, t2 T2)
2025/10/11 16:12:39 ==> MatchFuncCall func[T1, T2 interface{}](t1 T1, t2 T2) args: 1 flags: 0
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
--- PASS: TestTypeParamsErrCallArguments1 (0.00s)
=== RUN   TestTypeParamsErrCallArguments2
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func Test
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line b.xgo:2:1
2025/10/11 16:12:39 ==> Load func Test
2025/10/11 16:12:39 Val Test func[T1, T2 interface{}](t1 T1, t2 T2)
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Call 3 0 // func[T1, T2 interface{}](t1 T1, t2 T2)
2025/10/11 16:12:39 ==> MatchFuncCall func[T1, T2 interface{}](t1 T1, t2 T2) args: 3 flags: 0
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
--- PASS: TestTypeParamsErrCallArguments2 (0.00s)
=== RUN   TestTypeParamsErrCallArguments3
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func Test
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line b.xgo:2:1
2025/10/11 16:12:39 ==> Load func Test
2025/10/11 16:12:39 Val Test func[T1, T2 interface{}]()
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func[T1, T2 interface{}]()
2025/10/11 16:12:39 ==> MatchFuncCall func[T1, T2 interface{}]() args: 2 flags: 0
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
--- PASS: TestTypeParamsErrCallArguments3 (0.00s)
=== RUN   TestTypeParamsErrCallVariadicArguments1
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func Add
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line b.xgo:2:1
2025/10/11 16:12:39 ==> Load func Add
2025/10/11 16:12:39 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 Call 0 0 // func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 ==> MatchFuncCall func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2) args: 0 flags: 0
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
--- PASS: TestTypeParamsErrCallVariadicArguments1 (0.00s)
=== RUN   TestTypeParamsErrCallVariadicArguments2
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func Add
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line b.xgo:2:1
2025/10/11 16:12:39 ==> Load func Add
2025/10/11 16:12:39 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Call 1 0 // func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/10/11 16:12:39 ==> MatchFuncCall func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2) args: 1 flags: 0
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
--- PASS: TestTypeParamsErrCallVariadicArguments2 (0.00s)
=== RUN   TestTypeParamsRecvTypeError1
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Preload method Data.Test
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T interface{}] struct{v T}
2025/10/11 16:12:39 ==> Load method *Data[T interface{}].Test
--- PASS: TestTypeParamsRecvTypeError1 (0.00s)
=== RUN   TestTypeParamsRecvTypeError2
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Preload method Data.Test
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T interface{}] struct{v T}
2025/10/11 16:12:39 ==> Load method *Data[T interface{}].Test
--- PASS: TestTypeParamsRecvTypeError2 (0.00s)
=== RUN   TestTypeParamsRecvTypeError3
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Preload method Data.Test
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 ==> Load method *Data[T1, T2 interface{}].Test
--- PASS: TestTypeParamsRecvTypeError3 (0.00s)
=== RUN   TestGenericTypeWithoutInst1
2025/10/11 16:12:39 ==> Preload var [v]
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Preload method Data.Test
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 ==> Load method *Data[T1, T2 interface{}].Test
--- PASS: TestGenericTypeWithoutInst1 (0.00s)
=== RUN   TestGenericTypeWithoutInst2
2025/10/11 16:12:39 ==> Preload var [v]
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Preload type My
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> Load > NewType My
2025/10/11 16:12:39 ==> Load > InitType My
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 ==> LookupParent My => type My[T interface{}] struct{invalid type}
2025/10/11 16:12:39 ==> EnsureLoaded My[T interface{}]
2025/10/11 16:12:39 ==> Load var My[int] [v]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [v]
--- PASS: TestGenericTypeWithoutInst2 (0.00s)
=== RUN   TestGenericTypeWithoutInst3
2025/10/11 16:12:39 ==> Preload var [v]
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Preload type My
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> Load > NewType My
2025/10/11 16:12:39 ==> Load > InitType My
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 ==> LookupParent My => type My struct{invalid type}
2025/10/11 16:12:39 ==> Load var My [v]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [v]
--- PASS: TestGenericTypeWithoutInst3 (0.00s)
=== RUN   TestGenericTypeWithoutInst4
2025/10/11 16:12:39 ==> Preload var [v]
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Preload type My
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> Load > NewType My
2025/10/11 16:12:39 ==> Load > InitType My
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 ==> LookupParent My => type My struct{v map[string]invalid type}
2025/10/11 16:12:39 ==> Load var My [v]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [v]
--- PASS: TestGenericTypeWithoutInst4 (0.00s)
=== RUN   TestGenericTypeWithoutInst5
2025/10/11 16:12:39 ==> Preload var [v]
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 ==> Load var invalid type [v]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [v]
--- PASS: TestGenericTypeWithoutInst5 (0.00s)
=== RUN   TestGenericTypeWithoutInst6
2025/10/11 16:12:39 ==> Preload type T
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> Load > NewType T
2025/10/11 16:12:39 NewType T
2025/10/11 16:12:39 ==> Load > InitType T
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 InitType T invalid type
--- PASS: TestGenericTypeWithoutInst6 (0.00s)
=== RUN   TestGenericTypeWithoutInst7
2025/10/11 16:12:39 ==> Preload type My
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> Load > NewType My
2025/10/11 16:12:39 NewType My
2025/10/11 16:12:39 ==> Load > InitType My
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 InitType My struct{invalid type}
--- PASS: TestGenericTypeWithoutInst7 (0.00s)
=== RUN   TestGenericTypeWithoutInst8
2025/10/11 16:12:39 ==> Preload func test
2025/10/11 16:12:39 ==> Preload type Data
2025/10/11 16:12:39 ==> Load > NewType Data
2025/10/11 16:12:39 ==> Load > InitType Data
2025/10/11 16:12:39 ==> Load func test
2025/10/11 16:12:39 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/10/11 16:12:39 NewFunc test func(v1 int, v2 *invalid type)
2025/10/11 16:12:39 End // Func
--- PASS: TestGenericTypeWithoutInst8 (0.00s)
=== RUN   TestGenericTypeCompositeLit
2025/10/11 16:12:39 ==> Preload var [a]
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload type A
2025/10/11 16:12:39 ==> Preload type B
2025/10/11 16:12:39 ==> Load > NewType A
2025/10/11 16:12:39 ==> Load > InitType A
2025/10/11 16:12:39 ==> Load > NewType B
2025/10/11 16:12:39 ==> Load > InitType B
2025/10/11 16:12:39 ==> LookupParent A => type github.com/goplus/xgo/cl.A[T interface{}] struct{m T}
2025/10/11 16:12:39 ==> EnsureLoaded github.com/goplus/xgo/cl.A[T interface{}]
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 ==> Load var [2]int [a]
2025/10/11 16:12:39 NewVarDefs
2025/10/11 16:12:39 NewVar [a]
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 If
2025/10/11 16:12:39 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:39 Val a [2]int
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 BinaryOp ==
2025/10/11 16:12:39 Then
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType untyped string ("world"), any
2025/10/11 16:12:39 End // If
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> LookupParent B => type github.com/goplus/xgo/cl.B[T interface{}] struct{n github.com/goplus/xgo/cl.A[T]}
2025/10/11 16:12:39 ==> EnsureLoaded github.com/goplus/xgo/cl.B[T interface{}]
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.B[int] 0 false
2025/10/11 16:12:39 Member n 2 // github.com/goplus/xgo/cl.B[int]
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType github.com/goplus/xgo/cl.A[int], any
2025/10/11 16:12:39 ==> EnsureLoaded github.com/goplus/xgo/cl.A[int]
2025/10/11 16:12:39 If
2025/10/11 16:12:39 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:39 ==> LookupParent B => type github.com/goplus/xgo/cl.B[T interface{}] struct{n github.com/goplus/xgo/cl.A[T]}
2025/10/11 16:12:39 ==> EnsureLoaded github.com/goplus/xgo/cl.B[T interface{}]
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl.B[int] 0 false
2025/10/11 16:12:39 Member n 2 // github.com/goplus/xgo/cl.B[int]
2025/10/11 16:12:39 Member m 2 // github.com/goplus/xgo/cl.A[int]
2025/10/11 16:12:39 BinaryOp <
2025/10/11 16:12:39 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType untyped int (0), unboundFuncParam{typ: <nil>}
2025/10/11 16:12:39 ==> MatchType int, unboundFuncParam{typ: untyped int}
2025/10/11 16:12:39 Then
2025/10/11 16:12:39 End // If
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 ==> ASTFile
--- PASS: TestGenericTypeCompositeLit (0.00s)
=== RUN   TestInferFuncLambda
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func ListMap
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> Load func ListMap
2025/10/11 16:12:39 Val ListMap func[T interface{}](ar []T, fn func(v T) T) []T
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 4 false
2025/10/11 16:12:39 Val nil untyped nil
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 4 false
2025/10/11 16:12:39 NewClosure func(x int) int
2025/10/11 16:12:39 Val x int
2025/10/11 16:12:39 Val x int
2025/10/11 16:12:39 BinaryOp *
2025/10/11 16:12:39 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:39 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:39 Return 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 Call 2 0 // func[T interface{}](ar []T, fn func(v T) T) []T
2025/10/11 16:12:39 ==> MatchFuncCall func[T interface{}](ar []T, fn func(v T) T) []T args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(ar []int, fn func(v int) int) []int
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 ==> MatchType func(x int) int, func(v int) int
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType []int, any
2025/10/11 16:12:39 Val ListMap func[T interface{}](ar []T, fn func(v T) T) []T
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 4 false
2025/10/11 16:12:39 Val nil untyped nil
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 4 false
2025/10/11 16:12:39 NewClosure func(x int) int
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val x int
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType int, any
2025/10/11 16:12:39 Val x int
2025/10/11 16:12:39 Return 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 Call 2 0 // func[T interface{}](ar []T, fn func(v T) T) []T
2025/10/11 16:12:39 ==> MatchFuncCall func[T interface{}](ar []T, fn func(v T) T) []T args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(ar []int, fn func(v int) int) []int
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 ==> MatchType func(x int) int, func(v int) int
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 ==> ASTFile
--- PASS: TestInferFuncLambda (0.00s)
=== RUN   TestInferOverloadFuncLambda
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Preload func ListMap__0
2025/10/11 16:12:39 ==> Preload func ListMap__1
2025/10/11 16:12:39 ==> Load func ListMap__0
2025/10/11 16:12:39 ==> Load func ListMap__1
2025/10/11 16:12:39 ==> NewOverloadFunc ListMap
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val ListMap func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 4 false
2025/10/11 16:12:39 Val nil untyped nil
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 4 false
2025/10/11 16:12:39 NewClosure func(x int) int
2025/10/11 16:12:39 Val x int
2025/10/11 16:12:39 Val x int
2025/10/11 16:12:39 BinaryOp *
2025/10/11 16:12:39 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:39 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:39 Return 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func[T interface{}](ar []T, fn func(v T) T) []T args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(ar []int, fn func(v int) int) []int
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 ==> MatchType func(x int) int, func(v int) int
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType []int, any
2025/10/11 16:12:39 Val ListMap func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit <nil> 4 false
2025/10/11 16:12:39 Val nil untyped nil
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:39 SliceLit []int 4 false
2025/10/11 16:12:39 NewClosure func(x int) int
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val x int
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType int, any
2025/10/11 16:12:39 Val x int
2025/10/11 16:12:39 Return 1
2025/10/11 16:12:39 ==> MatchType int, int
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func[T interface{}](ar []T, fn func(v T) T) []T args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(ar []int, fn func(v int) int) []int
2025/10/11 16:12:39 ==> MatchType []int, []int
2025/10/11 16:12:39 ==> MatchType func(x int) int, func(v int) int
2025/10/11 16:12:39 Val ListMap func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 Val nil untyped nil
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 NewClosure func(x string)
2025/10/11 16:12:39 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val x string
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType string, any
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func[T interface{}](ar []T, fn func(v T) T) []T args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a string, fn func(s string)) args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:39 ==> MatchType func(x string), func(s string)
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 ==> ASTFile
--- PASS: TestInferOverloadFuncLambda (0.00s)
=== RUN   TestGenericFuncAlias
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 Val Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func[N any](n N) args: 1 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(n int)
2025/10/11 16:12:39 ==> MatchType untyped int (100), int
2025/10/11 16:12:39 Val Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func() args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func[N any](n N) args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func[N1, N2 any](n1 N1, n2 N2) args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(n1 string, n2 int)
2025/10/11 16:12:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:39 ==> MatchType untyped int (100), int
2025/10/11 16:12:39 Val Test__1 func[N any](n N)
2025/10/11 16:12:39 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:39 Call 1 0 // func[N any](n N)
2025/10/11 16:12:39 ==> MatchFuncCall func[N any](n N) args: 1 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(n int)
2025/10/11 16:12:39 ==> MatchType untyped int (100), int
2025/10/11 16:12:39 Val Test__1 func[N any](n N)
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Index 1 false
2025/10/11 16:12:39 ==> InferType func(n int)
2025/10/11 16:12:39 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:39 Call 1 0 // func(n int)
2025/10/11 16:12:39 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType untyped int (100), int
2025/10/11 16:12:39 Val Test__2 func[N1, N2 any](n1 N1, n2 N2)
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val true untyped bool
2025/10/11 16:12:39 Call 2 0 // func[N1, N2 any](n1 N1, n2 N2)
2025/10/11 16:12:39 ==> MatchFuncCall func[N1, N2 any](n1 N1, n2 N2) args: 2 flags: 0
2025/10/11 16:12:39 ==> InferFunc func(n1 int, n2 bool)
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:39 Val Test__2 func[N1, N2 any](n1 N1, n2 N2)
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Val string string
2025/10/11 16:12:39 Val type string => Typ string
2025/10/11 16:12:39 Index 2 false
2025/10/11 16:12:39 ==> InferType func(n1 int, n2 string)
2025/10/11 16:12:39 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 Call 2 0 // func(n1 int, n2 string)
2025/10/11 16:12:39 ==> MatchFuncCall func(n1 int, n2 string) args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType untyped int (1), int
2025/10/11 16:12:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 ==> ASTFile
--- PASS: TestGenericFuncAlias (0.00s)
=== RUN   TestGoptLambdaFunc
2025/10/11 16:12:39 ==> Preload type Message
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Load > NewType Message
2025/10/11 16:12:39 NewType Message
2025/10/11 16:12:39 ==> Load > InitType Message
2025/10/11 16:12:39 InitType Message struct{info string}
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 DefineVarStart [p]
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl/internal/overload/bar.Player 0 false
2025/10/11 16:12:39 UnaryOp & flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 Val p *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/10/11 16:12:39 Member onCmd 1 // *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/10/11 16:12:39 Val Message github.com/goplus/xgo/cl.Message
2025/10/11 16:12:39 Val type github.com/goplus/xgo/cl.Message struct{info string} => Typ github.com/goplus/xgo/cl.Message
2025/10/11 16:12:39 NewClosure func(msg github.com/goplus/xgo/cl.Message) error
2025/10/11 16:12:39 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val msg github.com/goplus/xgo/cl.Message
2025/10/11 16:12:39 Member info 2 // github.com/goplus/xgo/cl.Message
2025/10/11 16:12:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:39 ==> MatchType string, any
2025/10/11 16:12:39 Val nil untyped nil
2025/10/11 16:12:39 Return 1
2025/10/11 16:12:39 ==> MatchType untyped nil, error
2025/10/11 16:12:39 ==> EnsureLoaded error
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 8
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 24
2025/10/11 16:12:39 ==> MatchFuncCall func[T any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, handler func(cmd T) error) args: 3 flags: 24
2025/10/11 16:12:39 boundTypeParams: bar.Gopt_Player_Gopx_OnCmd__0 sig: func[T any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, handler func(cmd T) error) args: 3 flags: 24
2025/10/11 16:12:39 ==> MatchType *github.com/goplus/xgo/cl/internal/overload/bar.Player, *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/10/11 16:12:39 ==> MatchType func(msg github.com/goplus/xgo/cl.Message) error, func(cmd github.com/goplus/xgo/cl.Message) error
2025/10/11 16:12:39 Val p *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/10/11 16:12:39 Member onCmd 1 // *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Val Message github.com/goplus/xgo/cl.Message
2025/10/11 16:12:39 Val type github.com/goplus/xgo/cl.Message struct{info string} => Typ github.com/goplus/xgo/cl.Message
2025/10/11 16:12:39 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:39 Val int int
2025/10/11 16:12:39 Val type int => Typ int
2025/10/11 16:12:39 Val Message github.com/goplus/xgo/cl.Message
2025/10/11 16:12:39 Val type github.com/goplus/xgo/cl.Message struct{info string} => Typ github.com/goplus/xgo/cl.Message
2025/10/11 16:12:39 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:39 NewClosure func(n int, msg github.com/goplus/xgo/cl.Message) error
2025/10/11 16:12:39 Val echo func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 Val n int
2025/10/11 16:12:39 Val msg github.com/goplus/xgo/cl.Message
2025/10/11 16:12:39 Member info 2 // github.com/goplus/xgo/cl.Message
2025/10/11 16:12:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:39 ==> MatchType int, any
2025/10/11 16:12:39 ==> MatchType string, any
2025/10/11 16:12:39 Val nil untyped nil
2025/10/11 16:12:39 Return 1
2025/10/11 16:12:39 ==> MatchType untyped nil, error
2025/10/11 16:12:39 ==> EnsureLoaded error
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 Call 4 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:39 ==> MatchFuncCall TyTypeAsParams args: 4 flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall TyTemplateRecvMethod args: 4 flags: 8
2025/10/11 16:12:39 ==> MatchFuncCall TyOverloadFunc args: 5 flags: 24
2025/10/11 16:12:39 ==> MatchFuncCall func[T any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, handler func(cmd T) error) args: 5 flags: 24
2025/10/11 16:12:39 boundTypeParams: bar.Gopt_Player_Gopx_OnCmd__0 sig: func[T any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, handler func(cmd T) error) args: 5 flags: 24
2025/10/11 16:12:39 ==> MatchFuncCall func[T1 ~int, T2 any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, n T1, handler func(n T1, cmd T2) error) args: 5 flags: 24
2025/10/11 16:12:39 boundTypeParams: bar.Gopt_Player_Gopx_OnCmd__1 sig: func[T1 ~int, T2 any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, n T1, handler func(n T1, cmd T2) error) args: 5 flags: 24
2025/10/11 16:12:39 ==> MatchType *github.com/goplus/xgo/cl/internal/overload/bar.Player, *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/10/11 16:12:39 ==> MatchType untyped int (100), int
2025/10/11 16:12:39 ==> MatchType func(n int, msg github.com/goplus/xgo/cl.Message) error, func(n int, cmd github.com/goplus/xgo/cl.Message) error
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 ==> ASTFile
--- PASS: TestGoptLambdaFunc (0.00s)
=== RUN   TestGoptLambdaError
2025/10/11 16:12:39 ==> Preload type Message
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Load > NewType Message
2025/10/11 16:12:39 NewType Message
2025/10/11 16:12:39 ==> Load > InitType Message
2025/10/11 16:12:39 InitType Message struct{info string}
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line bar.xgo:7:1
2025/10/11 16:12:39 DefineVarStart [p]
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl/internal/overload/bar.Player 0 false
2025/10/11 16:12:39 UnaryOp & flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 SetComments 0
//line bar.xgo:8:1
2025/10/11 16:12:39 Val p *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/10/11 16:12:39 Member onCmd 1 // *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/10/11 16:12:39 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:39 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:39 Val Message Message
2025/10/11 16:12:39 Val type Message struct{info string} => Typ Message
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
2025/10/11 16:12:39 ==> Preload type Message
2025/10/11 16:12:39 ==> Preload func main
2025/10/11 16:12:39 ==> Load > NewType Message
2025/10/11 16:12:39 NewType Message
2025/10/11 16:12:39 ==> Load > InitType Message
2025/10/11 16:12:39 InitType Message struct{info string}
2025/10/11 16:12:39 ==> Load func main
2025/10/11 16:12:39 NewFunc main func()
2025/10/11 16:12:39 SetComments 0
//line bar.xgo:7:1
2025/10/11 16:12:39 DefineVarStart [p]
2025/10/11 16:12:39 StructLit github.com/goplus/xgo/cl/internal/overload/bar.Player 0 false
2025/10/11 16:12:39 UnaryOp & flags: 0
2025/10/11 16:12:39 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:39 EndInit 1
2025/10/11 16:12:39 SetComments 0
//line bar.xgo:8:1
2025/10/11 16:12:39 Val p *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/10/11 16:12:39 Member onCmd 1 // *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/10/11 16:12:39 Val string string
2025/10/11 16:12:39 Val type string => Typ string
2025/10/11 16:12:39 Val Message Message
2025/10/11 16:12:39 Val type Message struct{info string} => Typ Message
2025/10/11 16:12:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:39 Val string string
2025/10/11 16:12:39 Val type string => Typ string
2025/10/11 16:12:39 Val Message Message
2025/10/11 16:12:39 Val type Message struct{info string} => Typ Message
2025/10/11 16:12:39 ResetStmt
2025/10/11 16:12:39 End // Func
--- PASS: TestGoptLambdaError (0.00s)
=== RUN   TestAliasTypeparams
    typeparams_test.go:850:
--- SKIP: TestAliasTypeparams (0.00s)
PASS
coverage: 98.0% of statements
ok  	github.com/goplus/xgo/cl	21.987s	coverage: 98.0% of statements
	github.com/goplus/xgo/cl/cltest		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/huh		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/llgo-hello		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/mcp		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/overload/bar		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/overload/foo			github.com/goplus/xgo/cl/internal/spx		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx/pkg		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx2			github.com/goplus/xgo/cl/internal/spx3		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx3/jwt		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx4		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx4/pkg		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/test		coverage: 0.0% of statements
?   	github.com/goplus/xgo/cl/internal/testutil	[no test files]
	github.com/goplus/xgo/cl/internal/typesalias		coverage: 0.0% of statements
=== RUN   TestTypeAndValue
--- PASS: TestTypeAndValue (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/cl/internal/typesutil	0.007s	coverage: 100.0% of statements
?   	github.com/goplus/xgo/cl/internal/unit	[no test files]
	github.com/goplus/xgo/cl/outline		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/chore/goptestgo		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/base		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/bug		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/build		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/clean		coverage: 0.0% of statements
?   	github.com/goplus/xgo/cmd/internal/deps	[no test files]
	github.com/goplus/xgo/cmd/internal/doc		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/env		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/gengo		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/gopfmt		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/gopget		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/help		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/install		coverage: 0.0% of statements
?   	github.com/goplus/xgo/cmd/internal/list	[no test files]
	github.com/goplus/xgo/cmd/internal/mod		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/run		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/serve		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/test		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/version		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/watch		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/xgo		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/fullspec/mixgo-complex		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/mixgo		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/typeasparamsfunc		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/typeasparamsmethod		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/typeparamscast		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/xgo-sample/cpkag/b		coverage: 0.0% of statements
=== RUN   TestToIndex
--- PASS: TestToIndex (0.00s)
=== RUN   TestCheckTypeMethod
--- PASS: TestCheckTypeMethod (0.00s)
=== RUN   TestIsGopPackage
--- PASS: TestIsGopPackage (0.00s)
=== RUN   TestDocRecv
--- PASS: TestDocRecv (0.00s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/gopoFn
=== RUN   TestFromTestdata/gopoMethod
=== RUN   TestFromTestdata/overloadFn
=== RUN   TestFromTestdata/overloadMethod
--- PASS: TestFromTestdata (0.00s)
    --- PASS: TestFromTestdata/gopoFn (0.00s)
    --- PASS: TestFromTestdata/gopoMethod (0.00s)
    --- PASS: TestFromTestdata/overloadFn (0.00s)
    --- PASS: TestFromTestdata/overloadMethod (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/doc	0.011s	coverage: 100.0% of statements
=== RUN   TestBasic
--- PASS: TestBasic (0.00s)
=== RUN   TestFindGoModFileInGoModDir
=== RUN   TestFindGoModFileInGoModDir/the_src/_is_a_valid_mod_dir
=== RUN   TestFindGoModFileInGoModDir/the_src/_is_not_a_valid_mod_dir
--- PASS: TestFindGoModFileInGoModDir (0.00s)
    --- PASS: TestFindGoModFileInGoModDir/the_src/_is_a_valid_mod_dir (0.00s)
    --- PASS: TestFindGoModFileInGoModDir/the_src/_is_not_a_valid_mod_dir (0.00s)
=== RUN   TestFindGoModFileInGopRoot
=== RUN   TestFindGoModFileInGopRoot/without_xgo_root
=== RUN   TestFindGoModFileInGopRoot/set_XGOROOT_to_a_valid_xgoroot_path
=== RUN   TestFindGoModFileInGopRoot/set_XGOROOT_to_an_invalid_xgoroot_path
2025/10/11 16:12:18
XGOROOT (/tmp/TestFindGoModFileInGopRootset_XGOROOT_to_an_invalid_xgoroot_path2098861361/001/invalid_xgoroot) is not valid
=== RUN   TestFindGoModFileInGopRoot/set_defaultXGoRoot_to_a_valid_xgoroot_path
=== RUN   TestFindGoModFileInGopRoot/set_defaultXGoRoot_to_an_invalid_path
=== RUN   TestFindGoModFileInGopRoot/use_$HOME/xgo
=== RUN   TestFindGoModFileInGopRoot/check_if_parent_dir_of_the_executable_is_valid_gop_root
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority/without_xgo_root
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority/set_defaultXGoRoot_to_a_valid_xgo_root_dir
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority/the_executable's_parent_dir_is_a_valid_xgo_root_dir
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority/set_XGOROOT_to_an_invalid_xgo_root_dir
2025/10/11 16:12:18
XGOROOT (/tmp/TestFindGoModFileInGopRoottest_xgo_root_priority2208559089/001/new_xgo_root3) is not valid
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority/set_XGOROOT_to_a_valid_xgo_root_dir
--- PASS: TestFindGoModFileInGopRoot (0.01s)
    --- PASS: TestFindGoModFileInGopRoot/without_xgo_root (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/set_XGOROOT_to_a_valid_xgoroot_path (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/set_XGOROOT_to_an_invalid_xgoroot_path (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/set_defaultXGoRoot_to_a_valid_xgoroot_path (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/set_defaultXGoRoot_to_an_invalid_path (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/use_$HOME/xgo (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/check_if_parent_dir_of_the_executable_is_valid_gop_root (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority (0.00s)
        --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority/without_xgo_root (0.00s)
        --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority/set_defaultXGoRoot_to_a_valid_xgo_root_dir (0.00s)
        --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority/the_executable's_parent_dir_is_a_valid_xgo_root_dir (0.00s)
        --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority/set_XGOROOT_to_an_invalid_xgo_root_dir (0.00s)
        --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority/set_XGOROOT_to_a_valid_xgo_root_dir (0.00s)
=== RUN   TestPanic
=== RUN   TestPanic/initEnvPanic
=== RUN   TestPanic/XGOROOT_panic
2025/10/11 16:12:18 XGOROOT not found: no such file or directory
--- PASS: TestPanic (0.00s)
    --- PASS: TestPanic/initEnvPanic (0.00s)
    --- PASS: TestPanic/XGOROOT_panic (0.00s)
=== RUN   TestEnv
--- PASS: TestEnv (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/env	0.022s	coverage: 100.0% of statements
	github.com/goplus/xgo/format		coverage: 0.0% of statements
=== RUN   TestSeekAfter
--- PASS: TestSeekAfter (0.00s)
=== RUN   TestTokOf
--- PASS: TestTokOf (0.00s)
=== RUN   TestSplitStmts
=== RUN   TestSplitStmts/basic
2025/10/11 16:12:18 Parsing /app/format/formatutil/_testdata/splitstmts/basic
--- PASS: TestSplitStmts (0.00s)
    --- PASS: TestSplitStmts/basic (0.00s)
=== RUN   TestRearrangeFuncs
=== RUN   TestRearrangeFuncs/noeol
2025/10/11 16:12:18 Parsing /app/format/formatutil/_testdata/rearrange/noeol
=== RUN   TestRearrangeFuncs/nondecl
2025/10/11 16:12:18 Parsing /app/format/formatutil/_testdata/rearrange/nondecl
--- PASS: TestRearrangeFuncs (0.00s)
    --- PASS: TestRearrangeFuncs/noeol (0.00s)
    --- PASS: TestRearrangeFuncs/nondecl (0.00s)
=== RUN   TestFormat
=== RUN   TestFormat/basic
2025/10/11 16:12:18 Parsing /app/format/formatutil/_testdata/format/basic
=== RUN   TestFormat/nondecl
2025/10/11 16:12:18 Parsing /app/format/formatutil/_testdata/format/nondecl
--- PASS: TestFormat (0.00s)
    --- PASS: TestFormat/basic (0.00s)
    --- PASS: TestFormat/nondecl (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/format/formatutil	0.014s	coverage: 100.0% of statements
=== RUN   TestFilter
--- PASS: TestFilter (0.00s)
=== RUN   TestAssert
--- PASS: TestAssert (0.00s)
=== RUN   TestErrLabel
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:3615: expected ';', found 'EOF'
--- PASS: TestErrLabel (0.00s)
=== RUN   TestErrTplLit
 /app/parser/parser.go:713: ast.Ident{Name: tpl}
 /app/parser/parser.go:1830: ast.DomainTextLit{Domain: tpl, Value: `a =`}
--- PASS: TestErrTplLit (0.00s)
=== RUN   TestErrTuple
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3615: expected ';', found 'EOF'
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:1895: expected ')', found ','
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{12 INT 1 <nil>}}
 /app/parser/parser.go:2147: missing ',' in argument list
 /app/parser/parser.go:1945: expected operand, found ')'
 /app/parser/parser.go:2147: missing ',' in argument list
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3615: expected ';', found 'EOF'
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
 /app/parser/parser.go:3009: expected ';', found 'EOF'
 /app/parser/parser.go:1635: expected '}', found 'EOF'
 /app/parser/parser.go:4050: expected ';', found 'EOF'
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
--- PASS: TestErrTuple (0.00s)
=== RUN   TestErrOperand
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:1945: expected operand, found 'EOF'
 /app/parser/parser.go:3615: expected ';', found 'EOF'
--- PASS: TestErrOperand (0.00s)
=== RUN   TestErrMissingComma
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: b}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:4088: ast.FuncDecl{Name: a, ...}
--- PASS: TestErrMissingComma (0.00s)
=== RUN   TestErrLambda
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "lambda"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3457: expected 'IDENT', found "hello"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: test, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x"}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "lambda"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3457: expected 'IDENT', found "x"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: test, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x"}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{54 STRING "x" <nil>}}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "lambda"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3457: expected 'IDENT', found "x"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: test, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "y"}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "lambda"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:713: ast.Ident{Name: y}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3457: expected 'IDENT', found "y"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: test, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: onTouchStart}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "someone"}
 /app/parser/parser.go:713: ast.Ident{Name: say}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "touched by someone"}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: say, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3457: expected 'IDENT', found "someone"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: onTouchStart, Ellipsis: false, isCmd: true}
--- PASS: TestErrLambda (0.00s)
=== RUN   TestErrTooManyParseExpr
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:710: expected 'IDENT', found 'var'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3777: expected ';', found 'var'
 /app/parser/parser.go:710: expected 'IDENT', found 'var'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3777: expected ';', found 'var'
 /app/parser/parser.go:710: expected 'IDENT', found 'var'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3777: expected ';', found 'var'
 /app/parser/parser.go:710: expected 'IDENT', found 'var'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3777: expected ';', found 'var'
--- PASS: TestErrTooManyParseExpr (0.00s)
=== RUN   TestErrTooMany
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:710: expected 'IDENT', found '}'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:1340: expected '(', found g
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
--- PASS: TestErrTooMany (0.00s)
=== RUN   TestErrInFunc
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:1945: expected operand, found '}'
 /app/parser/parser.go:2897: expected 1 expression
 /app/parser/parser.go:3615: expected ';', found 'EOF'
 /app/parser/parser.go:1635: expected '}', found 'EOF'
 /app/parser/parser.go:4050: expected ';', found 'EOF'
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:1945: expected operand, found '=>'
 /app/parser/parser.go:2897: expected 1 expression
 /app/parser/parser.go:3615: expected ';', found 'EOF'
 /app/parser/parser.go:1635: expected '}', found 'EOF'
 /app/parser/parser.go:4050: expected ';', found 'EOF'
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:3648: expected statement, found ','
 /app/parser/parser.go:1635: expected '}', found 'EOF'
 /app/parser/parser.go:4050: expected ';', found 'EOF'
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
--- PASS: TestErrInFunc (0.00s)
=== RUN   TestClassErrCode
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: B}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:710: expected 'IDENT', found '*'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found B
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:3768: expected ';', found int
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found ')'
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found 'EOF'
 /app/parser/parser.go:3852: expected ')', found 'EOF'
 /app/parser/parser.go:3853: expected ';', found 'EOF'
 /app/parser/parser.go:710: expected 'IDENT', found '['
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found ']'
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:710: expected 'IDENT', found '['
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found ']'
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:3768: expected ';', found '='
 /app/parser/parser.go:710: expected 'IDENT', found 10
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:3768: expected ';', found '='
 /app/parser/parser.go:710: expected 'IDENT', found 10
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: c}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
 /app/parser/parser.go:713: ast.Ident{Name: d}
--- PASS: TestClassErrCode (0.00s)
=== RUN   TestErrGlobal
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:4133: expected statement, found '}'
--- PASS: TestErrGlobal (0.00s)
=== RUN   TestErrCompositeLiteral
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:2064: ast.IndexExpr{X: T, Index: int}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{T 11 int 15}}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:713: ast.Ident{Name: b}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
--- PASS: TestErrCompositeLiteral (0.00s)
=== RUN   TestErrSelectorExpr
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2417: expected selector or type assertion, found '*'
 /app/parser/parser.go:3615: expected ';', found p
--- PASS: TestErrSelectorExpr (0.00s)
=== RUN   TestErrStringLitEx
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1945: expected operand, found '...'
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "${ ... }"}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "${b"}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "$a${b}"}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
--- PASS: TestErrStringLitEx (0.00s)
=== RUN   TestErrStringLiteral
 /app/parser/parser.go:713: ast.Ident{Name: run}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: run, Ellipsis: false, isCmd: true}
--- PASS: TestErrStringLiteral (0.00s)
=== RUN   TestErrFieldDecl
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
--- PASS: TestErrFieldDecl (0.00s)
=== RUN   TestParseFieldDecl
 /app/parser/parser.go:1050: expected field name or embedded type, found 'type'
--- PASS: TestParseFieldDecl (0.00s)
=== RUN   TestCheckExpr
 /app/parser/parser_test.go:349: expected expression
--- PASS: TestCheckExpr (0.00s)
=== RUN   TestErrFuncDecl
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:4060: expected ';', found '+'
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:453: expected type, found '+'
 /app/parser/parser.go:2110: expected '(', found newline
 /app/parser/parser.go:502: expected ')', found 'EOF'
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc0002d66a0 0xc0002d5140}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4004: expected ';', found 'EOF'
 /app/parser/parser.go:639: ast.Ident{Tok: +}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: b}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: +, ...}
--- PASS: TestErrFuncDecl (0.00s)
=== RUN   TestErrForIn
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:3482: expected 'in', found i
 /app/parser/parser.go:713: ast.Ident{Name: b}
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: a, Fors: [0xc0002f00c0]}
--- PASS: TestErrForIn (0.00s)
=== RUN   TestErrKwargExpr
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 13}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: f, Ellipsis: false, isCmd: true}
--- PASS: TestErrKwargExpr (0.00s)
=== RUN   TestNumberUnitLit
 /app/parser/parser.go:3459: expected 'IDENT', found , found 'ILLEGAL'
--- PASS: TestNumberUnitLit (0.00s)
=== RUN   TestImplicitIdent
--- PASS: TestImplicitIdent (0.00s)
=== RUN   TestErrGlobalVarWithSyntaxError
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:710: expected 'IDENT', found '='
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found 2
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: sprites}
 /app/parser/parser.go:1505: expected type argument list
 /app/parser/parser.go:3768: expected ';', found Sprite
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found ')'
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:1340: expected '(', found reset
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 10
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:713: ast.Ident{Name: sprites}
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:713: ast.Ident{Name: make}
 /app/parser/parser.go:713: ast.Ident{Name: Sprite}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: Sprite}
 /app/parser/parser.go:1593: expected ')', found ','
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:710: expected 'IDENT', found '}'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: onStart}
 /app/parser/parser.go:3768: expected ';', found '=>'
 /app/parser/parser.go:710: expected 'IDENT', found '{'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: reset}
 /app/parser/parser.go:3768: expected ';', found '('
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: sprites}
 /app/parser/parser.go:713: ast.Ident{Name: Sprite}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: Sprite}
 /app/parser/parser.go:713: ast.Ident{Name: reset}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
 /app/parser/parser.go:713: ast.Ident{Name: sprites}
 /app/parser/parser.go:713: ast.Ident{Name: make}
 /app/parser/parser.go:713: ast.Ident{Name: Sprite}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: Sprite}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: make, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: reset, ...}
 /app/parser/parser.go:713: ast.Ident{Name: onStart}
 /app/parser/parser.go:713: ast.Ident{Name: reset}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: reset, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: onStart, Ellipsis: false, isCmd: true}
--- PASS: TestErrGlobalVarWithSyntaxError (0.00s)
=== RUN   TestStd
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: t}
 /app/parser/parser.go:713: ast.Ident{Name: false}
 /app/parser/parser.go:713: ast.Ident{Name: t}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x:"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: s}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hello"}
 /app/parser/parser.go:713: ast.Ident{Name: s}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "world"}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hi"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "xsw"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x:"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:713: ast.Ident{Name: c}
 /app/parser/parser.go:713: ast.Ident{Name: make}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: make, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:713: ast.Ident{Name: c}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: c}
 /app/parser/parser.go:713: ast.Ident{Name: panic}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "error"}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: panic, Ellipsis: false, isCmd: false}
--- PASS: TestStd (0.00s)
=== RUN   TestFromInstance
=== RUN   TestFromInstance/instance1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_instance/instance1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(type) (
    1:  1: . . . "type"
    1:  6: . . . TypeSpec (
    1:  6: . . . . IDENT T1
 /app/parser/parser.go:713: ast.Ident{Name: T1}
    1:  9: . . . . Type (
    1:  9: . . . . . TypeName (
    1:  9: . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    1: 11: . . . . . )
    1: 11: . . . . . TypeInstance (
    1: 11: . . . . . . "["
    1: 12: . . . . . . Type (
    1: 12: . . . . . . . TypeName (
    1: 12: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 15: . . . . . . . )
    1: 15: . . . . . . )
    1: 15: . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    1: 16: . . . . . )
    1: 16: . . . . )
    1: 16: . . . . ";"
    3:  1: . . . )
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . GenDecl(type) (
    3:  1: . . . "type"
    3:  6: . . . TypeSpec (
    3:  6: . . . . IDENT T2
 /app/parser/parser.go:713: ast.Ident{Name: T2}
    3:  9: . . . . Type (
    3:  9: . . . . . TypeName (
    3:  9: . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    3: 11: . . . . . )
    3: 11: . . . . . TypeInstance (
    3: 11: . . . . . . "["
    3: 12: . . . . . . Type (
    3: 12: . . . . . . . TypeName (
    3: 12: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 15: . . . . . . . )
    3: 15: . . . . . . )
    3: 15: . . . . . . ","
    3: 17: . . . . . . Type (
    3: 17: . . . . . . . TypeName (
    3: 17: . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    3: 23: . . . . . . . )
    3: 23: . . . . . . )
    3: 23: . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    3: 24: . . . . . )
    3: 24: . . . . )
    3: 24: . . . . ";"
    5:  1: . . . )
    5:  1: . . )
    5:  1: . )
    5:  1: . Declaration (
    5:  1: . . GenDecl(type) (
    5:  1: . . . "type"
    5:  6: . . . TypeSpec (
    5:  6: . . . . IDENT T3
 /app/parser/parser.go:713: ast.Ident{Name: T3}
    5:  9: . . . . Type (
    5:  9: . . . . . PointerType (
    5:  9: . . . . . . "*"
    5: 10: . . . . . . Type (
    5: 10: . . . . . . . TypeName (
    5: 10: . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    5: 12: . . . . . . . )
    5: 12: . . . . . . . TypeInstance (
    5: 12: . . . . . . . . "["
    5: 13: . . . . . . . . Type (
    5: 13: . . . . . . . . . TypeName (
    5: 13: . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    5: 15: . . . . . . . . . )
    5: 15: . . . . . . . . . TypeInstance (
    5: 15: . . . . . . . . . . "["
    5: 16: . . . . . . . . . . Type (
    5: 16: . . . . . . . . . . . TypeName (
    5: 16: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 19: . . . . . . . . . . . )
    5: 19: . . . . . . . . . . )
    5: 19: . . . . . . . . . . ","
    5: 21: . . . . . . . . . . Type (
    5: 21: . . . . . . . . . . . TypeName (
    5: 21: . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    5: 23: . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . TypeInstance (
    5: 23: . . . . . . . . . . . . "["
    5: 24: . . . . . . . . . . . . Type (
    5: 24: . . . . . . . . . . . . . TypeName (
    5: 24: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 27: . . . . . . . . . . . . . )
    5: 27: . . . . . . . . . . . . )
    5: 27: . . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    5: 28: . . . . . . . . . . . )
    5: 28: . . . . . . . . . . )
    5: 28: . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int 0xc0000f9110]}
    5: 29: . . . . . . . . . )
    5: 29: . . . . . . . . )
    5: 29: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: &{P2 57 [int 0xc0000f9110] 70}}
    5: 30: . . . . . . . )
    5: 30: . . . . . . )
    5: 30: . . . . . )
    5: 30: . . . . )
    5: 30: . . . . ";"
    7:  1: . . . )
    7:  1: . . )
    7:  1: . )
    7:  1: . Declaration (
    7:  1: . . GenDecl(type) (
    7:  1: . . . "type"
    7:  6: . . . TypeSpec (
    7:  6: . . . . IDENT S1
 /app/parser/parser.go:713: ast.Ident{Name: S1}
    7:  9: . . . . Type (
    7:  9: . . . . . StructType (
    7:  9: . . . . . . "struct"
    7: 16: . . . . . . "{"
    8:  2: . . . . . . FieldDecl (
    8:  2: . . . . . . . IDENT v1
 /app/parser/parser.go:713: ast.Ident{Name: v1}
    8:  5: . . . . . . . Type (
    8:  5: . . . . . . . . TypeName (
    8:  5: . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    8:  7: . . . . . . . . )
    8:  7: . . . . . . . . TypeInstance (
    8:  7: . . . . . . . . . "["
    8:  8: . . . . . . . . . Type (
    8:  8: . . . . . . . . . . TypeName (
    8:  8: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    8: 11: . . . . . . . . . . )
    8: 11: . . . . . . . . . )
    8: 11: . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    8: 12: . . . . . . . . )
    8: 12: . . . . . . . )
    8: 12: . . . . . . . ";"
    9:  2: . . . . . . )
    9:  2: . . . . . . FieldDecl (
    9:  2: . . . . . . . IDENT v2
 /app/parser/parser.go:713: ast.Ident{Name: v2}
    9:  5: . . . . . . . Type (
    9:  5: . . . . . . . . TypeName (
    9:  5: . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    9:  7: . . . . . . . . )
    9:  7: . . . . . . . . TypeInstance (
    9:  7: . . . . . . . . . "["
    9:  8: . . . . . . . . . Type (
    9:  8: . . . . . . . . . . TypeName (
    9:  8: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 11: . . . . . . . . . . )
    9: 11: . . . . . . . . . )
    9: 11: . . . . . . . . . ","
    9: 13: . . . . . . . . . Type (
    9: 13: . . . . . . . . . . TypeName (
    9: 13: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    9: 19: . . . . . . . . . . )
    9: 19: . . . . . . . . . )
    9: 19: . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    9: 20: . . . . . . . . )
    9: 20: . . . . . . . )
    9: 20: . . . . . . . ";"
   10:  1: . . . . . . )
   10:  1: . . . . . . "}"
   10:  2: . . . . . )
   10:  2: . . . . )
   10:  2: . . . . ";"
   12:  1: . . . )
   12:  1: . . )
   12:  1: . )
   12:  1: . Declaration (
   12:  1: . . GenDecl(type) (
   12:  1: . . . "type"
   12:  6: . . . TypeSpec (
   12:  6: . . . . IDENT S2
 /app/parser/parser.go:713: ast.Ident{Name: S2}
   12:  9: . . . . Type (
   12:  9: . . . . . StructType (
   12:  9: . . . . . . "struct"
   12: 16: . . . . . . "{"
   13:  2: . . . . . . FieldDecl (
   13:  2: . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   13:  4: . . . . . . . ArrayFieldOrTypeInstance (
   13:  4: . . . . . . . . "["
   13:  5: . . . . . . . . Expression (
   13:  5: . . . . . . . . . BinaryExpr (
   13:  5: . . . . . . . . . . UnaryExpr (
   13:  5: . . . . . . . . . . . PrimaryExpr (
   13:  5: . . . . . . . . . . . . Operand (
   13:  5: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   13:  8: . . . . . . . . . . . . )
   13:  8: . . . . . . . . . . . )
   13:  8: . . . . . . . . . . )
   13:  8: . . . . . . . . . )
   13:  8: . . . . . . . . )
   13:  8: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   13:  9: . . . . . . . )
   13:  9: . . . . . . . ";"
   14:  1: . . . . . . )
   14:  1: . . . . . . "}"
   14:  2: . . . . . )
   14:  2: . . . . )
   14:  2: . . . . ";"
   16:  1: . . . )
   16:  1: . . )
   16:  1: . )
   16:  1: . Declaration (
   16:  1: . . GenDecl(type) (
   16:  1: . . . "type"
   16:  6: . . . TypeSpec (
   16:  6: . . . . IDENT A1
 /app/parser/parser.go:713: ast.Ident{Name: A1}
   16:  9: . . . . Type (
   16:  9: . . . . . ArrayType (
   16:  9: . . . . . . "["
   16: 10: . . . . . . "]"
   16: 11: . . . . . . Type (
   16: 11: . . . . . . . TypeName (
   16: 11: . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   16: 13: . . . . . . . )
   16: 13: . . . . . . . TypeInstance (
   16: 13: . . . . . . . . "["
   16: 14: . . . . . . . . Type (
   16: 14: . . . . . . . . . TypeName (
   16: 14: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16: 17: . . . . . . . . . )
   16: 17: . . . . . . . . )
   16: 17: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   16: 18: . . . . . . . )
   16: 18: . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{P1 167 int 171}}
   16: 18: . . . . . )
   16: 18: . . . . )
   16: 18: . . . . ";"
   18:  1: . . . )
   18:  1: . . )
   18:  1: . )
   18:  1: . Declaration (
   18:  1: . . GenDecl(type) (
   18:  1: . . . "type"
   18:  6: . . . TypeSpec (
   18:  6: . . . . IDENT A2
 /app/parser/parser.go:713: ast.Ident{Name: A2}
   18:  9: . . . . Type (
   18:  9: . . . . . ArrayType (
   18:  9: . . . . . . "["
   18: 10: . . . . . . Expression (
   18: 10: . . . . . . . BinaryExpr (
   18: 10: . . . . . . . . UnaryExpr (
   18: 10: . . . . . . . . . PrimaryExpr (
   18: 10: . . . . . . . . . . Operand (
   18: 10: . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   18: 11: . . . . . . . . . . )
   18: 11: . . . . . . . . . )
   18: 11: . . . . . . . . )
   18: 11: . . . . . . . )
   18: 11: . . . . . . )
   18: 11: . . . . . . "]"
   18: 12: . . . . . . Type (
   18: 12: . . . . . . . TypeName (
   18: 12: . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   18: 14: . . . . . . . )
   18: 14: . . . . . . . TypeInstance (
   18: 14: . . . . . . . . "["
   18: 15: . . . . . . . . Type (
   18: 15: . . . . . . . . . TypeName (
   18: 15: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   18: 18: . . . . . . . . . )
   18: 18: . . . . . . . . )
   18: 18: . . . . . . . . ","
   18: 20: . . . . . . . . Type (
   18: 20: . . . . . . . . . TypeName (
   18: 20: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   18: 26: . . . . . . . . . )
   18: 26: . . . . . . . . )
   18: 26: . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   18: 27: . . . . . . . )
   18: 27: . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: &{183 INT 2 <nil>}, Elt: &{P2 187 [int string] 199}}
   18: 27: . . . . . )
   18: 27: . . . . )
   18: 27: . . . . ";"
   20:  1: . . . )
   20:  1: . . )
   20:  1: . )
   20:  1: . Declaration (
   20:  1: . . GenDecl(type) (
   20:  1: . . . "type"
   20:  6: . . . TypeSpec (
   20:  6: . . . . IDENT M1
 /app/parser/parser.go:713: ast.Ident{Name: M1}
   20:  9: . . . . Type (
   20:  9: . . . . . MapType (
   20:  9: . . . . . . "map"
   20: 12: . . . . . . "["
   20: 13: . . . . . . Type (
   20: 13: . . . . . . . TypeName (
   20: 13: . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   20: 15: . . . . . . . )
   20: 15: . . . . . . . TypeInstance (
   20: 15: . . . . . . . . "["
   20: 16: . . . . . . . . Type (
   20: 16: . . . . . . . . . TypeName (
   20: 16: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   20: 19: . . . . . . . . . )
   20: 19: . . . . . . . . )
   20: 19: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   20: 20: . . . . . . . )
   20: 20: . . . . . . )
   20: 20: . . . . . . "]"
   20: 21: . . . . . . Type (
   20: 21: . . . . . . . TypeName (
   20: 21: . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   20: 23: . . . . . . . )
   20: 23: . . . . . . . TypeInstance (
   20: 23: . . . . . . . . "["
   20: 24: . . . . . . . . Type (
   20: 24: . . . . . . . . . TypeName (
   20: 24: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   20: 27: . . . . . . . . . )
   20: 27: . . . . . . . . )
   20: 27: . . . . . . . . ","
   20: 29: . . . . . . . . Type (
   20: 29: . . . . . . . . . TypeName (
   20: 29: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   20: 35: . . . . . . . . . )
   20: 35: . . . . . . . . )
   20: 35: . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   20: 36: . . . . . . . )
   20: 36: . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: &{P1 216 int 220}, Value: &{P2 224 [int string] 236}}
   20: 36: . . . . . )
   20: 36: . . . . )
   20: 36: . . . . ";"
   22:  1: . . . )
   22:  1: . . )
   22:  1: . )
   22:  1: . Declaration (
   22:  1: . . GenDecl(type) (
   22:  1: . . . "type"
   22:  6: . . . TypeSpec (
   22:  6: . . . . IDENT C1
 /app/parser/parser.go:713: ast.Ident{Name: C1}
   22:  9: . . . . Type (
   22:  9: . . . . . ChanType (
   22:  9: . . . . . . "chan"
   22: 14: . . . . . . Type (
   22: 14: . . . . . . . TypeName (
   22: 14: . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   22: 16: . . . . . . . )
   22: 16: . . . . . . . TypeInstance (
   22: 16: . . . . . . . . "["
   22: 17: . . . . . . . . Type (
   22: 17: . . . . . . . . . TypeName (
   22: 17: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   22: 20: . . . . . . . . . )
   22: 20: . . . . . . . . )
   22: 20: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   22: 21: . . . . . . . )
   22: 21: . . . . . . )
   22: 21: . . . . . )
   22: 21: . . . . )
   22: 21: . . . . ";"
   22: 22: . . . )
   22: 22: . . )
   22: 22: . )
   22: 22: )
=== RUN   TestFromInstance/instance2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_instance/instance2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT fn1
 /app/parser/parser.go:713: ast.Ident{Name: fn1}
    1:  9: . . . Signature (
    1:  9: . . . . Parameters (
    1:  9: . . . . . "("
    1: 10: . . . . . ParameterList (
    1: 10: . . . . . . ParamDeclOrNil (
    1: 10: . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    1: 12: . . . . . . . ArrayFieldOrTypeInstance (
    1: 12: . . . . . . . . "["
    1: 13: . . . . . . . . Expression (
    1: 13: . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 16: . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . )
    1: 16: . . . . . . . . . . )
    1: 16: . . . . . . . . . )
    1: 16: . . . . . . . . )
    1: 16: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    1: 17: . . . . . . . )
    1: 17: . . . . . . )
    1: 17: . . . . . . ","
    1: 19: . . . . . . ParamDeclOrNil (
    1: 19: . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    1: 21: . . . . . . . ArrayFieldOrTypeInstance (
    1: 21: . . . . . . . . "["
    1: 22: . . . . . . . . Expression (
    1: 22: . . . . . . . . . BinaryExpr (
    1: 22: . . . . . . . . . . UnaryExpr (
    1: 22: . . . . . . . . . . . PrimaryExpr (
    1: 22: . . . . . . . . . . . . Operand (
    1: 22: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 25: . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . )
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . . ","
    1: 27: . . . . . . . . Expression (
    1: 27: . . . . . . . . . BinaryExpr (
    1: 27: . . . . . . . . . . UnaryExpr (
    1: 27: . . . . . . . . . . . PrimaryExpr (
    1: 27: . . . . . . . . . . . . Operand (
    1: 27: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    1: 33: . . . . . . . . . . . . )
    1: 33: . . . . . . . . . . . )
    1: 33: . . . . . . . . . . )
    1: 33: . . . . . . . . . )
    1: 33: . . . . . . . . )
    1: 33: . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    1: 34: . . . . . . . )
    1: 34: . . . . . . )
    1: 34: . . . . . )
    1: 34: . . . . . ")"
    1: 35: . . . . )
    1: 35: . . . . Result (
    1: 35: . . . . )
    1: 35: . . . )
    1: 35: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn1, ...}
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT fn2
 /app/parser/parser.go:713: ast.Ident{Name: fn2}
    3:  9: . . . Signature (
    3:  9: . . . . Parameters (
    3:  9: . . . . . "("
    3: 10: . . . . . ParameterList (
    3: 10: . . . . . . ParamDeclOrNil (
    3: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
    3: 13: . . . . . . . Type (
    3: 13: . . . . . . . . TypeName (
    3: 13: . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    3: 15: . . . . . . . . )
    3: 15: . . . . . . . . TypeInstance (
    3: 15: . . . . . . . . . "["
    3: 16: . . . . . . . . . Type (
    3: 16: . . . . . . . . . . TypeName (
    3: 16: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 19: . . . . . . . . . . )
    3: 19: . . . . . . . . . )
    3: 19: . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    3: 20: . . . . . . . . )
    3: 20: . . . . . . . )
    3: 20: . . . . . . )
    3: 20: . . . . . . ","
    3: 22: . . . . . . ParamDeclOrNil (
    3: 22: . . . . . . . IDENT p2
 /app/parser/parser.go:713: ast.Ident{Name: p2}
    3: 25: . . . . . . . Type (
    3: 25: . . . . . . . . TypeName (
    3: 25: . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    3: 27: . . . . . . . . )
    3: 27: . . . . . . . . TypeInstance (
    3: 27: . . . . . . . . . "["
    3: 28: . . . . . . . . . Type (
    3: 28: . . . . . . . . . . TypeName (
    3: 28: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 31: . . . . . . . . . . )
    3: 31: . . . . . . . . . )
    3: 31: . . . . . . . . . ","
    3: 33: . . . . . . . . . Type (
    3: 33: . . . . . . . . . . TypeName (
    3: 33: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    3: 39: . . . . . . . . . . )
    3: 39: . . . . . . . . . )
    3: 39: . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    3: 40: . . . . . . . . )
    3: 40: . . . . . . . )
    3: 40: . . . . . . )
    3: 40: . . . . . )
    3: 40: . . . . . ")"
    3: 41: . . . . )
    3: 41: . . . . Result (
    3: 41: . . . . )
    3: 41: . . . )
    3: 41: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn2, ...}
    5:  1: . . )
    5:  1: . )
    5:  1: . Declaration (
    5:  1: . . FunctionDeclOrCall (
    5:  1: . . . "func"
    5:  6: . . . IDENT fn3
 /app/parser/parser.go:713: ast.Ident{Name: fn3}
    5:  9: . . . Signature (
    5:  9: . . . . Parameters (
    5:  9: . . . . . "("
    5: 10: . . . . . ParameterList (
    5: 10: . . . . . . ParamDeclOrNil (
    5: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
    5: 13: . . . . . . . Type (
    5: 13: . . . . . . . . TypeName (
    5: 13: . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    5: 15: . . . . . . . . )
    5: 15: . . . . . . . . TypeInstance (
    5: 15: . . . . . . . . . "["
    5: 16: . . . . . . . . . Type (
    5: 16: . . . . . . . . . . TypeName (
    5: 16: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 19: . . . . . . . . . . )
    5: 19: . . . . . . . . . )
    5: 19: . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    5: 20: . . . . . . . . )
    5: 20: . . . . . . . )
    5: 20: . . . . . . )
    5: 20: . . . . . . ","
    5: 22: . . . . . . ParamDeclOrNil (
    5: 22: . . . . . . . IDENT p2
 /app/parser/parser.go:713: ast.Ident{Name: p2}
    5: 25: . . . . . . . DotsType (
    5: 25: . . . . . . . . "..."
    5: 28: . . . . . . . . Type (
    5: 28: . . . . . . . . . TypeName (
    5: 28: . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    5: 30: . . . . . . . . . )
    5: 30: . . . . . . . . . TypeInstance (
    5: 30: . . . . . . . . . . "["
    5: 31: . . . . . . . . . . Type (
    5: 31: . . . . . . . . . . . TypeName (
    5: 31: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 34: . . . . . . . . . . . )
    5: 34: . . . . . . . . . . )
    5: 34: . . . . . . . . . . ","
    5: 36: . . . . . . . . . . Type (
    5: 36: . . . . . . . . . . . TypeName (
    5: 36: . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 42: . . . . . . . . . . . )
    5: 42: . . . . . . . . . . )
    5: 42: . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    5: 43: . . . . . . . . . )
    5: 43: . . . . . . . . )
    5: 43: . . . . . . . )
    5: 43: . . . . . . )
    5: 43: . . . . . )
    5: 43: . . . . . ")"
    5: 44: . . . . )
    5: 44: . . . . Result (
    5: 44: . . . . )
    5: 44: . . . )
    5: 44: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn3, ...}
    7:  1: . . )
    7:  1: . )
    7:  1: . Declaration (
    7:  1: . . FunctionDeclOrCall (
    7:  1: . . . "func"
    7:  6: . . . IDENT fn4
 /app/parser/parser.go:713: ast.Ident{Name: fn4}
    7:  9: . . . Signature (
    7:  9: . . . . Parameters (
    7:  9: . . . . . "("
    7: 10: . . . . . ParameterList (
    7: 10: . . . . . . ParamDeclOrNil (
    7: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
    7: 13: . . . . . . . ArrayFieldOrTypeInstance (
    7: 13: . . . . . . . . "["
    7: 14: . . . . . . . . "]"
    7: 15: . . . . . . . . Type (
    7: 15: . . . . . . . . . TypeName (
    7: 15: . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    7: 17: . . . . . . . . . )
    7: 17: . . . . . . . . . TypeInstance (
    7: 17: . . . . . . . . . . "["
    7: 18: . . . . . . . . . . Type (
    7: 18: . . . . . . . . . . . TypeName (
    7: 18: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 21: . . . . . . . . . . . )
    7: 21: . . . . . . . . . . )
    7: 21: . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    7: 22: . . . . . . . . . )
    7: 22: . . . . . . . . )
    7: 22: . . . . . . . )
    7: 22: . . . . . . )
    7: 22: . . . . . . ","
    7: 24: . . . . . . ParamDeclOrNil (
    7: 24: . . . . . . . IDENT p3
 /app/parser/parser.go:713: ast.Ident{Name: p3}
    7: 27: . . . . . . . ArrayFieldOrTypeInstance (
    7: 27: . . . . . . . . "["
    7: 28: . . . . . . . . "]"
    7: 29: . . . . . . . . Type (
    7: 29: . . . . . . . . . TypeName (
    7: 29: . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    7: 31: . . . . . . . . . )
    7: 31: . . . . . . . . . TypeInstance (
    7: 31: . . . . . . . . . . "["
    7: 32: . . . . . . . . . . Type (
    7: 32: . . . . . . . . . . . TypeName (
    7: 32: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 35: . . . . . . . . . . . )
    7: 35: . . . . . . . . . . )
    7: 35: . . . . . . . . . . ","
    7: 37: . . . . . . . . . . Type (
    7: 37: . . . . . . . . . . . TypeName (
    7: 37: . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    7: 43: . . . . . . . . . . . )
    7: 43: . . . . . . . . . . )
    7: 43: . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    7: 44: . . . . . . . . . )
    7: 44: . . . . . . . . )
    7: 44: . . . . . . . )
    7: 44: . . . . . . )
    7: 44: . . . . . )
    7: 44: . . . . . ")"
    7: 46: . . . . )
    7: 46: . . . . Result (
    7: 46: . . . . . PointerType (
    7: 46: . . . . . . "*"
    7: 47: . . . . . . Type (
    7: 47: . . . . . . . TypeName (
    7: 47: . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    7: 49: . . . . . . . )
    7: 49: . . . . . . . TypeInstance (
    7: 49: . . . . . . . . "["
    7: 50: . . . . . . . . Type (
    7: 50: . . . . . . . . . TypeName (
    7: 50: . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    7: 52: . . . . . . . . . )
    7: 52: . . . . . . . . . TypeInstance (
    7: 52: . . . . . . . . . . "["
    7: 53: . . . . . . . . . . Type (
    7: 53: . . . . . . . . . . . TypeName (
    7: 53: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 56: . . . . . . . . . . . )
    7: 56: . . . . . . . . . . )
    7: 56: . . . . . . . . . . ","
    7: 58: . . . . . . . . . . Type (
    7: 58: . . . . . . . . . . . TypeName (
    7: 58: . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    7: 60: . . . . . . . . . . . )
    7: 60: . . . . . . . . . . . TypeInstance (
    7: 60: . . . . . . . . . . . . "["
    7: 61: . . . . . . . . . . . . Type (
    7: 61: . . . . . . . . . . . . . TypeName (
    7: 61: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 64: . . . . . . . . . . . . . )
    7: 64: . . . . . . . . . . . . )
    7: 64: . . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    7: 65: . . . . . . . . . . . )
    7: 65: . . . . . . . . . . )
    7: 65: . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int 0xc0000f98c0]}
    7: 66: . . . . . . . . . )
    7: 66: . . . . . . . . )
    7: 66: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: &{P2 175 [int 0xc0000f98c0] 188}}
    7: 67: . . . . . . . )
    7: 67: . . . . . . )
    7: 67: . . . . . )
    7: 67: . . . . )
    7: 67: . . . )
    7: 67: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn4, ...}
    9:  1: . . )
    9:  1: . )
    9:  1: . Declaration (
    9:  1: . . FunctionDeclOrCall (
    9:  1: . . . "func"
    9:  6: . . . IDENT fn5
 /app/parser/parser.go:713: ast.Ident{Name: fn5}
    9:  9: . . . Signature (
    9:  9: . . . . Parameters (
    9:  9: . . . . . "("
    9: 10: . . . . . ParameterList (
    9: 10: . . . . . . ParamDeclOrNil (
    9: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
    9: 13: . . . . . . . ArrayFieldOrTypeInstance (
    9: 13: . . . . . . . . "["
    9: 14: . . . . . . . . "]"
    9: 15: . . . . . . . . Type (
    9: 15: . . . . . . . . . TypeName (
    9: 15: . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    9: 17: . . . . . . . . . )
    9: 17: . . . . . . . . . TypeInstance (
    9: 17: . . . . . . . . . . "["
    9: 18: . . . . . . . . . . Type (
    9: 18: . . . . . . . . . . . TypeName (
    9: 18: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 21: . . . . . . . . . . . )
    9: 21: . . . . . . . . . . )
    9: 21: . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    9: 22: . . . . . . . . . )
    9: 22: . . . . . . . . )
    9: 22: . . . . . . . )
    9: 22: . . . . . . )
    9: 22: . . . . . . ","
    9: 24: . . . . . . ParamDeclOrNil (
    9: 24: . . . . . . . IDENT p2
 /app/parser/parser.go:713: ast.Ident{Name: p2}
    9: 27: . . . . . . . ArrayFieldOrTypeInstance (
    9: 27: . . . . . . . . "["
    9: 28: . . . . . . . . Expression (
    9: 28: . . . . . . . . . BinaryExpr (
    9: 28: . . . . . . . . . . UnaryExpr (
    9: 28: . . . . . . . . . . . PrimaryExpr (
    9: 28: . . . . . . . . . . . . Operand (
    9: 28: . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    9: 29: . . . . . . . . . . . . )
    9: 29: . . . . . . . . . . . )
    9: 29: . . . . . . . . . . )
    9: 29: . . . . . . . . . )
    9: 29: . . . . . . . . )
    9: 29: . . . . . . . . "]"
    9: 30: . . . . . . . . TypeName (
    9: 30: . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    9: 32: . . . . . . . . )
    9: 32: . . . . . . . . TypeInstance (
    9: 32: . . . . . . . . . "["
    9: 33: . . . . . . . . . Type (
    9: 33: . . . . . . . . . . TypeName (
    9: 33: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 36: . . . . . . . . . . )
    9: 36: . . . . . . . . . )
    9: 36: . . . . . . . . . ","
    9: 38: . . . . . . . . . Type (
    9: 38: . . . . . . . . . . TypeName (
    9: 38: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    9: 44: . . . . . . . . . . )
    9: 44: . . . . . . . . . )
    9: 44: . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    9: 45: . . . . . . . . )
    9: 45: . . . . . . . )
    9: 45: . . . . . . )
    9: 45: . . . . . )
    9: 45: . . . . . ")"
    9: 46: . . . . )
    9: 46: . . . . Result (
    9: 46: . . . . )
    9: 46: . . . )
    9: 46: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn5, ...}
   11:  1: . . )
   11:  1: . )
   11:  1: . Declaration (
   11:  1: . . FunctionDeclOrCall (
   11:  1: . . . "func"
   11:  6: . . . IDENT fn6
 /app/parser/parser.go:713: ast.Ident{Name: fn6}
   11:  9: . . . Signature (
   11:  9: . . . . Parameters (
   11:  9: . . . . . "("
   11: 10: . . . . . ParameterList (
   11: 10: . . . . . . ParamDeclOrNil (
   11: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
   11: 13: . . . . . . . Type (
   11: 13: . . . . . . . . ChanType (
   11: 13: . . . . . . . . . "chan"
   11: 18: . . . . . . . . . Type (
   11: 18: . . . . . . . . . . TypeName (
   11: 18: . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   11: 20: . . . . . . . . . . )
   11: 20: . . . . . . . . . . TypeInstance (
   11: 20: . . . . . . . . . . . "["
   11: 21: . . . . . . . . . . . Type (
   11: 21: . . . . . . . . . . . . TypeName (
   11: 21: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   11: 24: . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   11: 25: . . . . . . . . . . )
   11: 25: . . . . . . . . . )
   11: 25: . . . . . . . . )
   11: 25: . . . . . . . )
   11: 25: . . . . . . )
   11: 25: . . . . . . ","
   11: 27: . . . . . . ParamDeclOrNil (
   11: 27: . . . . . . . IDENT p2
 /app/parser/parser.go:713: ast.Ident{Name: p2}
   11: 30: . . . . . . . Type (
   11: 30: . . . . . . . . MapType (
   11: 30: . . . . . . . . . "map"
   11: 33: . . . . . . . . . "["
   11: 34: . . . . . . . . . Type (
   11: 34: . . . . . . . . . . TypeName (
   11: 34: . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   11: 36: . . . . . . . . . . )
   11: 36: . . . . . . . . . . TypeInstance (
   11: 36: . . . . . . . . . . . "["
   11: 37: . . . . . . . . . . . Type (
   11: 37: . . . . . . . . . . . . TypeName (
   11: 37: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   11: 40: . . . . . . . . . . . . )
   11: 40: . . . . . . . . . . . )
   11: 40: . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   11: 41: . . . . . . . . . . )
   11: 41: . . . . . . . . . )
   11: 41: . . . . . . . . . "]"
   11: 42: . . . . . . . . . Type (
   11: 42: . . . . . . . . . . TypeName (
   11: 42: . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   11: 44: . . . . . . . . . . )
   11: 44: . . . . . . . . . . TypeInstance (
   11: 44: . . . . . . . . . . . "["
   11: 45: . . . . . . . . . . . Type (
   11: 45: . . . . . . . . . . . . TypeName (
   11: 45: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   11: 48: . . . . . . . . . . . . )
   11: 48: . . . . . . . . . . . )
   11: 48: . . . . . . . . . . . ","
   11: 50: . . . . . . . . . . . Type (
   11: 50: . . . . . . . . . . . . TypeName (
   11: 50: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   11: 56: . . . . . . . . . . . . )
   11: 56: . . . . . . . . . . . )
   11: 56: . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   11: 57: . . . . . . . . . . )
   11: 57: . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: &{P1 274 int 278}, Value: &{P2 282 [int string] 294}}
   11: 57: . . . . . . . . )
   11: 57: . . . . . . . )
   11: 57: . . . . . . )
   11: 57: . . . . . )
   11: 57: . . . . . ")"
   11: 58: . . . . )
   11: 58: . . . . Result (
   11: 58: . . . . )
   11: 58: . . . )
   11: 58: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn6, ...}
   13:  1: . . )
   13:  1: . )
   13:  1: . Declaration (
   13:  1: . . FunctionDeclOrCall (
   13:  1: . . . "func"
   13:  6: . . . IDENT fn7
 /app/parser/parser.go:713: ast.Ident{Name: fn7}
   13:  9: . . . Signature (
   13:  9: . . . . Parameters (
   13:  9: . . . . . "("
   13: 10: . . . . . ParameterList (
   13: 10: . . . . . . ParamDeclOrNil (
   13: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
   13: 13: . . . . . . . Type (
   13: 13: . . . . . . . . StructType (
   13: 13: . . . . . . . . . "struct"
   13: 20: . . . . . . . . . "{"
   14:  2: . . . . . . . . . FieldDecl (
   14:  2: . . . . . . . . . . IDENT v1
 /app/parser/parser.go:713: ast.Ident{Name: v1}
   14:  5: . . . . . . . . . . Type (
   14:  5: . . . . . . . . . . . TypeName (
   14:  5: . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   14:  7: . . . . . . . . . . . )
   14:  7: . . . . . . . . . . . TypeInstance (
   14:  7: . . . . . . . . . . . . "["
   14:  8: . . . . . . . . . . . . Type (
   14:  8: . . . . . . . . . . . . . TypeName (
   14:  8: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   14: 11: . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   14: 12: . . . . . . . . . . . )
   14: 12: . . . . . . . . . . )
   14: 12: . . . . . . . . . . ";"
   15:  2: . . . . . . . . . )
   15:  2: . . . . . . . . . FieldDecl (
   15:  2: . . . . . . . . . . IDENT v2
 /app/parser/parser.go:713: ast.Ident{Name: v2}
   15:  5: . . . . . . . . . . Type (
   15:  5: . . . . . . . . . . . TypeName (
   15:  5: . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   15:  7: . . . . . . . . . . . )
   15:  7: . . . . . . . . . . . TypeInstance (
   15:  7: . . . . . . . . . . . . "["
   15:  8: . . . . . . . . . . . . Type (
   15:  8: . . . . . . . . . . . . . TypeName (
   15:  8: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   15: 11: . . . . . . . . . . . . . )
   15: 11: . . . . . . . . . . . . )
   15: 11: . . . . . . . . . . . . ","
   15: 13: . . . . . . . . . . . . Type (
   15: 13: . . . . . . . . . . . . . TypeName (
   15: 13: . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   15: 19: . . . . . . . . . . . . . )
   15: 19: . . . . . . . . . . . . )
   15: 19: . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   15: 20: . . . . . . . . . . . )
   15: 20: . . . . . . . . . . )
   15: 20: . . . . . . . . . . ";"
   16:  1: . . . . . . . . . )
   16:  1: . . . . . . . . . "}"
   16:  2: . . . . . . . . )
   16:  2: . . . . . . . )
   16:  2: . . . . . . )
   16:  2: . . . . . )
   16:  2: . . . . . ")"
   16:  3: . . . . )
   16:  3: . . . . Result (
   16:  3: . . . . )
   16:  3: . . . )
   16:  3: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn7, ...}
   16:  4: . . )
   16:  4: . )
   16:  4: )
=== RUN   TestFromInstance/instance3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_instance/instance3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  8: . . . . . . . . . . )
    1:  8: . . . . . . . . . . CallOrConversion (
    1:  8: . . . . . . . . . . . "("
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . IndexOrSlice (
    1: 11: . . . . . . . . . . . . . . . . "["
    1: 12: . . . . . . . . . . . . . . . . Expression (
    1: 12: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 12: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 15: . . . . . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
    1: 16: . . . . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . . . . . LiteralValue (
    1: 16: . . . . . . . . . . . . . . . . "{"
    1: 17: . . . . . . . . . . . . . . . . "}"
    1: 18: . . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . ","
    1: 20: . . . . . . . . . . . Expression (
    1: 20: . . . . . . . . . . . . BinaryExpr (
    1: 20: . . . . . . . . . . . . . UnaryExpr (
    1: 20: . . . . . . . . . . . . . . PrimaryExpr (
    1: 20: . . . . . . . . . . . . . . . Operand (
    1: 20: . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    1: 22: . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . IndexOrSlice (
    1: 22: . . . . . . . . . . . . . . . . "["
    1: 23: . . . . . . . . . . . . . . . . Expression (
    1: 23: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 23: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 23: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 23: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 23: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 26: . . . . . . . . . . . . . . . . . . . . )
    1: 26: . . . . . . . . . . . . . . . . . . . )
    1: 26: . . . . . . . . . . . . . . . . . . )
    1: 26: . . . . . . . . . . . . . . . . . )
    1: 26: . . . . . . . . . . . . . . . . )
    1: 26: . . . . . . . . . . . . . . . . ","
    1: 28: . . . . . . . . . . . . . . . . Type (
    1: 28: . . . . . . . . . . . . . . . . . TypeName (
    1: 28: . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    1: 34: . . . . . . . . . . . . . . . . . )
    1: 34: . . . . . . . . . . . . . . . . )
    1: 34: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    1: 35: . . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . . . LiteralValue (
    1: 35: . . . . . . . . . . . . . . . . "{"
    1: 36: . . . . . . . . . . . . . . . . "}"
    1: 37: . . . . . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    1: 38: . . . . . . . . . . )
    1: 38: . . . . . . . . . )
    1: 38: . . . . . . . . )
    1: 38: . . . . . . . )
    1: 38: . . . . . . )
    1: 38: . . . . . )
    1: 38: . . . . )
    1: 38: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  8: . . . . . . . . . . )
    2:  8: . . . . . . . . . . CallOrConversion (
    2:  8: . . . . . . . . . . . "("
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . "("
    2: 10: . . . . . . . . . . . . . . . . Expression (
    2: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . "*"
    2: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    2: 13: . . . . . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . "["
    2: 14: . . . . . . . . . . . . . . . . . . . . . . Expression (
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    2: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
    2: 18: . . . . . . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{48 0xc0000f9f20}}
    2: 19: . . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . . . CallOrConversion (
    2: 19: . . . . . . . . . . . . . . . . "("
    2: 20: . . . . . . . . . . . . . . . . Expression (
    2: 20: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 20: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 20: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 20: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 20: . . . . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    2: 23: . . . . . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{47 0xc00000efa8 56}, Ellipsis: false, isCmd: false}
    2: 24: . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . ","
    2: 26: . . . . . . . . . . . Expression (
    2: 26: . . . . . . . . . . . . BinaryExpr (
    2: 26: . . . . . . . . . . . . . UnaryExpr (
    2: 26: . . . . . . . . . . . . . . PrimaryExpr (
    2: 26: . . . . . . . . . . . . . . . Operand (
    2: 26: . . . . . . . . . . . . . . . . "("
    2: 27: . . . . . . . . . . . . . . . . Expression (
    2: 27: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . . "*"
    2: 28: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 28: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 28: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 28: . . . . . . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    2: 30: . . . . . . . . . . . . . . . . . . . . . )
    2: 30: . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    2: 30: . . . . . . . . . . . . . . . . . . . . . . "["
    2: 31: . . . . . . . . . . . . . . . . . . . . . . Expression (
    2: 31: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 31: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 31: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    2: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 34: . . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    2: 34: . . . . . . . . . . . . . . . . . . . . . . )
    2: 34: . . . . . . . . . . . . . . . . . . . . . . ","
    2: 36: . . . . . . . . . . . . . . . . . . . . . . Type (
    2: 36: . . . . . . . . . . . . . . . . . . . . . . . TypeName (
    2: 36: . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    2: 42: . . . . . . . . . . . . . . . . . . . . . . . )
    2: 42: . . . . . . . . . . . . . . . . . . . . . . )
    2: 42: . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    2: 43: . . . . . . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{65 0xc00035c0c0}}
    2: 44: . . . . . . . . . . . . . . . )
    2: 44: . . . . . . . . . . . . . . . CallOrConversion (
    2: 44: . . . . . . . . . . . . . . . . "("
    2: 45: . . . . . . . . . . . . . . . . Expression (
    2: 45: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 45: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 45: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 45: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 45: . . . . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    2: 48: . . . . . . . . . . . . . . . . . . . . )
    2: 48: . . . . . . . . . . . . . . . . . . . )
    2: 48: . . . . . . . . . . . . . . . . . . )
    2: 48: . . . . . . . . . . . . . . . . . )
    2: 48: . . . . . . . . . . . . . . . . )
    2: 48: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{64 0xc00000eff0 81}, Ellipsis: false, isCmd: false}
    2: 49: . . . . . . . . . . . . . . . )
    2: 49: . . . . . . . . . . . . . . )
    2: 49: . . . . . . . . . . . . . )
    2: 49: . . . . . . . . . . . . )
    2: 49: . . . . . . . . . . . )
    2: 49: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    2: 50: . . . . . . . . . . )
    2: 50: . . . . . . . . . )
    2: 50: . . . . . . . . )
    2: 50: . . . . . . . )
    2: 50: . . . . . . )
    2: 50: . . . . . )
    2: 50: . . . . )
    2: 50: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  9: . . . . . . . . . . )
    4:  9: . . . . . . . . . . CallOrConversion (
    4:  9: . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . Operand (
    4:  9: . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    4: 11: . . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . . . IndexOrSlice (
    4: 11: . . . . . . . . . . . . . . . . "["
    4: 12: . . . . . . . . . . . . . . . . Expression (
    4: 12: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 12: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 12: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 12: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 12: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    4: 15: . . . . . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
    4: 16: . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . . LiteralValue (
    4: 16: . . . . . . . . . . . . . . . . "{"
    4: 17: . . . . . . . . . . . . . . . . "}"
    4: 18: . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . ","
    4: 20: . . . . . . . . . . . Expression (
    4: 20: . . . . . . . . . . . . BinaryExpr (
    4: 20: . . . . . . . . . . . . . UnaryExpr (
    4: 20: . . . . . . . . . . . . . . PrimaryExpr (
    4: 20: . . . . . . . . . . . . . . . Operand (
    4: 20: . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    4: 22: . . . . . . . . . . . . . . . )
    4: 22: . . . . . . . . . . . . . . . IndexOrSlice (
    4: 22: . . . . . . . . . . . . . . . . "["
    4: 23: . . . . . . . . . . . . . . . . Expression (
    4: 23: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 23: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    4: 26: . . . . . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . ","
    4: 28: . . . . . . . . . . . . . . . . Type (
    4: 28: . . . . . . . . . . . . . . . . . TypeName (
    4: 28: . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    4: 34: . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    4: 35: . . . . . . . . . . . . . . . )
    4: 35: . . . . . . . . . . . . . . . LiteralValue (
    4: 35: . . . . . . . . . . . . . . . . "{"
    4: 36: . . . . . . . . . . . . . . . . "}"
    4: 37: . . . . . . . . . . . . . . . )
    4: 37: . . . . . . . . . . . . . . )
    4: 37: . . . . . . . . . . . . . )
    4: 37: . . . . . . . . . . . . )
    4: 37: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 37: . . . . . . . . . . )
    4: 37: . . . . . . . . . )
    4: 37: . . . . . . . . )
    4: 37: . . . . . . . )
    4: 37: . . . . . . )
    4: 37: . . . . . )
    4: 37: . . . . )
    4: 37: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  9: . . . . . . . . . . )
    5:  9: . . . . . . . . . . CallOrConversion (
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . "("
    5: 10: . . . . . . . . . . . . . . . . Expression (
    5: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 10: . . . . . . . . . . . . . . . . . . . "*"
    5: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    5: 13: . . . . . . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    5: 13: . . . . . . . . . . . . . . . . . . . . . . "["
    5: 14: . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 14: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 14: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 14: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
    5: 18: . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{136 0xc000364000}}
    5: 19: . . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . . . CallOrConversion (
    5: 19: . . . . . . . . . . . . . . . . "("
    5: 20: . . . . . . . . . . . . . . . . Expression (
    5: 20: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . . . Operand (
    5: 20: . . . . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    5: 23: . . . . . . . . . . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{135 0xc00000f038 144}, Ellipsis: false, isCmd: false}
    5: 24: . . . . . . . . . . . . . . . )
    5: 24: . . . . . . . . . . . . . . )
    5: 24: . . . . . . . . . . . . . )
    5: 24: . . . . . . . . . . . . )
    5: 24: . . . . . . . . . . . )
    5: 24: . . . . . . . . . . . ","
    5: 26: . . . . . . . . . . . Expression (
    5: 26: . . . . . . . . . . . . BinaryExpr (
    5: 26: . . . . . . . . . . . . . UnaryExpr (
    5: 26: . . . . . . . . . . . . . . PrimaryExpr (
    5: 26: . . . . . . . . . . . . . . . Operand (
    5: 26: . . . . . . . . . . . . . . . . "("
    5: 27: . . . . . . . . . . . . . . . . Expression (
    5: 27: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 27: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 27: . . . . . . . . . . . . . . . . . . . "*"
    5: 28: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 28: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 28: . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    5: 30: . . . . . . . . . . . . . . . . . . . . . )
    5: 30: . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    5: 30: . . . . . . . . . . . . . . . . . . . . . . "["
    5: 31: . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 31: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 31: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 31: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 34: . . . . . . . . . . . . . . . . . . . . . . )
    5: 34: . . . . . . . . . . . . . . . . . . . . . . ","
    5: 36: . . . . . . . . . . . . . . . . . . . . . . Type (
    5: 36: . . . . . . . . . . . . . . . . . . . . . . . TypeName (
    5: 36: . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    5: 43: . . . . . . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{153 0xc00035c200}}
    5: 44: . . . . . . . . . . . . . . . )
    5: 44: . . . . . . . . . . . . . . . CallOrConversion (
    5: 44: . . . . . . . . . . . . . . . . "("
    5: 45: . . . . . . . . . . . . . . . . Expression (
    5: 45: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 45: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 45: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 45: . . . . . . . . . . . . . . . . . . . . Operand (
    5: 45: . . . . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    5: 48: . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{152 0xc00000f080 169}, Ellipsis: false, isCmd: false}
    5: 49: . . . . . . . . . . . . . . . )
    5: 49: . . . . . . . . . . . . . . )
    5: 49: . . . . . . . . . . . . . )
    5: 49: . . . . . . . . . . . . )
    5: 49: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 49: . . . . . . . . . . )
    5: 49: . . . . . . . . . )
    5: 49: . . . . . . . . )
    5: 49: . . . . . . . )
    5: 49: . . . . . . )
    5: 49: . . . . . )
    5: 49: . . . . )
    5: 49: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . SimpleStmt (
    7:  1: . . . . . ExpressionList (
    7:  1: . . . . . . Expression (
    7:  1: . . . . . . . BinaryExpr (
    7:  1: . . . . . . . . UnaryExpr (
    7:  1: . . . . . . . . . PrimaryExpr (
    7:  1: . . . . . . . . . . Operand (
    7:  1: . . . . . . . . . . . FuncTypeOrLit (
    7:  1: . . . . . . . . . . . . FuncType (
    7:  1: . . . . . . . . . . . . . "func"
    7:  5: . . . . . . . . . . . . . Signature (
    7:  5: . . . . . . . . . . . . . . Parameters (
    7:  5: . . . . . . . . . . . . . . . "("
    7:  6: . . . . . . . . . . . . . . . ParameterList (
    7:  6: . . . . . . . . . . . . . . . . ParamDeclOrNil (
    7:  6: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  8: . . . . . . . . . . . . . . . . . Type (
    7:  8: . . . . . . . . . . . . . . . . . . TypeName (
    7:  8: . . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    7: 10: . . . . . . . . . . . . . . . . . . )
    7: 10: . . . . . . . . . . . . . . . . . . TypeInstance (
    7: 10: . . . . . . . . . . . . . . . . . . . "["
    7: 11: . . . . . . . . . . . . . . . . . . . Type (
    7: 11: . . . . . . . . . . . . . . . . . . . . TypeName (
    7: 11: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 14: . . . . . . . . . . . . . . . . . . . . )
    7: 14: . . . . . . . . . . . . . . . . . . . )
    7: 14: . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    7: 15: . . . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . . ","
    7: 17: . . . . . . . . . . . . . . . . ParamDeclOrNil (
    7: 17: . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    7: 19: . . . . . . . . . . . . . . . . . Type (
    7: 19: . . . . . . . . . . . . . . . . . . PointerType (
    7: 19: . . . . . . . . . . . . . . . . . . . "*"
    7: 20: . . . . . . . . . . . . . . . . . . . Type (
    7: 20: . . . . . . . . . . . . . . . . . . . . TypeName (
    7: 20: . . . . . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    7: 22: . . . . . . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . . . . . . . TypeInstance (
    7: 22: . . . . . . . . . . . . . . . . . . . . . "["
    7: 23: . . . . . . . . . . . . . . . . . . . . . Type (
    7: 23: . . . . . . . . . . . . . . . . . . . . . . TypeName (
    7: 23: . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 26: . . . . . . . . . . . . . . . . . . . . . . )
    7: 26: . . . . . . . . . . . . . . . . . . . . . )
    7: 26: . . . . . . . . . . . . . . . . . . . . . ","
    7: 28: . . . . . . . . . . . . . . . . . . . . . Type (
    7: 28: . . . . . . . . . . . . . . . . . . . . . . TypeName (
    7: 28: . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    7: 34: . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    7: 35: . . . . . . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . ")"
    7: 37: . . . . . . . . . . . . . . )
    7: 37: . . . . . . . . . . . . . . Result (
    7: 37: . . . . . . . . . . . . . . . PointerType (
    7: 37: . . . . . . . . . . . . . . . . "*"
    7: 38: . . . . . . . . . . . . . . . . Type (
    7: 38: . . . . . . . . . . . . . . . . . TypeName (
    7: 38: . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 42: . . . . . . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . Body (
    7: 42: . . . . . . . . . . . . . "{"
    8:  2: . . . . . . . . . . . . . StatementList (
    8:  2: . . . . . . . . . . . . . . Statement (
    8:  2: . . . . . . . . . . . . . . . ReturnStmt (
    8:  2: . . . . . . . . . . . . . . . . "return"
    8:  9: . . . . . . . . . . . . . . . . ExpressionList (
    8:  9: . . . . . . . . . . . . . . . . . Expression (
    8:  9: . . . . . . . . . . . . . . . . . . BinaryExpr (
    8:  9: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    8:  9: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    8:  9: . . . . . . . . . . . . . . . . . . . . . Operand (
    8:  9: . . . . . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    8: 12: . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . ";"
    9:  1: . . . . . . . . . . . . . . . )
    9:  1: . . . . . . . . . . . . . . )
    9:  1: . . . . . . . . . . . . . )
    9:  1: . . . . . . . . . . . . . "}"
    9:  2: . . . . . . . . . . . . )
    9:  2: . . . . . . . . . . . )
    9:  2: . . . . . . . . . . )
    9:  2: . . . . . . . . . . CallOrConversion (
    9:  2: . . . . . . . . . . . "("
    9:  3: . . . . . . . . . . . Expression (
    9:  3: . . . . . . . . . . . . BinaryExpr (
    9:  3: . . . . . . . . . . . . . UnaryExpr (
    9:  3: . . . . . . . . . . . . . . PrimaryExpr (
    9:  3: . . . . . . . . . . . . . . . Operand (
    9:  3: . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    9:  5: . . . . . . . . . . . . . . . )
    9:  5: . . . . . . . . . . . . . . . IndexOrSlice (
    9:  5: . . . . . . . . . . . . . . . . "["
    9:  6: . . . . . . . . . . . . . . . . Expression (
    9:  6: . . . . . . . . . . . . . . . . . BinaryExpr (
    9:  6: . . . . . . . . . . . . . . . . . . UnaryExpr (
    9:  6: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9:  6: . . . . . . . . . . . . . . . . . . . . Operand (
    9:  6: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9:  9: . . . . . . . . . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
    9: 10: . . . . . . . . . . . . . . . )
    9: 10: . . . . . . . . . . . . . . . LiteralValue (
    9: 10: . . . . . . . . . . . . . . . . "{"
    9: 11: . . . . . . . . . . . . . . . . ElementList (
    9: 11: . . . . . . . . . . . . . . . . . Element (
    9: 11: . . . . . . . . . . . . . . . . . . Element (
    9: 11: . . . . . . . . . . . . . . . . . . . Expression (
    9: 11: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . . . . Operand (
    9: 11: . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    9: 12: . . . . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . "}"
    9: 13: . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . ","
    9: 15: . . . . . . . . . . . Expression (
    9: 15: . . . . . . . . . . . . BinaryExpr (
    9: 15: . . . . . . . . . . . . . UnaryExpr (
    9: 15: . . . . . . . . . . . . . . "&"
    9: 16: . . . . . . . . . . . . . . UnaryExpr (
    9: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    9: 16: . . . . . . . . . . . . . . . . Operand (
    9: 16: . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    9: 18: . . . . . . . . . . . . . . . . )
    9: 18: . . . . . . . . . . . . . . . . IndexOrSlice (
    9: 18: . . . . . . . . . . . . . . . . . "["
    9: 19: . . . . . . . . . . . . . . . . . Expression (
    9: 19: . . . . . . . . . . . . . . . . . . BinaryExpr (
    9: 19: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 19: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 19: . . . . . . . . . . . . . . . . . . . . . Operand (
    9: 19: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 22: . . . . . . . . . . . . . . . . . . . . . )
    9: 22: . . . . . . . . . . . . . . . . . . . . )
    9: 22: . . . . . . . . . . . . . . . . . . . )
    9: 22: . . . . . . . . . . . . . . . . . . )
    9: 22: . . . . . . . . . . . . . . . . . )
    9: 22: . . . . . . . . . . . . . . . . . ","
    9: 24: . . . . . . . . . . . . . . . . . Type (
    9: 24: . . . . . . . . . . . . . . . . . . TypeName (
    9: 24: . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    9: 30: . . . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    9: 31: . . . . . . . . . . . . . . . . )
    9: 31: . . . . . . . . . . . . . . . . LiteralValue (
    9: 31: . . . . . . . . . . . . . . . . . "{"
    9: 32: . . . . . . . . . . . . . . . . . "}"
    9: 33: . . . . . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc00035e580 0xc000364150}, Ellipsis: false, isCmd: false}
    9: 34: . . . . . . . . . . )
    9: 34: . . . . . . . . . )
    9: 34: . . . . . . . . )
    9: 34: . . . . . . . )
    9: 34: . . . . . . )
    9: 34: . . . . . )
    9: 34: . . . . )
    9: 34: . . . . ";"
   11:  1: . . . )
   11:  1: . . . Statement (
   11:  1: . . . . SimpleStmt (
   11:  1: . . . . . ExpressionList (
   11:  1: . . . . . . Expression (
   11:  1: . . . . . . . BinaryExpr (
   11:  1: . . . . . . . . UnaryExpr (
   11:  1: . . . . . . . . . PrimaryExpr (
   11:  1: . . . . . . . . . . Operand (
   11:  1: . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   11:  4: . . . . . . . . . . )
   11:  4: . . . . . . . . . . CallOrConversion (
   11:  4: . . . . . . . . . . . "("
   11:  5: . . . . . . . . . . . Expression (
   11:  5: . . . . . . . . . . . . "=>"
   11:  8: . . . . . . . . . . . . Expression (
   11:  8: . . . . . . . . . . . . . BinaryExpr (
   11:  8: . . . . . . . . . . . . . . UnaryExpr (
   11:  8: . . . . . . . . . . . . . . . PrimaryExpr (
   11:  8: . . . . . . . . . . . . . . . . Operand (
   11:  8: . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   11: 10: . . . . . . . . . . . . . . . . )
   11: 10: . . . . . . . . . . . . . . . . IndexOrSlice (
   11: 10: . . . . . . . . . . . . . . . . . "["
   11: 11: . . . . . . . . . . . . . . . . . Expression (
   11: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   11: 14: . . . . . . . . . . . . . . . . . . . . . )
   11: 14: . . . . . . . . . . . . . . . . . . . . )
   11: 14: . . . . . . . . . . . . . . . . . . . )
   11: 14: . . . . . . . . . . . . . . . . . . )
   11: 14: . . . . . . . . . . . . . . . . . )
   11: 14: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
   11: 15: . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . LiteralValue (
   11: 15: . . . . . . . . . . . . . . . . . "{"
   11: 16: . . . . . . . . . . . . . . . . . ElementList (
   11: 16: . . . . . . . . . . . . . . . . . . Element (
   11: 16: . . . . . . . . . . . . . . . . . . . Element (
   11: 16: . . . . . . . . . . . . . . . . . . . . Expression (
   11: 16: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 16: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 16: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 16: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 16: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . "}"
   11: 18: . . . . . . . . . . . . . . . . )
   11: 18: . . . . . . . . . . . . . . . )
   11: 18: . . . . . . . . . . . . . . )
   11: 18: . . . . . . . . . . . . . )
   11: 18: . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
   11: 18: . . . . . . . . . . . )
   11: 18: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
   11: 19: . . . . . . . . . . )
   11: 19: . . . . . . . . . )
   11: 19: . . . . . . . . )
   11: 19: . . . . . . . )
   11: 19: . . . . . . )
   11: 19: . . . . . )
   11: 19: . . . . )
   11: 19: . . . . ";"
   12:  1: . . . )
   12:  1: . . . Statement (
   12:  1: . . . . SimpleStmt (
   12:  1: . . . . . ExpressionList (
   12:  1: . . . . . . Expression (
   12:  1: . . . . . . . BinaryExpr (
   12:  1: . . . . . . . . UnaryExpr (
   12:  1: . . . . . . . . . PrimaryExpr (
   12:  1: . . . . . . . . . . Operand (
   12:  1: . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   12:  4: . . . . . . . . . . )
   12:  4: . . . . . . . . . . CallOrConversion (
   12:  4: . . . . . . . . . . . "("
   12:  5: . . . . . . . . . . . Expression (
   12:  5: . . . . . . . . . . . . "=>"
   12:  8: . . . . . . . . . . . . BlockStmt (
   12:  8: . . . . . . . . . . . . . "{"
   13:  2: . . . . . . . . . . . . . StatementList (
   13:  2: . . . . . . . . . . . . . . Statement (
   13:  2: . . . . . . . . . . . . . . . SimpleStmt (
   13:  2: . . . . . . . . . . . . . . . . ExpressionList (
   13:  2: . . . . . . . . . . . . . . . . . Expression (
   13:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
   13:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
   13:  2: . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   13:  9: . . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   13:  9: . . . . . . . . . . . . . . . . . . . . . . "("
   13: 10: . . . . . . . . . . . . . . . . . . . . . . Expression (
   13: 10: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . . . . . . . . . "&"
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   13: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
   13: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "["
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
   13: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
   13: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
   13: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   13: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   13: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   13: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "{"
   13: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "}"
   13: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   13: 29: . . . . . . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . ";"
   14:  1: . . . . . . . . . . . . . . )
   14:  1: . . . . . . . . . . . . . )
   14:  1: . . . . . . . . . . . . . "}"
   14:  2: . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
   14:  2: . . . . . . . . . . . )
   14:  2: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
   14:  3: . . . . . . . . . . )
   14:  3: . . . . . . . . . )
   14:  3: . . . . . . . . )
   14:  3: . . . . . . . )
   14:  3: . . . . . . )
   14:  3: . . . . . )
   14:  3: . . . . )
   14:  3: . . . . ";"
   16:  1: . . . )
   16:  1: . . . Statement (
   16:  1: . . . . SimpleStmt (
   16:  1: . . . . . ExpressionList (
   16:  1: . . . . . . Expression (
   16:  1: . . . . . . . BinaryExpr (
   16:  1: . . . . . . . . UnaryExpr (
   16:  1: . . . . . . . . . PrimaryExpr (
   16:  1: . . . . . . . . . . Operand (
   16:  1: . . . . . . . . . . . IDENT fn1
 /app/parser/parser.go:713: ast.Ident{Name: fn1}
   16:  4: . . . . . . . . . . )
   16:  4: . . . . . . . . . . IndexOrSlice (
   16:  4: . . . . . . . . . . . "["
   16:  5: . . . . . . . . . . . Expression (
   16:  5: . . . . . . . . . . . . BinaryExpr (
   16:  5: . . . . . . . . . . . . . UnaryExpr (
   16:  5: . . . . . . . . . . . . . . PrimaryExpr (
   16:  5: . . . . . . . . . . . . . . . Operand (
   16:  5: . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16:  8: . . . . . . . . . . . . . . . )
   16:  8: . . . . . . . . . . . . . . )
   16:  8: . . . . . . . . . . . . . )
   16:  8: . . . . . . . . . . . . )
   16:  8: . . . . . . . . . . . )
   16:  8: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn1, Index: int}
   16:  9: . . . . . . . . . . )
   16:  9: . . . . . . . . . . CallOrConversion (
   16:  9: . . . . . . . . . . . "("
   16: 10: . . . . . . . . . . . Expression (
   16: 10: . . . . . . . . . . . . BinaryExpr (
   16: 10: . . . . . . . . . . . . . UnaryExpr (
   16: 10: . . . . . . . . . . . . . . PrimaryExpr (
   16: 10: . . . . . . . . . . . . . . . Operand (
   16: 10: . . . . . . . . . . . . . . . . ArrayType (
   16: 10: . . . . . . . . . . . . . . . . . "["
   16: 11: . . . . . . . . . . . . . . . . . "]"
   16: 12: . . . . . . . . . . . . . . . . . TypeName (
   16: 12: . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   16: 14: . . . . . . . . . . . . . . . . . )
   16: 14: . . . . . . . . . . . . . . . . . TypeInstance (
   16: 14: . . . . . . . . . . . . . . . . . . "["
   16: 15: . . . . . . . . . . . . . . . . . . Type (
   16: 15: . . . . . . . . . . . . . . . . . . . TypeName (
   16: 15: . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16: 18: . . . . . . . . . . . . . . . . . . . )
   16: 18: . . . . . . . . . . . . . . . . . . )
   16: 18: . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   16: 19: . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{P1 341 int 345}}
   16: 19: . . . . . . . . . . . . . . . . )
   16: 19: . . . . . . . . . . . . . . . )
   16: 19: . . . . . . . . . . . . . . . LiteralValue (
   16: 19: . . . . . . . . . . . . . . . . "{"
   16: 20: . . . . . . . . . . . . . . . . ElementList (
   16: 20: . . . . . . . . . . . . . . . . . Element (
   16: 20: . . . . . . . . . . . . . . . . . . Element (
   16: 20: . . . . . . . . . . . . . . . . . . . Expression (
   16: 20: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 20: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 20: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 20: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 20: . . . . . . . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   16: 22: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 22: . . . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
   16: 22: . . . . . . . . . . . . . . . . . . . . . . . . "["
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
   16: 27: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   16: 27: . . . . . . . . . . . . . . . . . . . . . . . . "{"
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . ElementList (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . "}"
   16: 30: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . ","
   16: 32: . . . . . . . . . . . . . . . . . Element (
   16: 32: . . . . . . . . . . . . . . . . . . Element (
   16: 32: . . . . . . . . . . . . . . . . . . . Expression (
   16: 32: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 32: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 32: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 32: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 32: . . . . . . . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   16: 34: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 34: . . . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
   16: 34: . . . . . . . . . . . . . . . . . . . . . . . . "["
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
   16: 39: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 39: . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   16: 39: . . . . . . . . . . . . . . . . . . . . . . . . "{"
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . ElementList (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . "}"
   16: 42: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . "}"
   16: 43: . . . . . . . . . . . . . . . )
   16: 43: . . . . . . . . . . . . . . )
   16: 43: . . . . . . . . . . . . . )
   16: 43: . . . . . . . . . . . . )
   16: 43: . . . . . . . . . . . )
   16: 43: . . . . . . . . . . . ","
   16: 45: . . . . . . . . . . . Expression (
   16: 45: . . . . . . . . . . . . BinaryExpr (
   16: 45: . . . . . . . . . . . . . UnaryExpr (
   16: 45: . . . . . . . . . . . . . . "&"
   16: 46: . . . . . . . . . . . . . . UnaryExpr (
   16: 46: . . . . . . . . . . . . . . . PrimaryExpr (
   16: 46: . . . . . . . . . . . . . . . . Operand (
   16: 46: . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   16: 48: . . . . . . . . . . . . . . . . )
   16: 48: . . . . . . . . . . . . . . . . IndexOrSlice (
   16: 48: . . . . . . . . . . . . . . . . . "["
   16: 49: . . . . . . . . . . . . . . . . . Expression (
   16: 49: . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 49: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 49: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 49: . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 49: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16: 52: . . . . . . . . . . . . . . . . . . . . . )
   16: 52: . . . . . . . . . . . . . . . . . . . . )
   16: 52: . . . . . . . . . . . . . . . . . . . )
   16: 52: . . . . . . . . . . . . . . . . . . )
   16: 52: . . . . . . . . . . . . . . . . . )
   16: 52: . . . . . . . . . . . . . . . . . ","
   16: 54: . . . . . . . . . . . . . . . . . Type (
   16: 54: . . . . . . . . . . . . . . . . . . TypeName (
   16: 54: . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   16: 60: . . . . . . . . . . . . . . . . . . )
   16: 60: . . . . . . . . . . . . . . . . . )
   16: 60: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   16: 61: . . . . . . . . . . . . . . . . )
   16: 61: . . . . . . . . . . . . . . . . LiteralValue (
   16: 61: . . . . . . . . . . . . . . . . . "{"
   16: 62: . . . . . . . . . . . . . . . . . "}"
   16: 63: . . . . . . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn1 331 int 335}, Ellipsis: false, isCmd: false}
   16: 64: . . . . . . . . . . )
   16: 64: . . . . . . . . . )
   16: 64: . . . . . . . . )
   16: 64: . . . . . . . )
   16: 64: . . . . . . )
   16: 64: . . . . . )
   16: 64: . . . . )
   16: 64: . . . . ";"
   17:  1: . . . )
   17:  1: . . . Statement (
   17:  1: . . . . SimpleStmt (
   17:  1: . . . . . ExpressionList (
   17:  1: . . . . . . Expression (
   17:  1: . . . . . . . BinaryExpr (
   17:  1: . . . . . . . . UnaryExpr (
   17:  1: . . . . . . . . . PrimaryExpr (
   17:  1: . . . . . . . . . . Operand (
   17:  1: . . . . . . . . . . . IDENT fn2
 /app/parser/parser.go:713: ast.Ident{Name: fn2}
   17:  4: . . . . . . . . . . )
   17:  4: . . . . . . . . . . IndexOrSlice (
   17:  4: . . . . . . . . . . . "["
   17:  5: . . . . . . . . . . . Expression (
   17:  5: . . . . . . . . . . . . BinaryExpr (
   17:  5: . . . . . . . . . . . . . UnaryExpr (
   17:  5: . . . . . . . . . . . . . . PrimaryExpr (
   17:  5: . . . . . . . . . . . . . . . Operand (
   17:  5: . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   17:  8: . . . . . . . . . . . . . . . )
   17:  8: . . . . . . . . . . . . . . )
   17:  8: . . . . . . . . . . . . . )
   17:  8: . . . . . . . . . . . . )
   17:  8: . . . . . . . . . . . )
   17:  8: . . . . . . . . . . . ","
   17: 10: . . . . . . . . . . . Type (
   17: 10: . . . . . . . . . . . . TypeName (
   17: 10: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   17: 16: . . . . . . . . . . . . )
   17: 16: . . . . . . . . . . . )
   17: 16: . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: fn2, Index: [int string]}
   17: 17: . . . . . . . . . . )
   17: 17: . . . . . . . . . . CallOrConversion (
   17: 17: . . . . . . . . . . . "("
   17: 18: . . . . . . . . . . . Expression (
   17: 18: . . . . . . . . . . . . BinaryExpr (
   17: 18: . . . . . . . . . . . . . UnaryExpr (
   17: 18: . . . . . . . . . . . . . . "&"
   17: 19: . . . . . . . . . . . . . . UnaryExpr (
   17: 19: . . . . . . . . . . . . . . . PrimaryExpr (
   17: 19: . . . . . . . . . . . . . . . . Operand (
   17: 19: . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   17: 21: . . . . . . . . . . . . . . . . )
   17: 21: . . . . . . . . . . . . . . . . IndexOrSlice (
   17: 21: . . . . . . . . . . . . . . . . . "["
   17: 22: . . . . . . . . . . . . . . . . . Expression (
   17: 22: . . . . . . . . . . . . . . . . . . BinaryExpr (
   17: 22: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   17: 22: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 22: . . . . . . . . . . . . . . . . . . . . . Operand (
   17: 22: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   17: 25: . . . . . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
   17: 26: . . . . . . . . . . . . . . . . )
   17: 26: . . . . . . . . . . . . . . . . LiteralValue (
   17: 26: . . . . . . . . . . . . . . . . . "{"
   17: 27: . . . . . . . . . . . . . . . . . "}"
   17: 28: . . . . . . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . ","
   17: 30: . . . . . . . . . . . Expression (
   17: 30: . . . . . . . . . . . . BinaryExpr (
   17: 30: . . . . . . . . . . . . . UnaryExpr (
   17: 30: . . . . . . . . . . . . . . "&"
   17: 31: . . . . . . . . . . . . . . UnaryExpr (
   17: 31: . . . . . . . . . . . . . . . PrimaryExpr (
   17: 31: . . . . . . . . . . . . . . . . Operand (
   17: 31: . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   17: 33: . . . . . . . . . . . . . . . . )
   17: 33: . . . . . . . . . . . . . . . . IndexOrSlice (
   17: 33: . . . . . . . . . . . . . . . . . "["
   17: 34: . . . . . . . . . . . . . . . . . Expression (
   17: 34: . . . . . . . . . . . . . . . . . . BinaryExpr (
   17: 34: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   17: 34: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 34: . . . . . . . . . . . . . . . . . . . . . Operand (
   17: 34: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   17: 37: . . . . . . . . . . . . . . . . . . . . . )
   17: 37: . . . . . . . . . . . . . . . . . . . . )
   17: 37: . . . . . . . . . . . . . . . . . . . )
   17: 37: . . . . . . . . . . . . . . . . . . )
   17: 37: . . . . . . . . . . . . . . . . . )
   17: 37: . . . . . . . . . . . . . . . . . ","
   17: 39: . . . . . . . . . . . . . . . . . Type (
   17: 39: . . . . . . . . . . . . . . . . . . TypeName (
   17: 39: . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   17: 45: . . . . . . . . . . . . . . . . . . )
   17: 45: . . . . . . . . . . . . . . . . . )
   17: 45: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   17: 46: . . . . . . . . . . . . . . . . )
   17: 46: . . . . . . . . . . . . . . . . LiteralValue (
   17: 46: . . . . . . . . . . . . . . . . . "{"
   17: 47: . . . . . . . . . . . . . . . . . "}"
   17: 48: . . . . . . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn2 395 [int string] 407}, Ellipsis: false, isCmd: false}
   17: 49: . . . . . . . . . . )
   17: 49: . . . . . . . . . )
   17: 49: . . . . . . . . )
   17: 49: . . . . . . . )
   17: 49: . . . . . . )
   17: 49: . . . . . )
   17: 49: . . . . )
   17: 49: . . . . ";"
   19:  1: . . . )
   19:  1: . . . Statement (
   19:  1: . . . . SimpleStmt (
   19:  1: . . . . . ExpressionList (
   19:  1: . . . . . . Expression (
   19:  1: . . . . . . . BinaryExpr (
   19:  1: . . . . . . . . UnaryExpr (
   19:  1: . . . . . . . . . PrimaryExpr (
   19:  1: . . . . . . . . . . Operand (
   19:  1: . . . . . . . . . . . IDENT foo1
 /app/parser/parser.go:713: ast.Ident{Name: foo1}
   19:  5: . . . . . . . . . . )
   19:  5: . . . . . . . . . . IndexOrSlice (
   19:  5: . . . . . . . . . . . "["
   19:  6: . . . . . . . . . . . Expression (
   19:  6: . . . . . . . . . . . . BinaryExpr (
   19:  6: . . . . . . . . . . . . . UnaryExpr (
   19:  6: . . . . . . . . . . . . . . PrimaryExpr (
   19:  6: . . . . . . . . . . . . . . . Operand (
   19:  6: . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   19:  9: . . . . . . . . . . . . . . . )
   19:  9: . . . . . . . . . . . . . . )
   19:  9: . . . . . . . . . . . . . )
   19:  9: . . . . . . . . . . . . )
   19:  9: . . . . . . . . . . . )
   19:  9: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: foo1, Index: int}
   19: 10: . . . . . . . . . . )
   19: 10: . . . . . . . . . . CallOrConversion (
   19: 10: . . . . . . . . . . . "("
   19: 11: . . . . . . . . . . . Expression (
   19: 11: . . . . . . . . . . . . "=>"
   19: 14: . . . . . . . . . . . . Expression (
   19: 14: . . . . . . . . . . . . . BinaryExpr (
   19: 14: . . . . . . . . . . . . . . UnaryExpr (
   19: 14: . . . . . . . . . . . . . . . PrimaryExpr (
   19: 14: . . . . . . . . . . . . . . . . Operand (
   19: 14: . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   19: 16: . . . . . . . . . . . . . . . . )
   19: 16: . . . . . . . . . . . . . . . . IndexOrSlice (
   19: 16: . . . . . . . . . . . . . . . . . "["
   19: 17: . . . . . . . . . . . . . . . . . Expression (
   19: 17: . . . . . . . . . . . . . . . . . . BinaryExpr (
   19: 17: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   19: 17: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   19: 17: . . . . . . . . . . . . . . . . . . . . . Operand (
   19: 17: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   19: 20: . . . . . . . . . . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
   19: 21: . . . . . . . . . . . . . . . . )
   19: 21: . . . . . . . . . . . . . . . . LiteralValue (
   19: 21: . . . . . . . . . . . . . . . . . "{"
   19: 22: . . . . . . . . . . . . . . . . . ElementList (
   19: 22: . . . . . . . . . . . . . . . . . . Element (
   19: 22: . . . . . . . . . . . . . . . . . . . Element (
   19: 22: . . . . . . . . . . . . . . . . . . . . Expression (
   19: 22: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   19: 22: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   19: 22: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   19: 22: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   19: 22: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   19: 23: . . . . . . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . "}"
   19: 24: . . . . . . . . . . . . . . . . )
   19: 24: . . . . . . . . . . . . . . . )
   19: 24: . . . . . . . . . . . . . . )
   19: 24: . . . . . . . . . . . . . )
   19: 24: . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
   19: 24: . . . . . . . . . . . )
   19: 24: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{foo1 446 int 450}, Ellipsis: false, isCmd: false}
   19: 25: . . . . . . . . . . )
   19: 25: . . . . . . . . . )
   19: 25: . . . . . . . . )
   19: 25: . . . . . . . )
   19: 25: . . . . . . )
   19: 25: . . . . . )
   19: 25: . . . . )
   19: 25: . . . . ";"
   20:  1: . . . )
   20:  1: . . . Statement (
   20:  1: . . . . SimpleStmt (
   20:  1: . . . . . ExpressionList (
   20:  1: . . . . . . Expression (
   20:  1: . . . . . . . BinaryExpr (
   20:  1: . . . . . . . . UnaryExpr (
   20:  1: . . . . . . . . . PrimaryExpr (
   20:  1: . . . . . . . . . . Operand (
   20:  1: . . . . . . . . . . . IDENT foo2
 /app/parser/parser.go:713: ast.Ident{Name: foo2}
   20:  5: . . . . . . . . . . )
   20:  5: . . . . . . . . . . IndexOrSlice (
   20:  5: . . . . . . . . . . . "["
   20:  6: . . . . . . . . . . . Expression (
   20:  6: . . . . . . . . . . . . BinaryExpr (
   20:  6: . . . . . . . . . . . . . UnaryExpr (
   20:  6: . . . . . . . . . . . . . . PrimaryExpr (
   20:  6: . . . . . . . . . . . . . . . Operand (
   20:  6: . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   20:  9: . . . . . . . . . . . . . . . )
   20:  9: . . . . . . . . . . . . . . )
   20:  9: . . . . . . . . . . . . . )
   20:  9: . . . . . . . . . . . . )
   20:  9: . . . . . . . . . . . )
   20:  9: . . . . . . . . . . . ","
   20: 11: . . . . . . . . . . . Type (
   20: 11: . . . . . . . . . . . . TypeName (
   20: 11: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   20: 17: . . . . . . . . . . . . )
   20: 17: . . . . . . . . . . . )
   20: 17: . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: foo2, Index: [int string]}
   20: 18: . . . . . . . . . . )
   20: 18: . . . . . . . . . . CallOrConversion (
   20: 18: . . . . . . . . . . . "("
   20: 19: . . . . . . . . . . . Expression (
   20: 19: . . . . . . . . . . . . "=>"
   20: 22: . . . . . . . . . . . . BlockStmt (
   20: 22: . . . . . . . . . . . . . "{"
   21:  2: . . . . . . . . . . . . . StatementList (
   21:  2: . . . . . . . . . . . . . . Statement (
   21:  2: . . . . . . . . . . . . . . . SimpleStmt (
   21:  2: . . . . . . . . . . . . . . . . ExpressionList (
   21:  2: . . . . . . . . . . . . . . . . . Expression (
   21:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
   21:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   21:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   21:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
   21:  2: . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   21:  9: . . . . . . . . . . . . . . . . . . . . . )
   21:  9: . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   21:  9: . . . . . . . . . . . . . . . . . . . . . . "("
   21: 10: . . . . . . . . . . . . . . . . . . . . . . Expression (
   21: 10: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   21: 10: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   21: 10: . . . . . . . . . . . . . . . . . . . . . . . . . "&"
   21: 11: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   21: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   21: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   21: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   21: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
   21: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "["
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
   21: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
   21: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
   21: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   21: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   21: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   21: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "{"
   21: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "}"
   21: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   21: 29: . . . . . . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . ";"
   22:  1: . . . . . . . . . . . . . . )
   22:  1: . . . . . . . . . . . . . )
   22:  1: . . . . . . . . . . . . . "}"
   22:  2: . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
   22:  2: . . . . . . . . . . . )
   22:  2: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{foo2 471 [int string] 483}, Ellipsis: false, isCmd: false}
   22:  3: . . . . . . . . . . )
   22:  3: . . . . . . . . . )
   22:  3: . . . . . . . . )
   22:  3: . . . . . . . )
   22:  3: . . . . . . )
   22:  3: . . . . . )
   22:  3: . . . . )
   22:  3: . . . . ";"
   22:  4: . . . )
   22:  4: . . )
   22:  4: . )
   22:  4: )
=== RUN   TestFromInstance/instance4
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_instance/instance4
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . . IndexOrSlice (
    1:  3: . . . . . . . . . . . "["
    1:  4: . . . . . . . . . . . Expression (
    1:  4: . . . . . . . . . . . . BinaryExpr (
    1:  4: . . . . . . . . . . . . . UnaryExpr (
    1:  4: . . . . . . . . . . . . . . PrimaryExpr (
    1:  4: . . . . . . . . . . . . . . . Operand (
    1:  4: . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1:  7: . . . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: int}
    1:  8: . . . . . . . . . . )
    1:  8: . . . . . . . . . . CallOrConversion (
    1:  8: . . . . . . . . . . . "("
    1:  9: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 3 int 7}, Ellipsis: false, isCmd: false}
    1: 10: . . . . . . . . . . )
    1: 10: . . . . . . . . . )
    1: 10: . . . . . . . . )
    1: 10: . . . . . . . )
    1: 10: . . . . . . )
    1: 10: . . . . . )
    1: 10: . . . . )
    1: 10: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    2:  3: . . . . . . . . . . )
    2:  3: . . . . . . . . . . IndexOrSlice (
    2:  3: . . . . . . . . . . . "["
    2:  4: . . . . . . . . . . . Expression (
    2:  4: . . . . . . . . . . . . BinaryExpr (
    2:  4: . . . . . . . . . . . . . UnaryExpr (
    2:  4: . . . . . . . . . . . . . . PrimaryExpr (
    2:  4: . . . . . . . . . . . . . . . Operand (
    2:  4: . . . . . . . . . . . . . . . . ArrayType (
    2:  4: . . . . . . . . . . . . . . . . . "["
    2:  5: . . . . . . . . . . . . . . . . . "]"
    2:  6: . . . . . . . . . . . . . . . . . TypeName (
    2:  6: . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    2:  9: . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: int}
    2:  9: . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{14 <nil> int}}
    2: 10: . . . . . . . . . . )
    2: 10: . . . . . . . . . . CallOrConversion (
    2: 10: . . . . . . . . . . . "("
    2: 11: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 13 0xc00018e600 19}, Ellipsis: false, isCmd: false}
    2: 12: . . . . . . . . . . )
    2: 12: . . . . . . . . . )
    2: 12: . . . . . . . . )
    2: 12: . . . . . . . )
    2: 12: . . . . . . )
    2: 12: . . . . . )
    2: 12: . . . . )
    2: 12: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    3:  3: . . . . . . . . . . )
    3:  3: . . . . . . . . . . IndexOrSlice (
    3:  3: . . . . . . . . . . . "["
    3:  4: . . . . . . . . . . . Expression (
    3:  4: . . . . . . . . . . . . BinaryExpr (
    3:  4: . . . . . . . . . . . . . UnaryExpr (
    3:  4: . . . . . . . . . . . . . . PrimaryExpr (
    3:  4: . . . . . . . . . . . . . . . Operand (
    3:  4: . . . . . . . . . . . . . . . . StructType (
    3:  4: . . . . . . . . . . . . . . . . . "struct"
    3: 11: . . . . . . . . . . . . . . . . . "{"
    4:  2: . . . . . . . . . . . . . . . . . FieldDecl (
    4:  2: . . . . . . . . . . . . . . . . . . IDENT X
 /app/parser/parser.go:713: ast.Ident{Name: X}
    4:  4: . . . . . . . . . . . . . . . . . . Type (
    4:  4: . . . . . . . . . . . . . . . . . . . TypeName (
    4:  4: . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    4:  7: . . . . . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . . . . . ";"
    5:  2: . . . . . . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . . . . . . . FieldDecl (
    5:  2: . . . . . . . . . . . . . . . . . . IDENT Y
 /app/parser/parser.go:713: ast.Ident{Name: Y}
    5:  4: . . . . . . . . . . . . . . . . . . Type (
    5:  4: . . . . . . . . . . . . . . . . . . . TypeName (
    5:  4: . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5:  7: . . . . . . . . . . . . . . . . . . . )
    5:  7: . . . . . . . . . . . . . . . . . . )
    5:  7: . . . . . . . . . . . . . . . . . . ";"
    6:  1: . . . . . . . . . . . . . . . . . )
    6:  1: . . . . . . . . . . . . . . . . . "}"
    6:  2: . . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{26 0xc00018e6c0 false}}
    6:  3: . . . . . . . . . . )
    6:  3: . . . . . . . . . . CallOrConversion (
    6:  3: . . . . . . . . . . . "("
    6:  4: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 25 0xc0001948a0 50}, Ellipsis: false, isCmd: false}
    6:  5: . . . . . . . . . . )
    6:  5: . . . . . . . . . )
    6:  5: . . . . . . . . )
    6:  5: . . . . . . . )
    6:  5: . . . . . . )
    6:  5: . . . . . )
    6:  5: . . . . )
    6:  5: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . SimpleStmt (
    7:  1: . . . . . ExpressionList (
    7:  1: . . . . . . Expression (
    7:  1: . . . . . . . BinaryExpr (
    7:  1: . . . . . . . . UnaryExpr (
    7:  1: . . . . . . . . . PrimaryExpr (
    7:  1: . . . . . . . . . . Operand (
    7:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    7:  3: . . . . . . . . . . )
    7:  3: . . . . . . . . . . IndexOrSlice (
    7:  3: . . . . . . . . . . . "["
    7:  4: . . . . . . . . . . . Expression (
    7:  4: . . . . . . . . . . . . BinaryExpr (
    7:  4: . . . . . . . . . . . . . UnaryExpr (
    7:  4: . . . . . . . . . . . . . . PrimaryExpr (
    7:  4: . . . . . . . . . . . . . . . Operand (
    7:  4: . . . . . . . . . . . . . . . . "map"
    7:  4: . . . . . . . . . . . . . . . . MapType (
    7:  7: . . . . . . . . . . . . . . . . . "["
    7:  8: . . . . . . . . . . . . . . . . . Type (
    7:  8: . . . . . . . . . . . . . . . . . . TypeName (
    7:  8: . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 11: . . . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . . . "]"
    7: 12: . . . . . . . . . . . . . . . . . Type (
    7: 12: . . . . . . . . . . . . . . . . . . TypeName (
    7: 12: . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    7: 18: . . . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: int, Value: string}
    7: 18: . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{57 int string}}
    7: 19: . . . . . . . . . . )
    7: 19: . . . . . . . . . . CallOrConversion (
    7: 19: . . . . . . . . . . . "("
    7: 20: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 56 0xc00018e750 71}, Ellipsis: false, isCmd: false}
    7: 21: . . . . . . . . . . )
    7: 21: . . . . . . . . . )
    7: 21: . . . . . . . . )
    7: 21: . . . . . . . )
    7: 21: . . . . . . )
    7: 21: . . . . . )
    7: 21: . . . . )
    7: 21: . . . . ";"
    8:  1: . . . )
    8:  1: . . . Statement (
    8:  1: . . . . SimpleStmt (
    8:  1: . . . . . ExpressionList (
    8:  1: . . . . . . Expression (
    8:  1: . . . . . . . BinaryExpr (
    8:  1: . . . . . . . . UnaryExpr (
    8:  1: . . . . . . . . . PrimaryExpr (
    8:  1: . . . . . . . . . . Operand (
    8:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    8:  3: . . . . . . . . . . )
    8:  3: . . . . . . . . . . IndexOrSlice (
    8:  3: . . . . . . . . . . . "["
    8:  4: . . . . . . . . . . . Expression (
    8:  4: . . . . . . . . . . . . BinaryExpr (
    8:  4: . . . . . . . . . . . . . UnaryExpr (
    8:  4: . . . . . . . . . . . . . . PrimaryExpr (
    8:  4: . . . . . . . . . . . . . . . Operand (
    8:  4: . . . . . . . . . . . . . . . . ChanType (
    8:  4: . . . . . . . . . . . . . . . . . "chan"
    8:  9: . . . . . . . . . . . . . . . . . Type (
    8:  9: . . . . . . . . . . . . . . . . . . TypeName (
    8:  9: . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    8: 12: . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{78 0 3 int}}
    8: 13: . . . . . . . . . . )
    8: 13: . . . . . . . . . . CallOrConversion (
    8: 13: . . . . . . . . . . . "("
    8: 14: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 77 0xc00018e810 86}, Ellipsis: false, isCmd: false}
    8: 15: . . . . . . . . . . )
    8: 15: . . . . . . . . . )
    8: 15: . . . . . . . . )
    8: 15: . . . . . . . )
    8: 15: . . . . . . )
    8: 15: . . . . . )
    8: 15: . . . . )
    8: 15: . . . . ";"
    9:  1: . . . )
    9:  1: . . . Statement (
    9:  1: . . . . SimpleStmt (
    9:  1: . . . . . ExpressionList (
    9:  1: . . . . . . Expression (
    9:  1: . . . . . . . BinaryExpr (
    9:  1: . . . . . . . . UnaryExpr (
    9:  1: . . . . . . . . . PrimaryExpr (
    9:  1: . . . . . . . . . . Operand (
    9:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    9:  3: . . . . . . . . . . )
    9:  3: . . . . . . . . . . IndexOrSlice (
    9:  3: . . . . . . . . . . . "["
    9:  4: . . . . . . . . . . . Expression (
    9:  4: . . . . . . . . . . . . BinaryExpr (
    9:  4: . . . . . . . . . . . . . UnaryExpr (
    9:  4: . . . . . . . . . . . . . . PrimaryExpr (
    9:  4: . . . . . . . . . . . . . . . Operand (
    9:  4: . . . . . . . . . . . . . . . . ChanType (
    9:  4: . . . . . . . . . . . . . . . . . "chan"
    9:  9: . . . . . . . . . . . . . . . . . Type (
    9:  9: . . . . . . . . . . . . . . . . . . StructType (
    9:  9: . . . . . . . . . . . . . . . . . . . "struct"
    9: 15: . . . . . . . . . . . . . . . . . . . "{"
    9: 16: . . . . . . . . . . . . . . . . . . . "}"
    9: 17: . . . . . . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{93 0 3 0xc0001948d0}}
    9: 18: . . . . . . . . . . )
    9: 18: . . . . . . . . . . CallOrConversion (
    9: 18: . . . . . . . . . . . "("
    9: 19: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 92 0xc00018e900 106}, Ellipsis: false, isCmd: false}
    9: 20: . . . . . . . . . . )
    9: 20: . . . . . . . . . )
    9: 20: . . . . . . . . )
    9: 20: . . . . . . . )
    9: 20: . . . . . . )
    9: 20: . . . . . )
    9: 20: . . . . )
    9: 20: . . . . ";"
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
   10:  3: . . . . . . . . . . )
   10:  3: . . . . . . . . . . IndexOrSlice (
   10:  3: . . . . . . . . . . . "["
   10:  4: . . . . . . . . . . . Expression (
   10:  4: . . . . . . . . . . . . BinaryExpr (
   10:  4: . . . . . . . . . . . . . UnaryExpr (
   10:  4: . . . . . . . . . . . . . . PrimaryExpr (
   10:  4: . . . . . . . . . . . . . . . Operand (
   10:  4: . . . . . . . . . . . . . . . . InterfaceType (
   10:  4: . . . . . . . . . . . . . . . . . "interface"
   10: 13: . . . . . . . . . . . . . . . . . "{"
   10: 14: . . . . . . . . . . . . . . . . . "}"
   10: 15: . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{113 0xc00018e9c0 false}}
   10: 16: . . . . . . . . . . )
   10: 16: . . . . . . . . . . CallOrConversion (
   10: 16: . . . . . . . . . . . "("
   10: 17: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 112 0xc0001948e8 124}, Ellipsis: false, isCmd: false}
   10: 18: . . . . . . . . . . )
   10: 18: . . . . . . . . . )
   10: 18: . . . . . . . . )
   10: 18: . . . . . . . )
   10: 18: . . . . . . )
   10: 18: . . . . . )
   10: 18: . . . . )
   10: 18: . . . . ";"
   11:  1: . . . )
   11:  1: . . . Statement (
   11:  1: . . . . SimpleStmt (
   11:  1: . . . . . ExpressionList (
   11:  1: . . . . . . Expression (
   11:  1: . . . . . . . BinaryExpr (
   11:  1: . . . . . . . . UnaryExpr (
   11:  1: . . . . . . . . . PrimaryExpr (
   11:  1: . . . . . . . . . . Operand (
   11:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
   11:  3: . . . . . . . . . . )
   11:  3: . . . . . . . . . . IndexOrSlice (
   11:  3: . . . . . . . . . . . "["
   11:  4: . . . . . . . . . . . Expression (
   11:  4: . . . . . . . . . . . . BinaryExpr (
   11:  4: . . . . . . . . . . . . . UnaryExpr (
   11:  4: . . . . . . . . . . . . . . PrimaryExpr (
   11:  4: . . . . . . . . . . . . . . . Operand (
   11:  4: . . . . . . . . . . . . . . . . InterfaceType (
   11:  4: . . . . . . . . . . . . . . . . . "interface"
   11: 13: . . . . . . . . . . . . . . . . . "{"
   11: 15: . . . . . . . . . . . . . . . . . MethodSpec (
   11: 15: . . . . . . . . . . . . . . . . . . TypeName (
   11: 15: . . . . . . . . . . . . . . . . . . . IDENT Method
 /app/parser/parser.go:713: ast.Ident{Name: Method}
   11: 21: . . . . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . . . . . Signature (
   11: 21: . . . . . . . . . . . . . . . . . . . Parameters (
   11: 21: . . . . . . . . . . . . . . . . . . . . "("
   11: 22: . . . . . . . . . . . . . . . . . . . . ")"
   11: 24: . . . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . . . . Result (
   11: 24: . . . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . . "}"
   11: 25: . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{131 0xc00018ea80 false}}
   11: 26: . . . . . . . . . . )
   11: 26: . . . . . . . . . . CallOrConversion (
   11: 26: . . . . . . . . . . . "("
   11: 27: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 130 0xc000194918 152}, Ellipsis: false, isCmd: false}
   11: 28: . . . . . . . . . . )
   11: 28: . . . . . . . . . )
   11: 28: . . . . . . . . )
   11: 28: . . . . . . . )
   11: 28: . . . . . . )
   11: 28: . . . . . )
   11: 28: . . . . )
   11: 28: . . . . ";"
   12:  1: . . . )
   12:  1: . . . Statement (
   12:  1: . . . . SimpleStmt (
   12:  1: . . . . . ExpressionList (
   12:  1: . . . . . . Expression (
   12:  1: . . . . . . . BinaryExpr (
   12:  1: . . . . . . . . UnaryExpr (
   12:  1: . . . . . . . . . PrimaryExpr (
   12:  1: . . . . . . . . . . Operand (
   12:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
   12:  3: . . . . . . . . . . )
   12:  3: . . . . . . . . . . IndexOrSlice (
   12:  3: . . . . . . . . . . . "["
   12:  4: . . . . . . . . . . . Expression (
   12:  4: . . . . . . . . . . . . BinaryExpr (
   12:  4: . . . . . . . . . . . . . UnaryExpr (
   12:  4: . . . . . . . . . . . . . . PrimaryExpr (
   12:  4: . . . . . . . . . . . . . . . Operand (
   12:  4: . . . . . . . . . . . . . . . . ArrayType (
   12:  4: . . . . . . . . . . . . . . . . . "["
   12:  5: . . . . . . . . . . . . . . . . . "]"
   12:  6: . . . . . . . . . . . . . . . . . StructType (
   12:  6: . . . . . . . . . . . . . . . . . . "struct"
   12: 13: . . . . . . . . . . . . . . . . . . "{"
   13:  2: . . . . . . . . . . . . . . . . . . FieldDecl (
   13:  2: . . . . . . . . . . . . . . . . . . . IDENT X
 /app/parser/parser.go:713: ast.Ident{Name: X}
   13:  4: . . . . . . . . . . . . . . . . . . . Type (
   13:  4: . . . . . . . . . . . . . . . . . . . . TypeName (
   13:  4: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   13:  7: . . . . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . . . . ";"
   14:  2: . . . . . . . . . . . . . . . . . . )
   14:  2: . . . . . . . . . . . . . . . . . . FieldDecl (
   14:  2: . . . . . . . . . . . . . . . . . . . IDENT Y
 /app/parser/parser.go:713: ast.Ident{Name: Y}
   14:  4: . . . . . . . . . . . . . . . . . . . Type (
   14:  4: . . . . . . . . . . . . . . . . . . . . TypeName (
   14:  4: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   14:  7: . . . . . . . . . . . . . . . . . . . . )
   14:  7: . . . . . . . . . . . . . . . . . . . )
   14:  7: . . . . . . . . . . . . . . . . . . . ";"
   15:  1: . . . . . . . . . . . . . . . . . . )
   15:  1: . . . . . . . . . . . . . . . . . . "}"
   15:  2: . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{161 0xc00018eb40 false}}
   15:  2: . . . . . . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . ","
   15:  4: . . . . . . . . . . . Type (
   15:  4: . . . . . . . . . . . . MapType (
   15:  4: . . . . . . . . . . . . . "map"
   15:  7: . . . . . . . . . . . . . "["
   15:  8: . . . . . . . . . . . . . Type (
   15:  8: . . . . . . . . . . . . . . TypeName (
   15:  8: . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   15: 11: . . . . . . . . . . . . . . )
   15: 11: . . . . . . . . . . . . . )
   15: 11: . . . . . . . . . . . . . "]"
   15: 12: . . . . . . . . . . . . . Type (
   15: 12: . . . . . . . . . . . . . . TypeName (
   15: 12: . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   15: 18: . . . . . . . . . . . . . . )
   15: 18: . . . . . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: int, Value: string}
   15: 18: . . . . . . . . . . . . )
   15: 18: . . . . . . . . . . . )
   15: 18: . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: fn, Index: [0xc00018eb70 0xc00018eba0]}
   15: 19: . . . . . . . . . . )
   15: 19: . . . . . . . . . . CallOrConversion (
   15: 19: . . . . . . . . . . . "("
   15: 20: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 158 [0xc00018eb70 0xc00018eba0] 201}, Ellipsis: false, isCmd: false}
   15: 21: . . . . . . . . . . )
   15: 21: . . . . . . . . . )
   15: 21: . . . . . . . . )
   15: 21: . . . . . . . )
   15: 21: . . . . . . )
   15: 21: . . . . . )
   15: 21: . . . . )
   15: 21: . . . . ";"
   15: 22: . . . )
   15: 22: . . )
   15: 22: . )
   15: 22: )
=== RUN   TestFromInstance/instance5
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_instance/instance5
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(var) (
    1:  1: . . . "var"
    1:  5: . . . varSpec (
    1:  5: . . . . IdentList (
    1:  5: . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  7: . . . . )
    1:  7: . . . . ArrayType (
    1:  7: . . . . . "["
    1:  8: . . . . . Expression (
    1:  8: . . . . . . BinaryExpr (
    1:  8: . . . . . . . UnaryExpr (
    1:  8: . . . . . . . . PrimaryExpr (
    1:  8: . . . . . . . . . Operand (
    1:  8: . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . )
    1:  9: . . . . . . )
    1:  9: . . . . . )
    1:  9: . . . . . "]"
    1: 10: . . . . . Type (
    1: 10: . . . . . . TypeName (
    1: 10: . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 13: . . . . . . )
    1: 13: . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: &{8 INT 2 <nil>}, Elt: int}
    1: 13: . . . . )
    1: 13: . . . . ";"
    3:  1: . . . )
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . StatementList (
    3:  1: . . . Statement (
    3:  1: . . . . IfStmt (
    3:  1: . . . . . "if"
    3:  4: . . . . . SimpleStmt (
    3:  4: . . . . . . ExpressionList (
    3:  4: . . . . . . . Expression (
    3:  4: . . . . . . . . BinaryExpr (
    3:  4: . . . . . . . . . UnaryExpr (
    3:  4: . . . . . . . . . . PrimaryExpr (
    3:  4: . . . . . . . . . . . Operand (
    3:  4: . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    3:  6: . . . . . . . . . . . )
    3:  6: . . . . . . . . . . )
    3:  6: . . . . . . . . . )
    3:  6: . . . . . . . . . "<"
    3:  8: . . . . . . . . . BinaryExpr (
    3:  8: . . . . . . . . . . UnaryExpr (
    3:  8: . . . . . . . . . . . PrimaryExpr (
    3:  8: . . . . . . . . . . . . Operand (
    3:  8: . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    3:  9: . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . IndexOrSlice (
    3:  9: . . . . . . . . . . . . . "["
    3: 10: . . . . . . . . . . . . . Expression (
    3: 10: . . . . . . . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    3: 11: . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: a, Index: &{24 INT 0 <nil>}}
    3: 13: . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . )
    3: 13: . . . . . . . . . . )
    3: 13: . . . . . . . . . )
    3: 13: . . . . . . . . )
    3: 13: . . . . . . . )
    3: 13: . . . . . . )
    3: 13: . . . . . )
    3: 13: . . . . . BlockStmt (
    3: 13: . . . . . . "{"
    4:  2: . . . . . . StatementList (
    4:  2: . . . . . . . Statement (
    4:  2: . . . . . . . . SimpleStmt (
    4:  2: . . . . . . . . . ExpressionList (
    4:  2: . . . . . . . . . . Expression (
    4:  2: . . . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4: 10: . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . CallOrConversion (
    4: 10: . . . . . . . . . . . . . . . Expression (
    4: 10: . . . . . . . . . . . . . . . . BinaryExpr (
    4: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 10: . . . . . . . . . . . . . . . . . . . Operand (
    4: 10: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4: 11: . . . . . . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 11: . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . )
    4: 11: . . . . . . . . . . )
    4: 11: . . . . . . . . . )
    4: 11: . . . . . . . . )
    4: 11: . . . . . . . . ";"
    5:  2: . . . . . . . )
    5:  2: . . . . . . . Statement (
    5:  2: . . . . . . . . SimpleStmt (
    5:  2: . . . . . . . . . ExpressionList (
    5:  2: . . . . . . . . . . Expression (
    5:  2: . . . . . . . . . . . BinaryExpr (
    5:  2: . . . . . . . . . . . . UnaryExpr (
    5:  2: . . . . . . . . . . . . . PrimaryExpr (
    5:  2: . . . . . . . . . . . . . . Operand (
    5:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 10: . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . CallOrConversion (
    5: 10: . . . . . . . . . . . . . . . Expression (
    5: 10: . . . . . . . . . . . . . . . . BinaryExpr (
    5: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 10: . . . . . . . . . . . . . . . . . . . Operand (
    5: 10: . . . . . . . . . . . . . . . . . . . . IDENT M
 /app/parser/parser.go:713: ast.Ident{Name: M}
    5: 11: . . . . . . . . . . . . . . . . . . . )
    5: 11: . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    5: 11: . . . . . . . . . . . . . . . . . . . . "["
    5: 12: . . . . . . . . . . . . . . . . . . . . Expression (
    5: 12: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 12: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 12: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 12: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 12: . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: M, Index: int}
    5: 16: . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . LiteralValue (
    5: 16: . . . . . . . . . . . . . . . . . . . . "{"
    5: 17: . . . . . . . . . . . . . . . . . . . . ElementList (
    5: 17: . . . . . . . . . . . . . . . . . . . . . Element (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    5: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . "}"
    5: 19: . . . . . . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 19: . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . )
    5: 19: . . . . . . . . . . )
    5: 19: . . . . . . . . . )
    5: 19: . . . . . . . . )
    5: 19: . . . . . . . . ";"
    6:  2: . . . . . . . )
    6:  2: . . . . . . . Statement (
    6:  2: . . . . . . . . SimpleStmt (
    6:  2: . . . . . . . . . ExpressionList (
    6:  2: . . . . . . . . . . Expression (
    6:  2: . . . . . . . . . . . BinaryExpr (
    6:  2: . . . . . . . . . . . . UnaryExpr (
    6:  2: . . . . . . . . . . . . . PrimaryExpr (
    6:  2: . . . . . . . . . . . . . . Operand (
    6:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    6: 10: . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . CallOrConversion (
    6: 10: . . . . . . . . . . . . . . . Expression (
    6: 10: . . . . . . . . . . . . . . . . BinaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . . . Operand (
    6: 10: . . . . . . . . . . . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    6: 11: . . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    6: 11: . . . . . . . . . . . . . . . . . . . . "["
    6: 12: . . . . . . . . . . . . . . . . . . . . Expression (
    6: 12: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 12: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 12: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 12: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 12: . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    6: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: T, Index: int}
    6: 16: . . . . . . . . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . . . . . . . . LiteralValue (
    6: 16: . . . . . . . . . . . . . . . . . . . . "{"
    6: 17: . . . . . . . . . . . . . . . . . . . . ElementList (
    6: 17: . . . . . . . . . . . . . . . . . . . . . Element (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . Element (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . Expression (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    6: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . ":"
    6: 20: . . . . . . . . . . . . . . . . . . . . . . Element (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . Expression (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    6: 21: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . ","
    6: 23: . . . . . . . . . . . . . . . . . . . . . Element (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . Element (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . Expression (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    6: 24: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . ":"
    6: 26: . . . . . . . . . . . . . . . . . . . . . . Element (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . Expression (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    6: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . "}"
    6: 28: . . . . . . . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    6: 28: . . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . )
    6: 28: . . . . . . . . . . )
    6: 28: . . . . . . . . . )
    6: 28: . . . . . . . . )
    6: 28: . . . . . . . . ";"
    7:  1: . . . . . . . )
    7:  1: . . . . . . )
    7:  1: . . . . . . "}"
    7:  2: . . . . . )
    7:  2: . . . . . ";"
    9:  1: . . . . )
    9:  1: . . . )
    9:  1: . . . Statement (
    9:  1: . . . . ForStmt (
    9:  1: . . . . . "for"
    9:  5: . . . . . SimpleStmt (
    9:  5: . . . . . . ExpressionList (
    9:  5: . . . . . . . Expression (
    9:  5: . . . . . . . . BinaryExpr (
    9:  5: . . . . . . . . . UnaryExpr (
    9:  5: . . . . . . . . . . PrimaryExpr (
    9:  5: . . . . . . . . . . . Operand (
    9:  5: . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
    9:  6: . . . . . . . . . . . )
    9:  6: . . . . . . . . . . )
    9:  6: . . . . . . . . . )
    9:  6: . . . . . . . . )
    9:  6: . . . . . . . )
    9:  6: . . . . . . . ","
    9:  8: . . . . . . . Expression (
    9:  8: . . . . . . . . BinaryExpr (
    9:  8: . . . . . . . . . UnaryExpr (
    9:  8: . . . . . . . . . . PrimaryExpr (
    9:  8: . . . . . . . . . . . Operand (
    9:  8: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    9: 10: . . . . . . . . . . . )
    9: 10: . . . . . . . . . . )
    9: 10: . . . . . . . . . )
    9: 10: . . . . . . . . )
    9: 10: . . . . . . . )
    9: 10: . . . . . . )
    9: 10: . . . . . . ":="
    9: 13: . . . . . . "range"
    9: 19: . . . . . . Expression (
    9: 19: . . . . . . . RangeExpr (
    9: 19: . . . . . . . . BinaryExpr (
    9: 19: . . . . . . . . . UnaryExpr (
    9: 19: . . . . . . . . . . PrimaryExpr (
    9: 19: . . . . . . . . . . . Operand (
    9: 19: . . . . . . . . . . . . ArrayType (
    9: 19: . . . . . . . . . . . . . "["
    9: 20: . . . . . . . . . . . . . "]"
    9: 21: . . . . . . . . . . . . . TypeName (
    9: 21: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 24: . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: int}
    9: 24: . . . . . . . . . . . . )
    9: 24: . . . . . . . . . . . )
    9: 24: . . . . . . . . . . . LiteralValue (
    9: 24: . . . . . . . . . . . . "{"
    9: 25: . . . . . . . . . . . . ElementList (
    9: 25: . . . . . . . . . . . . . Element (
    9: 25: . . . . . . . . . . . . . . Element (
    9: 25: . . . . . . . . . . . . . . . Expression (
    9: 25: . . . . . . . . . . . . . . . . BinaryExpr (
    9: 25: . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 25: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 25: . . . . . . . . . . . . . . . . . . . Operand (
    9: 25: . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    9: 26: . . . . . . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . ","
    9: 28: . . . . . . . . . . . . . Element (
    9: 28: . . . . . . . . . . . . . . Element (
    9: 28: . . . . . . . . . . . . . . . Expression (
    9: 28: . . . . . . . . . . . . . . . . BinaryExpr (
    9: 28: . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 28: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 28: . . . . . . . . . . . . . . . . . . . Operand (
    9: 28: . . . . . . . . . . . . . . . . . . . . INT 42
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 42}
    9: 30: . . . . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . "}"
    9: 32: . . . . . . . . . . . )
    9: 32: . . . . . . . . . . )
    9: 32: . . . . . . . . . )
    9: 32: . . . . . . . . )
    9: 32: . . . . . . . )
    9: 32: . . . . . . )
    9: 32: . . . . . )
    9: 32: . . . . . BlockStmt (
    9: 32: . . . . . . "{"
   10:  2: . . . . . . StatementList (
   10:  2: . . . . . . . Statement (
   10:  2: . . . . . . . . SimpleStmt (
   10:  2: . . . . . . . . . ExpressionList (
   10:  2: . . . . . . . . . . Expression (
   10:  2: . . . . . . . . . . . BinaryExpr (
   10:  2: . . . . . . . . . . . . UnaryExpr (
   10:  2: . . . . . . . . . . . . . PrimaryExpr (
   10:  2: . . . . . . . . . . . . . . Operand (
   10:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   10: 10: . . . . . . . . . . . . . . )
   10: 10: . . . . . . . . . . . . . . CallOrConversion (
   10: 10: . . . . . . . . . . . . . . . Expression (
   10: 10: . . . . . . . . . . . . . . . . BinaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . Operand (
   10: 10: . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   10: 11: . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
   10: 11: . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . )
   10: 11: . . . . . . . . . . )
   10: 11: . . . . . . . . . )
   10: 11: . . . . . . . . )
   10: 11: . . . . . . . . ";"
   11:  1: . . . . . . . )
   11:  1: . . . . . . )
   11:  1: . . . . . . "}"
   11:  2: . . . . . )
   11:  2: . . . . . ";"
   11:  3: . . . . )
   11:  3: . . . )
   11:  3: . . )
   11:  3: . )
   11:  3: )
--- PASS: TestFromInstance (0.03s)
    --- PASS: TestFromInstance/instance1 (0.00s)
    --- PASS: TestFromInstance/instance2 (0.00s)
    --- PASS: TestFromInstance/instance3 (0.01s)
    --- PASS: TestFromInstance/instance4 (0.00s)
    --- PASS: TestFromInstance/instance5 (0.00s)
=== RUN   TestParseExprFrom
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/interface.go:160: expected 'EOF', found ';'
--- PASS: TestParseExprFrom (0.00s)
=== RUN   TestReadSource
--- PASS: TestReadSource (0.00s)
=== RUN   TestParseFiles
--- PASS: TestParseFiles (0.00s)
=== RUN   TestIparseFileInvalidSrc
--- PASS: TestIparseFileInvalidSrc (0.00s)
=== RUN   TestIparseFileNoFset
--- PASS: TestIparseFileNoFset (0.00s)
=== RUN   TestParseDir
--- PASS: TestParseDir (0.00s)
=== RUN   TestParseGo
   17:  1: File (
   17:  1: . Declaration (
   17:  1: . . GenDecl(type) (
   17:  1: . . . "type"
   17:  6: . . . TypeSpec (
   17:  6: . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   17:  8: . . . . Type (
   17:  8: . . . . . StructType (
   17:  8: . . . . . . "struct"
   17: 15: . . . . . . "{"
   18:  2: . . . . . . FieldDecl (
   18:  2: . . . . . . . "*"
   18:  3: . . . . . . . QualifiedIdent (
   18:  3: . . . . . . . . TypeName (
   18:  3: . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   18:  4: . . . . . . . . )
   18:  4: . . . . . . . )
   18:  4: . . . . . . . ";"
   19:  2: . . . . . . )
   19:  2: . . . . . . FieldDecl (
   19:  2: . . . . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
   19:  4: . . . . . . . Type (
   19:  4: . . . . . . . . TypeName (
   19:  4: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   19:  8: . . . . . . . . )
   19:  8: . . . . . . . )
   19:  8: . . . . . . . STRING `json:"a"`
   19: 18: . . . . . . . ";"
   20:  1: . . . . . . )
   20:  1: . . . . . . "}"
   20:  2: . . . . . )
   20:  2: . . . . )
   20:  2: . . . . ";"
   22:  1: . . . )
   22:  1: . . )
   22:  1: . )
   22:  1: . Declaration (
   22:  1: . . FunctionDeclOrCall (
   22:  1: . . . "func"
   22:  6: . . . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
   22:  9: . . . Signature (
   22:  9: . . . . Parameters (
   22:  9: . . . . . "("
   22: 10: . . . . . ParameterList (
   22: 10: . . . . . . ParamDeclOrNil (
   22: 10: . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   22: 12: . . . . . . . Type (
   22: 12: . . . . . . . . ChanType (
   22: 12: . . . . . . . . . "chan"
   22: 17: . . . . . . . . . Type (
   22: 17: . . . . . . . . . . TypeName (
   22: 17: . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   22: 21: . . . . . . . . . . )
   22: 21: . . . . . . . . . )
   22: 21: . . . . . . . . )
   22: 21: . . . . . . . )
   22: 21: . . . . . . )
   22: 21: . . . . . )
   22: 21: . . . . . ")"
   22: 23: . . . . )
   22: 23: . . . . Result (
   22: 23: . . . . . Parameters (
   22: 23: . . . . . . "("
   22: 24: . . . . . . ParameterList (
   22: 24: . . . . . . . ParamDeclOrNil (
   22: 24: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   22: 27: . . . . . . . )
   22: 27: . . . . . . . ","
   22: 29: . . . . . . . ParamDeclOrNil (
   22: 29: . . . . . . . . Type (
   22: 29: . . . . . . . . . ChanType (
   22: 29: . . . . . . . . . . "<-"
   22: 31: . . . . . . . . . . "chan"
   22: 36: . . . . . . . . . . Type (
   22: 36: . . . . . . . . . . . TypeName (
   22: 36: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   22: 41: . . . . . . . . . . . )
   22: 41: . . . . . . . . . . )
   22: 41: . . . . . . . . . )
   22: 41: . . . . . . . . )
   22: 41: . . . . . . . )
   22: 41: . . . . . . )
   22: 41: . . . . . . ")"
   22: 43: . . . . . )
   22: 43: . . . . )
   22: 43: . . . )
   22: 43: . . . Body (
   22: 43: . . . . "{"
   23:  2: . . . . StatementList (
   23:  2: . . . . . Statement (
   23:  2: . . . . . . SimpleStmt (
   23:  2: . . . . . . . ExpressionList (
   23:  2: . . . . . . . . Expression (
   23:  2: . . . . . . . . . BinaryExpr (
   23:  2: . . . . . . . . . . UnaryExpr (
   23:  2: . . . . . . . . . . . PrimaryExpr (
   23:  2: . . . . . . . . . . . . Operand (
   23:  2: . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   23:  4: . . . . . . . . . . . . )
   23:  4: . . . . . . . . . . . . "<-"
   23:  4: . . . . . . . . . . . )
   23:  4: . . . . . . . . . . )
   23:  4: . . . . . . . . . )
   23:  4: . . . . . . . . )
   23:  4: . . . . . . . )
   23:  7: . . . . . . . Expression (
   23:  7: . . . . . . . . BinaryExpr (
   23:  7: . . . . . . . . . UnaryExpr (
   23:  7: . . . . . . . . . . PrimaryExpr (
   23:  7: . . . . . . . . . . . Operand (
   23:  7: . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   23: 11: . . . . . . . . . . . )
   23: 11: . . . . . . . . . . )
   23: 11: . . . . . . . . . )
   23: 11: . . . . . . . . )
   23: 11: . . . . . . . )
   23: 11: . . . . . . )
   23: 11: . . . . . . ";"
   24:  2: . . . . . )
   24:  2: . . . . . Statement (
   24:  2: . . . . . . SimpleStmt (
   24:  2: . . . . . . . ExpressionList (
   24:  2: . . . . . . . . Expression (
   24:  2: . . . . . . . . . BinaryExpr (
   24:  2: . . . . . . . . . . UnaryExpr (
   24:  2: . . . . . . . . . . . "<-"
   24:  4: . . . . . . . . . . . UnaryExpr (
   24:  4: . . . . . . . . . . . . PrimaryExpr (
   24:  4: . . . . . . . . . . . . . Operand (
   24:  4: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   24:  5: . . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . )
   24:  5: . . . . . . . . . . )
   24:  5: . . . . . . . . . )
   24:  5: . . . . . . . . )
   24:  5: . . . . . . . )
   24:  5: . . . . . . )
   24:  5: . . . . . . ";"
   25:  2: . . . . . )
   25:  2: . . . . . Statement (
   25:  2: . . . . . . ReturnStmt (
   25:  2: . . . . . . . "return"
   25:  9: . . . . . . . ExpressionList (
   25:  9: . . . . . . . . Expression (
   25:  9: . . . . . . . . . BinaryExpr (
   25:  9: . . . . . . . . . . UnaryExpr (
   25:  9: . . . . . . . . . . . PrimaryExpr (
   25:  9: . . . . . . . . . . . . Operand (
   25:  9: . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   25: 10: . . . . . . . . . . . . )
   25: 10: . . . . . . . . . . . )
   25: 10: . . . . . . . . . . )
   25: 10: . . . . . . . . . )
   25: 10: . . . . . . . . )
   25: 10: . . . . . . . . ","
   25: 12: . . . . . . . . Expression (
   25: 12: . . . . . . . . . BinaryExpr (
   25: 12: . . . . . . . . . . UnaryExpr (
   25: 12: . . . . . . . . . . . PrimaryExpr (
   25: 12: . . . . . . . . . . . . Operand (
   25: 12: . . . . . . . . . . . . . "("
   25: 13: . . . . . . . . . . . . . Expression (
   25: 13: . . . . . . . . . . . . . . BinaryExpr (
   25: 13: . . . . . . . . . . . . . . . UnaryExpr (
   25: 13: . . . . . . . . . . . . . . . . "<-"
   25: 15: . . . . . . . . . . . . . . . . UnaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . . Operand (
   25: 15: . . . . . . . . . . . . . . . . . . . ChanType (
   25: 15: . . . . . . . . . . . . . . . . . . . . "chan"
   25: 20: . . . . . . . . . . . . . . . . . . . . Type (
   25: 20: . . . . . . . . . . . . . . . . . . . . . TypeName (
   25: 20: . . . . . . . . . . . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   25: 25: . . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
   25: 26: . . . . . . . . . . . . )
   25: 26: . . . . . . . . . . . . CallOrConversion (
   25: 26: . . . . . . . . . . . . . "("
   25: 27: . . . . . . . . . . . . . Expression (
   25: 27: . . . . . . . . . . . . . . BinaryExpr (
   25: 27: . . . . . . . . . . . . . . . UnaryExpr (
   25: 27: . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 27: . . . . . . . . . . . . . . . . . Operand (
   25: 27: . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   25: 30: . . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc00018f8f0 762}, Ellipsis: false, isCmd: false}
   25: 31: . . . . . . . . . . . . )
   25: 31: . . . . . . . . . . . )
   25: 31: . . . . . . . . . . )
   25: 31: . . . . . . . . . )
   25: 31: . . . . . . . . )
   25: 31: . . . . . . . )
   25: 31: . . . . . . . ";"
   26:  1: . . . . . . )
   26:  1: . . . . . )
   26:  1: . . . . )
   26:  1: . . . . "}"
   26:  2: . . . )
   26:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
   28:  1: . . )
   28:  1: . )
   28:  1: . Declaration (
   28:  1: . . FunctionDeclOrCall (
   28:  1: . . . "func"
   28:  6: . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   28:  9: . . . Signature (
   28:  9: . . . . Parameters (
   28:  9: . . . . . "("
   28: 10: . . . . . ParameterList (
   28: 10: . . . . . . ParamDeclOrNil (
   28: 10: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   28: 12: . . . . . . . Type (
   28: 12: . . . . . . . . FuncType (
   28: 12: . . . . . . . . . "func"
   28: 16: . . . . . . . . . Signature (
   28: 16: . . . . . . . . . . Parameters (
   28: 16: . . . . . . . . . . . "("
   28: 17: . . . . . . . . . . . ParameterList (
   28: 17: . . . . . . . . . . . . ParamDeclOrNil (
   28: 17: . . . . . . . . . . . . . Type (
   28: 17: . . . . . . . . . . . . . . ArrayType (
   28: 17: . . . . . . . . . . . . . . . "["
   28: 18: . . . . . . . . . . . . . . . "]"
   28: 19: . . . . . . . . . . . . . . . Type (
   28: 19: . . . . . . . . . . . . . . . . TypeName (
   28: 19: . . . . . . . . . . . . . . . . . IDENT byte
 /app/parser/parser.go:713: ast.Ident{Name: byte}
   28: 23: . . . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
   28: 23: . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . ","
   28: 25: . . . . . . . . . . . . ParamDeclOrNil (
   28: 25: . . . . . . . . . . . . . Type (
   28: 25: . . . . . . . . . . . . . . PointerType (
   28: 25: . . . . . . . . . . . . . . . "*"
   28: 26: . . . . . . . . . . . . . . . Type (
   28: 26: . . . . . . . . . . . . . . . . TypeName (
   28: 26: . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   28: 32: . . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . ","
   28: 34: . . . . . . . . . . . . ParamDeclOrNil (
   28: 34: . . . . . . . . . . . . . DotsType (
   28: 34: . . . . . . . . . . . . . . "..."
   28: 37: . . . . . . . . . . . . . . Type (
   28: 37: . . . . . . . . . . . . . . . TypeName (
   28: 37: . . . . . . . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   28: 38: . . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . ")"
   28: 40: . . . . . . . . . . )
   28: 40: . . . . . . . . . . Result (
   28: 40: . . . . . . . . . . . ChanType (
   28: 40: . . . . . . . . . . . . "chan"
   28: 44: . . . . . . . . . . . . "<-"
   28: 47: . . . . . . . . . . . . Type (
   28: 47: . . . . . . . . . . . . . TypeName (
   28: 47: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 50: . . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . )
   28: 50: . . . . . . . . . . )
   28: 50: . . . . . . . . . )
   28: 50: . . . . . . . . )
   28: 50: . . . . . . . )
   28: 50: . . . . . . )
   28: 50: . . . . . )
   28: 50: . . . . . ")"
   28: 52: . . . . )
   28: 52: . . . . Result (
   28: 52: . . . . . Parameters (
   28: 52: . . . . . . "("
   28: 53: . . . . . . ParameterList (
   28: 53: . . . . . . . ParamDeclOrNil (
   28: 53: . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   28: 55: . . . . . . . . Type (
   28: 55: . . . . . . . . . TypeName (
   28: 55: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 58: . . . . . . . . . )
   28: 58: . . . . . . . . )
   28: 58: . . . . . . . )
   28: 58: . . . . . . . ","
   28: 60: . . . . . . . ParamDeclOrNil (
   28: 60: . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   28: 64: . . . . . . . . Type (
   28: 64: . . . . . . . . . TypeName (
   28: 64: . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   28: 69: . . . . . . . . . )
   28: 69: . . . . . . . . )
   28: 69: . . . . . . . )
   28: 69: . . . . . . )
   28: 69: . . . . . . ")"
   28: 71: . . . . . )
   28: 71: . . . . )
   28: 71: . . . )
   28: 71: . . . Body (
   28: 71: . . . . "{"
   29:  2: . . . . StatementList (
   29:  2: . . . . . Statement (
   29:  2: . . . . . . ReturnStmt (
   29:  2: . . . . . . . "return"
   29:  8: . . . . . . . ";"
   30:  1: . . . . . . )
   30:  1: . . . . . )
   30:  1: . . . . )
   30:  1: . . . . "}"
   30:  2: . . . )
   30:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
   30:  3: . . )
   30:  3: . )
   30:  3: )
--- PASS: TestParseGo (0.00s)
=== RUN   TestParseGoFiles
   17:  1: File (
   17:  1: . Declaration (
   17:  1: . . GenDecl(type) (
   17:  1: . . . "type"
   17:  6: . . . TypeSpec (
   17:  6: . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   17:  8: . . . . Type (
   17:  8: . . . . . StructType (
   17:  8: . . . . . . "struct"
   17: 15: . . . . . . "{"
   18:  2: . . . . . . FieldDecl (
   18:  2: . . . . . . . "*"
   18:  3: . . . . . . . QualifiedIdent (
   18:  3: . . . . . . . . TypeName (
   18:  3: . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   18:  4: . . . . . . . . )
   18:  4: . . . . . . . )
   18:  4: . . . . . . . ";"
   19:  2: . . . . . . )
   19:  2: . . . . . . FieldDecl (
   19:  2: . . . . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
   19:  4: . . . . . . . Type (
   19:  4: . . . . . . . . TypeName (
   19:  4: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   19:  8: . . . . . . . . )
   19:  8: . . . . . . . )
   19:  8: . . . . . . . STRING `json:"a"`
   19: 18: . . . . . . . ";"
   20:  1: . . . . . . )
   20:  1: . . . . . . "}"
   20:  2: . . . . . )
   20:  2: . . . . )
   20:  2: . . . . ";"
   22:  1: . . . )
   22:  1: . . )
   22:  1: . )
   22:  1: . Declaration (
   22:  1: . . FunctionDeclOrCall (
   22:  1: . . . "func"
   22:  6: . . . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
   22:  9: . . . Signature (
   22:  9: . . . . Parameters (
   22:  9: . . . . . "("
   22: 10: . . . . . ParameterList (
   22: 10: . . . . . . ParamDeclOrNil (
   22: 10: . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   22: 12: . . . . . . . Type (
   22: 12: . . . . . . . . ChanType (
   22: 12: . . . . . . . . . "chan"
   22: 17: . . . . . . . . . Type (
   22: 17: . . . . . . . . . . TypeName (
   22: 17: . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   22: 21: . . . . . . . . . . )
   22: 21: . . . . . . . . . )
   22: 21: . . . . . . . . )
   22: 21: . . . . . . . )
   22: 21: . . . . . . )
   22: 21: . . . . . )
   22: 21: . . . . . ")"
   22: 23: . . . . )
   22: 23: . . . . Result (
   22: 23: . . . . . Parameters (
   22: 23: . . . . . . "("
   22: 24: . . . . . . ParameterList (
   22: 24: . . . . . . . ParamDeclOrNil (
   22: 24: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   22: 27: . . . . . . . )
   22: 27: . . . . . . . ","
   22: 29: . . . . . . . ParamDeclOrNil (
   22: 29: . . . . . . . . Type (
   22: 29: . . . . . . . . . ChanType (
   22: 29: . . . . . . . . . . "<-"
   22: 31: . . . . . . . . . . "chan"
   22: 36: . . . . . . . . . . Type (
   22: 36: . . . . . . . . . . . TypeName (
   22: 36: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   22: 41: . . . . . . . . . . . )
   22: 41: . . . . . . . . . . )
   22: 41: . . . . . . . . . )
   22: 41: . . . . . . . . )
   22: 41: . . . . . . . )
   22: 41: . . . . . . )
   22: 41: . . . . . . ")"
   22: 43: . . . . . )
   22: 43: . . . . )
   22: 43: . . . )
   22: 43: . . . Body (
   22: 43: . . . . "{"
   23:  2: . . . . StatementList (
   23:  2: . . . . . Statement (
   23:  2: . . . . . . SimpleStmt (
   23:  2: . . . . . . . ExpressionList (
   23:  2: . . . . . . . . Expression (
   23:  2: . . . . . . . . . BinaryExpr (
   23:  2: . . . . . . . . . . UnaryExpr (
   23:  2: . . . . . . . . . . . PrimaryExpr (
   23:  2: . . . . . . . . . . . . Operand (
   23:  2: . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   23:  4: . . . . . . . . . . . . )
   23:  4: . . . . . . . . . . . . "<-"
   23:  4: . . . . . . . . . . . )
   23:  4: . . . . . . . . . . )
   23:  4: . . . . . . . . . )
   23:  4: . . . . . . . . )
   23:  4: . . . . . . . )
   23:  7: . . . . . . . Expression (
   23:  7: . . . . . . . . BinaryExpr (
   23:  7: . . . . . . . . . UnaryExpr (
   23:  7: . . . . . . . . . . PrimaryExpr (
   23:  7: . . . . . . . . . . . Operand (
   23:  7: . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   23: 11: . . . . . . . . . . . )
   23: 11: . . . . . . . . . . )
   23: 11: . . . . . . . . . )
   23: 11: . . . . . . . . )
   23: 11: . . . . . . . )
   23: 11: . . . . . . )
   23: 11: . . . . . . ";"
   24:  2: . . . . . )
   24:  2: . . . . . Statement (
   24:  2: . . . . . . SimpleStmt (
   24:  2: . . . . . . . ExpressionList (
   24:  2: . . . . . . . . Expression (
   24:  2: . . . . . . . . . BinaryExpr (
   24:  2: . . . . . . . . . . UnaryExpr (
   24:  2: . . . . . . . . . . . "<-"
   24:  4: . . . . . . . . . . . UnaryExpr (
   24:  4: . . . . . . . . . . . . PrimaryExpr (
   24:  4: . . . . . . . . . . . . . Operand (
   24:  4: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   24:  5: . . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . )
   24:  5: . . . . . . . . . . )
   24:  5: . . . . . . . . . )
   24:  5: . . . . . . . . )
   24:  5: . . . . . . . )
   24:  5: . . . . . . )
   24:  5: . . . . . . ";"
   25:  2: . . . . . )
   25:  2: . . . . . Statement (
   25:  2: . . . . . . ReturnStmt (
   25:  2: . . . . . . . "return"
   25:  9: . . . . . . . ExpressionList (
   25:  9: . . . . . . . . Expression (
   25:  9: . . . . . . . . . BinaryExpr (
   25:  9: . . . . . . . . . . UnaryExpr (
   25:  9: . . . . . . . . . . . PrimaryExpr (
   25:  9: . . . . . . . . . . . . Operand (
   25:  9: . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   25: 10: . . . . . . . . . . . . )
   25: 10: . . . . . . . . . . . )
   25: 10: . . . . . . . . . . )
   25: 10: . . . . . . . . . )
   25: 10: . . . . . . . . )
   25: 10: . . . . . . . . ","
   25: 12: . . . . . . . . Expression (
   25: 12: . . . . . . . . . BinaryExpr (
   25: 12: . . . . . . . . . . UnaryExpr (
   25: 12: . . . . . . . . . . . PrimaryExpr (
   25: 12: . . . . . . . . . . . . Operand (
   25: 12: . . . . . . . . . . . . . "("
   25: 13: . . . . . . . . . . . . . Expression (
   25: 13: . . . . . . . . . . . . . . BinaryExpr (
   25: 13: . . . . . . . . . . . . . . . UnaryExpr (
   25: 13: . . . . . . . . . . . . . . . . "<-"
   25: 15: . . . . . . . . . . . . . . . . UnaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . . Operand (
   25: 15: . . . . . . . . . . . . . . . . . . . ChanType (
   25: 15: . . . . . . . . . . . . . . . . . . . . "chan"
   25: 20: . . . . . . . . . . . . . . . . . . . . Type (
   25: 20: . . . . . . . . . . . . . . . . . . . . . TypeName (
   25: 20: . . . . . . . . . . . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   25: 25: . . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
   25: 26: . . . . . . . . . . . . )
   25: 26: . . . . . . . . . . . . CallOrConversion (
   25: 26: . . . . . . . . . . . . . "("
   25: 27: . . . . . . . . . . . . . Expression (
   25: 27: . . . . . . . . . . . . . . BinaryExpr (
   25: 27: . . . . . . . . . . . . . . . UnaryExpr (
   25: 27: . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 27: . . . . . . . . . . . . . . . . . Operand (
   25: 27: . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   25: 30: . . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc00018fe60 762}, Ellipsis: false, isCmd: false}
   25: 31: . . . . . . . . . . . . )
   25: 31: . . . . . . . . . . . )
   25: 31: . . . . . . . . . . )
   25: 31: . . . . . . . . . )
   25: 31: . . . . . . . . )
   25: 31: . . . . . . . )
   25: 31: . . . . . . . ";"
   26:  1: . . . . . . )
   26:  1: . . . . . )
   26:  1: . . . . )
   26:  1: . . . . "}"
   26:  2: . . . )
   26:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
   28:  1: . . )
   28:  1: . )
   28:  1: . Declaration (
   28:  1: . . FunctionDeclOrCall (
   28:  1: . . . "func"
   28:  6: . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   28:  9: . . . Signature (
   28:  9: . . . . Parameters (
   28:  9: . . . . . "("
   28: 10: . . . . . ParameterList (
   28: 10: . . . . . . ParamDeclOrNil (
   28: 10: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   28: 12: . . . . . . . Type (
   28: 12: . . . . . . . . FuncType (
   28: 12: . . . . . . . . . "func"
   28: 16: . . . . . . . . . Signature (
   28: 16: . . . . . . . . . . Parameters (
   28: 16: . . . . . . . . . . . "("
   28: 17: . . . . . . . . . . . ParameterList (
   28: 17: . . . . . . . . . . . . ParamDeclOrNil (
   28: 17: . . . . . . . . . . . . . Type (
   28: 17: . . . . . . . . . . . . . . ArrayType (
   28: 17: . . . . . . . . . . . . . . . "["
   28: 18: . . . . . . . . . . . . . . . "]"
   28: 19: . . . . . . . . . . . . . . . Type (
   28: 19: . . . . . . . . . . . . . . . . TypeName (
   28: 19: . . . . . . . . . . . . . . . . . IDENT byte
 /app/parser/parser.go:713: ast.Ident{Name: byte}
   28: 23: . . . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
   28: 23: . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . ","
   28: 25: . . . . . . . . . . . . ParamDeclOrNil (
   28: 25: . . . . . . . . . . . . . Type (
   28: 25: . . . . . . . . . . . . . . PointerType (
   28: 25: . . . . . . . . . . . . . . . "*"
   28: 26: . . . . . . . . . . . . . . . Type (
   28: 26: . . . . . . . . . . . . . . . . TypeName (
   28: 26: . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   28: 32: . . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . ","
   28: 34: . . . . . . . . . . . . ParamDeclOrNil (
   28: 34: . . . . . . . . . . . . . DotsType (
   28: 34: . . . . . . . . . . . . . . "..."
   28: 37: . . . . . . . . . . . . . . Type (
   28: 37: . . . . . . . . . . . . . . . TypeName (
   28: 37: . . . . . . . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   28: 38: . . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . ")"
   28: 40: . . . . . . . . . . )
   28: 40: . . . . . . . . . . Result (
   28: 40: . . . . . . . . . . . ChanType (
   28: 40: . . . . . . . . . . . . "chan"
   28: 44: . . . . . . . . . . . . "<-"
   28: 47: . . . . . . . . . . . . Type (
   28: 47: . . . . . . . . . . . . . TypeName (
   28: 47: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 50: . . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . )
   28: 50: . . . . . . . . . . )
   28: 50: . . . . . . . . . )
   28: 50: . . . . . . . . )
   28: 50: . . . . . . . )
   28: 50: . . . . . . )
   28: 50: . . . . . )
   28: 50: . . . . . ")"
   28: 52: . . . . )
   28: 52: . . . . Result (
   28: 52: . . . . . Parameters (
   28: 52: . . . . . . "("
   28: 53: . . . . . . ParameterList (
   28: 53: . . . . . . . ParamDeclOrNil (
   28: 53: . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   28: 55: . . . . . . . . Type (
   28: 55: . . . . . . . . . TypeName (
   28: 55: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 58: . . . . . . . . . )
   28: 58: . . . . . . . . )
   28: 58: . . . . . . . )
   28: 58: . . . . . . . ","
   28: 60: . . . . . . . ParamDeclOrNil (
   28: 60: . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   28: 64: . . . . . . . . Type (
   28: 64: . . . . . . . . . TypeName (
   28: 64: . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   28: 69: . . . . . . . . . )
   28: 69: . . . . . . . . )
   28: 69: . . . . . . . )
   28: 69: . . . . . . )
   28: 69: . . . . . . ")"
   28: 71: . . . . . )
   28: 71: . . . . )
   28: 71: . . . )
   28: 71: . . . Body (
   28: 71: . . . . "{"
   29:  2: . . . . StatementList (
   29:  2: . . . . . Statement (
   29:  2: . . . . . . ReturnStmt (
   29:  2: . . . . . . . "return"
   29:  8: . . . . . . . ";"
   30:  1: . . . . . . )
   30:  1: . . . . . )
   30:  1: . . . . )
   30:  1: . . . . "}"
   30:  2: . . . )
   30:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
   30:  3: . . )
   30:  3: . )
   30:  3: )
--- PASS: TestParseGoFiles (0.00s)
=== RUN   TestParseEntries
=== RUN   TestParseEntries/.xgo_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0003a44e0 762}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries/.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{1604 1604 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{1603 0xc0003a4a80 1616}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries/.foo.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{2458 2458 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{2457 0xc0003a5020 2470}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries/.foo_file
=== RUN   TestParseEntries/.spx_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{3312 3312 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{3311 0xc0003a5650 3324}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
--- PASS: TestParseEntries (0.00s)
    --- PASS: TestParseEntries/.xgo_file (0.00s)
    --- PASS: TestParseEntries/.gox_file (0.00s)
    --- PASS: TestParseEntries/.foo.gox_file (0.00s)
    --- PASS: TestParseEntries/.foo_file (0.00s)
    --- PASS: TestParseEntries/.spx_file (0.00s)
=== RUN   TestParseEntries_SaveAbsFile
=== RUN   TestParseEntries_SaveAbsFile/.xgo_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0003a5cb0 762}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries_SaveAbsFile/.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{1604 1604 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{1603 0xc0003c02d0 1616}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries_SaveAbsFile/.foo.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{2458 2458 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{2457 0xc0003c0870 2470}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries_SaveAbsFile/.foo_file
=== RUN   TestParseEntries_SaveAbsFile/.spx_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{3312 3312 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{3311 0xc0003c0ea0 3324}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
--- PASS: TestParseEntries_SaveAbsFile (0.00s)
    --- PASS: TestParseEntries_SaveAbsFile/.xgo_file (0.00s)
    --- PASS: TestParseEntries_SaveAbsFile/.gox_file (0.00s)
    --- PASS: TestParseEntries_SaveAbsFile/.foo.gox_file (0.00s)
    --- PASS: TestParseEntries_SaveAbsFile/.foo_file (0.00s)
    --- PASS: TestParseEntries_SaveAbsFile/.spx_file (0.00s)
=== RUN   TestParseEntry
=== RUN   TestParseEntry/.xgo_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0003c1410 762}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntry/.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{1604 1604 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{1603 0xc0003c18f0 1616}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntry/.foo.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{2458 2458 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{2457 0xc0003c1dd0 2470}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntry/.foo_file
=== RUN   TestParseEntry/.spx_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{3312 3312 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{3311 0xc0003e2360 3324}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
--- PASS: TestParseEntry (0.00s)
    --- PASS: TestParseEntry/.xgo_file (0.00s)
    --- PASS: TestParseEntry/.gox_file (0.00s)
    --- PASS: TestParseEntry/.foo.gox_file (0.00s)
    --- PASS: TestParseEntry/.foo_file (0.00s)
    --- PASS: TestParseEntry/.spx_file (0.00s)
=== RUN   TestParseEntry2
=== RUN   TestParseEntry2/_yap.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0003e2870 762}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
--- PASS: TestParseEntry2 (0.00s)
    --- PASS: TestParseEntry2/_yap.gox_file (0.00s)
=== RUN   TestSaveAbsFile
=== RUN   TestSaveAbsFile/.xgo_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0003e2d80 762}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestSaveAbsFile/.xgo_file#01
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{1604 1604 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{1603 0xc0003e3260 1616}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestSaveAbsFile/dir
 /app/parser/parser.go:713: ast.Ident{Name: main}
 /app/parser/parser.go:713: ast.Ident{Name: main}
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: changeYpos, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: changeYpos, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:2064: ast.IndexExpr{X: x, Index: &{1811 INT 1 <nil>}}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:902: ast.SliceLit{Elts: []}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: x, Ellipsis: true, isCmd: true}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
--- PASS: TestSaveAbsFile (0.00s)
    --- PASS: TestSaveAbsFile/.xgo_file (0.00s)
    --- PASS: TestSaveAbsFile/.xgo_file#01 (0.00s)
    --- PASS: TestSaveAbsFile/dir (0.00s)
=== RUN   TestGopAutoGen
--- PASS: TestGopAutoGen (0.00s)
=== RUN   TestGoFile
--- PASS: TestGoFile (0.00s)
=== RUN   TestErrParse
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:4187: expected ';', found bar
 /app/parser/parser.go:713: ast.Ident{Name: foo}
--- PASS: TestErrParse (0.00s)
=== RUN   TestFromTestexpr
=== RUN   TestFromTestexpr/lambda
 /app/parser/parserdir_test.go:130: Parsing /app/parser/_testexpr/lambda
    1:  1: Expression (
    1:  1: . "=>"
    1:  4: . BlockStmt (
    1:  4: . . "{"
    2:  5: . . StatementList (
    2:  5: . . . Statement (
    2:  5: . . . . ReturnStmt (
    2:  5: . . . . . "return"
    2: 12: . . . . . ExpressionList (
    2: 12: . . . . . . Expression (
    2: 12: . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . IDENT this
 /app/parser/parser.go:713: ast.Ident{Name: this}
    2: 16: . . . . . . . . . . )
    2: 16: . . . . . . . . . )
    2: 16: . . . . . . . . )
    2: 16: . . . . . . . )
    2: 16: . . . . . . )
    2: 16: . . . . . )
    2: 16: . . . . . ";"
    3:  1: . . . . )
    3:  1: . . . )
    3:  1: . . )
    3:  1: . . "}"
    3:  2: . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
    3:  2: )
    3:  2: ";"
    3:  3: EOF
--- PASS: TestFromTestexpr (0.00s)
    --- PASS: TestFromTestexpr/lambda (0.00s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/append1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/append1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . . "<-"
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  6: . . . . . Expression (
    1:  6: . . . . . . BinaryExpr (
    1:  6: . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . . ","
    1:  9: . . . . . Expression (
    1:  9: . . . . . . BinaryExpr (
    1:  9: . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    1: 10: . . . . . . . . . )
    1: 10: . . . . . . . . )
    1: 10: . . . . . . . )
    1: 10: . . . . . . )
    1: 10: . . . . . )
    1: 10: . . . . . ","
    1: 12: . . . . . Expression (
    1: 12: . . . . . . BinaryExpr (
    1: 12: . . . . . . . UnaryExpr (
    1: 12: . . . . . . . . PrimaryExpr (
    1: 12: . . . . . . . . . Operand (
    1: 12: . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    1: 13: . . . . . . . . . )
    1: 13: . . . . . . . . )
    1: 13: . . . . . . . )
    1: 13: . . . . . . )
    1: 13: . . . . . )
    1: 13: . . . . )
    1: 13: . . . . ";"
    1: 14: . . . )
    1: 14: . . )
    1: 14: . )
    1: 14: )
=== RUN   TestFromTestdata/append2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/append2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . . "<-"
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  6: . . . . . Expression (
    1:  6: . . . . . . BinaryExpr (
    1:  6: . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . . "..."
    1: 10: . . . . )
    1: 10: . . . . ";"
    1: 11: . . . )
    1: 11: . . )
    1: 11: . )
    1: 11: )
=== RUN   TestFromTestdata/arrowop
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/arrowop
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  7: . . . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . . "+"
    1:  8: . . . . . . . . . . . . . BinaryExpr (
    1:  8: . . . . . . . . . . . . . . UnaryExpr (
    1:  8: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  8: . . . . . . . . . . . . . . . . Operand (
    1:  8: . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1: 10: . . . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . "->"
    1: 13: . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    1: 14: . . . . . . . . . . )
    1: 14: . . . . . . . . . )
    1: 14: . . . . . . . . )
    1: 14: . . . . . . . )
    1: 14: . . . . . . )
    1: 14: . . . . . )
    1: 14: . . . . )
    1: 14: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    2:  6: . . . . . . . . . . )
    2:  6: . . . . . . . . . . CallOrConversion (
    2:  6: . . . . . . . . . . . Expression (
    2:  6: . . . . . . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2:  8: . . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . "<>"
    2: 11: . . . . . . . . . . . . . BinaryExpr (
    2: 11: . . . . . . . . . . . . . . UnaryExpr (
    2: 11: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 11: . . . . . . . . . . . . . . . . Operand (
    2: 11: . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    2: 12: . . . . . . . . . . . . . . . . )
    2: 12: . . . . . . . . . . . . . . . )
    2: 12: . . . . . . . . . . . . . . )
    2: 12: . . . . . . . . . . . . . . "+"
    2: 13: . . . . . . . . . . . . . . BinaryExpr (
    2: 13: . . . . . . . . . . . . . . . UnaryExpr (
    2: 13: . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . Operand (
    2: 13: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 14: . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    2: 14: . . . . . . . . . . )
    2: 14: . . . . . . . . . )
    2: 14: . . . . . . . . )
    2: 14: . . . . . . . )
    2: 14: . . . . . . )
    2: 14: . . . . . )
    2: 14: . . . . )
    2: 14: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    3:  6: . . . . . . . . . . )
    3:  6: . . . . . . . . . . CallOrConversion (
    3:  6: . . . . . . . . . . . Expression (
    3:  6: . . . . . . . . . . . . BinaryExpr (
    3:  6: . . . . . . . . . . . . . UnaryExpr (
    3:  6: . . . . . . . . . . . . . . PrimaryExpr (
    3:  6: . . . . . . . . . . . . . . . Operand (
    3:  6: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    3:  8: . . . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . "->"
    3: 11: . . . . . . . . . . . . . BinaryExpr (
    3: 11: . . . . . . . . . . . . . . UnaryExpr (
    3: 11: . . . . . . . . . . . . . . . PrimaryExpr (
    3: 11: . . . . . . . . . . . . . . . . Operand (
    3: 11: . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    3: 12: . . . . . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    3: 12: . . . . . . . . . . )
    3: 12: . . . . . . . . . )
    3: 12: . . . . . . . . )
    3: 12: . . . . . . . )
    3: 12: . . . . . . )
    3: 12: . . . . . )
    3: 12: . . . . )
    3: 12: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    4:  6: . . . . . . . . . . )
    4:  6: . . . . . . . . . . CallOrConversion (
    4:  6: . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4:  8: . . . . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . . . "<>"
    4: 11: . . . . . . . . . . . . . BinaryExpr (
    4: 11: . . . . . . . . . . . . . . UnaryExpr (
    4: 11: . . . . . . . . . . . . . . . PrimaryExpr (
    4: 11: . . . . . . . . . . . . . . . . Operand (
    4: 11: . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4: 12: . . . . . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . ","
    4: 14: . . . . . . . . . . . Expression (
    4: 14: . . . . . . . . . . . . BinaryExpr (
    4: 14: . . . . . . . . . . . . . UnaryExpr (
    4: 14: . . . . . . . . . . . . . . PrimaryExpr (
    4: 14: . . . . . . . . . . . . . . . Operand (
    4: 14: . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    4: 18: . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    4: 18: . . . . . . . . . . )
    4: 18: . . . . . . . . . )
    4: 18: . . . . . . . . )
    4: 18: . . . . . . . )
    4: 18: . . . . . . )
    4: 18: . . . . . )
    4: 18: . . . . )
    4: 18: . . . . ";"
    4: 19: . . . )
    4: 19: . . )
    4: 19: . )
    4: 19: )
=== RUN   TestFromTestdata/autoprop
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/autoprop
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT L
 /app/parser/parser.go:713: ast.Ident{Name: L}
    1:  2: . . . . . . . . . . )
    1:  2: . . . . . . . . . )
    1:  2: . . . . . . . . )
    1:  2: . . . . . . . )
    1:  2: . . . . . . )
    1:  2: . . . . . )
    1:  2: . . . . . ":"
    2:  2: . . . . . Statement (
    2:  2: . . . . . . BranchStmt (
    2:  2: . . . . . . . "goto"
    2:  2: . . . . . . . SimpleStmt (
    2:  2: . . . . . . . . ExpressionList (
    2:  2: . . . . . . . . . Expression (
    2:  2: . . . . . . . . . . BinaryExpr (
    2:  2: . . . . . . . . . . . UnaryExpr (
    2:  2: . . . . . . . . . . . . PrimaryExpr (
    2:  2: . . . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: goto}
    2:  6: . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . CallOrConversion (
    2:  6: . . . . . . . . . . . . . . "("
    2:  7: . . . . . . . . . . . . . . Expression (
    2:  7: . . . . . . . . . . . . . . . BinaryExpr (
    2:  7: . . . . . . . . . . . . . . . . UnaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . Operand (
    2:  7: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2:  8: . . . . . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . ","
    2: 10: . . . . . . . . . . . . . . Expression (
    2: 10: . . . . . . . . . . . . . . . BinaryExpr (
    2: 10: . . . . . . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . Operand (
    2: 10: . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 11: . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: false}
    2: 13: . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . "+"
    2: 15: . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . IDENT break
 /app/parser/parser.go:713: ast.Ident{Name: break}
    2: 20: . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . CallOrConversion (
    2: 20: . . . . . . . . . . . . . . . "("
    2: 21: . . . . . . . . . . . . . . . Expression (
    2: 21: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 21: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 21: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 21: . . . . . . . . . . . . . . . . . . . Operand (
    2: 21: . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2: 22: . . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . ","
    2: 24: . . . . . . . . . . . . . . . Expression (
    2: 24: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 24: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 24: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 24: . . . . . . . . . . . . . . . . . . . Operand (
    2: 24: . . . . . . . . . . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
    2: 25: . . . . . . . . . . . . . . . . . . . )
    2: 25: . . . . . . . . . . . . . . . . . . )
    2: 25: . . . . . . . . . . . . . . . . . )
    2: 25: . . . . . . . . . . . . . . . . )
    2: 25: . . . . . . . . . . . . . . . )
    2: 25: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: break, Ellipsis: false, isCmd: false}
    2: 27: . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . "+"
    2: 29: . . . . . . . . . . . BinaryExpr (
    2: 29: . . . . . . . . . . . . UnaryExpr (
    2: 29: . . . . . . . . . . . . . PrimaryExpr (
    2: 29: . . . . . . . . . . . . . . Operand (
    2: 29: . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 30: . . . . . . . . . . . . . . )
    2: 30: . . . . . . . . . . . . . . "."
    2: 31: . . . . . . . . . . . . . . Selector (
    2: 31: . . . . . . . . . . . . . . . IDENT goto
 /app/parser/parser.go:713: ast.Ident{Name: goto}
    2: 35: . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . CallOrConversion (
    2: 35: . . . . . . . . . . . . . . . "("
    2: 36: . . . . . . . . . . . . . . . Expression (
    2: 36: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 36: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 36: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 36: . . . . . . . . . . . . . . . . . . . Operand (
    2: 36: . . . . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
    2: 37: . . . . . . . . . . . . . . . . . . . )
    2: 37: . . . . . . . . . . . . . . . . . . )
    2: 37: . . . . . . . . . . . . . . . . . )
    2: 37: . . . . . . . . . . . . . . . . )
    2: 37: . . . . . . . . . . . . . . . )
    2: 37: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{a goto}, Ellipsis: false, isCmd: false}
    2: 38: . . . . . . . . . . . . . . )
    2: 38: . . . . . . . . . . . . . )
    2: 38: . . . . . . . . . . . . )
    2: 38: . . . . . . . . . . . )
    2: 38: . . . . . . . . . . )
    2: 38: . . . . . . . . . )
    2: 38: . . . . . . . . )
    2: 38: . . . . . . . )
    2: 38: . . . . . . . ";"
    3:  2: . . . . . . )
    3:  2: . . . . . )
    3:  2: . . . . )
    3:  2: . . . )
    3:  2: . . . Statement (
    3:  2: . . . . BranchStmt (
    3:  2: . . . . . "goto"
    3:  7: . . . . . IDENT L
 /app/parser/parser.go:713: ast.Ident{Name: L}
    3:  8: . . . . . ";"
    3:  9: . . . . )
    3:  9: . . . )
    3:  9: . . )
    3:  9: . )
    3:  9: )
=== RUN   TestFromTestdata/build
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/build
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(type) (
    1:  1: . . . "type"
    1:  6: . . . TypeSpec (
    1:  6: . . . . IDENT cstring
 /app/parser/parser.go:713: ast.Ident{Name: cstring}
    1: 14: . . . . Type (
    1: 14: . . . . . TypeName (
    1: 14: . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    1: 20: . . . . . )
    1: 20: . . . . )
    1: 20: . . . . ";"
    3:  1: . . . )
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . StatementList (
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT title
 /app/parser/parser.go:713: ast.Ident{Name: title}
    3:  7: . . . . . . . . . . )
    3:  7: . . . . . . . . . )
    3:  7: . . . . . . . . )
    3:  7: . . . . . . . )
    3:  7: . . . . . . )
    3:  7: . . . . . )
    3:  7: . . . . . ":="
    3: 10: . . . . . ExpressionList (
    3: 10: . . . . . . Expression (
    3: 10: . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . STRING "Hello,world!2020-05-27"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hello,world!2020-05-27"}
    3: 34: . . . . . . . . . . )
    3: 34: . . . . . . . . . )
    3: 34: . . . . . . . . )
    3: 34: . . . . . . . )
    3: 34: . . . . . . )
    3: 34: . . . . . )
    3: 34: . . . . )
    3: 34: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
    4:  3: . . . . . . . . . . )
    4:  3: . . . . . . . . . )
    4:  3: . . . . . . . . )
    4:  3: . . . . . . . )
    4:  3: . . . . . . )
    4:  3: . . . . . )
    4:  3: . . . . . ":="
    4:  6: . . . . . ExpressionList (
    4:  6: . . . . . . Expression (
    4:  6: . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . "("
    4:  7: . . . . . . . . . . . Expression (
    4:  7: . . . . . . . . . . . . BinaryExpr (
    4:  7: . . . . . . . . . . . . . UnaryExpr (
    4:  7: . . . . . . . . . . . . . . "*"
    4:  8: . . . . . . . . . . . . . . UnaryExpr (
    4:  8: . . . . . . . . . . . . . . . PrimaryExpr (
    4:  8: . . . . . . . . . . . . . . . . Operand (
    4:  8: . . . . . . . . . . . . . . . . . IDENT cstring
 /app/parser/parser.go:713: ast.Ident{Name: cstring}
    4: 15: . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{62 cstring}}
    4: 16: . . . . . . . . . . )
    4: 16: . . . . . . . . . . CallOrConversion (
    4: 16: . . . . . . . . . . . "("
    4: 17: . . . . . . . . . . . Expression (
    4: 17: . . . . . . . . . . . . BinaryExpr (
    4: 17: . . . . . . . . . . . . . UnaryExpr (
    4: 17: . . . . . . . . . . . . . . "&"
    4: 18: . . . . . . . . . . . . . . UnaryExpr (
    4: 18: . . . . . . . . . . . . . . . PrimaryExpr (
    4: 18: . . . . . . . . . . . . . . . . Operand (
    4: 18: . . . . . . . . . . . . . . . . . IDENT title
 /app/parser/parser.go:713: ast.Ident{Name: title}
    4: 23: . . . . . . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{61 0xc0003f0a38 70}, Ellipsis: false, isCmd: false}
    4: 24: . . . . . . . . . . )
    4: 24: . . . . . . . . . )
    4: 24: . . . . . . . . )
    4: 24: . . . . . . . )
    4: 24: . . . . . . )
    4: 24: . . . . . )
    4: 24: . . . . )
    4: 24: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  8: . . . . . . . . . . )
    5:  8: . . . . . . . . . . CallOrConversion (
    5:  8: . . . . . . . . . . . "("
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . IDENT title
 /app/parser/parser.go:713: ast.Ident{Name: title}
    5: 14: . . . . . . . . . . . . . . . )
    5: 14: . . . . . . . . . . . . . . . IndexOrSlice (
    5: 14: . . . . . . . . . . . . . . . . "["
    5: 15: . . . . . . . . . . . . . . . . Expression (
    5: 15: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . . . . Operand (
    5: 15: . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    5: 17: . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . ":"
    5: 19: . . . . . . . . . . . . . . . . Expression (
    5: 19: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 19: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 19: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 19: . . . . . . . . . . . . . . . . . . . . Operand (
    5: 19: . . . . . . . . . . . . . . . . . . . . . IDENT len
 /app/parser/parser.go:713: ast.Ident{Name: len}
    5: 22: . . . . . . . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    5: 22: . . . . . . . . . . . . . . . . . . . . . "("
    5: 23: . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 23: . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 23: . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 23: . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 23: . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT title
 /app/parser/parser.go:713: ast.Ident{Name: title}
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: len, Ellipsis: false, isCmd: false}
    5: 29: . . . . . . . . . . . . . . . . . . . . )
    5: 29: . . . . . . . . . . . . . . . . . . . )
    5: 29: . . . . . . . . . . . . . . . . . . )
    5: 29: . . . . . . . . . . . . . . . . . . "-"
    5: 30: . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 30: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 30: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 30: . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 30: . . . . . . . . . . . . . . . . . . . . . . IDENT len
 /app/parser/parser.go:713: ast.Ident{Name: len}
    5: 33: . . . . . . . . . . . . . . . . . . . . . )
    5: 33: . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    5: 33: . . . . . . . . . . . . . . . . . . . . . . "("
    5: 34: . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "2006-01-02"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "2006-01-02"}
    5: 46: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 46: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 46: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 46: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 46: . . . . . . . . . . . . . . . . . . . . . . )
    5: 46: . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: len, Ellipsis: false, isCmd: false}
    5: 47: . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . "]"
    5: 48: . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 49: . . . . . . . . . . )
    5: 49: . . . . . . . . . )
    5: 49: . . . . . . . . )
    5: 49: . . . . . . . )
    5: 49: . . . . . . )
    5: 49: . . . . . )
    5: 49: . . . . )
    5: 49: . . . . ";"
    5: 50: . . . )
    5: 50: . . )
    5: 50: . )
    5: 50: )
=== RUN   TestFromTestdata/c2gohello
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/c2gohello
    1:  1: File (
    1:  1: . GenDecl(import) (
    1:  1: . . "import"
    1:  8: . . ImportSpec (
    1:  8: . . . STRING "C"
    1: 11: . . . ";"
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . StatementList (
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT C
 /app/parser/parser.go:713: ast.Ident{Name: C}
    3:  2: . . . . . . . . . . )
    3:  2: . . . . . . . . . . "."
    3:  3: . . . . . . . . . . Selector (
    3:  3: . . . . . . . . . . . IDENT printf
 /app/parser/parser.go:713: ast.Ident{Name: printf}
    3: 10: . . . . . . . . . . )
    3: 10: . . . . . . . . . . CallOrConversion (
    3: 10: . . . . . . . . . . . Expression (
    3: 10: . . . . . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . . . . . CSTRING "Hello, world!\n"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: CSTRING, Value: "Hello, world!\n"}
    3: 28: . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{C printf}, Ellipsis: false, isCmd: true}
    3: 28: . . . . . . . . . . )
    3: 28: . . . . . . . . . )
    3: 28: . . . . . . . . )
    3: 28: . . . . . . . )
    3: 28: . . . . . . )
    3: 28: . . . . . )
    3: 28: . . . . )
    3: 28: . . . . ";"
    3: 29: . . . )
    3: 29: . . )
    3: 29: . )
    3: 29: )
=== RUN   TestFromTestdata/cmdlinestyle1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/cmdlinestyle1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . "("
    1: 10: . . . . . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 11: . . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . "+"
    1: 12: . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 12: . . . . . . . . . . . . . . . . . . . . . . IMAG 2i
 /app/parser/parser.go:1862: ast.BasicLit{Kind: IMAG, Value: 2i}
    1: 14: . . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{0xc00040d470 11 + 0xc00040d4a0}}
    1: 15: . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . "*"
    1: 16: . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 17: . . . . . . . . . . )
    1: 17: . . . . . . . . . )
    1: 17: . . . . . . . . )
    1: 17: . . . . . . . )
    1: 17: . . . . . . )
    1: 17: . . . . . )
    1: 17: . . . . )
    1: 17: . . . . ";"
    1: 18: . . . )
    1: 18: . . )
    1: 18: . )
    1: 18: )
=== RUN   TestFromTestdata/cmdlinestyle2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/cmdlinestyle2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . . CallOrConversion (
    1:  3: . . . . . . . . . . . Expression (
    1:  3: . . . . . . . . . . . . BinaryExpr (
    1:  3: . . . . . . . . . . . . . UnaryExpr (
    1:  3: . . . . . . . . . . . . . . PrimaryExpr (
    1:  3: . . . . . . . . . . . . . . . Operand (
    1:  3: . . . . . . . . . . . . . . . . LiteralValue (
    1:  3: . . . . . . . . . . . . . . . . . "{"
    1:  4: . . . . . . . . . . . . . . . . . "}"
    1:  5: . . . . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: x, Ellipsis: false, isCmd: true}
    1:  5: . . . . . . . . . . )
    1:  5: . . . . . . . . . )
    1:  5: . . . . . . . . )
    1:  5: . . . . . . . )
    1:  5: . . . . . . )
    1:  5: . . . . . )
    1:  5: . . . . )
    1:  5: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  2: . . . . . . . . . . )
    2:  2: . . . . . . . . . . LiteralValue (
    2:  2: . . . . . . . . . . . "{"
    2:  3: . . . . . . . . . . . "}"
    2:  4: . . . . . . . . . . )
    2:  4: . . . . . . . . . )
    2:  4: . . . . . . . . )
    2:  4: . . . . . . . )
    2:  4: . . . . . . )
    2:  4: . . . . . )
    2:  4: . . . . )
    2:  4: . . . . ";"
    2:  5: . . . )
    2:  5: . . )
    2:  5: . )
    2:  5: )
=== RUN   TestFromTestdata/cmdlinestyle3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/cmdlinestyle3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . "&"
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 11: . . . . . . . . . . )
    1: 11: . . . . . . . . . )
    1: 11: . . . . . . . . )
    1: 11: . . . . . . . )
    1: 11: . . . . . . )
    1: 11: . . . . . )
    1: 11: . . . . )
    1: 11: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . "!"
    2: 10: . . . . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 10: . . . . . . . . . . . . . . . . Operand (
    2: 10: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 11: . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    2: 11: . . . . . . . . . . )
    2: 11: . . . . . . . . . )
    2: 11: . . . . . . . . )
    2: 11: . . . . . . . )
    2: 11: . . . . . . )
    2: 11: . . . . . )
    2: 11: . . . . )
    2: 11: . . . . ";"
    2: 12: . . . )
    2: 12: . . )
    2: 12: . )
    2: 12: )
=== RUN   TestFromTestdata/cmdlinestyle4
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/cmdlinestyle4
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT call
 /app/parser/parser.go:713: ast.Ident{Name: call}
    1: 10: . . . Signature (
    1: 10: . . . . Parameters (
    1: 10: . . . . . "("
    1: 11: . . . . . ParameterList (
    1: 11: . . . . . . ParamDeclOrNil (
    1: 11: . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    1: 14: . . . . . . . Type (
    1: 14: . . . . . . . . FuncType (
    1: 14: . . . . . . . . . "func"
    1: 18: . . . . . . . . . Signature (
    1: 18: . . . . . . . . . . Parameters (
    1: 18: . . . . . . . . . . . "("
    1: 19: . . . . . . . . . . . ParameterList (
    1: 19: . . . . . . . . . . . . ParamDeclOrNil (
    1: 19: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 21: . . . . . . . . . . . . . Type (
    1: 21: . . . . . . . . . . . . . . TypeName (
    1: 21: . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 24: . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . ")"
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . . Result (
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . . ")"
    1: 27: . . . . )
    1: 27: . . . . Result (
    1: 27: . . . . )
    1: 27: . . . )
    1: 27: . . . Body (
    1: 27: . . . . "{"
    1: 29: . . . . StatementList (
    1: 29: . . . . . Statement (
    1: 29: . . . . . . SimpleStmt (
    1: 29: . . . . . . . ExpressionList (
    1: 29: . . . . . . . . Expression (
    1: 29: . . . . . . . . . BinaryExpr (
    1: 29: . . . . . . . . . . UnaryExpr (
    1: 29: . . . . . . . . . . . PrimaryExpr (
    1: 29: . . . . . . . . . . . . Operand (
    1: 29: . . . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    1: 31: . . . . . . . . . . . . )
    1: 31: . . . . . . . . . . . . CallOrConversion (
    1: 31: . . . . . . . . . . . . . "("
    1: 32: . . . . . . . . . . . . . Expression (
    1: 32: . . . . . . . . . . . . . . BinaryExpr (
    1: 32: . . . . . . . . . . . . . . . UnaryExpr (
    1: 32: . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 32: . . . . . . . . . . . . . . . . . Operand (
    1: 32: . . . . . . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
    1: 35: . . . . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: fn, Ellipsis: false, isCmd: false}
    1: 37: . . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . )
    1: 37: . . . . . . . . . . )
    1: 37: . . . . . . . . . )
    1: 37: . . . . . . . . )
    1: 37: . . . . . . . )
    1: 37: . . . . . . )
    1: 37: . . . . . )
    1: 37: . . . . )
    1: 37: . . . . "}"
    1: 38: . . . )
    1: 38: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: call, ...}
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . StatementList (
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT call
 /app/parser/parser.go:713: ast.Ident{Name: call}
    3:  5: . . . . . . . . . . )
    3:  5: . . . . . . . . . . CallOrConversion (
    3:  5: . . . . . . . . . . . "("
    3:  6: . . . . . . . . . . . Expression (
    3:  6: . . . . . . . . . . . . BinaryExpr (
    3:  6: . . . . . . . . . . . . . UnaryExpr (
    3:  6: . . . . . . . . . . . . . . PrimaryExpr (
    3:  6: . . . . . . . . . . . . . . . Operand (
    3:  6: . . . . . . . . . . . . . . . . FuncTypeOrLit (
    3:  6: . . . . . . . . . . . . . . . . . FuncType (
    3:  6: . . . . . . . . . . . . . . . . . . "func"
    3: 10: . . . . . . . . . . . . . . . . . . Signature (
    3: 10: . . . . . . . . . . . . . . . . . . . Parameters (
    3: 10: . . . . . . . . . . . . . . . . . . . . "("
    3: 11: . . . . . . . . . . . . . . . . . . . . ParameterList (
    3: 11: . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
    3: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    3: 13: . . . . . . . . . . . . . . . . . . . . . . Type (
    3: 13: . . . . . . . . . . . . . . . . . . . . . . . TypeName (
    3: 13: . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 16: . . . . . . . . . . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . . . . . . . . ")"
    3: 18: . . . . . . . . . . . . . . . . . . . )
    3: 18: . . . . . . . . . . . . . . . . . . . Result (
    3: 18: . . . . . . . . . . . . . . . . . . . )
    3: 18: . . . . . . . . . . . . . . . . . . )
    3: 18: . . . . . . . . . . . . . . . . . )
    3: 18: . . . . . . . . . . . . . . . . . Body (
    3: 18: . . . . . . . . . . . . . . . . . . "{"
    3: 20: . . . . . . . . . . . . . . . . . . StatementList (
    3: 20: . . . . . . . . . . . . . . . . . . . Statement (
    3: 20: . . . . . . . . . . . . . . . . . . . . SimpleStmt (
    3: 20: . . . . . . . . . . . . . . . . . . . . . ExpressionList (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . Expression (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    3: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . "}"
    3: 29: . . . . . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: call, Ellipsis: false, isCmd: false}
    3: 30: . . . . . . . . . . )
    3: 30: . . . . . . . . . )
    3: 30: . . . . . . . . )
    3: 30: . . . . . . . )
    3: 30: . . . . . . )
    3: 30: . . . . . )
    3: 30: . . . . )
    3: 30: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT call
 /app/parser/parser.go:713: ast.Ident{Name: call}
    4:  5: . . . . . . . . . . )
    4:  5: . . . . . . . . . . CallOrConversion (
    4:  5: . . . . . . . . . . . "("
    4:  6: . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . . . FuncTypeOrLit (
    4:  6: . . . . . . . . . . . . . . . . . FuncType (
    4:  6: . . . . . . . . . . . . . . . . . . "func"
    4: 10: . . . . . . . . . . . . . . . . . . Signature (
    4: 10: . . . . . . . . . . . . . . . . . . . Parameters (
    4: 10: . . . . . . . . . . . . . . . . . . . . "("
    4: 11: . . . . . . . . . . . . . . . . . . . . ParameterList (
    4: 11: . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
    4: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 13: . . . . . . . . . . . . . . . . . . . . . . Type (
    4: 13: . . . . . . . . . . . . . . . . . . . . . . . TypeName (
    4: 13: . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    4: 16: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . . . . . . . ")"
    4: 18: . . . . . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . . . . . . Result (
    4: 18: . . . . . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . . . . Body (
    4: 18: . . . . . . . . . . . . . . . . . . "{"
    4: 20: . . . . . . . . . . . . . . . . . . StatementList (
    4: 20: . . . . . . . . . . . . . . . . . . . Statement (
    4: 20: . . . . . . . . . . . . . . . . . . . . SimpleStmt (
    4: 20: . . . . . . . . . . . . . . . . . . . . . ExpressionList (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . Expression (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . "}"
    4: 31: . . . . . . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: call, Ellipsis: false, isCmd: false}
    4: 32: . . . . . . . . . . )
    4: 32: . . . . . . . . . )
    4: 32: . . . . . . . . )
    4: 32: . . . . . . . )
    4: 32: . . . . . . )
    4: 32: . . . . . )
    4: 32: . . . . )
    4: 32: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT call
 /app/parser/parser.go:713: ast.Ident{Name: call}
    5:  5: . . . . . . . . . . )
    5:  5: . . . . . . . . . . CallOrConversion (
    5:  5: . . . . . . . . . . . "("
    5:  6: . . . . . . . . . . . Expression (
    5:  6: . . . . . . . . . . . . BinaryExpr (
    5:  6: . . . . . . . . . . . . . UnaryExpr (
    5:  6: . . . . . . . . . . . . . . PrimaryExpr (
    5:  6: . . . . . . . . . . . . . . . Operand (
    5:  6: . . . . . . . . . . . . . . . . FuncTypeOrLit (
    5:  6: . . . . . . . . . . . . . . . . . FuncType (
    5:  6: . . . . . . . . . . . . . . . . . . "func"
    5: 10: . . . . . . . . . . . . . . . . . . Signature (
    5: 10: . . . . . . . . . . . . . . . . . . . Parameters (
    5: 10: . . . . . . . . . . . . . . . . . . . . "("
    5: 11: . . . . . . . . . . . . . . . . . . . . ParameterList (
    5: 11: . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5: 13: . . . . . . . . . . . . . . . . . . . . . . Type (
    5: 13: . . . . . . . . . . . . . . . . . . . . . . . TypeName (
    5: 13: . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 16: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . ")"
    5: 18: . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . Result (
    5: 18: . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . Body (
    5: 18: . . . . . . . . . . . . . . . . . . "{"
    5: 20: . . . . . . . . . . . . . . . . . . StatementList (
    5: 20: . . . . . . . . . . . . . . . . . . . Statement (
    5: 20: . . . . . . . . . . . . . . . . . . . . SimpleStmt (
    5: 20: . . . . . . . . . . . . . . . . . . . . . ExpressionList (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "{"
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ElementList (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "x"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x"}
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "y"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "y"}
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 200
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 200}
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "}"
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . "}"
    5: 53: . . . . . . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: call, Ellipsis: false, isCmd: false}
    5: 54: . . . . . . . . . . )
    5: 54: . . . . . . . . . )
    5: 54: . . . . . . . . )
    5: 54: . . . . . . . )
    5: 54: . . . . . . )
    5: 54: . . . . . )
    5: 54: . . . . )
    5: 54: . . . . ";"
    5: 55: . . . )
    5: 55: . . )
    5: 55: . )
    5: 55: )
=== RUN   TestFromTestdata/collection
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/collection
    1:  1: COMMENT
    2:  1: COMMENT
    3:  1: COMMENT
    4:  1: COMMENT
    6:  1: COMMENT
    7:  1: COMMENT
    8:  1: COMMENT
    9:  1: COMMENT
   10:  1: COMMENT
   12:  1: COMMENT
   13:  1: COMMENT
   14:  1: COMMENT
   15:  1: COMMENT
   16:  1: COMMENT
   17:  1: COMMENT
   19:  1: File (
   19:  1: . "package"
   19:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
   19: 13: . ";"
   21:  1: . GenDecl(import) (
   21:  1: . . "import"
   21:  8: . . "("
   22:  2: . . ImportSpec (
   22:  2: . . . STRING "fmt"
   22:  7: . . . ";"
   23:  2: . . )
   23:  2: . . ImportSpec (
   23:  2: . . . STRING "strings"
   23: 11: . . . ";"
   24:  1: . . )
   24:  1: . . ")"
   24:  2: . . ";"
   26:  1: . . COMMENT
   27:  1: . . COMMENT
   28:  1: . )
   28:  1: . Declaration (
   28:  1: . . FunctionDeclOrCall (
   28:  1: . . . "func"
   28:  6: . . . IDENT Index
 /app/parser/parser.go:713: ast.Ident{Name: Index}
   28: 11: . . . Signature (
   28: 11: . . . . Parameters (
   28: 11: . . . . . "("
   28: 12: . . . . . ParameterList (
   28: 12: . . . . . . ParamDeclOrNil (
   28: 12: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   28: 15: . . . . . . . ArrayFieldOrTypeInstance (
   28: 15: . . . . . . . . "["
   28: 16: . . . . . . . . "]"
   28: 17: . . . . . . . . Type (
   28: 17: . . . . . . . . . TypeName (
   28: 17: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   28: 23: . . . . . . . . . )
   28: 23: . . . . . . . . )
   28: 23: . . . . . . . )
   28: 23: . . . . . . )
   28: 23: . . . . . . ","
   28: 25: . . . . . . ParamDeclOrNil (
   28: 25: . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
   28: 27: . . . . . . . Type (
   28: 27: . . . . . . . . TypeName (
   28: 27: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   28: 33: . . . . . . . . )
   28: 33: . . . . . . . )
   28: 33: . . . . . . )
   28: 33: . . . . . )
   28: 33: . . . . . ")"
   28: 35: . . . . )
   28: 35: . . . . Result (
   28: 35: . . . . . TypeName (
   28: 35: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 39: . . . . . )
   28: 39: . . . . )
   28: 39: . . . )
   28: 39: . . . Body (
   28: 39: . . . . "{"
   29:  2: . . . . StatementList (
   29:  2: . . . . . Statement (
   29:  2: . . . . . . ForStmt (
   29:  2: . . . . . . . "for"
   29:  6: . . . . . . . SimpleStmt (
   29:  6: . . . . . . . . ExpressionList (
   29:  6: . . . . . . . . . Expression (
   29:  6: . . . . . . . . . . BinaryExpr (
   29:  6: . . . . . . . . . . . UnaryExpr (
   29:  6: . . . . . . . . . . . . PrimaryExpr (
   29:  6: . . . . . . . . . . . . . Operand (
   29:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   29:  7: . . . . . . . . . . . . . )
   29:  7: . . . . . . . . . . . . )
   29:  7: . . . . . . . . . . . )
   29:  7: . . . . . . . . . . )
   29:  7: . . . . . . . . . )
   29:  7: . . . . . . . . . ","
   29:  9: . . . . . . . . . Expression (
   29:  9: . . . . . . . . . . BinaryExpr (
   29:  9: . . . . . . . . . . . UnaryExpr (
   29:  9: . . . . . . . . . . . . PrimaryExpr (
   29:  9: . . . . . . . . . . . . . Operand (
   29:  9: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   29: 11: . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . )
   29: 11: . . . . . . . . . . )
   29: 11: . . . . . . . . . )
   29: 11: . . . . . . . . )
   29: 11: . . . . . . . . ":="
   29: 14: . . . . . . . . "range"
   29: 20: . . . . . . . . Expression (
   29: 20: . . . . . . . . . RangeExpr (
   29: 20: . . . . . . . . . . BinaryExpr (
   29: 20: . . . . . . . . . . . UnaryExpr (
   29: 20: . . . . . . . . . . . . PrimaryExpr (
   29: 20: . . . . . . . . . . . . . Operand (
   29: 20: . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   29: 23: . . . . . . . . . . . . . )
   29: 23: . . . . . . . . . . . . )
   29: 23: . . . . . . . . . . . )
   29: 23: . . . . . . . . . . )
   29: 23: . . . . . . . . . )
   29: 23: . . . . . . . . )
   29: 23: . . . . . . . )
   29: 23: . . . . . . . BlockStmt (
   29: 23: . . . . . . . . "{"
   30:  3: . . . . . . . . StatementList (
   30:  3: . . . . . . . . . Statement (
   30:  3: . . . . . . . . . . IfStmt (
   30:  3: . . . . . . . . . . . "if"
   30:  6: . . . . . . . . . . . SimpleStmt (
   30:  6: . . . . . . . . . . . . ExpressionList (
   30:  6: . . . . . . . . . . . . . Expression (
   30:  6: . . . . . . . . . . . . . . BinaryExpr (
   30:  6: . . . . . . . . . . . . . . . UnaryExpr (
   30:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
   30:  6: . . . . . . . . . . . . . . . . . Operand (
   30:  6: . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   30:  8: . . . . . . . . . . . . . . . . . )
   30:  8: . . . . . . . . . . . . . . . . )
   30:  8: . . . . . . . . . . . . . . . )
   30:  8: . . . . . . . . . . . . . . . "=="
   30: 11: . . . . . . . . . . . . . . . BinaryExpr (
   30: 11: . . . . . . . . . . . . . . . . UnaryExpr (
   30: 11: . . . . . . . . . . . . . . . . . PrimaryExpr (
   30: 11: . . . . . . . . . . . . . . . . . . Operand (
   30: 11: . . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
   30: 13: . . . . . . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . BlockStmt (
   30: 13: . . . . . . . . . . . . "{"
   31:  4: . . . . . . . . . . . . StatementList (
   31:  4: . . . . . . . . . . . . . Statement (
   31:  4: . . . . . . . . . . . . . . ReturnStmt (
   31:  4: . . . . . . . . . . . . . . . "return"
   31: 11: . . . . . . . . . . . . . . . ExpressionList (
   31: 11: . . . . . . . . . . . . . . . . Expression (
   31: 11: . . . . . . . . . . . . . . . . . BinaryExpr (
   31: 11: . . . . . . . . . . . . . . . . . . UnaryExpr (
   31: 11: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   31: 11: . . . . . . . . . . . . . . . . . . . . Operand (
   31: 11: . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   31: 12: . . . . . . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . ";"
   32:  3: . . . . . . . . . . . . . . )
   32:  3: . . . . . . . . . . . . . )
   32:  3: . . . . . . . . . . . . )
   32:  3: . . . . . . . . . . . . "}"
   32:  4: . . . . . . . . . . . )
   32:  4: . . . . . . . . . . . ";"
   33:  2: . . . . . . . . . . )
   33:  2: . . . . . . . . . )
   33:  2: . . . . . . . . )
   33:  2: . . . . . . . . "}"
   33:  3: . . . . . . . )
   33:  3: . . . . . . . ";"
   34:  2: . . . . . . )
   34:  2: . . . . . )
   34:  2: . . . . . Statement (
   34:  2: . . . . . . ReturnStmt (
   34:  2: . . . . . . . "return"
   34:  9: . . . . . . . ExpressionList (
   34:  9: . . . . . . . . Expression (
   34:  9: . . . . . . . . . BinaryExpr (
   34:  9: . . . . . . . . . . UnaryExpr (
   34:  9: . . . . . . . . . . . "-"
   34: 10: . . . . . . . . . . . UnaryExpr (
   34: 10: . . . . . . . . . . . . PrimaryExpr (
   34: 10: . . . . . . . . . . . . . Operand (
   34: 10: . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   34: 11: . . . . . . . . . . . . . )
   34: 11: . . . . . . . . . . . . )
   34: 11: . . . . . . . . . . . )
   34: 11: . . . . . . . . . . )
   34: 11: . . . . . . . . . )
   34: 11: . . . . . . . . )
   34: 11: . . . . . . . )
   34: 11: . . . . . . . ";"
   35:  1: . . . . . . )
   35:  1: . . . . . )
   35:  1: . . . . )
   35:  1: . . . . "}"
   35:  2: . . . )
   35:  2: . . . ";"
   37:  1: . . . COMMENT
   38:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Index, ...}
   39:  1: . . )
   39:  1: . )
   39:  1: . Declaration (
   39:  1: . . FunctionDeclOrCall (
   39:  1: . . . "func"
   39:  6: . . . IDENT Include
 /app/parser/parser.go:713: ast.Ident{Name: Include}
   39: 13: . . . Signature (
   39: 13: . . . . Parameters (
   39: 13: . . . . . "("
   39: 14: . . . . . ParameterList (
   39: 14: . . . . . . ParamDeclOrNil (
   39: 14: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   39: 17: . . . . . . . ArrayFieldOrTypeInstance (
   39: 17: . . . . . . . . "["
   39: 18: . . . . . . . . "]"
   39: 19: . . . . . . . . Type (
   39: 19: . . . . . . . . . TypeName (
   39: 19: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   39: 25: . . . . . . . . . )
   39: 25: . . . . . . . . )
   39: 25: . . . . . . . )
   39: 25: . . . . . . )
   39: 25: . . . . . . ","
   39: 27: . . . . . . ParamDeclOrNil (
   39: 27: . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
   39: 29: . . . . . . . Type (
   39: 29: . . . . . . . . TypeName (
   39: 29: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   39: 35: . . . . . . . . )
   39: 35: . . . . . . . )
   39: 35: . . . . . . )
   39: 35: . . . . . )
   39: 35: . . . . . ")"
   39: 37: . . . . )
   39: 37: . . . . Result (
   39: 37: . . . . . TypeName (
   39: 37: . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   39: 42: . . . . . )
   39: 42: . . . . )
   39: 42: . . . )
   39: 42: . . . Body (
   39: 42: . . . . "{"
   40:  2: . . . . StatementList (
   40:  2: . . . . . Statement (
   40:  2: . . . . . . ReturnStmt (
   40:  2: . . . . . . . "return"
   40:  9: . . . . . . . ExpressionList (
   40:  9: . . . . . . . . Expression (
   40:  9: . . . . . . . . . BinaryExpr (
   40:  9: . . . . . . . . . . UnaryExpr (
   40:  9: . . . . . . . . . . . PrimaryExpr (
   40:  9: . . . . . . . . . . . . Operand (
   40:  9: . . . . . . . . . . . . . IDENT Index
 /app/parser/parser.go:713: ast.Ident{Name: Index}
   40: 14: . . . . . . . . . . . . )
   40: 14: . . . . . . . . . . . . CallOrConversion (
   40: 14: . . . . . . . . . . . . . "("
   40: 15: . . . . . . . . . . . . . Expression (
   40: 15: . . . . . . . . . . . . . . BinaryExpr (
   40: 15: . . . . . . . . . . . . . . . UnaryExpr (
   40: 15: . . . . . . . . . . . . . . . . PrimaryExpr (
   40: 15: . . . . . . . . . . . . . . . . . Operand (
   40: 15: . . . . . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   40: 17: . . . . . . . . . . . . . . . . . )
   40: 17: . . . . . . . . . . . . . . . . )
   40: 17: . . . . . . . . . . . . . . . )
   40: 17: . . . . . . . . . . . . . . )
   40: 17: . . . . . . . . . . . . . )
   40: 17: . . . . . . . . . . . . . ","
   40: 19: . . . . . . . . . . . . . Expression (
   40: 19: . . . . . . . . . . . . . . BinaryExpr (
   40: 19: . . . . . . . . . . . . . . . UnaryExpr (
   40: 19: . . . . . . . . . . . . . . . . PrimaryExpr (
   40: 19: . . . . . . . . . . . . . . . . . Operand (
   40: 19: . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
   40: 20: . . . . . . . . . . . . . . . . . )
   40: 20: . . . . . . . . . . . . . . . . )
   40: 20: . . . . . . . . . . . . . . . )
   40: 20: . . . . . . . . . . . . . . )
   40: 20: . . . . . . . . . . . . . )
   40: 20: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Index, Ellipsis: false, isCmd: false}
   40: 22: . . . . . . . . . . . . )
   40: 22: . . . . . . . . . . . )
   40: 22: . . . . . . . . . . )
   40: 22: . . . . . . . . . . ">="
   40: 25: . . . . . . . . . . BinaryExpr (
   40: 25: . . . . . . . . . . . UnaryExpr (
   40: 25: . . . . . . . . . . . . PrimaryExpr (
   40: 25: . . . . . . . . . . . . . Operand (
   40: 25: . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   40: 26: . . . . . . . . . . . . . )
   40: 26: . . . . . . . . . . . . )
   40: 26: . . . . . . . . . . . )
   40: 26: . . . . . . . . . . )
   40: 26: . . . . . . . . . )
   40: 26: . . . . . . . . )
   40: 26: . . . . . . . )
   40: 26: . . . . . . . ";"
   41:  1: . . . . . . )
   41:  1: . . . . . )
   41:  1: . . . . )
   41:  1: . . . . "}"
   41:  2: . . . )
   41:  2: . . . ";"
   43:  1: . . . COMMENT
   44:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Include, ...}
   45:  1: . . )
   45:  1: . )
   45:  1: . Declaration (
   45:  1: . . FunctionDeclOrCall (
   45:  1: . . . "func"
   45:  6: . . . IDENT Any
 /app/parser/parser.go:713: ast.Ident{Name: Any}
   45:  9: . . . Signature (
   45:  9: . . . . Parameters (
   45:  9: . . . . . "("
   45: 10: . . . . . ParameterList (
   45: 10: . . . . . . ParamDeclOrNil (
   45: 10: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   45: 13: . . . . . . . ArrayFieldOrTypeInstance (
   45: 13: . . . . . . . . "["
   45: 14: . . . . . . . . "]"
   45: 15: . . . . . . . . Type (
   45: 15: . . . . . . . . . TypeName (
   45: 15: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   45: 21: . . . . . . . . . )
   45: 21: . . . . . . . . )
   45: 21: . . . . . . . )
   45: 21: . . . . . . )
   45: 21: . . . . . . ","
   45: 23: . . . . . . ParamDeclOrNil (
   45: 23: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   45: 25: . . . . . . . Type (
   45: 25: . . . . . . . . FuncType (
   45: 25: . . . . . . . . . "func"
   45: 29: . . . . . . . . . Signature (
   45: 29: . . . . . . . . . . Parameters (
   45: 29: . . . . . . . . . . . "("
   45: 30: . . . . . . . . . . . ParameterList (
   45: 30: . . . . . . . . . . . . ParamDeclOrNil (
   45: 30: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   45: 36: . . . . . . . . . . . . )
   45: 36: . . . . . . . . . . . )
   45: 36: . . . . . . . . . . . ")"
   45: 38: . . . . . . . . . . )
   45: 38: . . . . . . . . . . Result (
   45: 38: . . . . . . . . . . . TypeName (
   45: 38: . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   45: 42: . . . . . . . . . . . )
   45: 42: . . . . . . . . . . )
   45: 42: . . . . . . . . . )
   45: 42: . . . . . . . . )
   45: 42: . . . . . . . )
   45: 42: . . . . . . )
   45: 42: . . . . . )
   45: 42: . . . . . ")"
   45: 44: . . . . )
   45: 44: . . . . Result (
   45: 44: . . . . . TypeName (
   45: 44: . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   45: 49: . . . . . )
   45: 49: . . . . )
   45: 49: . . . )
   45: 49: . . . Body (
   45: 49: . . . . "{"
   46:  2: . . . . StatementList (
   46:  2: . . . . . Statement (
   46:  2: . . . . . . ForStmt (
   46:  2: . . . . . . . "for"
   46:  6: . . . . . . . SimpleStmt (
   46:  6: . . . . . . . . ExpressionList (
   46:  6: . . . . . . . . . Expression (
   46:  6: . . . . . . . . . . BinaryExpr (
   46:  6: . . . . . . . . . . . UnaryExpr (
   46:  6: . . . . . . . . . . . . PrimaryExpr (
   46:  6: . . . . . . . . . . . . . Operand (
   46:  6: . . . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
   46:  7: . . . . . . . . . . . . . )
   46:  7: . . . . . . . . . . . . )
   46:  7: . . . . . . . . . . . )
   46:  7: . . . . . . . . . . )
   46:  7: . . . . . . . . . )
   46:  7: . . . . . . . . . ","
   46:  9: . . . . . . . . . Expression (
   46:  9: . . . . . . . . . . BinaryExpr (
   46:  9: . . . . . . . . . . . UnaryExpr (
   46:  9: . . . . . . . . . . . . PrimaryExpr (
   46:  9: . . . . . . . . . . . . . Operand (
   46:  9: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   46: 11: . . . . . . . . . . . . . )
   46: 11: . . . . . . . . . . . . )
   46: 11: . . . . . . . . . . . )
   46: 11: . . . . . . . . . . )
   46: 11: . . . . . . . . . )
   46: 11: . . . . . . . . )
   46: 11: . . . . . . . . ":="
   46: 14: . . . . . . . . "range"
   46: 20: . . . . . . . . Expression (
   46: 20: . . . . . . . . . RangeExpr (
   46: 20: . . . . . . . . . . BinaryExpr (
   46: 20: . . . . . . . . . . . UnaryExpr (
   46: 20: . . . . . . . . . . . . PrimaryExpr (
   46: 20: . . . . . . . . . . . . . Operand (
   46: 20: . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   46: 23: . . . . . . . . . . . . . )
   46: 23: . . . . . . . . . . . . )
   46: 23: . . . . . . . . . . . )
   46: 23: . . . . . . . . . . )
   46: 23: . . . . . . . . . )
   46: 23: . . . . . . . . )
   46: 23: . . . . . . . )
   46: 23: . . . . . . . BlockStmt (
   46: 23: . . . . . . . . "{"
   47:  3: . . . . . . . . StatementList (
   47:  3: . . . . . . . . . Statement (
   47:  3: . . . . . . . . . . IfStmt (
   47:  3: . . . . . . . . . . . "if"
   47:  6: . . . . . . . . . . . SimpleStmt (
   47:  6: . . . . . . . . . . . . ExpressionList (
   47:  6: . . . . . . . . . . . . . Expression (
   47:  6: . . . . . . . . . . . . . . BinaryExpr (
   47:  6: . . . . . . . . . . . . . . . UnaryExpr (
   47:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
   47:  6: . . . . . . . . . . . . . . . . . Operand (
   47:  6: . . . . . . . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   47:  7: . . . . . . . . . . . . . . . . . )
   47:  7: . . . . . . . . . . . . . . . . . CallOrConversion (
   47:  7: . . . . . . . . . . . . . . . . . . "("
   47:  8: . . . . . . . . . . . . . . . . . . Expression (
   47:  8: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   47:  8: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   47:  8: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   47:  8: . . . . . . . . . . . . . . . . . . . . . . Operand (
   47:  8: . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   47:  9: . . . . . . . . . . . . . . . . . . . . . . )
   47:  9: . . . . . . . . . . . . . . . . . . . . . )
   47:  9: . . . . . . . . . . . . . . . . . . . . )
   47:  9: . . . . . . . . . . . . . . . . . . . )
   47:  9: . . . . . . . . . . . . . . . . . . )
   47:  9: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: f, Ellipsis: false, isCmd: false}
   47: 11: . . . . . . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . BlockStmt (
   47: 11: . . . . . . . . . . . . "{"
   48:  4: . . . . . . . . . . . . StatementList (
   48:  4: . . . . . . . . . . . . . Statement (
   48:  4: . . . . . . . . . . . . . . ReturnStmt (
   48:  4: . . . . . . . . . . . . . . . "return"
   48: 11: . . . . . . . . . . . . . . . ExpressionList (
   48: 11: . . . . . . . . . . . . . . . . Expression (
   48: 11: . . . . . . . . . . . . . . . . . BinaryExpr (
   48: 11: . . . . . . . . . . . . . . . . . . UnaryExpr (
   48: 11: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   48: 11: . . . . . . . . . . . . . . . . . . . . Operand (
   48: 11: . . . . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   48: 15: . . . . . . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . ";"
   49:  3: . . . . . . . . . . . . . . )
   49:  3: . . . . . . . . . . . . . )
   49:  3: . . . . . . . . . . . . )
   49:  3: . . . . . . . . . . . . "}"
   49:  4: . . . . . . . . . . . )
   49:  4: . . . . . . . . . . . ";"
   50:  2: . . . . . . . . . . )
   50:  2: . . . . . . . . . )
   50:  2: . . . . . . . . )
   50:  2: . . . . . . . . "}"
   50:  3: . . . . . . . )
   50:  3: . . . . . . . ";"
   51:  2: . . . . . . )
   51:  2: . . . . . )
   51:  2: . . . . . Statement (
   51:  2: . . . . . . ReturnStmt (
   51:  2: . . . . . . . "return"
   51:  9: . . . . . . . ExpressionList (
   51:  9: . . . . . . . . Expression (
   51:  9: . . . . . . . . . BinaryExpr (
   51:  9: . . . . . . . . . . UnaryExpr (
   51:  9: . . . . . . . . . . . PrimaryExpr (
   51:  9: . . . . . . . . . . . . Operand (
   51:  9: . . . . . . . . . . . . . IDENT false
 /app/parser/parser.go:713: ast.Ident{Name: false}
   51: 14: . . . . . . . . . . . . )
   51: 14: . . . . . . . . . . . )
   51: 14: . . . . . . . . . . )
   51: 14: . . . . . . . . . )
   51: 14: . . . . . . . . )
   51: 14: . . . . . . . )
   51: 14: . . . . . . . ";"
   52:  1: . . . . . . )
   52:  1: . . . . . )
   52:  1: . . . . )
   52:  1: . . . . "}"
   52:  2: . . . )
   52:  2: . . . ";"
   54:  1: . . . COMMENT
   55:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Any, ...}
   56:  1: . . )
   56:  1: . )
   56:  1: . Declaration (
   56:  1: . . FunctionDeclOrCall (
   56:  1: . . . "func"
   56:  6: . . . IDENT All
 /app/parser/parser.go:713: ast.Ident{Name: All}
   56:  9: . . . Signature (
   56:  9: . . . . Parameters (
   56:  9: . . . . . "("
   56: 10: . . . . . ParameterList (
   56: 10: . . . . . . ParamDeclOrNil (
   56: 10: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   56: 13: . . . . . . . ArrayFieldOrTypeInstance (
   56: 13: . . . . . . . . "["
   56: 14: . . . . . . . . "]"
   56: 15: . . . . . . . . Type (
   56: 15: . . . . . . . . . TypeName (
   56: 15: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   56: 21: . . . . . . . . . )
   56: 21: . . . . . . . . )
   56: 21: . . . . . . . )
   56: 21: . . . . . . )
   56: 21: . . . . . . ","
   56: 23: . . . . . . ParamDeclOrNil (
   56: 23: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   56: 25: . . . . . . . Type (
   56: 25: . . . . . . . . FuncType (
   56: 25: . . . . . . . . . "func"
   56: 29: . . . . . . . . . Signature (
   56: 29: . . . . . . . . . . Parameters (
   56: 29: . . . . . . . . . . . "("
   56: 30: . . . . . . . . . . . ParameterList (
   56: 30: . . . . . . . . . . . . ParamDeclOrNil (
   56: 30: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   56: 36: . . . . . . . . . . . . )
   56: 36: . . . . . . . . . . . )
   56: 36: . . . . . . . . . . . ")"
   56: 38: . . . . . . . . . . )
   56: 38: . . . . . . . . . . Result (
   56: 38: . . . . . . . . . . . TypeName (
   56: 38: . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   56: 42: . . . . . . . . . . . )
   56: 42: . . . . . . . . . . )
   56: 42: . . . . . . . . . )
   56: 42: . . . . . . . . )
   56: 42: . . . . . . . )
   56: 42: . . . . . . )
   56: 42: . . . . . )
   56: 42: . . . . . ")"
   56: 44: . . . . )
   56: 44: . . . . Result (
   56: 44: . . . . . TypeName (
   56: 44: . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   56: 49: . . . . . )
   56: 49: . . . . )
   56: 49: . . . )
   56: 49: . . . Body (
   56: 49: . . . . "{"
   57:  2: . . . . StatementList (
   57:  2: . . . . . Statement (
   57:  2: . . . . . . ForStmt (
   57:  2: . . . . . . . "for"
   57:  6: . . . . . . . SimpleStmt (
   57:  6: . . . . . . . . ExpressionList (
   57:  6: . . . . . . . . . Expression (
   57:  6: . . . . . . . . . . BinaryExpr (
   57:  6: . . . . . . . . . . . UnaryExpr (
   57:  6: . . . . . . . . . . . . PrimaryExpr (
   57:  6: . . . . . . . . . . . . . Operand (
   57:  6: . . . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
   57:  7: . . . . . . . . . . . . . )
   57:  7: . . . . . . . . . . . . )
   57:  7: . . . . . . . . . . . )
   57:  7: . . . . . . . . . . )
   57:  7: . . . . . . . . . )
   57:  7: . . . . . . . . . ","
   57:  9: . . . . . . . . . Expression (
   57:  9: . . . . . . . . . . BinaryExpr (
   57:  9: . . . . . . . . . . . UnaryExpr (
   57:  9: . . . . . . . . . . . . PrimaryExpr (
   57:  9: . . . . . . . . . . . . . Operand (
   57:  9: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   57: 11: . . . . . . . . . . . . . )
   57: 11: . . . . . . . . . . . . )
   57: 11: . . . . . . . . . . . )
   57: 11: . . . . . . . . . . )
   57: 11: . . . . . . . . . )
   57: 11: . . . . . . . . )
   57: 11: . . . . . . . . ":="
   57: 14: . . . . . . . . "range"
   57: 20: . . . . . . . . Expression (
   57: 20: . . . . . . . . . RangeExpr (
   57: 20: . . . . . . . . . . BinaryExpr (
   57: 20: . . . . . . . . . . . UnaryExpr (
   57: 20: . . . . . . . . . . . . PrimaryExpr (
   57: 20: . . . . . . . . . . . . . Operand (
   57: 20: . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   57: 23: . . . . . . . . . . . . . )
   57: 23: . . . . . . . . . . . . )
   57: 23: . . . . . . . . . . . )
   57: 23: . . . . . . . . . . )
   57: 23: . . . . . . . . . )
   57: 23: . . . . . . . . )
   57: 23: . . . . . . . )
   57: 23: . . . . . . . BlockStmt (
   57: 23: . . . . . . . . "{"
   58:  3: . . . . . . . . StatementList (
   58:  3: . . . . . . . . . Statement (
   58:  3: . . . . . . . . . . IfStmt (
   58:  3: . . . . . . . . . . . "if"
   58:  6: . . . . . . . . . . . SimpleStmt (
   58:  6: . . . . . . . . . . . . ExpressionList (
   58:  6: . . . . . . . . . . . . . Expression (
   58:  6: . . . . . . . . . . . . . . BinaryExpr (
   58:  6: . . . . . . . . . . . . . . . UnaryExpr (
   58:  6: . . . . . . . . . . . . . . . . "!"
   58:  7: . . . . . . . . . . . . . . . . UnaryExpr (
   58:  7: . . . . . . . . . . . . . . . . . PrimaryExpr (
   58:  7: . . . . . . . . . . . . . . . . . . Operand (
   58:  7: . . . . . . . . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   58:  8: . . . . . . . . . . . . . . . . . . )
   58:  8: . . . . . . . . . . . . . . . . . . CallOrConversion (
   58:  8: . . . . . . . . . . . . . . . . . . . "("
   58:  9: . . . . . . . . . . . . . . . . . . . Expression (
   58:  9: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   58:  9: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   58:  9: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   58:  9: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   58:  9: . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   58: 10: . . . . . . . . . . . . . . . . . . . . . . . )
   58: 10: . . . . . . . . . . . . . . . . . . . . . . )
   58: 10: . . . . . . . . . . . . . . . . . . . . . )
   58: 10: . . . . . . . . . . . . . . . . . . . . )
   58: 10: . . . . . . . . . . . . . . . . . . . )
   58: 10: . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: f, Ellipsis: false, isCmd: false}
   58: 12: . . . . . . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . BlockStmt (
   58: 12: . . . . . . . . . . . . "{"
   59:  4: . . . . . . . . . . . . StatementList (
   59:  4: . . . . . . . . . . . . . Statement (
   59:  4: . . . . . . . . . . . . . . ReturnStmt (
   59:  4: . . . . . . . . . . . . . . . "return"
   59: 11: . . . . . . . . . . . . . . . ExpressionList (
   59: 11: . . . . . . . . . . . . . . . . Expression (
   59: 11: . . . . . . . . . . . . . . . . . BinaryExpr (
   59: 11: . . . . . . . . . . . . . . . . . . UnaryExpr (
   59: 11: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   59: 11: . . . . . . . . . . . . . . . . . . . . Operand (
   59: 11: . . . . . . . . . . . . . . . . . . . . . IDENT false
 /app/parser/parser.go:713: ast.Ident{Name: false}
   59: 16: . . . . . . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . ";"
   60:  3: . . . . . . . . . . . . . . )
   60:  3: . . . . . . . . . . . . . )
   60:  3: . . . . . . . . . . . . )
   60:  3: . . . . . . . . . . . . "}"
   60:  4: . . . . . . . . . . . )
   60:  4: . . . . . . . . . . . ";"
   61:  2: . . . . . . . . . . )
   61:  2: . . . . . . . . . )
   61:  2: . . . . . . . . )
   61:  2: . . . . . . . . "}"
   61:  3: . . . . . . . )
   61:  3: . . . . . . . ";"
   62:  2: . . . . . . )
   62:  2: . . . . . )
   62:  2: . . . . . Statement (
   62:  2: . . . . . . ReturnStmt (
   62:  2: . . . . . . . "return"
   62:  9: . . . . . . . ExpressionList (
   62:  9: . . . . . . . . Expression (
   62:  9: . . . . . . . . . BinaryExpr (
   62:  9: . . . . . . . . . . UnaryExpr (
   62:  9: . . . . . . . . . . . PrimaryExpr (
   62:  9: . . . . . . . . . . . . Operand (
   62:  9: . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   62: 13: . . . . . . . . . . . . )
   62: 13: . . . . . . . . . . . )
   62: 13: . . . . . . . . . . )
   62: 13: . . . . . . . . . )
   62: 13: . . . . . . . . )
   62: 13: . . . . . . . )
   62: 13: . . . . . . . ";"
   63:  1: . . . . . . )
   63:  1: . . . . . )
   63:  1: . . . . )
   63:  1: . . . . "}"
   63:  2: . . . )
   63:  2: . . . ";"
   65:  1: . . . COMMENT
   66:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: All, ...}
   67:  1: . . )
   67:  1: . )
   67:  1: . Declaration (
   67:  1: . . FunctionDeclOrCall (
   67:  1: . . . "func"
   67:  6: . . . IDENT Filter
 /app/parser/parser.go:713: ast.Ident{Name: Filter}
   67: 12: . . . Signature (
   67: 12: . . . . Parameters (
   67: 12: . . . . . "("
   67: 13: . . . . . ParameterList (
   67: 13: . . . . . . ParamDeclOrNil (
   67: 13: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   67: 16: . . . . . . . ArrayFieldOrTypeInstance (
   67: 16: . . . . . . . . "["
   67: 17: . . . . . . . . "]"
   67: 18: . . . . . . . . Type (
   67: 18: . . . . . . . . . TypeName (
   67: 18: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   67: 24: . . . . . . . . . )
   67: 24: . . . . . . . . )
   67: 24: . . . . . . . )
   67: 24: . . . . . . )
   67: 24: . . . . . . ","
   67: 26: . . . . . . ParamDeclOrNil (
   67: 26: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   67: 28: . . . . . . . Type (
   67: 28: . . . . . . . . FuncType (
   67: 28: . . . . . . . . . "func"
   67: 32: . . . . . . . . . Signature (
   67: 32: . . . . . . . . . . Parameters (
   67: 32: . . . . . . . . . . . "("
   67: 33: . . . . . . . . . . . ParameterList (
   67: 33: . . . . . . . . . . . . ParamDeclOrNil (
   67: 33: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   67: 39: . . . . . . . . . . . . )
   67: 39: . . . . . . . . . . . )
   67: 39: . . . . . . . . . . . ")"
   67: 41: . . . . . . . . . . )
   67: 41: . . . . . . . . . . Result (
   67: 41: . . . . . . . . . . . TypeName (
   67: 41: . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   67: 45: . . . . . . . . . . . )
   67: 45: . . . . . . . . . . )
   67: 45: . . . . . . . . . )
   67: 45: . . . . . . . . )
   67: 45: . . . . . . . )
   67: 45: . . . . . . )
   67: 45: . . . . . )
   67: 45: . . . . . ")"
   67: 47: . . . . )
   67: 47: . . . . Result (
   67: 47: . . . . . ArrayType (
   67: 47: . . . . . . "["
   67: 48: . . . . . . "]"
   67: 49: . . . . . . Type (
   67: 49: . . . . . . . TypeName (
   67: 49: . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   67: 56: . . . . . . . )
   67: 56: . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: string}
   67: 56: . . . . . )
   67: 56: . . . . )
   67: 56: . . . )
   67: 56: . . . Body (
   67: 56: . . . . "{"
   68:  2: . . . . StatementList (
   68:  2: . . . . . Statement (
   68:  2: . . . . . . SimpleStmt (
   68:  2: . . . . . . . ExpressionList (
   68:  2: . . . . . . . . Expression (
   68:  2: . . . . . . . . . BinaryExpr (
   68:  2: . . . . . . . . . . UnaryExpr (
   68:  2: . . . . . . . . . . . PrimaryExpr (
   68:  2: . . . . . . . . . . . . Operand (
   68:  2: . . . . . . . . . . . . . IDENT vsf
 /app/parser/parser.go:713: ast.Ident{Name: vsf}
   68:  6: . . . . . . . . . . . . )
   68:  6: . . . . . . . . . . . )
   68:  6: . . . . . . . . . . )
   68:  6: . . . . . . . . . )
   68:  6: . . . . . . . . )
   68:  6: . . . . . . . )
   68:  6: . . . . . . . ":="
   68:  9: . . . . . . . ExpressionList (
   68:  9: . . . . . . . . Expression (
   68:  9: . . . . . . . . . BinaryExpr (
   68:  9: . . . . . . . . . . UnaryExpr (
   68:  9: . . . . . . . . . . . PrimaryExpr (
   68:  9: . . . . . . . . . . . . Operand (
   68:  9: . . . . . . . . . . . . . IDENT make
 /app/parser/parser.go:713: ast.Ident{Name: make}
   68: 13: . . . . . . . . . . . . )
   68: 13: . . . . . . . . . . . . CallOrConversion (
   68: 13: . . . . . . . . . . . . . "("
   68: 14: . . . . . . . . . . . . . Expression (
   68: 14: . . . . . . . . . . . . . . BinaryExpr (
   68: 14: . . . . . . . . . . . . . . . UnaryExpr (
   68: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   68: 14: . . . . . . . . . . . . . . . . . Operand (
   68: 14: . . . . . . . . . . . . . . . . . . ArrayType (
   68: 14: . . . . . . . . . . . . . . . . . . . "["
   68: 15: . . . . . . . . . . . . . . . . . . . "]"
   68: 16: . . . . . . . . . . . . . . . . . . . TypeName (
   68: 16: . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   68: 22: . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: string}
   68: 22: . . . . . . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . ","
   68: 24: . . . . . . . . . . . . . Expression (
   68: 24: . . . . . . . . . . . . . . BinaryExpr (
   68: 24: . . . . . . . . . . . . . . . UnaryExpr (
   68: 24: . . . . . . . . . . . . . . . . PrimaryExpr (
   68: 24: . . . . . . . . . . . . . . . . . Operand (
   68: 24: . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   68: 25: . . . . . . . . . . . . . . . . . )
   68: 25: . . . . . . . . . . . . . . . . )
   68: 25: . . . . . . . . . . . . . . . )
   68: 25: . . . . . . . . . . . . . . )
   68: 25: . . . . . . . . . . . . . )
   68: 25: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: make, Ellipsis: false, isCmd: false}
   68: 26: . . . . . . . . . . . . )
   68: 26: . . . . . . . . . . . )
   68: 26: . . . . . . . . . . )
   68: 26: . . . . . . . . . )
   68: 26: . . . . . . . . )
   68: 26: . . . . . . . )
   68: 26: . . . . . . )
   68: 26: . . . . . . ";"
   69:  2: . . . . . )
   69:  2: . . . . . Statement (
   69:  2: . . . . . . ForStmt (
   69:  2: . . . . . . . "for"
   69:  6: . . . . . . . SimpleStmt (
   69:  6: . . . . . . . . ExpressionList (
   69:  6: . . . . . . . . . Expression (
   69:  6: . . . . . . . . . . BinaryExpr (
   69:  6: . . . . . . . . . . . UnaryExpr (
   69:  6: . . . . . . . . . . . . PrimaryExpr (
   69:  6: . . . . . . . . . . . . . Operand (
   69:  6: . . . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
   69:  7: . . . . . . . . . . . . . )
   69:  7: . . . . . . . . . . . . )
   69:  7: . . . . . . . . . . . )
   69:  7: . . . . . . . . . . )
   69:  7: . . . . . . . . . )
   69:  7: . . . . . . . . . ","
   69:  9: . . . . . . . . . Expression (
   69:  9: . . . . . . . . . . BinaryExpr (
   69:  9: . . . . . . . . . . . UnaryExpr (
   69:  9: . . . . . . . . . . . . PrimaryExpr (
   69:  9: . . . . . . . . . . . . . Operand (
   69:  9: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   69: 11: . . . . . . . . . . . . . )
   69: 11: . . . . . . . . . . . . )
   69: 11: . . . . . . . . . . . )
   69: 11: . . . . . . . . . . )
   69: 11: . . . . . . . . . )
   69: 11: . . . . . . . . )
   69: 11: . . . . . . . . ":="
   69: 14: . . . . . . . . "range"
   69: 20: . . . . . . . . Expression (
   69: 20: . . . . . . . . . RangeExpr (
   69: 20: . . . . . . . . . . BinaryExpr (
   69: 20: . . . . . . . . . . . UnaryExpr (
   69: 20: . . . . . . . . . . . . PrimaryExpr (
   69: 20: . . . . . . . . . . . . . Operand (
   69: 20: . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   69: 23: . . . . . . . . . . . . . )
   69: 23: . . . . . . . . . . . . )
   69: 23: . . . . . . . . . . . )
   69: 23: . . . . . . . . . . )
   69: 23: . . . . . . . . . )
   69: 23: . . . . . . . . )
   69: 23: . . . . . . . )
   69: 23: . . . . . . . BlockStmt (
   69: 23: . . . . . . . . "{"
   70:  3: . . . . . . . . StatementList (
   70:  3: . . . . . . . . . Statement (
   70:  3: . . . . . . . . . . IfStmt (
   70:  3: . . . . . . . . . . . "if"
   70:  6: . . . . . . . . . . . SimpleStmt (
   70:  6: . . . . . . . . . . . . ExpressionList (
   70:  6: . . . . . . . . . . . . . Expression (
   70:  6: . . . . . . . . . . . . . . BinaryExpr (
   70:  6: . . . . . . . . . . . . . . . UnaryExpr (
   70:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
   70:  6: . . . . . . . . . . . . . . . . . Operand (
   70:  6: . . . . . . . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   70:  7: . . . . . . . . . . . . . . . . . )
   70:  7: . . . . . . . . . . . . . . . . . CallOrConversion (
   70:  7: . . . . . . . . . . . . . . . . . . "("
   70:  8: . . . . . . . . . . . . . . . . . . Expression (
   70:  8: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   70:  8: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   70:  8: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   70:  8: . . . . . . . . . . . . . . . . . . . . . . Operand (
   70:  8: . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   70:  9: . . . . . . . . . . . . . . . . . . . . . . )
   70:  9: . . . . . . . . . . . . . . . . . . . . . )
   70:  9: . . . . . . . . . . . . . . . . . . . . )
   70:  9: . . . . . . . . . . . . . . . . . . . )
   70:  9: . . . . . . . . . . . . . . . . . . )
   70:  9: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: f, Ellipsis: false, isCmd: false}
   70: 11: . . . . . . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . BlockStmt (
   70: 11: . . . . . . . . . . . . "{"
   71:  4: . . . . . . . . . . . . StatementList (
   71:  4: . . . . . . . . . . . . . Statement (
   71:  4: . . . . . . . . . . . . . . SimpleStmt (
   71:  4: . . . . . . . . . . . . . . . ExpressionList (
   71:  4: . . . . . . . . . . . . . . . . Expression (
   71:  4: . . . . . . . . . . . . . . . . . BinaryExpr (
   71:  4: . . . . . . . . . . . . . . . . . . UnaryExpr (
   71:  4: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   71:  4: . . . . . . . . . . . . . . . . . . . . Operand (
   71:  4: . . . . . . . . . . . . . . . . . . . . . IDENT vsf
 /app/parser/parser.go:713: ast.Ident{Name: vsf}
   71:  8: . . . . . . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . "="
   71: 10: . . . . . . . . . . . . . . . ExpressionList (
   71: 10: . . . . . . . . . . . . . . . . Expression (
   71: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
   71: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
   71: 10: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   71: 10: . . . . . . . . . . . . . . . . . . . . Operand (
   71: 10: . . . . . . . . . . . . . . . . . . . . . IDENT append
 /app/parser/parser.go:713: ast.Ident{Name: append}
   71: 16: . . . . . . . . . . . . . . . . . . . . )
   71: 16: . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   71: 16: . . . . . . . . . . . . . . . . . . . . . "("
   71: 17: . . . . . . . . . . . . . . . . . . . . . Expression (
   71: 17: . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   71: 17: . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   71: 17: . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   71: 17: . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   71: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT vsf
 /app/parser/parser.go:713: ast.Ident{Name: vsf}
   71: 20: . . . . . . . . . . . . . . . . . . . . . . . . . )
   71: 20: . . . . . . . . . . . . . . . . . . . . . . . . )
   71: 20: . . . . . . . . . . . . . . . . . . . . . . . )
   71: 20: . . . . . . . . . . . . . . . . . . . . . . )
   71: 20: . . . . . . . . . . . . . . . . . . . . . )
   71: 20: . . . . . . . . . . . . . . . . . . . . . ","
   71: 22: . . . . . . . . . . . . . . . . . . . . . Expression (
   71: 22: . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   71: 22: . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   71: 22: . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   71: 22: . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   71: 22: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   71: 23: . . . . . . . . . . . . . . . . . . . . . . . . . )
   71: 23: . . . . . . . . . . . . . . . . . . . . . . . . )
   71: 23: . . . . . . . . . . . . . . . . . . . . . . . )
   71: 23: . . . . . . . . . . . . . . . . . . . . . . )
   71: 23: . . . . . . . . . . . . . . . . . . . . . )
   71: 23: . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: append, Ellipsis: false, isCmd: false}
   71: 24: . . . . . . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . ";"
   72:  3: . . . . . . . . . . . . . )
   72:  3: . . . . . . . . . . . . )
   72:  3: . . . . . . . . . . . . "}"
   72:  4: . . . . . . . . . . . )
   72:  4: . . . . . . . . . . . ";"
   73:  2: . . . . . . . . . . )
   73:  2: . . . . . . . . . )
   73:  2: . . . . . . . . )
   73:  2: . . . . . . . . "}"
   73:  3: . . . . . . . )
   73:  3: . . . . . . . ";"
   74:  2: . . . . . . )
   74:  2: . . . . . )
   74:  2: . . . . . Statement (
   74:  2: . . . . . . ReturnStmt (
   74:  2: . . . . . . . "return"
   74:  9: . . . . . . . ExpressionList (
   74:  9: . . . . . . . . Expression (
   74:  9: . . . . . . . . . BinaryExpr (
   74:  9: . . . . . . . . . . UnaryExpr (
   74:  9: . . . . . . . . . . . PrimaryExpr (
   74:  9: . . . . . . . . . . . . Operand (
   74:  9: . . . . . . . . . . . . . IDENT vsf
 /app/parser/parser.go:713: ast.Ident{Name: vsf}
   74: 12: . . . . . . . . . . . . )
   74: 12: . . . . . . . . . . . )
   74: 12: . . . . . . . . . . )
   74: 12: . . . . . . . . . )
   74: 12: . . . . . . . . )
   74: 12: . . . . . . . )
   74: 12: . . . . . . . ";"
   75:  1: . . . . . . )
   75:  1: . . . . . )
   75:  1: . . . . )
   75:  1: . . . . "}"
   75:  2: . . . )
   75:  2: . . . ";"
   77:  1: . . . COMMENT
   78:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Filter, ...}
   79:  1: . . )
   79:  1: . )
   79:  1: . Declaration (
   79:  1: . . FunctionDeclOrCall (
   79:  1: . . . "func"
   79:  6: . . . IDENT Map
 /app/parser/parser.go:713: ast.Ident{Name: Map}
   79:  9: . . . Signature (
   79:  9: . . . . Parameters (
   79:  9: . . . . . "("
   79: 10: . . . . . ParameterList (
   79: 10: . . . . . . ParamDeclOrNil (
   79: 10: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   79: 13: . . . . . . . ArrayFieldOrTypeInstance (
   79: 13: . . . . . . . . "["
   79: 14: . . . . . . . . "]"
   79: 15: . . . . . . . . Type (
   79: 15: . . . . . . . . . TypeName (
   79: 15: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   79: 21: . . . . . . . . . )
   79: 21: . . . . . . . . )
   79: 21: . . . . . . . )
   79: 21: . . . . . . )
   79: 21: . . . . . . ","
   79: 23: . . . . . . ParamDeclOrNil (
   79: 23: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   79: 25: . . . . . . . Type (
   79: 25: . . . . . . . . FuncType (
   79: 25: . . . . . . . . . "func"
   79: 29: . . . . . . . . . Signature (
   79: 29: . . . . . . . . . . Parameters (
   79: 29: . . . . . . . . . . . "("
   79: 30: . . . . . . . . . . . ParameterList (
   79: 30: . . . . . . . . . . . . ParamDeclOrNil (
   79: 30: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   79: 36: . . . . . . . . . . . . )
   79: 36: . . . . . . . . . . . )
   79: 36: . . . . . . . . . . . ")"
   79: 38: . . . . . . . . . . )
   79: 38: . . . . . . . . . . Result (
   79: 38: . . . . . . . . . . . TypeName (
   79: 38: . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   79: 44: . . . . . . . . . . . )
   79: 44: . . . . . . . . . . )
   79: 44: . . . . . . . . . )
   79: 44: . . . . . . . . )
   79: 44: . . . . . . . )
   79: 44: . . . . . . )
   79: 44: . . . . . )
   79: 44: . . . . . ")"
   79: 46: . . . . )
   79: 46: . . . . Result (
   79: 46: . . . . . ArrayType (
   79: 46: . . . . . . "["
   79: 47: . . . . . . "]"
   79: 48: . . . . . . Type (
   79: 48: . . . . . . . TypeName (
   79: 48: . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   79: 55: . . . . . . . )
   79: 55: . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: string}
   79: 55: . . . . . )
   79: 55: . . . . )
   79: 55: . . . )
   79: 55: . . . Body (
   79: 55: . . . . "{"
   80:  2: . . . . StatementList (
   80:  2: . . . . . Statement (
   80:  2: . . . . . . SimpleStmt (
   80:  2: . . . . . . . ExpressionList (
   80:  2: . . . . . . . . Expression (
   80:  2: . . . . . . . . . BinaryExpr (
   80:  2: . . . . . . . . . . UnaryExpr (
   80:  2: . . . . . . . . . . . PrimaryExpr (
   80:  2: . . . . . . . . . . . . Operand (
   80:  2: . . . . . . . . . . . . . IDENT vsm
 /app/parser/parser.go:713: ast.Ident{Name: vsm}
   80:  6: . . . . . . . . . . . . )
   80:  6: . . . . . . . . . . . )
   80:  6: . . . . . . . . . . )
   80:  6: . . . . . . . . . )
   80:  6: . . . . . . . . )
   80:  6: . . . . . . . )
   80:  6: . . . . . . . ":="
   80:  9: . . . . . . . ExpressionList (
   80:  9: . . . . . . . . Expression (
   80:  9: . . . . . . . . . BinaryExpr (
   80:  9: . . . . . . . . . . UnaryExpr (
   80:  9: . . . . . . . . . . . PrimaryExpr (
   80:  9: . . . . . . . . . . . . Operand (
   80:  9: . . . . . . . . . . . . . IDENT make
 /app/parser/parser.go:713: ast.Ident{Name: make}
   80: 13: . . . . . . . . . . . . )
   80: 13: . . . . . . . . . . . . CallOrConversion (
   80: 13: . . . . . . . . . . . . . "("
   80: 14: . . . . . . . . . . . . . Expression (
   80: 14: . . . . . . . . . . . . . . BinaryExpr (
   80: 14: . . . . . . . . . . . . . . . UnaryExpr (
   80: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   80: 14: . . . . . . . . . . . . . . . . . Operand (
   80: 14: . . . . . . . . . . . . . . . . . . ArrayType (
   80: 14: . . . . . . . . . . . . . . . . . . . "["
   80: 15: . . . . . . . . . . . . . . . . . . . "]"
   80: 16: . . . . . . . . . . . . . . . . . . . TypeName (
   80: 16: . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   80: 22: . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: string}
   80: 22: . . . . . . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . ","
   80: 24: . . . . . . . . . . . . . Expression (
   80: 24: . . . . . . . . . . . . . . BinaryExpr (
   80: 24: . . . . . . . . . . . . . . . UnaryExpr (
   80: 24: . . . . . . . . . . . . . . . . PrimaryExpr (
   80: 24: . . . . . . . . . . . . . . . . . Operand (
   80: 24: . . . . . . . . . . . . . . . . . . IDENT len
 /app/parser/parser.go:713: ast.Ident{Name: len}
   80: 27: . . . . . . . . . . . . . . . . . )
   80: 27: . . . . . . . . . . . . . . . . . CallOrConversion (
   80: 27: . . . . . . . . . . . . . . . . . . "("
   80: 28: . . . . . . . . . . . . . . . . . . Expression (
   80: 28: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   80: 28: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   80: 28: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   80: 28: . . . . . . . . . . . . . . . . . . . . . . Operand (
   80: 28: . . . . . . . . . . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   80: 30: . . . . . . . . . . . . . . . . . . . . . . )
   80: 30: . . . . . . . . . . . . . . . . . . . . . )
   80: 30: . . . . . . . . . . . . . . . . . . . . )
   80: 30: . . . . . . . . . . . . . . . . . . . )
   80: 30: . . . . . . . . . . . . . . . . . . )
   80: 30: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: len, Ellipsis: false, isCmd: false}
   80: 31: . . . . . . . . . . . . . . . . . )
   80: 31: . . . . . . . . . . . . . . . . )
   80: 31: . . . . . . . . . . . . . . . )
   80: 31: . . . . . . . . . . . . . . )
   80: 31: . . . . . . . . . . . . . )
   80: 31: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: make, Ellipsis: false, isCmd: false}
   80: 32: . . . . . . . . . . . . )
   80: 32: . . . . . . . . . . . )
   80: 32: . . . . . . . . . . )
   80: 32: . . . . . . . . . )
   80: 32: . . . . . . . . )
   80: 32: . . . . . . . )
   80: 32: . . . . . . )
   80: 32: . . . . . . ";"
   81:  2: . . . . . )
   81:  2: . . . . . Statement (
   81:  2: . . . . . . ForStmt (
   81:  2: . . . . . . . "for"
   81:  6: . . . . . . . SimpleStmt (
   81:  6: . . . . . . . . ExpressionList (
   81:  6: . . . . . . . . . Expression (
   81:  6: . . . . . . . . . . BinaryExpr (
   81:  6: . . . . . . . . . . . UnaryExpr (
   81:  6: . . . . . . . . . . . . PrimaryExpr (
   81:  6: . . . . . . . . . . . . . Operand (
   81:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   81:  7: . . . . . . . . . . . . . )
   81:  7: . . . . . . . . . . . . )
   81:  7: . . . . . . . . . . . )
   81:  7: . . . . . . . . . . )
   81:  7: . . . . . . . . . )
   81:  7: . . . . . . . . . ","
   81:  9: . . . . . . . . . Expression (
   81:  9: . . . . . . . . . . BinaryExpr (
   81:  9: . . . . . . . . . . . UnaryExpr (
   81:  9: . . . . . . . . . . . . PrimaryExpr (
   81:  9: . . . . . . . . . . . . . Operand (
   81:  9: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   81: 11: . . . . . . . . . . . . . )
   81: 11: . . . . . . . . . . . . )
   81: 11: . . . . . . . . . . . )
   81: 11: . . . . . . . . . . )
   81: 11: . . . . . . . . . )
   81: 11: . . . . . . . . )
   81: 11: . . . . . . . . ":="
   81: 14: . . . . . . . . "range"
   81: 20: . . . . . . . . Expression (
   81: 20: . . . . . . . . . RangeExpr (
   81: 20: . . . . . . . . . . BinaryExpr (
   81: 20: . . . . . . . . . . . UnaryExpr (
   81: 20: . . . . . . . . . . . . PrimaryExpr (
   81: 20: . . . . . . . . . . . . . Operand (
   81: 20: . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   81: 23: . . . . . . . . . . . . . )
   81: 23: . . . . . . . . . . . . )
   81: 23: . . . . . . . . . . . )
   81: 23: . . . . . . . . . . )
   81: 23: . . . . . . . . . )
   81: 23: . . . . . . . . )
   81: 23: . . . . . . . )
   81: 23: . . . . . . . BlockStmt (
   81: 23: . . . . . . . . "{"
   82:  3: . . . . . . . . StatementList (
   82:  3: . . . . . . . . . Statement (
   82:  3: . . . . . . . . . . SimpleStmt (
   82:  3: . . . . . . . . . . . ExpressionList (
   82:  3: . . . . . . . . . . . . Expression (
   82:  3: . . . . . . . . . . . . . BinaryExpr (
   82:  3: . . . . . . . . . . . . . . UnaryExpr (
   82:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   82:  3: . . . . . . . . . . . . . . . . Operand (
   82:  3: . . . . . . . . . . . . . . . . . IDENT vsm
 /app/parser/parser.go:713: ast.Ident{Name: vsm}
   82:  6: . . . . . . . . . . . . . . . . )
   82:  6: . . . . . . . . . . . . . . . . IndexOrSlice (
   82:  6: . . . . . . . . . . . . . . . . . "["
   82:  7: . . . . . . . . . . . . . . . . . Expression (
   82:  7: . . . . . . . . . . . . . . . . . . BinaryExpr (
   82:  7: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   82:  7: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   82:  7: . . . . . . . . . . . . . . . . . . . . . Operand (
   82:  7: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   82:  8: . . . . . . . . . . . . . . . . . . . . . )
   82:  8: . . . . . . . . . . . . . . . . . . . . )
   82:  8: . . . . . . . . . . . . . . . . . . . )
   82:  8: . . . . . . . . . . . . . . . . . . )
   82:  8: . . . . . . . . . . . . . . . . . )
   82:  8: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: vsm, Index: i}
   82: 10: . . . . . . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . "="
   82: 12: . . . . . . . . . . . ExpressionList (
   82: 12: . . . . . . . . . . . . Expression (
   82: 12: . . . . . . . . . . . . . BinaryExpr (
   82: 12: . . . . . . . . . . . . . . UnaryExpr (
   82: 12: . . . . . . . . . . . . . . . PrimaryExpr (
   82: 12: . . . . . . . . . . . . . . . . Operand (
   82: 12: . . . . . . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   82: 13: . . . . . . . . . . . . . . . . )
   82: 13: . . . . . . . . . . . . . . . . CallOrConversion (
   82: 13: . . . . . . . . . . . . . . . . . "("
   82: 14: . . . . . . . . . . . . . . . . . Expression (
   82: 14: . . . . . . . . . . . . . . . . . . BinaryExpr (
   82: 14: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   82: 14: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   82: 14: . . . . . . . . . . . . . . . . . . . . . Operand (
   82: 14: . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   82: 15: . . . . . . . . . . . . . . . . . . . . . )
   82: 15: . . . . . . . . . . . . . . . . . . . . )
   82: 15: . . . . . . . . . . . . . . . . . . . )
   82: 15: . . . . . . . . . . . . . . . . . . )
   82: 15: . . . . . . . . . . . . . . . . . )
   82: 15: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: f, Ellipsis: false, isCmd: false}
   82: 16: . . . . . . . . . . . . . . . . )
   82: 16: . . . . . . . . . . . . . . . )
   82: 16: . . . . . . . . . . . . . . )
   82: 16: . . . . . . . . . . . . . )
   82: 16: . . . . . . . . . . . . )
   82: 16: . . . . . . . . . . . )
   82: 16: . . . . . . . . . . )
   82: 16: . . . . . . . . . . ";"
   83:  2: . . . . . . . . . )
   83:  2: . . . . . . . . )
   83:  2: . . . . . . . . "}"
   83:  3: . . . . . . . )
   83:  3: . . . . . . . ";"
   84:  2: . . . . . . )
   84:  2: . . . . . )
   84:  2: . . . . . Statement (
   84:  2: . . . . . . ReturnStmt (
   84:  2: . . . . . . . "return"
   84:  9: . . . . . . . ExpressionList (
   84:  9: . . . . . . . . Expression (
   84:  9: . . . . . . . . . BinaryExpr (
   84:  9: . . . . . . . . . . UnaryExpr (
   84:  9: . . . . . . . . . . . PrimaryExpr (
   84:  9: . . . . . . . . . . . . Operand (
   84:  9: . . . . . . . . . . . . . IDENT vsm
 /app/parser/parser.go:713: ast.Ident{Name: vsm}
   84: 12: . . . . . . . . . . . . )
   84: 12: . . . . . . . . . . . )
   84: 12: . . . . . . . . . . )
   84: 12: . . . . . . . . . )
   84: 12: . . . . . . . . )
   84: 12: . . . . . . . )
   84: 12: . . . . . . . ";"
   85:  1: . . . . . . )
   85:  1: . . . . . )
   85:  1: . . . . )
   85:  1: . . . . "}"
   85:  2: . . . )
   85:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Map, ...}
   87:  1: . . )
   87:  1: . )
   87:  1: . Declaration (
   87:  1: . . FunctionDeclOrCall (
   87:  1: . . . "func"
   87:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
   87: 10: . . . Signature (
   87: 10: . . . . Parameters (
   87: 10: . . . . . "("
   87: 11: . . . . . ")"
   87: 13: . . . . )
   87: 13: . . . . Result (
   87: 13: . . . . )
   87: 13: . . . )
   87: 13: . . . Body (
   87: 13: . . . . "{"
   89:  2: . . . . COMMENT
   90:  2: . . . . StatementList (
   90:  2: . . . . . Statement (
   90:  2: . . . . . . GenDecl(var) (
   90:  2: . . . . . . . "var"
   90:  6: . . . . . . . varSpec (
   90:  6: . . . . . . . . IdentList (
   90:  6: . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
   90: 11: . . . . . . . . )
   90: 11: . . . . . . . . "="
   90: 13: . . . . . . . . ExpressionList (
   90: 13: . . . . . . . . . Expression (
   90: 13: . . . . . . . . . . BinaryExpr (
   90: 13: . . . . . . . . . . . UnaryExpr (
   90: 13: . . . . . . . . . . . . PrimaryExpr (
   90: 13: . . . . . . . . . . . . . Operand (
   90: 13: . . . . . . . . . . . . . . ArrayType (
   90: 13: . . . . . . . . . . . . . . . "["
   90: 14: . . . . . . . . . . . . . . . "]"
   90: 15: . . . . . . . . . . . . . . . TypeName (
   90: 15: . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   90: 21: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: string}
   90: 21: . . . . . . . . . . . . . . )
   90: 21: . . . . . . . . . . . . . )
   90: 21: . . . . . . . . . . . . . LiteralValue (
   90: 21: . . . . . . . . . . . . . . "{"
   90: 22: . . . . . . . . . . . . . . ElementList (
   90: 22: . . . . . . . . . . . . . . . Element (
   90: 22: . . . . . . . . . . . . . . . . Element (
   90: 22: . . . . . . . . . . . . . . . . . Expression (
   90: 22: . . . . . . . . . . . . . . . . . . BinaryExpr (
   90: 22: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   90: 22: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   90: 22: . . . . . . . . . . . . . . . . . . . . . Operand (
   90: 22: . . . . . . . . . . . . . . . . . . . . . . STRING "peach"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "peach"}
   90: 29: . . . . . . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . ","
   90: 31: . . . . . . . . . . . . . . . Element (
   90: 31: . . . . . . . . . . . . . . . . Element (
   90: 31: . . . . . . . . . . . . . . . . . Expression (
   90: 31: . . . . . . . . . . . . . . . . . . BinaryExpr (
   90: 31: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   90: 31: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   90: 31: . . . . . . . . . . . . . . . . . . . . . Operand (
   90: 31: . . . . . . . . . . . . . . . . . . . . . . STRING "apple"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "apple"}
   90: 38: . . . . . . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . ","
   90: 40: . . . . . . . . . . . . . . . Element (
   90: 40: . . . . . . . . . . . . . . . . Element (
   90: 40: . . . . . . . . . . . . . . . . . Expression (
   90: 40: . . . . . . . . . . . . . . . . . . BinaryExpr (
   90: 40: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   90: 40: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   90: 40: . . . . . . . . . . . . . . . . . . . . . Operand (
   90: 40: . . . . . . . . . . . . . . . . . . . . . . STRING "pear"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "pear"}
   90: 46: . . . . . . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . ","
   90: 48: . . . . . . . . . . . . . . . Element (
   90: 48: . . . . . . . . . . . . . . . . Element (
   90: 48: . . . . . . . . . . . . . . . . . Expression (
   90: 48: . . . . . . . . . . . . . . . . . . BinaryExpr (
   90: 48: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   90: 48: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   90: 48: . . . . . . . . . . . . . . . . . . . . . Operand (
   90: 48: . . . . . . . . . . . . . . . . . . . . . . STRING "plum"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "plum"}
   90: 54: . . . . . . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . "}"
   90: 55: . . . . . . . . . . . . . )
   90: 55: . . . . . . . . . . . . )
   90: 55: . . . . . . . . . . . )
   90: 55: . . . . . . . . . . )
   90: 55: . . . . . . . . . )
   90: 55: . . . . . . . . )
   90: 55: . . . . . . . . ";"
   92:  2: . . . . . . . )
   92:  2: . . . . . . )
   92:  2: . . . . . )
   92:  2: . . . . . Statement (
   92:  2: . . . . . . SimpleStmt (
   92:  2: . . . . . . . ExpressionList (
   92:  2: . . . . . . . . Expression (
   92:  2: . . . . . . . . . BinaryExpr (
   92:  2: . . . . . . . . . . UnaryExpr (
   92:  2: . . . . . . . . . . . PrimaryExpr (
   92:  2: . . . . . . . . . . . . Operand (
   92:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
   92:  5: . . . . . . . . . . . . )
   92:  5: . . . . . . . . . . . . "."
   92:  6: . . . . . . . . . . . . Selector (
   92:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
   92: 13: . . . . . . . . . . . . )
   92: 13: . . . . . . . . . . . . CallOrConversion (
   92: 13: . . . . . . . . . . . . . "("
   92: 14: . . . . . . . . . . . . . Expression (
   92: 14: . . . . . . . . . . . . . . BinaryExpr (
   92: 14: . . . . . . . . . . . . . . . UnaryExpr (
   92: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   92: 14: . . . . . . . . . . . . . . . . . Operand (
   92: 14: . . . . . . . . . . . . . . . . . . IDENT Index
 /app/parser/parser.go:713: ast.Ident{Name: Index}
   92: 19: . . . . . . . . . . . . . . . . . )
   92: 19: . . . . . . . . . . . . . . . . . CallOrConversion (
   92: 19: . . . . . . . . . . . . . . . . . . "("
   92: 20: . . . . . . . . . . . . . . . . . . Expression (
   92: 20: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   92: 20: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   92: 20: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   92: 20: . . . . . . . . . . . . . . . . . . . . . . Operand (
   92: 20: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
   92: 24: . . . . . . . . . . . . . . . . . . . . . . )
   92: 24: . . . . . . . . . . . . . . . . . . . . . )
   92: 24: . . . . . . . . . . . . . . . . . . . . )
   92: 24: . . . . . . . . . . . . . . . . . . . )
   92: 24: . . . . . . . . . . . . . . . . . . )
   92: 24: . . . . . . . . . . . . . . . . . . ","
   92: 26: . . . . . . . . . . . . . . . . . . Expression (
   92: 26: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   92: 26: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   92: 26: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   92: 26: . . . . . . . . . . . . . . . . . . . . . . Operand (
   92: 26: . . . . . . . . . . . . . . . . . . . . . . . STRING "pear"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "pear"}
   92: 32: . . . . . . . . . . . . . . . . . . . . . . )
   92: 32: . . . . . . . . . . . . . . . . . . . . . )
   92: 32: . . . . . . . . . . . . . . . . . . . . )
   92: 32: . . . . . . . . . . . . . . . . . . . )
   92: 32: . . . . . . . . . . . . . . . . . . )
   92: 32: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Index, Ellipsis: false, isCmd: false}
   92: 33: . . . . . . . . . . . . . . . . . )
   92: 33: . . . . . . . . . . . . . . . . )
   92: 33: . . . . . . . . . . . . . . . )
   92: 33: . . . . . . . . . . . . . . )
   92: 33: . . . . . . . . . . . . . )
   92: 33: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
   92: 34: . . . . . . . . . . . . )
   92: 34: . . . . . . . . . . . )
   92: 34: . . . . . . . . . . )
   92: 34: . . . . . . . . . )
   92: 34: . . . . . . . . )
   92: 34: . . . . . . . )
   92: 34: . . . . . . )
   92: 34: . . . . . . ";"
   94:  2: . . . . . )
   94:  2: . . . . . Statement (
   94:  2: . . . . . . SimpleStmt (
   94:  2: . . . . . . . ExpressionList (
   94:  2: . . . . . . . . Expression (
   94:  2: . . . . . . . . . BinaryExpr (
   94:  2: . . . . . . . . . . UnaryExpr (
   94:  2: . . . . . . . . . . . PrimaryExpr (
   94:  2: . . . . . . . . . . . . Operand (
   94:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
   94:  5: . . . . . . . . . . . . )
   94:  5: . . . . . . . . . . . . "."
   94:  6: . . . . . . . . . . . . Selector (
   94:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
   94: 13: . . . . . . . . . . . . )
   94: 13: . . . . . . . . . . . . CallOrConversion (
   94: 13: . . . . . . . . . . . . . "("
   94: 14: . . . . . . . . . . . . . Expression (
   94: 14: . . . . . . . . . . . . . . BinaryExpr (
   94: 14: . . . . . . . . . . . . . . . UnaryExpr (
   94: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   94: 14: . . . . . . . . . . . . . . . . . Operand (
   94: 14: . . . . . . . . . . . . . . . . . . IDENT Include
 /app/parser/parser.go:713: ast.Ident{Name: Include}
   94: 21: . . . . . . . . . . . . . . . . . )
   94: 21: . . . . . . . . . . . . . . . . . CallOrConversion (
   94: 21: . . . . . . . . . . . . . . . . . . "("
   94: 22: . . . . . . . . . . . . . . . . . . Expression (
   94: 22: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   94: 22: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   94: 22: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   94: 22: . . . . . . . . . . . . . . . . . . . . . . Operand (
   94: 22: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
   94: 26: . . . . . . . . . . . . . . . . . . . . . . )
   94: 26: . . . . . . . . . . . . . . . . . . . . . )
   94: 26: . . . . . . . . . . . . . . . . . . . . )
   94: 26: . . . . . . . . . . . . . . . . . . . )
   94: 26: . . . . . . . . . . . . . . . . . . )
   94: 26: . . . . . . . . . . . . . . . . . . ","
   94: 28: . . . . . . . . . . . . . . . . . . Expression (
   94: 28: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   94: 28: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   94: 28: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   94: 28: . . . . . . . . . . . . . . . . . . . . . . Operand (
   94: 28: . . . . . . . . . . . . . . . . . . . . . . . STRING "grape"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "grape"}
   94: 35: . . . . . . . . . . . . . . . . . . . . . . )
   94: 35: . . . . . . . . . . . . . . . . . . . . . )
   94: 35: . . . . . . . . . . . . . . . . . . . . )
   94: 35: . . . . . . . . . . . . . . . . . . . )
   94: 35: . . . . . . . . . . . . . . . . . . )
   94: 35: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Include, Ellipsis: false, isCmd: false}
   94: 36: . . . . . . . . . . . . . . . . . )
   94: 36: . . . . . . . . . . . . . . . . )
   94: 36: . . . . . . . . . . . . . . . )
   94: 36: . . . . . . . . . . . . . . )
   94: 36: . . . . . . . . . . . . . )
   94: 36: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
   94: 37: . . . . . . . . . . . . )
   94: 37: . . . . . . . . . . . )
   94: 37: . . . . . . . . . . )
   94: 37: . . . . . . . . . )
   94: 37: . . . . . . . . )
   94: 37: . . . . . . . )
   94: 37: . . . . . . )
   94: 37: . . . . . . ";"
   96:  2: . . . . . )
   96:  2: . . . . . Statement (
   96:  2: . . . . . . SimpleStmt (
   96:  2: . . . . . . . ExpressionList (
   96:  2: . . . . . . . . Expression (
   96:  2: . . . . . . . . . BinaryExpr (
   96:  2: . . . . . . . . . . UnaryExpr (
   96:  2: . . . . . . . . . . . PrimaryExpr (
   96:  2: . . . . . . . . . . . . Operand (
   96:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
   96:  5: . . . . . . . . . . . . )
   96:  5: . . . . . . . . . . . . "."
   96:  6: . . . . . . . . . . . . Selector (
   96:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
   96: 13: . . . . . . . . . . . . )
   96: 13: . . . . . . . . . . . . CallOrConversion (
   96: 13: . . . . . . . . . . . . . "("
   96: 14: . . . . . . . . . . . . . Expression (
   96: 14: . . . . . . . . . . . . . . BinaryExpr (
   96: 14: . . . . . . . . . . . . . . . UnaryExpr (
   96: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   96: 14: . . . . . . . . . . . . . . . . . Operand (
   96: 14: . . . . . . . . . . . . . . . . . . IDENT Any
 /app/parser/parser.go:713: ast.Ident{Name: Any}
   96: 17: . . . . . . . . . . . . . . . . . )
   96: 17: . . . . . . . . . . . . . . . . . CallOrConversion (
   96: 17: . . . . . . . . . . . . . . . . . . "("
   96: 18: . . . . . . . . . . . . . . . . . . Expression (
   96: 18: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   96: 18: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   96: 18: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   96: 18: . . . . . . . . . . . . . . . . . . . . . . Operand (
   96: 18: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
   96: 22: . . . . . . . . . . . . . . . . . . . . . . )
   96: 22: . . . . . . . . . . . . . . . . . . . . . )
   96: 22: . . . . . . . . . . . . . . . . . . . . )
   96: 22: . . . . . . . . . . . . . . . . . . . )
   96: 22: . . . . . . . . . . . . . . . . . . )
   96: 22: . . . . . . . . . . . . . . . . . . ","
   96: 24: . . . . . . . . . . . . . . . . . . Expression (
   96: 24: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   96: 24: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   96: 24: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   96: 24: . . . . . . . . . . . . . . . . . . . . . . Operand (
   96: 24: . . . . . . . . . . . . . . . . . . . . . . . FuncTypeOrLit (
   96: 24: . . . . . . . . . . . . . . . . . . . . . . . . FuncType (
   96: 24: . . . . . . . . . . . . . . . . . . . . . . . . . "func"
   96: 28: . . . . . . . . . . . . . . . . . . . . . . . . . Signature (
   96: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . Parameters (
   96: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
   96: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . ParameterList (
   96: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
   96: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   96: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
   96: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
   96: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   96: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
   96: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . Result (
   96: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
   96: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . Body (
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . . "{"
   97:  3: . . . . . . . . . . . . . . . . . . . . . . . . . StatementList (
   97:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . Statement (
   97:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . ReturnStmt (
   97:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "return"
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ExpressionList (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT strings
 /app/parser/parser.go:713: ast.Ident{Name: strings}
   97: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "."
   97: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Selector (
   97: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT HasPrefix
 /app/parser/parser.go:713: ast.Ident{Name: HasPrefix}
   97: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   97: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "p"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "p"}
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strings HasPrefix}, Ellipsis: false, isCmd: false}
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";"
   98:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   98:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   98:  2: . . . . . . . . . . . . . . . . . . . . . . . . . )
   98:  2: . . . . . . . . . . . . . . . . . . . . . . . . . "}"
   98:  3: . . . . . . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Any, Ellipsis: false, isCmd: false}
   98:  4: . . . . . . . . . . . . . . . . . )
   98:  4: . . . . . . . . . . . . . . . . )
   98:  4: . . . . . . . . . . . . . . . )
   98:  4: . . . . . . . . . . . . . . )
   98:  4: . . . . . . . . . . . . . )
   98:  4: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
   98:  5: . . . . . . . . . . . . )
   98:  5: . . . . . . . . . . . )
   98:  5: . . . . . . . . . . )
   98:  5: . . . . . . . . . )
   98:  5: . . . . . . . . )
   98:  5: . . . . . . . )
   98:  5: . . . . . . )
   98:  5: . . . . . . ";"
  100:  2: . . . . . )
  100:  2: . . . . . Statement (
  100:  2: . . . . . . SimpleStmt (
  100:  2: . . . . . . . ExpressionList (
  100:  2: . . . . . . . . Expression (
  100:  2: . . . . . . . . . BinaryExpr (
  100:  2: . . . . . . . . . . UnaryExpr (
  100:  2: . . . . . . . . . . . PrimaryExpr (
  100:  2: . . . . . . . . . . . . Operand (
  100:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
  100:  5: . . . . . . . . . . . . )
  100:  5: . . . . . . . . . . . . "."
  100:  6: . . . . . . . . . . . . Selector (
  100:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
  100: 13: . . . . . . . . . . . . )
  100: 13: . . . . . . . . . . . . CallOrConversion (
  100: 13: . . . . . . . . . . . . . "("
  100: 14: . . . . . . . . . . . . . Expression (
  100: 14: . . . . . . . . . . . . . . BinaryExpr (
  100: 14: . . . . . . . . . . . . . . . UnaryExpr (
  100: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
  100: 14: . . . . . . . . . . . . . . . . . Operand (
  100: 14: . . . . . . . . . . . . . . . . . . IDENT All
 /app/parser/parser.go:713: ast.Ident{Name: All}
  100: 17: . . . . . . . . . . . . . . . . . )
  100: 17: . . . . . . . . . . . . . . . . . CallOrConversion (
  100: 17: . . . . . . . . . . . . . . . . . . "("
  100: 18: . . . . . . . . . . . . . . . . . . Expression (
  100: 18: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  100: 18: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  100: 18: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  100: 18: . . . . . . . . . . . . . . . . . . . . . . Operand (
  100: 18: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
  100: 22: . . . . . . . . . . . . . . . . . . . . . . )
  100: 22: . . . . . . . . . . . . . . . . . . . . . )
  100: 22: . . . . . . . . . . . . . . . . . . . . )
  100: 22: . . . . . . . . . . . . . . . . . . . )
  100: 22: . . . . . . . . . . . . . . . . . . )
  100: 22: . . . . . . . . . . . . . . . . . . ","
  100: 24: . . . . . . . . . . . . . . . . . . Expression (
  100: 24: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  100: 24: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  100: 24: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  100: 24: . . . . . . . . . . . . . . . . . . . . . . Operand (
  100: 24: . . . . . . . . . . . . . . . . . . . . . . . FuncTypeOrLit (
  100: 24: . . . . . . . . . . . . . . . . . . . . . . . . FuncType (
  100: 24: . . . . . . . . . . . . . . . . . . . . . . . . . "func"
  100: 28: . . . . . . . . . . . . . . . . . . . . . . . . . Signature (
  100: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . Parameters (
  100: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
  100: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . ParameterList (
  100: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
  100: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
  100: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
  100: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
  100: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
  100: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
  100: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . Result (
  100: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
  100: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . Body (
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . . "{"
  101:  3: . . . . . . . . . . . . . . . . . . . . . . . . . StatementList (
  101:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . Statement (
  101:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . ReturnStmt (
  101:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "return"
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ExpressionList (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT strings
 /app/parser/parser.go:713: ast.Ident{Name: strings}
  101: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "."
  101: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Selector (
  101: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT HasPrefix
 /app/parser/parser.go:713: ast.Ident{Name: HasPrefix}
  101: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
  101: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "p"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "p"}
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strings HasPrefix}, Ellipsis: false, isCmd: false}
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";"
  102:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  102:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  102:  2: . . . . . . . . . . . . . . . . . . . . . . . . . )
  102:  2: . . . . . . . . . . . . . . . . . . . . . . . . . "}"
  102:  3: . . . . . . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: All, Ellipsis: false, isCmd: false}
  102:  4: . . . . . . . . . . . . . . . . . )
  102:  4: . . . . . . . . . . . . . . . . )
  102:  4: . . . . . . . . . . . . . . . )
  102:  4: . . . . . . . . . . . . . . )
  102:  4: . . . . . . . . . . . . . )
  102:  4: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
  102:  5: . . . . . . . . . . . . )
  102:  5: . . . . . . . . . . . )
  102:  5: . . . . . . . . . . )
  102:  5: . . . . . . . . . )
  102:  5: . . . . . . . . )
  102:  5: . . . . . . . )
  102:  5: . . . . . . )
  102:  5: . . . . . . ";"
  104:  2: . . . . . )
  104:  2: . . . . . Statement (
  104:  2: . . . . . . SimpleStmt (
  104:  2: . . . . . . . ExpressionList (
  104:  2: . . . . . . . . Expression (
  104:  2: . . . . . . . . . BinaryExpr (
  104:  2: . . . . . . . . . . UnaryExpr (
  104:  2: . . . . . . . . . . . PrimaryExpr (
  104:  2: . . . . . . . . . . . . Operand (
  104:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
  104:  5: . . . . . . . . . . . . )
  104:  5: . . . . . . . . . . . . "."
  104:  6: . . . . . . . . . . . . Selector (
  104:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
  104: 13: . . . . . . . . . . . . )
  104: 13: . . . . . . . . . . . . CallOrConversion (
  104: 13: . . . . . . . . . . . . . "("
  104: 14: . . . . . . . . . . . . . Expression (
  104: 14: . . . . . . . . . . . . . . BinaryExpr (
  104: 14: . . . . . . . . . . . . . . . UnaryExpr (
  104: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
  104: 14: . . . . . . . . . . . . . . . . . Operand (
  104: 14: . . . . . . . . . . . . . . . . . . IDENT Filter
 /app/parser/parser.go:713: ast.Ident{Name: Filter}
  104: 20: . . . . . . . . . . . . . . . . . )
  104: 20: . . . . . . . . . . . . . . . . . CallOrConversion (
  104: 20: . . . . . . . . . . . . . . . . . . "("
  104: 21: . . . . . . . . . . . . . . . . . . Expression (
  104: 21: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  104: 21: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  104: 21: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  104: 21: . . . . . . . . . . . . . . . . . . . . . . Operand (
  104: 21: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
  104: 25: . . . . . . . . . . . . . . . . . . . . . . )
  104: 25: . . . . . . . . . . . . . . . . . . . . . )
  104: 25: . . . . . . . . . . . . . . . . . . . . )
  104: 25: . . . . . . . . . . . . . . . . . . . )
  104: 25: . . . . . . . . . . . . . . . . . . )
  104: 25: . . . . . . . . . . . . . . . . . . ","
  104: 27: . . . . . . . . . . . . . . . . . . Expression (
  104: 27: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  104: 27: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  104: 27: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  104: 27: . . . . . . . . . . . . . . . . . . . . . . Operand (
  104: 27: . . . . . . . . . . . . . . . . . . . . . . . FuncTypeOrLit (
  104: 27: . . . . . . . . . . . . . . . . . . . . . . . . FuncType (
  104: 27: . . . . . . . . . . . . . . . . . . . . . . . . . "func"
  104: 31: . . . . . . . . . . . . . . . . . . . . . . . . . Signature (
  104: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . Parameters (
  104: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
  104: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . ParameterList (
  104: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
  104: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
  104: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
  104: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
  104: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
  104: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
  104: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . Result (
  104: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
  104: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . Body (
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . . "{"
  105:  3: . . . . . . . . . . . . . . . . . . . . . . . . . StatementList (
  105:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . Statement (
  105:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . ReturnStmt (
  105:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "return"
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ExpressionList (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT strings
 /app/parser/parser.go:713: ast.Ident{Name: strings}
  105: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "."
  105: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Selector (
  105: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT Contains
 /app/parser/parser.go:713: ast.Ident{Name: Contains}
  105: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
  105: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "e"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "e"}
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strings Contains}, Ellipsis: false, isCmd: false}
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";"
  106:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  106:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  106:  2: . . . . . . . . . . . . . . . . . . . . . . . . . )
  106:  2: . . . . . . . . . . . . . . . . . . . . . . . . . "}"
  106:  3: . . . . . . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Filter, Ellipsis: false, isCmd: false}
  106:  4: . . . . . . . . . . . . . . . . . )
  106:  4: . . . . . . . . . . . . . . . . )
  106:  4: . . . . . . . . . . . . . . . )
  106:  4: . . . . . . . . . . . . . . )
  106:  4: . . . . . . . . . . . . . )
  106:  4: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
  106:  5: . . . . . . . . . . . . )
  106:  5: . . . . . . . . . . . )
  106:  5: . . . . . . . . . . )
  106:  5: . . . . . . . . . )
  106:  5: . . . . . . . . )
  106:  5: . . . . . . . )
  106:  5: . . . . . . )
  106:  5: . . . . . . ";"
  108:  2: . . . . . . COMMENT
  109:  2: . . . . . . COMMENT
  110:  2: . . . . . . COMMENT
  111:  2: . . . . . )
  111:  2: . . . . . Statement (
  111:  2: . . . . . . SimpleStmt (
  111:  2: . . . . . . . ExpressionList (
  111:  2: . . . . . . . . Expression (
  111:  2: . . . . . . . . . BinaryExpr (
  111:  2: . . . . . . . . . . UnaryExpr (
  111:  2: . . . . . . . . . . . PrimaryExpr (
  111:  2: . . . . . . . . . . . . Operand (
  111:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
  111:  5: . . . . . . . . . . . . )
  111:  5: . . . . . . . . . . . . "."
  111:  6: . . . . . . . . . . . . Selector (
  111:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
  111: 13: . . . . . . . . . . . . )
  111: 13: . . . . . . . . . . . . CallOrConversion (
  111: 13: . . . . . . . . . . . . . "("
  111: 14: . . . . . . . . . . . . . Expression (
  111: 14: . . . . . . . . . . . . . . BinaryExpr (
  111: 14: . . . . . . . . . . . . . . . UnaryExpr (
  111: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
  111: 14: . . . . . . . . . . . . . . . . . Operand (
  111: 14: . . . . . . . . . . . . . . . . . . IDENT Map
 /app/parser/parser.go:713: ast.Ident{Name: Map}
  111: 17: . . . . . . . . . . . . . . . . . )
  111: 17: . . . . . . . . . . . . . . . . . CallOrConversion (
  111: 17: . . . . . . . . . . . . . . . . . . "("
  111: 18: . . . . . . . . . . . . . . . . . . Expression (
  111: 18: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  111: 18: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  111: 18: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  111: 18: . . . . . . . . . . . . . . . . . . . . . . Operand (
  111: 18: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
  111: 22: . . . . . . . . . . . . . . . . . . . . . . )
  111: 22: . . . . . . . . . . . . . . . . . . . . . )
  111: 22: . . . . . . . . . . . . . . . . . . . . )
  111: 22: . . . . . . . . . . . . . . . . . . . )
  111: 22: . . . . . . . . . . . . . . . . . . )
  111: 22: . . . . . . . . . . . . . . . . . . ","
  111: 24: . . . . . . . . . . . . . . . . . . Expression (
  111: 24: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  111: 24: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  111: 24: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  111: 24: . . . . . . . . . . . . . . . . . . . . . . Operand (
  111: 24: . . . . . . . . . . . . . . . . . . . . . . . IDENT strings
 /app/parser/parser.go:713: ast.Ident{Name: strings}
  111: 31: . . . . . . . . . . . . . . . . . . . . . . )
  111: 31: . . . . . . . . . . . . . . . . . . . . . . "."
  111: 32: . . . . . . . . . . . . . . . . . . . . . . Selector (
  111: 32: . . . . . . . . . . . . . . . . . . . . . . . IDENT ToUpper
 /app/parser/parser.go:713: ast.Ident{Name: ToUpper}
  111: 39: . . . . . . . . . . . . . . . . . . . . . . )
  111: 39: . . . . . . . . . . . . . . . . . . . . . )
  111: 39: . . . . . . . . . . . . . . . . . . . . )
  111: 39: . . . . . . . . . . . . . . . . . . . )
  111: 39: . . . . . . . . . . . . . . . . . . )
  111: 39: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Map, Ellipsis: false, isCmd: false}
  111: 40: . . . . . . . . . . . . . . . . . )
  111: 40: . . . . . . . . . . . . . . . . )
  111: 40: . . . . . . . . . . . . . . . )
  111: 40: . . . . . . . . . . . . . . )
  111: 40: . . . . . . . . . . . . . )
  111: 40: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
  111: 41: . . . . . . . . . . . . )
  111: 41: . . . . . . . . . . . )
  111: 41: . . . . . . . . . . )
  111: 41: . . . . . . . . . )
  111: 41: . . . . . . . . )
  111: 41: . . . . . . . )
  111: 41: . . . . . . )
  111: 41: . . . . . . ";"
  113:  1: . . . . . )
  113:  1: . . . . )
  113:  1: . . . . "}"
  113:  2: . . . )
  113:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
  113:  3: . . )
  113:  3: . )
  113:  3: )
=== RUN   TestFromTestdata/complit
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/complit
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . "]"
    1:  8: . . . . . . . . . . . . ArrayType (
    1:  8: . . . . . . . . . . . . . "["
    1:  9: . . . . . . . . . . . . . "]"
    1: 10: . . . . . . . . . . . . . TypeName (
    1: 10: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 13: . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: int}
    1: 13: . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{8 <nil> int}}
    1: 13: . . . . . . . . . . . )
    1: 13: . . . . . . . . . . )
    1: 13: . . . . . . . . . . LiteralValue (
    1: 13: . . . . . . . . . . . "{"
    1: 14: . . . . . . . . . . . "}"
    1: 15: . . . . . . . . . . )
    1: 15: . . . . . . . . . )
    1: 15: . . . . . . . . )
    1: 15: . . . . . . . )
    1: 15: . . . . . . )
    1: 15: . . . . . )
    1: 15: . . . . )
    1: 15: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  8: . . . . . . . . . . )
    2:  8: . . . . . . . . . . CallOrConversion (
    2:  8: . . . . . . . . . . . "("
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 10: . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    2: 11: . . . . . . . . . . )
    2: 11: . . . . . . . . . )
    2: 11: . . . . . . . . )
    2: 11: . . . . . . . )
    2: 11: . . . . . . )
    2: 11: . . . . . )
    2: 11: . . . . )
    2: 11: . . . . ";"
    2: 12: . . . )
    2: 12: . . )
    2: 12: . )
    2: 12: )
=== RUN   TestFromTestdata/domainhuh
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/domainhuh
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT form
 /app/parser/parser.go:713: ast.Ident{Name: form}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . )
    1:  6: . . . . . . . . )
    1:  6: . . . . . . . )
    1:  6: . . . . . . )
    1:  6: . . . . . )
    1:  6: . . . . . ":="
    1:  9: . . . . . ExpressionList (
    1:  9: . . . . . . Expression (
    1:  9: . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . IDENT huh
 /app/parser/parser.go:713: ast.Ident{Name: huh}
 /app/parser/parser.go:713: ast.Ident{Name: ret}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
 /app/parser/parser.go:1830: ast.DomainTextLit{Domain: huh, Value: `> &ret, 10
<form>
	<group>
		<select id="Burger" title="Choose your burger">
			<option value="classic" title="Charmburger Classic"/>
			<option value="chickwich" title="Chickwich"/>
			<option value="fishburger" title="Fishburger"/>
			<option value="charmpossible" title="Charmpossible Burger"/>
		</select>
	</group>
</form>
`}
    1: 12: . . . . . . . . . . . STRING `> &ret, 10
<form>
	<group>
		<select id="Burger" title="Choose your burger">
			<option value="classic" title="Charmburger Classic"/>
			<option value="chickwich" title="Chickwich"/>
			<option value="fishburger" title="Fishburger"/>
			<option value="charmpossible" title="Charmpossible Burger"/>
		</select>
	</group>
</form>
`
   12:  2: . . . . . . . . . . )
   12:  2: . . . . . . . . . )
   12:  2: . . . . . . . . )
   12:  2: . . . . . . . )
   12:  2: . . . . . . )
   12:  2: . . . . . )
   12:  2: . . . . )
   12:  2: . . . . ";"
   12:  3: . . . )
   12:  3: . . )
   12:  3: . )
   12:  3: )
=== RUN   TestFromTestdata/domaintext
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/domaintext
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT cl
 /app/parser/parser.go:713: ast.Ident{Name: cl}
    1:  4: . . . . . . . . . . )
    1:  4: . . . . . . . . . )
    1:  4: . . . . . . . . )
    1:  4: . . . . . . . )
    1:  4: . . . . . . )
    1:  4: . . . . . )
    1:  4: . . . . . ":="
    1:  7: . . . . . ExpressionList (
    1:  7: . . . . . . Expression (
    1:  7: . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . IDENT tpl
 /app/parser/parser.go:713: ast.Ident{Name: tpl}
 /app/parser/parser.go:1830: ast.DomainTextLit{Domain: tpl, Value: `
expr = termExpr % ("+" | "-")

termExpr = unaryExpr % ("*" | "/")

unaryExpr = operand | "-" unaryExpr

operand = INT | FLOAT | "(" expr ")"
`}
    1: 10: . . . . . . . . . . . STRING `
expr = termExpr % ("+" | "-")

termExpr = unaryExpr % ("*" | "/")

unaryExpr = operand | "-" unaryExpr

operand = INT | FLOAT | "(" expr ")"
`
    9:  2: . . . . . . . . . . )
    9:  2: . . . . . . . . . . "!"
    9:  3: . . . . . . . . . )
    9:  3: . . . . . . . . )
    9:  3: . . . . . . . )
    9:  3: . . . . . . )
    9:  3: . . . . . )
    9:  3: . . . . )
    9:  3: . . . . ";"
    9:  4: . . . )
    9:  4: . . )
    9:  4: . )
    9:  4: )
=== RUN   TestFromTestdata/domaintpl
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/domaintpl
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT cl
 /app/parser/parser.go:713: ast.Ident{Name: cl}
    1:  4: . . . . . . . . . . )
    1:  4: . . . . . . . . . )
    1:  4: . . . . . . . . )
    1:  4: . . . . . . . )
    1:  4: . . . . . . )
    1:  4: . . . . . )
    1:  4: . . . . . ":="
    1:  7: . . . . . ExpressionList (
    1:  7: . . . . . . Expression (
    1:  7: . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . IDENT tpl
 /app/parser/parser.go:713: ast.Ident{Name: tpl}
 /app/parser/parser.go:713: ast.Ident{Name: ast}
 /app/parser/parser.go:713: ast.Ident{Name: File}
 /app/parser/parser.go:713: ast.Ident{Name: Stmts}
 /app/parser/parser.go:713: ast.Ident{Name: this}
 /app/parser/parser.go:713: ast.Ident{Name: ast}
 /app/parser/parser.go:713: ast.Ident{Name: Stmt}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{ast Stmt}}
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
 /app/parser/parser.go:713: ast.Ident{Name: n}
 /app/parser/parser.go:713: ast.Ident{Name: any}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: any}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:2064: ast.IndexExpr{X: &{n 119 0xc000118660 125}, Index: &{127 INT 0 <nil>}}
 /app/parser/parser.go:713: ast.Ident{Name: ast}
 /app/parser/parser.go:713: ast.Ident{Name: Stmt}
 /app/parser/parser.go:713: ast.Ident{Name: n}
 /app/parser/parser.go:713: ast.Ident{Name: this}
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{0xc000118750 130 0xc00000e4b0 139}, Fors: [0xc000012360]}
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
 /app/parser/parser.go:1830: ast.DomainTextLit{Domain: tpl, Value: `
file = stmts => {
	return &ast.File{
		Stmts: this.([]ast.Stmt),
	}
}

stmts = *(stmt ";") => {
	return [n.([]any)[0].(ast.Stmt) for n in this]
}
`}
    1: 10: . . . . . . . . . . . STRING `
file = stmts => {
	return &ast.File{
		Stmts: this.([]ast.Stmt),
	}
}

stmts = *(stmt ";") => {
	return [n.([]any)[0].(ast.Stmt) for n in this]
}
`
   11:  2: . . . . . . . . . . )
   11:  2: . . . . . . . . . . "!"
   11:  3: . . . . . . . . . )
   11:  3: . . . . . . . . )
   11:  3: . . . . . . . )
   11:  3: . . . . . . )
   11:  3: . . . . . )
   11:  3: . . . . )
   11:  3: . . . . ";"
   11:  4: . . . )
   11:  4: . . )
   11:  4: . )
   11:  4: )
=== RUN   TestFromTestdata/embedded1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/embedded1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(type) (
    1:  1: . . . "type"
    1:  6: . . . TypeSpec (
    1:  6: . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    1:  8: . . . . Type (
    1:  8: . . . . . StructType (
    1:  8: . . . . . . "struct"
    1: 15: . . . . . . "{"
    2:  2: . . . . . . FieldDecl (
    2:  2: . . . . . . . IDENT abc
 /app/parser/parser.go:713: ast.Ident{Name: abc}
    2:  5: . . . . . . . QualifiedIdent (
    2:  5: . . . . . . . . TypeName (
    2:  5: . . . . . . . . . "."
    2:  6: . . . . . . . . . IDENT E
 /app/parser/parser.go:713: ast.Ident{Name: E}
    2:  7: . . . . . . . . )
    2:  7: . . . . . . . )
    2:  7: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . . "}"
    3:  2: . . . . . )
    3:  2: . . . . )
    3:  2: . . . . ";"
    3:  3: . . . )
    3:  3: . . )
    3:  3: . )
    3:  3: )
=== RUN   TestFromTestdata/envop1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/envop1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . EnvExpr (
    1:  6: . . . . . . . . . . . . . . . . . "$"
    1:  7: . . . . . . . . . . . . . . . . . "{"
    1:  8: . . . . . . . . . . . . . . . . . IDENT name
 /app/parser/parser.go:713: ast.Ident{Name: name}
    1: 12: . . . . . . . . . . . . . . . . . "}"
    1: 13: . . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . ","
    1: 15: . . . . . . . . . . . Expression (
    1: 15: . . . . . . . . . . . . BinaryExpr (
    1: 15: . . . . . . . . . . . . . UnaryExpr (
    1: 15: . . . . . . . . . . . . . . PrimaryExpr (
    1: 15: . . . . . . . . . . . . . . . Operand (
    1: 15: . . . . . . . . . . . . . . . . EnvExpr (
    1: 15: . . . . . . . . . . . . . . . . . "$"
    1: 16: . . . . . . . . . . . . . . . . . IDENT id
 /app/parser/parser.go:713: ast.Ident{Name: id}
    1: 18: . . . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    1: 18: . . . . . . . . . . )
    1: 18: . . . . . . . . . )
    1: 18: . . . . . . . . )
    1: 18: . . . . . . . )
    1: 18: . . . . . . )
    1: 18: . . . . . )
    1: 18: . . . . )
    1: 18: . . . . ";"
    1: 19: . . . )
    1: 19: . . )
    1: 19: . )
    1: 19: )
=== RUN   TestFromTestdata/envop2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/envop2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . EnvExpr (
    1:  1: . . . . . . . . . . . . "$"
    1:  2: . . . . . . . . . . . . "{"
    1:  3: . . . . . . . . . . . . IDENT name
 /app/parser/parser.go:713: ast.Ident{Name: name}
    1:  7: . . . . . . . . . . . . "}"
    1:  8: . . . . . . . . . . . )
    1:  8: . . . . . . . . . . )
    1:  8: . . . . . . . . . )
    1:  8: . . . . . . . . )
    1:  8: . . . . . . . )
    1:  8: . . . . . . )
    1:  8: . . . . . )
    1:  8: . . . . )
    1:  8: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    2:  6: . . . . . . . . . . )
    2:  6: . . . . . . . . . . CallOrConversion (
    2:  6: . . . . . . . . . . . Expression (
    2:  6: . . . . . . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . . . . . . LiteralValue (
    2:  6: . . . . . . . . . . . . . . . . . "{"
    2:  7: . . . . . . . . . . . . . . . . . ElementList (
    2:  7: . . . . . . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . . . . . . . Expression (
    2:  7: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  7: . . . . . . . . . . . . . . . . . . . . . . . . . STRING "id"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "id"}
    2: 11: . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . ":"
    2: 13: . . . . . . . . . . . . . . . . . . . Element (
    2: 13: . . . . . . . . . . . . . . . . . . . . Expression (
    2: 13: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . . . . EnvExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . "$"
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT id
 /app/parser/parser.go:713: ast.Ident{Name: id}
    2: 16: . . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . "}"
    2: 17: . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    2: 17: . . . . . . . . . . )
    2: 17: . . . . . . . . . )
    2: 17: . . . . . . . . )
    2: 17: . . . . . . . )
    2: 17: . . . . . . )
    2: 17: . . . . . )
    2: 17: . . . . )
    2: 17: . . . . ";"
    2: 18: . . . )
    2: 18: . . )
    2: 18: . )
    2: 18: )
=== RUN   TestFromTestdata/errwrap1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/errwrap1
    1:  1: File (
    1:  1: . GenDecl(import) (
    1:  1: . . "import"
    1:  8: . . "("
    2:  2: . . ImportSpec (
    2:  2: . . . STRING "strconv"
    2: 11: . . . ";"
    3:  1: . . )
    3:  1: . . ")"
    3:  2: . . ";"
    5:  1: . )
    5:  1: . Declaration (
    5:  1: . . FunctionDeclOrCall (
    5:  1: . . . "func"
    5:  6: . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
    5:  9: . . . Signature (
    5:  9: . . . . Parameters (
    5:  9: . . . . . "("
    5: 10: . . . . . ParameterList (
    5: 10: . . . . . . ParamDeclOrNil (
    5: 10: . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5: 11: . . . . . . )
    5: 11: . . . . . . ","
    5: 13: . . . . . . ParamDeclOrNil (
    5: 13: . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    5: 15: . . . . . . . Type (
    5: 15: . . . . . . . . TypeName (
    5: 15: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 21: . . . . . . . . )
    5: 21: . . . . . . . )
    5: 21: . . . . . . )
    5: 21: . . . . . )
    5: 21: . . . . . ")"
    5: 23: . . . . )
    5: 23: . . . . Result (
    5: 23: . . . . . Parameters (
    5: 23: . . . . . . "("
    5: 24: . . . . . . ParameterList (
    5: 24: . . . . . . . ParamDeclOrNil (
    5: 24: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 27: . . . . . . . )
    5: 27: . . . . . . . ","
    5: 29: . . . . . . . ParamDeclOrNil (
    5: 29: . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
    5: 34: . . . . . . . )
    5: 34: . . . . . . )
    5: 34: . . . . . . ")"
    5: 36: . . . . . )
    5: 36: . . . . )
    5: 36: . . . )
    5: 36: . . . Body (
    5: 36: . . . . "{"
    6:  2: . . . . StatementList (
    6:  2: . . . . . Statement (
    6:  2: . . . . . . ReturnStmt (
    6:  2: . . . . . . . "return"
    6:  9: . . . . . . . ExpressionList (
    6:  9: . . . . . . . . Expression (
    6:  9: . . . . . . . . . BinaryExpr (
    6:  9: . . . . . . . . . . UnaryExpr (
    6:  9: . . . . . . . . . . . PrimaryExpr (
    6:  9: . . . . . . . . . . . . Operand (
    6:  9: . . . . . . . . . . . . . IDENT strconv
 /app/parser/parser.go:713: ast.Ident{Name: strconv}
    6: 16: . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . "."
    6: 17: . . . . . . . . . . . . Selector (
    6: 17: . . . . . . . . . . . . . IDENT Atoi
 /app/parser/parser.go:713: ast.Ident{Name: Atoi}
    6: 21: . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . CallOrConversion (
    6: 21: . . . . . . . . . . . . . "("
    6: 22: . . . . . . . . . . . . . Expression (
    6: 22: . . . . . . . . . . . . . . BinaryExpr (
    6: 22: . . . . . . . . . . . . . . . UnaryExpr (
    6: 22: . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 22: . . . . . . . . . . . . . . . . . Operand (
    6: 22: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 23: . . . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strconv Atoi}, Ellipsis: false, isCmd: false}
    6: 24: . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . "?"
    6: 26: . . . . . . . . . . . )
    6: 26: . . . . . . . . . . )
    6: 26: . . . . . . . . . . "+"
    6: 28: . . . . . . . . . . BinaryExpr (
    6: 28: . . . . . . . . . . . UnaryExpr (
    6: 28: . . . . . . . . . . . . PrimaryExpr (
    6: 28: . . . . . . . . . . . . . Operand (
    6: 28: . . . . . . . . . . . . . . IDENT strconv
 /app/parser/parser.go:713: ast.Ident{Name: strconv}
    6: 35: . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . "."
    6: 36: . . . . . . . . . . . . . Selector (
    6: 36: . . . . . . . . . . . . . . IDENT Atoi
 /app/parser/parser.go:713: ast.Ident{Name: Atoi}
    6: 40: . . . . . . . . . . . . . )
    6: 40: . . . . . . . . . . . . . CallOrConversion (
    6: 40: . . . . . . . . . . . . . . "("
    6: 41: . . . . . . . . . . . . . . Expression (
    6: 41: . . . . . . . . . . . . . . . BinaryExpr (
    6: 41: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 41: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 41: . . . . . . . . . . . . . . . . . . Operand (
    6: 41: . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    6: 42: . . . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strconv Atoi}, Ellipsis: false, isCmd: false}
    6: 43: . . . . . . . . . . . . . )
    6: 43: . . . . . . . . . . . . . "?"
    6: 44: . . . . . . . . . . . . )
    6: 44: . . . . . . . . . . . )
    6: 44: . . . . . . . . . . )
    6: 44: . . . . . . . . . )
    6: 44: . . . . . . . . )
    6: 44: . . . . . . . . ","
    6: 46: . . . . . . . . Expression (
    6: 46: . . . . . . . . . BinaryExpr (
    6: 46: . . . . . . . . . . UnaryExpr (
    6: 46: . . . . . . . . . . . PrimaryExpr (
    6: 46: . . . . . . . . . . . . Operand (
    6: 46: . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    6: 49: . . . . . . . . . . . . )
    6: 49: . . . . . . . . . . . )
    6: 49: . . . . . . . . . . )
    6: 49: . . . . . . . . . )
    6: 49: . . . . . . . . )
    6: 49: . . . . . . . )
    6: 49: . . . . . . . ";"
    7:  1: . . . . . . )
    7:  1: . . . . . )
    7:  1: . . . . )
    7:  1: . . . . "}"
    7:  2: . . . )
    7:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: add, ...}
    9:  1: . . )
    9:  1: . )
    9:  1: . Declaration (
    9:  1: . . FunctionDeclOrCall (
    9:  1: . . . "func"
    9:  6: . . . IDENT addSafe
 /app/parser/parser.go:713: ast.Ident{Name: addSafe}
    9: 13: . . . Signature (
    9: 13: . . . . Parameters (
    9: 13: . . . . . "("
    9: 14: . . . . . ParameterList (
    9: 14: . . . . . . ParamDeclOrNil (
    9: 14: . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    9: 15: . . . . . . )
    9: 15: . . . . . . ","
    9: 17: . . . . . . ParamDeclOrNil (
    9: 17: . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    9: 19: . . . . . . . Type (
    9: 19: . . . . . . . . TypeName (
    9: 19: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    9: 25: . . . . . . . . )
    9: 25: . . . . . . . )
    9: 25: . . . . . . )
    9: 25: . . . . . )
    9: 25: . . . . . ")"
    9: 27: . . . . )
    9: 27: . . . . Result (
    9: 27: . . . . . TypeName (
    9: 27: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 31: . . . . . )
    9: 31: . . . . )
    9: 31: . . . )
    9: 31: . . . Body (
    9: 31: . . . . "{"
   10:  2: . . . . StatementList (
   10:  2: . . . . . Statement (
   10:  2: . . . . . . ReturnStmt (
   10:  2: . . . . . . . "return"
   10:  9: . . . . . . . ExpressionList (
   10:  9: . . . . . . . . Expression (
   10:  9: . . . . . . . . . BinaryExpr (
   10:  9: . . . . . . . . . . UnaryExpr (
   10:  9: . . . . . . . . . . . PrimaryExpr (
   10:  9: . . . . . . . . . . . . Operand (
   10:  9: . . . . . . . . . . . . . IDENT strconv
 /app/parser/parser.go:713: ast.Ident{Name: strconv}
   10: 16: . . . . . . . . . . . . )
   10: 16: . . . . . . . . . . . . "."
   10: 17: . . . . . . . . . . . . Selector (
   10: 17: . . . . . . . . . . . . . IDENT Atoi
 /app/parser/parser.go:713: ast.Ident{Name: Atoi}
   10: 21: . . . . . . . . . . . . )
   10: 21: . . . . . . . . . . . . CallOrConversion (
   10: 21: . . . . . . . . . . . . . "("
   10: 22: . . . . . . . . . . . . . Expression (
   10: 22: . . . . . . . . . . . . . . BinaryExpr (
   10: 22: . . . . . . . . . . . . . . . UnaryExpr (
   10: 22: . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 22: . . . . . . . . . . . . . . . . . Operand (
   10: 22: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   10: 23: . . . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strconv Atoi}, Ellipsis: false, isCmd: false}
   10: 24: . . . . . . . . . . . . )
   10: 24: . . . . . . . . . . . . "?"
   10: 25: . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . ":"
   10: 26: . . . . . . . . . . . UnaryExpr (
   10: 26: . . . . . . . . . . . . PrimaryExpr (
   10: 26: . . . . . . . . . . . . . Operand (
   10: 26: . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   10: 28: . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . )
   10: 28: . . . . . . . . . . )
   10: 28: . . . . . . . . . . "+"
   10: 30: . . . . . . . . . . BinaryExpr (
   10: 30: . . . . . . . . . . . UnaryExpr (
   10: 30: . . . . . . . . . . . . PrimaryExpr (
   10: 30: . . . . . . . . . . . . . Operand (
   10: 30: . . . . . . . . . . . . . . IDENT strconv
 /app/parser/parser.go:713: ast.Ident{Name: strconv}
   10: 37: . . . . . . . . . . . . . )
   10: 37: . . . . . . . . . . . . . "."
   10: 38: . . . . . . . . . . . . . Selector (
   10: 38: . . . . . . . . . . . . . . IDENT Atoi
 /app/parser/parser.go:713: ast.Ident{Name: Atoi}
   10: 42: . . . . . . . . . . . . . )
   10: 42: . . . . . . . . . . . . . CallOrConversion (
   10: 42: . . . . . . . . . . . . . . "("
   10: 43: . . . . . . . . . . . . . . Expression (
   10: 43: . . . . . . . . . . . . . . . BinaryExpr (
   10: 43: . . . . . . . . . . . . . . . . UnaryExpr (
   10: 43: . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 43: . . . . . . . . . . . . . . . . . . Operand (
   10: 43: . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
   10: 44: . . . . . . . . . . . . . . . . . . )
   10: 44: . . . . . . . . . . . . . . . . . )
   10: 44: . . . . . . . . . . . . . . . . )
   10: 44: . . . . . . . . . . . . . . . )
   10: 44: . . . . . . . . . . . . . . )
   10: 44: . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strconv Atoi}, Ellipsis: false, isCmd: false}
   10: 45: . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . "?"
   10: 46: . . . . . . . . . . . . )
   10: 46: . . . . . . . . . . . . ":"
   10: 47: . . . . . . . . . . . . UnaryExpr (
   10: 47: . . . . . . . . . . . . . PrimaryExpr (
   10: 47: . . . . . . . . . . . . . . Operand (
   10: 47: . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   10: 48: . . . . . . . . . . . . . . )
   10: 48: . . . . . . . . . . . . . )
   10: 48: . . . . . . . . . . . . )
   10: 48: . . . . . . . . . . . )
   10: 48: . . . . . . . . . . )
   10: 48: . . . . . . . . . )
   10: 48: . . . . . . . . )
   10: 48: . . . . . . . )
   10: 48: . . . . . . . ";"
   11:  1: . . . . . . )
   11:  1: . . . . . )
   11:  1: . . . . )
   11:  1: . . . . "}"
   11:  2: . . . )
   11:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: addSafe, ...}
   13:  1: . . )
   13:  1: . )
   13:  1: . Declaration (
   13:  1: . . StatementList (
   13:  1: . . . Statement (
   13:  1: . . . . SimpleStmt (
   13:  1: . . . . . ExpressionList (
   13:  1: . . . . . . Expression (
   13:  1: . . . . . . . BinaryExpr (
   13:  1: . . . . . . . . UnaryExpr (
   13:  1: . . . . . . . . . PrimaryExpr (
   13:  1: . . . . . . . . . . Operand (
   13:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   13:  8: . . . . . . . . . . )
   13:  8: . . . . . . . . . . CallOrConversion (
   13:  8: . . . . . . . . . . . "("
   13:  9: . . . . . . . . . . . Expression (
   13:  9: . . . . . . . . . . . . BinaryExpr (
   13:  9: . . . . . . . . . . . . . UnaryExpr (
   13:  9: . . . . . . . . . . . . . . PrimaryExpr (
   13:  9: . . . . . . . . . . . . . . . Operand (
   13:  9: . . . . . . . . . . . . . . . . STRING `add("100", "23"):`
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: `add("100", "23"):`}
   13: 28: . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . ","
   13: 30: . . . . . . . . . . . Expression (
   13: 30: . . . . . . . . . . . . BinaryExpr (
   13: 30: . . . . . . . . . . . . . UnaryExpr (
   13: 30: . . . . . . . . . . . . . . PrimaryExpr (
   13: 30: . . . . . . . . . . . . . . . Operand (
   13: 30: . . . . . . . . . . . . . . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
   13: 33: . . . . . . . . . . . . . . . )
   13: 33: . . . . . . . . . . . . . . . CallOrConversion (
   13: 33: . . . . . . . . . . . . . . . . "("
   13: 34: . . . . . . . . . . . . . . . . Expression (
   13: 34: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 34: . . . . . . . . . . . . . . . . . . . . . STRING "100"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "100"}
   13: 39: . . . . . . . . . . . . . . . . . . . . )
   13: 39: . . . . . . . . . . . . . . . . . . . )
   13: 39: . . . . . . . . . . . . . . . . . . )
   13: 39: . . . . . . . . . . . . . . . . . )
   13: 39: . . . . . . . . . . . . . . . . )
   13: 39: . . . . . . . . . . . . . . . . ","
   13: 41: . . . . . . . . . . . . . . . . Expression (
   13: 41: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 41: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 41: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 41: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 41: . . . . . . . . . . . . . . . . . . . . . STRING "23"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "23"}
   13: 45: . . . . . . . . . . . . . . . . . . . . )
   13: 45: . . . . . . . . . . . . . . . . . . . )
   13: 45: . . . . . . . . . . . . . . . . . . )
   13: 45: . . . . . . . . . . . . . . . . . )
   13: 45: . . . . . . . . . . . . . . . . )
   13: 45: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: add, Ellipsis: false, isCmd: false}
   13: 46: . . . . . . . . . . . . . . . )
   13: 46: . . . . . . . . . . . . . . . "!"
   13: 47: . . . . . . . . . . . . . . )
   13: 47: . . . . . . . . . . . . . )
   13: 47: . . . . . . . . . . . . )
   13: 47: . . . . . . . . . . . )
   13: 47: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   13: 48: . . . . . . . . . . )
   13: 48: . . . . . . . . . )
   13: 48: . . . . . . . . )
   13: 48: . . . . . . . )
   13: 48: . . . . . . )
   13: 48: . . . . . )
   13: 48: . . . . )
   13: 48: . . . . ";"
   15:  1: . . . )
   15:  1: . . . Statement (
   15:  1: . . . . SimpleStmt (
   15:  1: . . . . . ExpressionList (
   15:  1: . . . . . . Expression (
   15:  1: . . . . . . . BinaryExpr (
   15:  1: . . . . . . . . UnaryExpr (
   15:  1: . . . . . . . . . PrimaryExpr (
   15:  1: . . . . . . . . . . Operand (
   15:  1: . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   15:  4: . . . . . . . . . . )
   15:  4: . . . . . . . . . )
   15:  4: . . . . . . . . )
   15:  4: . . . . . . . )
   15:  4: . . . . . . )
   15:  4: . . . . . . ","
   15:  6: . . . . . . Expression (
   15:  6: . . . . . . . BinaryExpr (
   15:  6: . . . . . . . . UnaryExpr (
   15:  6: . . . . . . . . . PrimaryExpr (
   15:  6: . . . . . . . . . . Operand (
   15:  6: . . . . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   15: 10: . . . . . . . . . . )
   15: 10: . . . . . . . . . )
   15: 10: . . . . . . . . )
   15: 10: . . . . . . . )
   15: 10: . . . . . . )
   15: 10: . . . . . )
   15: 10: . . . . . ":="
   15: 13: . . . . . ExpressionList (
   15: 13: . . . . . . Expression (
   15: 13: . . . . . . . BinaryExpr (
   15: 13: . . . . . . . . UnaryExpr (
   15: 13: . . . . . . . . . PrimaryExpr (
   15: 13: . . . . . . . . . . Operand (
   15: 13: . . . . . . . . . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
   15: 16: . . . . . . . . . . )
   15: 16: . . . . . . . . . . CallOrConversion (
   15: 16: . . . . . . . . . . . "("
   15: 17: . . . . . . . . . . . Expression (
   15: 17: . . . . . . . . . . . . BinaryExpr (
   15: 17: . . . . . . . . . . . . . UnaryExpr (
   15: 17: . . . . . . . . . . . . . . PrimaryExpr (
   15: 17: . . . . . . . . . . . . . . . Operand (
   15: 17: . . . . . . . . . . . . . . . . STRING "10"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "10"}
   15: 21: . . . . . . . . . . . . . . . )
   15: 21: . . . . . . . . . . . . . . )
   15: 21: . . . . . . . . . . . . . )
   15: 21: . . . . . . . . . . . . )
   15: 21: . . . . . . . . . . . )
   15: 21: . . . . . . . . . . . ","
   15: 23: . . . . . . . . . . . Expression (
   15: 23: . . . . . . . . . . . . BinaryExpr (
   15: 23: . . . . . . . . . . . . . UnaryExpr (
   15: 23: . . . . . . . . . . . . . . PrimaryExpr (
   15: 23: . . . . . . . . . . . . . . . Operand (
   15: 23: . . . . . . . . . . . . . . . . STRING "abc"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "abc"}
   15: 28: . . . . . . . . . . . . . . . )
   15: 28: . . . . . . . . . . . . . . )
   15: 28: . . . . . . . . . . . . . )
   15: 28: . . . . . . . . . . . . )
   15: 28: . . . . . . . . . . . )
   15: 28: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: add, Ellipsis: false, isCmd: false}
   15: 29: . . . . . . . . . . )
   15: 29: . . . . . . . . . )
   15: 29: . . . . . . . . )
   15: 29: . . . . . . . )
   15: 29: . . . . . . )
   15: 29: . . . . . )
   15: 29: . . . . )
   15: 29: . . . . ";"
   16:  1: . . . )
   16:  1: . . . Statement (
   16:  1: . . . . SimpleStmt (
   16:  1: . . . . . ExpressionList (
   16:  1: . . . . . . Expression (
   16:  1: . . . . . . . BinaryExpr (
   16:  1: . . . . . . . . UnaryExpr (
   16:  1: . . . . . . . . . PrimaryExpr (
   16:  1: . . . . . . . . . . Operand (
   16:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   16:  8: . . . . . . . . . . )
   16:  8: . . . . . . . . . . CallOrConversion (
   16:  8: . . . . . . . . . . . "("
   16:  9: . . . . . . . . . . . Expression (
   16:  9: . . . . . . . . . . . . BinaryExpr (
   16:  9: . . . . . . . . . . . . . UnaryExpr (
   16:  9: . . . . . . . . . . . . . . PrimaryExpr (
   16:  9: . . . . . . . . . . . . . . . Operand (
   16:  9: . . . . . . . . . . . . . . . . STRING `add("10", "abc"):`
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: `add("10", "abc"):`}
   16: 28: . . . . . . . . . . . . . . . )
   16: 28: . . . . . . . . . . . . . . )
   16: 28: . . . . . . . . . . . . . )
   16: 28: . . . . . . . . . . . . )
   16: 28: . . . . . . . . . . . )
   16: 28: . . . . . . . . . . . ","
   16: 30: . . . . . . . . . . . Expression (
   16: 30: . . . . . . . . . . . . BinaryExpr (
   16: 30: . . . . . . . . . . . . . UnaryExpr (
   16: 30: . . . . . . . . . . . . . . PrimaryExpr (
   16: 30: . . . . . . . . . . . . . . . Operand (
   16: 30: . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   16: 33: . . . . . . . . . . . . . . . )
   16: 33: . . . . . . . . . . . . . . )
   16: 33: . . . . . . . . . . . . . )
   16: 33: . . . . . . . . . . . . )
   16: 33: . . . . . . . . . . . )
   16: 33: . . . . . . . . . . . ","
   16: 35: . . . . . . . . . . . Expression (
   16: 35: . . . . . . . . . . . . BinaryExpr (
   16: 35: . . . . . . . . . . . . . UnaryExpr (
   16: 35: . . . . . . . . . . . . . . PrimaryExpr (
   16: 35: . . . . . . . . . . . . . . . Operand (
   16: 35: . . . . . . . . . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   16: 38: . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   16: 39: . . . . . . . . . . )
   16: 39: . . . . . . . . . )
   16: 39: . . . . . . . . )
   16: 39: . . . . . . . )
   16: 39: . . . . . . )
   16: 39: . . . . . )
   16: 39: . . . . )
   16: 39: . . . . ";"
   18:  1: . . . )
   18:  1: . . . Statement (
   18:  1: . . . . SimpleStmt (
   18:  1: . . . . . ExpressionList (
   18:  1: . . . . . . Expression (
   18:  1: . . . . . . . BinaryExpr (
   18:  1: . . . . . . . . UnaryExpr (
   18:  1: . . . . . . . . . PrimaryExpr (
   18:  1: . . . . . . . . . . Operand (
   18:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   18:  8: . . . . . . . . . . )
   18:  8: . . . . . . . . . . CallOrConversion (
   18:  8: . . . . . . . . . . . "("
   18:  9: . . . . . . . . . . . Expression (
   18:  9: . . . . . . . . . . . . BinaryExpr (
   18:  9: . . . . . . . . . . . . . UnaryExpr (
   18:  9: . . . . . . . . . . . . . . PrimaryExpr (
   18:  9: . . . . . . . . . . . . . . . Operand (
   18:  9: . . . . . . . . . . . . . . . . STRING `addSafe("10", "abc"):`
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: `addSafe("10", "abc"):`}
   18: 32: . . . . . . . . . . . . . . . )
   18: 32: . . . . . . . . . . . . . . )
   18: 32: . . . . . . . . . . . . . )
   18: 32: . . . . . . . . . . . . )
   18: 32: . . . . . . . . . . . )
   18: 32: . . . . . . . . . . . ","
   18: 34: . . . . . . . . . . . Expression (
   18: 34: . . . . . . . . . . . . BinaryExpr (
   18: 34: . . . . . . . . . . . . . UnaryExpr (
   18: 34: . . . . . . . . . . . . . . PrimaryExpr (
   18: 34: . . . . . . . . . . . . . . . Operand (
   18: 34: . . . . . . . . . . . . . . . . IDENT addSafe
 /app/parser/parser.go:713: ast.Ident{Name: addSafe}
   18: 41: . . . . . . . . . . . . . . . )
   18: 41: . . . . . . . . . . . . . . . CallOrConversion (
   18: 41: . . . . . . . . . . . . . . . . "("
   18: 42: . . . . . . . . . . . . . . . . Expression (
   18: 42: . . . . . . . . . . . . . . . . . BinaryExpr (
   18: 42: . . . . . . . . . . . . . . . . . . UnaryExpr (
   18: 42: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   18: 42: . . . . . . . . . . . . . . . . . . . . Operand (
   18: 42: . . . . . . . . . . . . . . . . . . . . . STRING "10"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "10"}
   18: 46: . . . . . . . . . . . . . . . . . . . . )
   18: 46: . . . . . . . . . . . . . . . . . . . )
   18: 46: . . . . . . . . . . . . . . . . . . )
   18: 46: . . . . . . . . . . . . . . . . . )
   18: 46: . . . . . . . . . . . . . . . . )
   18: 46: . . . . . . . . . . . . . . . . ","
   18: 48: . . . . . . . . . . . . . . . . Expression (
   18: 48: . . . . . . . . . . . . . . . . . BinaryExpr (
   18: 48: . . . . . . . . . . . . . . . . . . UnaryExpr (
   18: 48: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   18: 48: . . . . . . . . . . . . . . . . . . . . Operand (
   18: 48: . . . . . . . . . . . . . . . . . . . . . STRING "abc"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "abc"}
   18: 53: . . . . . . . . . . . . . . . . . . . . )
   18: 53: . . . . . . . . . . . . . . . . . . . )
   18: 53: . . . . . . . . . . . . . . . . . . )
   18: 53: . . . . . . . . . . . . . . . . . )
   18: 53: . . . . . . . . . . . . . . . . )
   18: 53: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: addSafe, Ellipsis: false, isCmd: false}
   18: 54: . . . . . . . . . . . . . . . )
   18: 54: . . . . . . . . . . . . . . )
   18: 54: . . . . . . . . . . . . . )
   18: 54: . . . . . . . . . . . . )
   18: 54: . . . . . . . . . . . )
   18: 54: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   18: 55: . . . . . . . . . . )
   18: 55: . . . . . . . . . )
   18: 55: . . . . . . . . )
   18: 55: . . . . . . . )
   18: 55: . . . . . . )
   18: 55: . . . . . )
   18: 55: . . . . )
   18: 55: . . . . ";"
   18: 56: . . . )
   18: 56: . . )
   18: 56: . )
   18: 56: )
=== RUN   TestFromTestdata/errwrap2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/errwrap2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT neg
 /app/parser/parser.go:713: ast.Ident{Name: neg}
    1:  9: . . . Signature (
    1:  9: . . . . Parameters (
    1:  9: . . . . . "("
    1: 10: . . . . . ParameterList (
    1: 10: . . . . . . ParamDeclOrNil (
    1: 10: . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 12: . . . . . . . Type (
    1: 12: . . . . . . . . TypeName (
    1: 12: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    1: 18: . . . . . . . . )
    1: 18: . . . . . . . )
    1: 18: . . . . . . )
    1: 18: . . . . . )
    1: 18: . . . . . ")"
    1: 20: . . . . )
    1: 20: . . . . Result (
    1: 20: . . . . . Parameters (
    1: 20: . . . . . . "("
    1: 21: . . . . . . ParameterList (
    1: 21: . . . . . . . ParamDeclOrNil (
    1: 21: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 24: . . . . . . . )
    1: 24: . . . . . . . ","
    1: 26: . . . . . . . ParamDeclOrNil (
    1: 26: . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
    1: 31: . . . . . . . )
    1: 31: . . . . . . )
    1: 31: . . . . . . ")"
    1: 33: . . . . . )
    1: 33: . . . . )
    1: 33: . . . )
    1: 33: . . . Body (
    1: 33: . . . . "{"
    2:  2: . . . . StatementList (
    2:  2: . . . . . Statement (
    2:  2: . . . . . . ReturnStmt (
    2:  2: . . . . . . . "return"
    2:  9: . . . . . . . ExpressionList (
    2:  9: . . . . . . . . Expression (
    2:  9: . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . "-"
    2: 10: . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . PrimaryExpr (
    2: 10: . . . . . . . . . . . . . Operand (
    2: 10: . . . . . . . . . . . . . . IDENT atoi
 /app/parser/parser.go:713: ast.Ident{Name: atoi}
    2: 14: . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . CallOrConversion (
    2: 14: . . . . . . . . . . . . . . "("
    2: 15: . . . . . . . . . . . . . . Expression (
    2: 15: . . . . . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 16: . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: atoi, Ellipsis: false, isCmd: false}
    2: 17: . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . "?"
    2: 18: . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . )
    2: 18: . . . . . . . . . . )
    2: 18: . . . . . . . . . )
    2: 18: . . . . . . . . )
    2: 18: . . . . . . . . ","
    2: 20: . . . . . . . . Expression (
    2: 20: . . . . . . . . . BinaryExpr (
    2: 20: . . . . . . . . . . UnaryExpr (
    2: 20: . . . . . . . . . . . PrimaryExpr (
    2: 20: . . . . . . . . . . . . Operand (
    2: 20: . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    2: 23: . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . )
    2: 23: . . . . . . . . . . )
    2: 23: . . . . . . . . . )
    2: 23: . . . . . . . . )
    2: 23: . . . . . . . )
    2: 23: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . )
    3:  1: . . . . )
    3:  1: . . . . "}"
    3:  2: . . . )
    3:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: neg, ...}
    3:  3: . . )
    3:  3: . )
    3:  3: )
=== RUN   TestFromTestdata/errwrap3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/errwrap3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT mkdir
 /app/parser/parser.go:713: ast.Ident{Name: mkdir}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . "!"
    1:  8: . . . . . . . . . . CallOrConversion (
    1:  8: . . . . . . . . . . . Expression (
    1:  8: . . . . . . . . . . . . BinaryExpr (
    1:  8: . . . . . . . . . . . . . UnaryExpr (
    1:  8: . . . . . . . . . . . . . . PrimaryExpr (
    1:  8: . . . . . . . . . . . . . . . Operand (
    1:  8: . . . . . . . . . . . . . . . . STRING "foo"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "foo"}
    1: 13: . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{mkdir ! 6 <nil>}, Ellipsis: false, isCmd: true}
    1: 13: . . . . . . . . . . )
    1: 13: . . . . . . . . . )
    1: 13: . . . . . . . . )
    1: 13: . . . . . . . )
    1: 13: . . . . . . )
    1: 13: . . . . . )
    1: 13: . . . . )
    1: 13: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    2: 12: . . . . . . . . . . . . . . . )
    2: 12: . . . . . . . . . . . . . . . CallOrConversion (
    2: 12: . . . . . . . . . . . . . . . . "("
    2: 13: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    2: 14: . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . "!"
    2: 15: . . . . . . . . . . . . . . . "."
    2: 16: . . . . . . . . . . . . . . . Selector (
    2: 16: . . . . . . . . . . . . . . . . IDENT fields
 /app/parser/parser.go:713: ast.Ident{Name: fields}
    2: 22: . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    2: 22: . . . . . . . . . . )
    2: 22: . . . . . . . . . )
    2: 22: . . . . . . . . )
    2: 22: . . . . . . . )
    2: 22: . . . . . . )
    2: 22: . . . . . )
    2: 22: . . . . )
    2: 22: . . . . ";"
    2: 23: . . . )
    2: 23: . . )
    2: 23: . )
    2: 23: )
=== RUN   TestFromTestdata/exists
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/exists
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . ","
    1: 10: . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ","
    1: 13: . . . . . . . . . . . . Expression (
    1: 13: . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . ","
    1: 16: . . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . ","
    1: 19: . . . . . . . . . . . . Expression (
    1: 19: . . . . . . . . . . . . . BinaryExpr (
    1: 19: . . . . . . . . . . . . . . UnaryExpr (
    1: 19: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 19: . . . . . . . . . . . . . . . . Operand (
    1: 19: . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    1: 20: . . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . ","
    1: 22: . . . . . . . . . . . . Expression (
    1: 22: . . . . . . . . . . . . . BinaryExpr (
    1: 22: . . . . . . . . . . . . . . UnaryExpr (
    1: 22: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 22: . . . . . . . . . . . . . . . . Operand (
    1: 22: . . . . . . . . . . . . . . . . . INT 19
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 19}
    1: 24: . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . "]"
    1: 25: . . . . . . . . . . . )
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT hasEven
 /app/parser/parser.go:713: ast.Ident{Name: hasEven}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . )
    2:  9: . . . . . . . . )
    2:  9: . . . . . . . )
    2:  9: . . . . . . )
    2:  9: . . . . . )
    2:  9: . . . . . ":="
    2: 12: . . . . . ExpressionList (
    2: 12: . . . . . . Expression (
    2: 12: . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . LiteralValue (
    2: 12: . . . . . . . . . . . . "{"
    2: 13: . . . . . . . . . . . . ElementList (
    2: 13: . . . . . . . . . . . . . ForPhrase (
    2: 13: . . . . . . . . . . . . . . "for"
    2: 17: . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 19: . . . . . . . . . . . . . . IDENT in
    2: 22: . . . . . . . . . . . . . . Expression (
    2: 22: . . . . . . . . . . . . . . . RangeExpr (
    2: 22: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . . Operand (
    2: 22: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 24: . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . "if"
    2: 27: . . . . . . . . . . . . . . SimpleStmt (
    2: 27: . . . . . . . . . . . . . . . ExpressionList (
    2: 27: . . . . . . . . . . . . . . . . Expression (
    2: 27: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 27: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 28: . . . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . "%"
    2: 29: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 29: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 31: . . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . "=="
    2: 34: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 34: . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    2: 35: . . . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . "}"
    2: 36: . . . . . . . . . . . )
    2: 36: . . . . . . . . . . )
    2: 36: . . . . . . . . . )
    2: 36: . . . . . . . . )
    2: 36: . . . . . . . )
    2: 36: . . . . . . )
    2: 36: . . . . . )
    2: 36: . . . . )
    2: 36: . . . . ";"
    2: 37: . . . )
    2: 37: . . )
    2: 37: . )
    2: 37: )
=== RUN   TestFromTestdata/fnbody
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/fnbody
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . )
    1:  7: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . BlockStmt (
    2:  1: . . . . . "{"
    3:  2: . . . . . StatementList (
    3:  2: . . . . . . Statement (
    3:  2: . . . . . . . GenDecl(type) (
    3:  2: . . . . . . . . "type"
    3:  7: . . . . . . . . TypeSpec (
    3:  7: . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    3:  9: . . . . . . . . . "="
    3: 11: . . . . . . . . . Type (
    3: 11: . . . . . . . . . . TypeName (
    3: 11: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 14: . . . . . . . . . . )
    3: 14: . . . . . . . . . )
    3: 14: . . . . . . . . . ";"
    4:  2: . . . . . . . . )
    4:  2: . . . . . . . )
    4:  2: . . . . . . )
    4:  2: . . . . . . Statement (
    4:  2: . . . . . . . GenDecl(var) (
    4:  2: . . . . . . . . "var"
    4:  6: . . . . . . . . varSpec (
    4:  6: . . . . . . . . . IdentList (
    4:  6: . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4:  8: . . . . . . . . . )
    4:  8: . . . . . . . . . "="
    4: 10: . . . . . . . . . ExpressionList (
    4: 10: . . . . . . . . . . Expression (
    4: 10: . . . . . . . . . . . BinaryExpr (
    4: 10: . . . . . . . . . . . . UnaryExpr (
    4: 10: . . . . . . . . . . . . . PrimaryExpr (
    4: 10: . . . . . . . . . . . . . . Operand (
    4: 10: . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    4: 11: . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . )
    4: 11: . . . . . . . . . . )
    4: 11: . . . . . . . . . )
    4: 11: . . . . . . . . . ";"
    5:  2: . . . . . . . . )
    5:  2: . . . . . . . )
    5:  2: . . . . . . )
    5:  2: . . . . . . Statement (
    5:  2: . . . . . . . GenDecl(var) (
    5:  2: . . . . . . . . "var"
    5:  6: . . . . . . . . varSpec (
    5:  6: . . . . . . . . . IdentList (
    5:  6: . . . . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
    5:  8: . . . . . . . . . )
    5:  8: . . . . . . . . . TypeName (
    5:  8: . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    5: 10: . . . . . . . . . )
    5: 10: . . . . . . . . . "="
    5: 12: . . . . . . . . . ExpressionList (
    5: 12: . . . . . . . . . . Expression (
    5: 12: . . . . . . . . . . . BinaryExpr (
    5: 12: . . . . . . . . . . . . UnaryExpr (
    5: 12: . . . . . . . . . . . . . PrimaryExpr (
    5: 12: . . . . . . . . . . . . . . Operand (
    5: 12: . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    5: 13: . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . )
    5: 13: . . . . . . . . . . )
    5: 13: . . . . . . . . . )
    5: 13: . . . . . . . . . ";"
    6:  1: . . . . . . . . )
    6:  1: . . . . . . . )
    6:  1: . . . . . . )
    6:  1: . . . . . )
    6:  1: . . . . . "}"
    6:  2: . . . . )
    6:  2: . . . . ";"
    6:  3: . . . )
    6:  3: . . )
    6:  3: . )
    6:  3: )
=== RUN   TestFromTestdata/fncall
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/fncall
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . . CallOrConversion (
    1:  3: . . . . . . . . . . . "("
    1:  4: . . . . . . . . . . . Expression (
    1:  4: . . . . . . . . . . . . BinaryExpr (
    1:  4: . . . . . . . . . . . . . UnaryExpr (
    1:  4: . . . . . . . . . . . . . . PrimaryExpr (
    1:  4: . . . . . . . . . . . . . . . Operand (
    1:  4: . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  5: . . . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: fn, Ellipsis: false, isCmd: false}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . "("
    1:  7: . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 3 [0xc0004c4960] 0 [] 5 0}, Ellipsis: false, isCmd: false}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . )
    1:  9: . . . . . . )
    1:  9: . . . . . )
    1:  9: . . . . )
    1:  9: . . . . ";"
    1: 10: . . . )
    1: 10: . . )
    1: 10: . )
    1: 10: )
=== RUN   TestFromTestdata/forloop
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/forloop
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . )
    1:  7: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . ForStmt (
    2:  1: . . . . . "for"
    2:  5: . . . . . "range"
    2: 11: . . . . . Expression (
    2: 11: . . . . . . RangeExpr (
    2: 11: . . . . . . . BinaryExpr (
    2: 11: . . . . . . . . UnaryExpr (
    2: 11: . . . . . . . . . PrimaryExpr (
    2: 11: . . . . . . . . . . Operand (
    2: 11: . . . . . . . . . . . ArrayType (
    2: 11: . . . . . . . . . . . . "["
    2: 12: . . . . . . . . . . . . Expression (
    2: 12: . . . . . . . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 13: . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . ","
    2: 15: . . . . . . . . . . . . Expression (
    2: 15: . . . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2: 16: . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . ","
    2: 18: . . . . . . . . . . . . Expression (
    2: 18: . . . . . . . . . . . . . BinaryExpr (
    2: 18: . . . . . . . . . . . . . . UnaryExpr (
    2: 18: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 18: . . . . . . . . . . . . . . . . Operand (
    2: 18: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    2: 19: . . . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . ","
    2: 21: . . . . . . . . . . . . Expression (
    2: 21: . . . . . . . . . . . . . BinaryExpr (
    2: 21: . . . . . . . . . . . . . . UnaryExpr (
    2: 21: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 21: . . . . . . . . . . . . . . . . Operand (
    2: 21: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    2: 22: . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . ","
    2: 24: . . . . . . . . . . . . Expression (
    2: 24: . . . . . . . . . . . . . BinaryExpr (
    2: 24: . . . . . . . . . . . . . . UnaryExpr (
    2: 24: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 24: . . . . . . . . . . . . . . . . Operand (
    2: 24: . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    2: 26: . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . "]"
    2: 28: . . . . . . . . . . . )
    2: 28: . . . . . . . . . . )
    2: 28: . . . . . . . . . )
    2: 28: . . . . . . . . )
    2: 28: . . . . . . . )
    2: 28: . . . . . . )
    2: 28: . . . . . )
    2: 28: . . . . . BlockStmt (
    2: 28: . . . . . . "{"
    3:  2: . . . . . . StatementList (
    3:  2: . . . . . . . Statement (
    3:  2: . . . . . . . . SimpleStmt (
    3:  2: . . . . . . . . . ExpressionList (
    3:  2: . . . . . . . . . . Expression (
    3:  2: . . . . . . . . . . . BinaryExpr (
    3:  2: . . . . . . . . . . . . UnaryExpr (
    3:  2: . . . . . . . . . . . . . PrimaryExpr (
    3:  2: . . . . . . . . . . . . . . Operand (
    3:  2: . . . . . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    3:  3: . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . )
    3:  3: . . . . . . . . . . )
    3:  3: . . . . . . . . . )
    3:  3: . . . . . . . . . "++"
    3:  5: . . . . . . . . )
    3:  5: . . . . . . . . ";"
    4:  1: . . . . . . . )
    4:  1: . . . . . . )
    4:  1: . . . . . . "}"
    4:  2: . . . . . )
    4:  2: . . . . . ";"
    5:  1: . . . . )
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  8: . . . . . . . . . . )
    5:  8: . . . . . . . . . . CallOrConversion (
    5:  8: . . . . . . . . . . . "("
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . STRING "n:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "n:"}
    5: 13: . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . ","
    5: 15: . . . . . . . . . . . Expression (
    5: 15: . . . . . . . . . . . . BinaryExpr (
    5: 15: . . . . . . . . . . . . . UnaryExpr (
    5: 15: . . . . . . . . . . . . . . PrimaryExpr (
    5: 15: . . . . . . . . . . . . . . . Operand (
    5: 15: . . . . . . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    5: 16: . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 17: . . . . . . . . . . )
    5: 17: . . . . . . . . . )
    5: 17: . . . . . . . . )
    5: 17: . . . . . . . )
    5: 17: . . . . . . )
    5: 17: . . . . . )
    5: 17: . . . . )
    5: 17: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . ForStmt (
    7:  1: . . . . . "for"
    7:  5: . . . . . SimpleStmt (
    7:  5: . . . . . . ExpressionList (
    7:  5: . . . . . . . Expression (
    7:  5: . . . . . . . . BinaryExpr (
    7:  5: . . . . . . . . . UnaryExpr (
    7:  5: . . . . . . . . . . PrimaryExpr (
    7:  5: . . . . . . . . . . . Operand (
    7:  5: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  7: . . . . . . . . . . . )
    7:  7: . . . . . . . . . . )
    7:  7: . . . . . . . . . )
    7:  7: . . . . . . . . )
    7:  7: . . . . . . . )
    7:  7: . . . . . . )
    7:  7: . . . . . . ":="
    7: 10: . . . . . . "range"
    7: 16: . . . . . . Expression (
    7: 16: . . . . . . . RangeExpr (
    7: 16: . . . . . . . . BinaryExpr (
    7: 16: . . . . . . . . . UnaryExpr (
    7: 16: . . . . . . . . . . PrimaryExpr (
    7: 16: . . . . . . . . . . . Operand (
    7: 16: . . . . . . . . . . . . ArrayType (
    7: 16: . . . . . . . . . . . . . "["
    7: 17: . . . . . . . . . . . . . Expression (
    7: 17: . . . . . . . . . . . . . . BinaryExpr (
    7: 17: . . . . . . . . . . . . . . . UnaryExpr (
    7: 17: . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 17: . . . . . . . . . . . . . . . . . Operand (
    7: 17: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 18: . . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc0004c4e10]}
    7: 20: . . . . . . . . . . . . )
    7: 20: . . . . . . . . . . . )
    7: 20: . . . . . . . . . . )
    7: 20: . . . . . . . . . )
    7: 20: . . . . . . . . )
    7: 20: . . . . . . . )
    7: 20: . . . . . . )
    7: 20: . . . . . )
    7: 20: . . . . . BlockStmt (
    7: 20: . . . . . . "{"
    8:  1: . . . . . . StatementList (
    8:  1: . . . . . . )
    8:  1: . . . . . . "}"
    8:  2: . . . . . )
    8:  2: . . . . . ";"
   10:  1: . . . . )
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   10:  5: . . . . . . . . . . )
   10:  5: . . . . . . . . . )
   10:  5: . . . . . . . . )
   10:  5: . . . . . . . )
   10:  5: . . . . . . )
   10:  5: . . . . . )
   10:  5: . . . . . ":="
   10:  8: . . . . . ExpressionList (
   10:  8: . . . . . . Expression (
   10:  8: . . . . . . . BinaryExpr (
   10:  8: . . . . . . . . UnaryExpr (
   10:  8: . . . . . . . . . PrimaryExpr (
   10:  8: . . . . . . . . . . Operand (
   10:  8: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   10:  9: . . . . . . . . . . )
   10:  9: . . . . . . . . . )
   10:  9: . . . . . . . . )
   10:  9: . . . . . . . )
   10:  9: . . . . . . )
   10:  9: . . . . . )
   10:  9: . . . . )
   10:  9: . . . . ";"
   11:  1: . . . )
   11:  1: . . . Statement (
   11:  1: . . . . ForStmt (
   11:  1: . . . . . "for"
   11:  5: . . . . . SimpleStmt (
   11:  5: . . . . . . ExpressionList (
   11:  5: . . . . . . . Expression (
   11:  5: . . . . . . . . BinaryExpr (
   11:  5: . . . . . . . . . UnaryExpr (
   11:  5: . . . . . . . . . . PrimaryExpr (
   11:  5: . . . . . . . . . . . Operand (
   11:  5: . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
   11:  6: . . . . . . . . . . . )
   11:  6: . . . . . . . . . . )
   11:  6: . . . . . . . . . )
   11:  6: . . . . . . . . )
   11:  6: . . . . . . . )
   11:  6: . . . . . . . ","
   11:  8: . . . . . . . Expression (
   11:  8: . . . . . . . . BinaryExpr (
   11:  8: . . . . . . . . . UnaryExpr (
   11:  8: . . . . . . . . . . PrimaryExpr (
   11:  8: . . . . . . . . . . . Operand (
   11:  8: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 10: . . . . . . . . . . . )
   11: 10: . . . . . . . . . . )
   11: 10: . . . . . . . . . )
   11: 10: . . . . . . . . )
   11: 10: . . . . . . . )
   11: 10: . . . . . . )
   11: 10: . . . . . . ":="
   11: 13: . . . . . . "range"
   11: 19: . . . . . . Expression (
   11: 19: . . . . . . . RangeExpr (
   11: 19: . . . . . . . . BinaryExpr (
   11: 19: . . . . . . . . . UnaryExpr (
   11: 19: . . . . . . . . . . PrimaryExpr (
   11: 19: . . . . . . . . . . . Operand (
   11: 19: . . . . . . . . . . . . ArrayType (
   11: 19: . . . . . . . . . . . . . "["
   11: 20: . . . . . . . . . . . . . Expression (
   11: 20: . . . . . . . . . . . . . . BinaryExpr (
   11: 20: . . . . . . . . . . . . . . . UnaryExpr (
   11: 20: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 20: . . . . . . . . . . . . . . . . . Operand (
   11: 20: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   11: 21: . . . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . ","
   11: 23: . . . . . . . . . . . . . Expression (
   11: 23: . . . . . . . . . . . . . . BinaryExpr (
   11: 23: . . . . . . . . . . . . . . . UnaryExpr (
   11: 23: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 23: . . . . . . . . . . . . . . . . . Operand (
   11: 23: . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   11: 24: . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . ","
   11: 26: . . . . . . . . . . . . . Expression (
   11: 26: . . . . . . . . . . . . . . BinaryExpr (
   11: 26: . . . . . . . . . . . . . . . UnaryExpr (
   11: 26: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 26: . . . . . . . . . . . . . . . . . Operand (
   11: 26: . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   11: 27: . . . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . ","
   11: 29: . . . . . . . . . . . . . Expression (
   11: 29: . . . . . . . . . . . . . . BinaryExpr (
   11: 29: . . . . . . . . . . . . . . . UnaryExpr (
   11: 29: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 29: . . . . . . . . . . . . . . . . . Operand (
   11: 29: . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
   11: 30: . . . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . ","
   11: 32: . . . . . . . . . . . . . Expression (
   11: 32: . . . . . . . . . . . . . . BinaryExpr (
   11: 32: . . . . . . . . . . . . . . . UnaryExpr (
   11: 32: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 32: . . . . . . . . . . . . . . . . . Operand (
   11: 32: . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
   11: 34: . . . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . "]"
   11: 36: . . . . . . . . . . . . )
   11: 36: . . . . . . . . . . . )
   11: 36: . . . . . . . . . . )
   11: 36: . . . . . . . . . )
   11: 36: . . . . . . . . )
   11: 36: . . . . . . . )
   11: 36: . . . . . . )
   11: 36: . . . . . )
   11: 36: . . . . . BlockStmt (
   11: 36: . . . . . . "{"
   12:  2: . . . . . . StatementList (
   12:  2: . . . . . . . Statement (
   12:  2: . . . . . . . . IfStmt (
   12:  2: . . . . . . . . . "if"
   12:  5: . . . . . . . . . SimpleStmt (
   12:  5: . . . . . . . . . . ExpressionList (
   12:  5: . . . . . . . . . . . Expression (
   12:  5: . . . . . . . . . . . . BinaryExpr (
   12:  5: . . . . . . . . . . . . . UnaryExpr (
   12:  5: . . . . . . . . . . . . . . PrimaryExpr (
   12:  5: . . . . . . . . . . . . . . . Operand (
   12:  5: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   12:  7: . . . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . ">"
   12:  9: . . . . . . . . . . . . . BinaryExpr (
   12:  9: . . . . . . . . . . . . . . UnaryExpr (
   12:  9: . . . . . . . . . . . . . . . PrimaryExpr (
   12:  9: . . . . . . . . . . . . . . . . Operand (
   12:  9: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   12: 11: . . . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . )
   12: 11: . . . . . . . . . . )
   12: 11: . . . . . . . . . )
   12: 11: . . . . . . . . . BlockStmt (
   12: 11: . . . . . . . . . . "{"
   13:  3: . . . . . . . . . . StatementList (
   13:  3: . . . . . . . . . . . Statement (
   13:  3: . . . . . . . . . . . . SimpleStmt (
   13:  3: . . . . . . . . . . . . . ExpressionList (
   13:  3: . . . . . . . . . . . . . . Expression (
   13:  3: . . . . . . . . . . . . . . . BinaryExpr (
   13:  3: . . . . . . . . . . . . . . . . UnaryExpr (
   13:  3: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  3: . . . . . . . . . . . . . . . . . . Operand (
   13:  3: . . . . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   13:  7: . . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . "+="
   13: 10: . . . . . . . . . . . . . ExpressionList (
   13: 10: . . . . . . . . . . . . . . Expression (
   13: 10: . . . . . . . . . . . . . . . BinaryExpr (
   13: 10: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . . Operand (
   13: 10: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   13: 11: . . . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . ";"
   14:  2: . . . . . . . . . . . )
   14:  2: . . . . . . . . . . )
   14:  2: . . . . . . . . . . "}"
   14:  3: . . . . . . . . . )
   14:  3: . . . . . . . . . ";"
   15:  1: . . . . . . . . )
   15:  1: . . . . . . . )
   15:  1: . . . . . . )
   15:  1: . . . . . . "}"
   15:  2: . . . . . )
   15:  2: . . . . . ";"
   16:  1: . . . . )
   16:  1: . . . )
   16:  1: . . . Statement (
   16:  1: . . . . SimpleStmt (
   16:  1: . . . . . ExpressionList (
   16:  1: . . . . . . Expression (
   16:  1: . . . . . . . BinaryExpr (
   16:  1: . . . . . . . . UnaryExpr (
   16:  1: . . . . . . . . . PrimaryExpr (
   16:  1: . . . . . . . . . . Operand (
   16:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   16:  8: . . . . . . . . . . )
   16:  8: . . . . . . . . . . CallOrConversion (
   16:  8: . . . . . . . . . . . "("
   16:  9: . . . . . . . . . . . Expression (
   16:  9: . . . . . . . . . . . . BinaryExpr (
   16:  9: . . . . . . . . . . . . . UnaryExpr (
   16:  9: . . . . . . . . . . . . . . PrimaryExpr (
   16:  9: . . . . . . . . . . . . . . . Operand (
   16:  9: . . . . . . . . . . . . . . . . STRING "sum(1,3,5,7,11):"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "sum(1,3,5,7,11):"}
   16: 27: . . . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . ","
   16: 29: . . . . . . . . . . . Expression (
   16: 29: . . . . . . . . . . . . BinaryExpr (
   16: 29: . . . . . . . . . . . . . UnaryExpr (
   16: 29: . . . . . . . . . . . . . . PrimaryExpr (
   16: 29: . . . . . . . . . . . . . . . Operand (
   16: 29: . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   16: 32: . . . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   16: 33: . . . . . . . . . . )
   16: 33: . . . . . . . . . )
   16: 33: . . . . . . . . )
   16: 33: . . . . . . . )
   16: 33: . . . . . . )
   16: 33: . . . . . )
   16: 33: . . . . )
   16: 33: . . . . ";"
   18:  1: . . . )
   18:  1: . . . Statement (
   18:  1: . . . . SimpleStmt (
   18:  1: . . . . . ExpressionList (
   18:  1: . . . . . . Expression (
   18:  1: . . . . . . . BinaryExpr (
   18:  1: . . . . . . . . UnaryExpr (
   18:  1: . . . . . . . . . PrimaryExpr (
   18:  1: . . . . . . . . . . Operand (
   18:  1: . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   18:  5: . . . . . . . . . . )
   18:  5: . . . . . . . . . )
   18:  5: . . . . . . . . )
   18:  5: . . . . . . . )
   18:  5: . . . . . . )
   18:  5: . . . . . )
   18:  5: . . . . . "="
   18:  7: . . . . . ExpressionList (
   18:  7: . . . . . . Expression (
   18:  7: . . . . . . . BinaryExpr (
   18:  7: . . . . . . . . UnaryExpr (
   18:  7: . . . . . . . . . PrimaryExpr (
   18:  7: . . . . . . . . . . Operand (
   18:  7: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   18:  8: . . . . . . . . . . )
   18:  8: . . . . . . . . . )
   18:  8: . . . . . . . . )
   18:  8: . . . . . . . )
   18:  8: . . . . . . )
   18:  8: . . . . . )
   18:  8: . . . . )
   18:  8: . . . . ";"
   19:  1: . . . )
   19:  1: . . . Statement (
   19:  1: . . . . ForStmt (
   19:  1: . . . . . "for"
   19:  5: . . . . . SimpleStmt (
   19:  5: . . . . . . ExpressionList (
   19:  5: . . . . . . . Expression (
   19:  5: . . . . . . . . BinaryExpr (
   19:  5: . . . . . . . . . UnaryExpr (
   19:  5: . . . . . . . . . . PrimaryExpr (
   19:  5: . . . . . . . . . . . Operand (
   19:  5: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19:  7: . . . . . . . . . . . )
   19:  7: . . . . . . . . . . )
   19:  7: . . . . . . . . . )
   19:  7: . . . . . . . . )
   19:  7: . . . . . . . )
   19:  7: . . . . . . )
   19:  7: . . . . . . ":="
   19: 10: . . . . . . ExpressionList (
   19: 10: . . . . . . . Expression (
   19: 10: . . . . . . . . BinaryExpr (
   19: 10: . . . . . . . . . UnaryExpr (
   19: 10: . . . . . . . . . . PrimaryExpr (
   19: 10: . . . . . . . . . . . Operand (
   19: 10: . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   19: 11: . . . . . . . . . . . )
   19: 11: . . . . . . . . . . )
   19: 11: . . . . . . . . . )
   19: 11: . . . . . . . . )
   19: 11: . . . . . . . )
   19: 11: . . . . . . )
   19: 11: . . . . . )
   19: 11: . . . . . ";"
   19: 13: . . . . . SimpleStmt (
   19: 13: . . . . . . ExpressionList (
   19: 13: . . . . . . . Expression (
   19: 13: . . . . . . . . BinaryExpr (
   19: 13: . . . . . . . . . UnaryExpr (
   19: 13: . . . . . . . . . . PrimaryExpr (
   19: 13: . . . . . . . . . . . Operand (
   19: 13: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19: 15: . . . . . . . . . . . )
   19: 15: . . . . . . . . . . )
   19: 15: . . . . . . . . . )
   19: 15: . . . . . . . . . "<"
   19: 17: . . . . . . . . . BinaryExpr (
   19: 17: . . . . . . . . . . UnaryExpr (
   19: 17: . . . . . . . . . . . PrimaryExpr (
   19: 17: . . . . . . . . . . . . Operand (
   19: 17: . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
   19: 20: . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . )
   19: 20: . . . . . . . . . . )
   19: 20: . . . . . . . . . )
   19: 20: . . . . . . . . )
   19: 20: . . . . . . . )
   19: 20: . . . . . . )
   19: 20: . . . . . )
   19: 20: . . . . . ";"
   19: 22: . . . . . SimpleStmt (
   19: 22: . . . . . . ExpressionList (
   19: 22: . . . . . . . Expression (
   19: 22: . . . . . . . . BinaryExpr (
   19: 22: . . . . . . . . . UnaryExpr (
   19: 22: . . . . . . . . . . PrimaryExpr (
   19: 22: . . . . . . . . . . . Operand (
   19: 22: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19: 23: . . . . . . . . . . . )
   19: 23: . . . . . . . . . . )
   19: 23: . . . . . . . . . )
   19: 23: . . . . . . . . )
   19: 23: . . . . . . . )
   19: 23: . . . . . . )
   19: 23: . . . . . . "++"
   19: 26: . . . . . )
   19: 26: . . . . . BlockStmt (
   19: 26: . . . . . . "{"
   20:  2: . . . . . . StatementList (
   20:  2: . . . . . . . Statement (
   20:  2: . . . . . . . . SimpleStmt (
   20:  2: . . . . . . . . . ExpressionList (
   20:  2: . . . . . . . . . . Expression (
   20:  2: . . . . . . . . . . . BinaryExpr (
   20:  2: . . . . . . . . . . . . UnaryExpr (
   20:  2: . . . . . . . . . . . . . PrimaryExpr (
   20:  2: . . . . . . . . . . . . . . Operand (
   20:  2: . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   20:  6: . . . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . )
   20:  6: . . . . . . . . . . )
   20:  6: . . . . . . . . . )
   20:  6: . . . . . . . . . "+="
   20:  9: . . . . . . . . . ExpressionList (
   20:  9: . . . . . . . . . . Expression (
   20:  9: . . . . . . . . . . . BinaryExpr (
   20:  9: . . . . . . . . . . . . UnaryExpr (
   20:  9: . . . . . . . . . . . . . PrimaryExpr (
   20:  9: . . . . . . . . . . . . . . Operand (
   20:  9: . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   20: 10: . . . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . )
   20: 10: . . . . . . . . . . )
   20: 10: . . . . . . . . . )
   20: 10: . . . . . . . . )
   20: 10: . . . . . . . . ";"
   21:  1: . . . . . . . )
   21:  1: . . . . . . )
   21:  1: . . . . . . "}"
   21:  2: . . . . . )
   21:  2: . . . . . ";"
   22:  1: . . . . )
   22:  1: . . . )
   22:  1: . . . Statement (
   22:  1: . . . . SimpleStmt (
   22:  1: . . . . . ExpressionList (
   22:  1: . . . . . . Expression (
   22:  1: . . . . . . . BinaryExpr (
   22:  1: . . . . . . . . UnaryExpr (
   22:  1: . . . . . . . . . PrimaryExpr (
   22:  1: . . . . . . . . . . Operand (
   22:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   22:  8: . . . . . . . . . . )
   22:  8: . . . . . . . . . . CallOrConversion (
   22:  8: . . . . . . . . . . . "("
   22:  9: . . . . . . . . . . . Expression (
   22:  9: . . . . . . . . . . . . BinaryExpr (
   22:  9: . . . . . . . . . . . . . UnaryExpr (
   22:  9: . . . . . . . . . . . . . . PrimaryExpr (
   22:  9: . . . . . . . . . . . . . . . Operand (
   22:  9: . . . . . . . . . . . . . . . . STRING "sum(1-100):"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "sum(1-100):"}
   22: 22: . . . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . ","
   22: 24: . . . . . . . . . . . Expression (
   22: 24: . . . . . . . . . . . . BinaryExpr (
   22: 24: . . . . . . . . . . . . . UnaryExpr (
   22: 24: . . . . . . . . . . . . . . PrimaryExpr (
   22: 24: . . . . . . . . . . . . . . . Operand (
   22: 24: . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   22: 27: . . . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   22: 28: . . . . . . . . . . )
   22: 28: . . . . . . . . . )
   22: 28: . . . . . . . . )
   22: 28: . . . . . . . )
   22: 28: . . . . . . )
   22: 28: . . . . . )
   22: 28: . . . . )
   22: 28: . . . . ";"
   24:  1: . . . )
   24:  1: . . . Statement (
   24:  1: . . . . ForStmt (
   24:  1: . . . . . "for"
   24:  5: . . . . . SimpleStmt (
   24:  5: . . . . . . ExpressionList (
   24:  5: . . . . . . . Expression (
   24:  5: . . . . . . . . BinaryExpr (
   24:  5: . . . . . . . . . UnaryExpr (
   24:  5: . . . . . . . . . . PrimaryExpr (
   24:  5: . . . . . . . . . . . Operand (
   24:  5: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   24:  7: . . . . . . . . . . . )
   24:  7: . . . . . . . . . . )
   24:  7: . . . . . . . . . )
   24:  7: . . . . . . . . )
   24:  7: . . . . . . . )
   24:  7: . . . . . . )
   24:  7: . . . . . . IDENT in
   24: 10: . . . . . . Expression (
   24: 10: . . . . . . . RangeExpr (
   24: 10: . . . . . . . . BinaryExpr (
   24: 10: . . . . . . . . . UnaryExpr (
   24: 10: . . . . . . . . . . PrimaryExpr (
   24: 10: . . . . . . . . . . . Operand (
   24: 10: . . . . . . . . . . . . ArrayType (
   24: 10: . . . . . . . . . . . . . "["
   24: 11: . . . . . . . . . . . . . Expression (
   24: 11: . . . . . . . . . . . . . . BinaryExpr (
   24: 11: . . . . . . . . . . . . . . . UnaryExpr (
   24: 11: . . . . . . . . . . . . . . . . PrimaryExpr (
   24: 11: . . . . . . . . . . . . . . . . . Operand (
   24: 11: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   24: 12: . . . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc0004c5380]}
   24: 14: . . . . . . . . . . . . )
   24: 14: . . . . . . . . . . . )
   24: 14: . . . . . . . . . . )
   24: 14: . . . . . . . . . )
   24: 14: . . . . . . . . )
   24: 14: . . . . . . . )
   24: 14: . . . . . . )
   24: 14: . . . . . )
   24: 14: . . . . . BlockStmt (
   24: 14: . . . . . . "{"
   25:  2: . . . . . . StatementList (
   25:  2: . . . . . . . Statement (
   25:  2: . . . . . . . . SimpleStmt (
   25:  2: . . . . . . . . . ExpressionList (
   25:  2: . . . . . . . . . . Expression (
   25:  2: . . . . . . . . . . . BinaryExpr (
   25:  2: . . . . . . . . . . . . UnaryExpr (
   25:  2: . . . . . . . . . . . . . PrimaryExpr (
   25:  2: . . . . . . . . . . . . . . Operand (
   25:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   25:  9: . . . . . . . . . . . . . . )
   25:  9: . . . . . . . . . . . . . . CallOrConversion (
   25:  9: . . . . . . . . . . . . . . . "("
   25: 10: . . . . . . . . . . . . . . . Expression (
   25: 10: . . . . . . . . . . . . . . . . BinaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . . . Operand (
   25: 10: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   25: 11: . . . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   25: 12: . . . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . )
   25: 12: . . . . . . . . . . )
   25: 12: . . . . . . . . . )
   25: 12: . . . . . . . . )
   25: 12: . . . . . . . . ";"
   26:  1: . . . . . . . )
   26:  1: . . . . . . )
   26:  1: . . . . . . "}"
   26:  2: . . . . . )
   26:  2: . . . . . ";"
   28:  1: . . . . )
   28:  1: . . . )
   28:  1: . . . Statement (
   28:  1: . . . . ForStmt (
   28:  1: . . . . . "for"
   28:  5: . . . . . SimpleStmt (
   28:  5: . . . . . . ExpressionList (
   28:  5: . . . . . . . Expression (
   28:  5: . . . . . . . . BinaryExpr (
   28:  5: . . . . . . . . . UnaryExpr (
   28:  5: . . . . . . . . . . PrimaryExpr (
   28:  5: . . . . . . . . . . . Operand (
   28:  5: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   28:  6: . . . . . . . . . . . )
   28:  6: . . . . . . . . . . )
   28:  6: . . . . . . . . . )
   28:  6: . . . . . . . . )
   28:  6: . . . . . . . )
   28:  6: . . . . . . . ","
   28:  8: . . . . . . . Expression (
   28:  8: . . . . . . . . BinaryExpr (
   28:  8: . . . . . . . . . UnaryExpr (
   28:  8: . . . . . . . . . . PrimaryExpr (
   28:  8: . . . . . . . . . . . Operand (
   28:  8: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   28: 10: . . . . . . . . . . . )
   28: 10: . . . . . . . . . . )
   28: 10: . . . . . . . . . )
   28: 10: . . . . . . . . )
   28: 10: . . . . . . . )
   28: 10: . . . . . . )
   28: 10: . . . . . . IDENT in
   28: 13: . . . . . . Expression (
   28: 13: . . . . . . . RangeExpr (
   28: 13: . . . . . . . . BinaryExpr (
   28: 13: . . . . . . . . . UnaryExpr (
   28: 13: . . . . . . . . . . PrimaryExpr (
   28: 13: . . . . . . . . . . . Operand (
   28: 13: . . . . . . . . . . . . ArrayType (
   28: 13: . . . . . . . . . . . . . "["
   28: 14: . . . . . . . . . . . . . Expression (
   28: 14: . . . . . . . . . . . . . . BinaryExpr (
   28: 14: . . . . . . . . . . . . . . . UnaryExpr (
   28: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   28: 14: . . . . . . . . . . . . . . . . . Operand (
   28: 14: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   28: 15: . . . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc0004c5470]}
   28: 17: . . . . . . . . . . . . )
   28: 17: . . . . . . . . . . . )
   28: 17: . . . . . . . . . . )
   28: 17: . . . . . . . . . )
   28: 17: . . . . . . . . )
   28: 17: . . . . . . . )
   28: 17: . . . . . . )
   28: 17: . . . . . . "if"
   28: 20: . . . . . . Expression (
   28: 20: . . . . . . . BinaryExpr (
   28: 20: . . . . . . . . UnaryExpr (
   28: 20: . . . . . . . . . PrimaryExpr (
   28: 20: . . . . . . . . . . Operand (
   28: 20: . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   28: 21: . . . . . . . . . . )
   28: 21: . . . . . . . . . )
   28: 21: . . . . . . . . )
   28: 21: . . . . . . . . "%"
   28: 22: . . . . . . . . BinaryExpr (
   28: 22: . . . . . . . . . UnaryExpr (
   28: 22: . . . . . . . . . . PrimaryExpr (
   28: 22: . . . . . . . . . . . Operand (
   28: 22: . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   28: 24: . . . . . . . . . . . )
   28: 24: . . . . . . . . . . )
   28: 24: . . . . . . . . . )
   28: 24: . . . . . . . . )
   28: 24: . . . . . . . . "=="
   28: 27: . . . . . . . . BinaryExpr (
   28: 27: . . . . . . . . . UnaryExpr (
   28: 27: . . . . . . . . . . PrimaryExpr (
   28: 27: . . . . . . . . . . . Operand (
   28: 27: . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   28: 29: . . . . . . . . . . . )
   28: 29: . . . . . . . . . . )
   28: 29: . . . . . . . . . )
   28: 29: . . . . . . . . )
   28: 29: . . . . . . . )
   28: 29: . . . . . . )
   28: 29: . . . . . )
   28: 29: . . . . . BlockStmt (
   28: 29: . . . . . . "{"
   29:  2: . . . . . . StatementList (
   29:  2: . . . . . . . Statement (
   29:  2: . . . . . . . . SimpleStmt (
   29:  2: . . . . . . . . . ExpressionList (
   29:  2: . . . . . . . . . . Expression (
   29:  2: . . . . . . . . . . . BinaryExpr (
   29:  2: . . . . . . . . . . . . UnaryExpr (
   29:  2: . . . . . . . . . . . . . PrimaryExpr (
   29:  2: . . . . . . . . . . . . . . Operand (
   29:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   29:  9: . . . . . . . . . . . . . . )
   29:  9: . . . . . . . . . . . . . . CallOrConversion (
   29:  9: . . . . . . . . . . . . . . . "("
   29: 10: . . . . . . . . . . . . . . . Expression (
   29: 10: . . . . . . . . . . . . . . . . BinaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . . . Operand (
   29: 10: . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   29: 11: . . . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . ","
   29: 13: . . . . . . . . . . . . . . . Expression (
   29: 13: . . . . . . . . . . . . . . . . BinaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . UnaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . . . Operand (
   29: 13: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   29: 14: . . . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   29: 15: . . . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . )
   29: 15: . . . . . . . . . . )
   29: 15: . . . . . . . . . )
   29: 15: . . . . . . . . )
   29: 15: . . . . . . . . ";"
   30:  1: . . . . . . . )
   30:  1: . . . . . . )
   30:  1: . . . . . . "}"
   30:  2: . . . . . )
   30:  2: . . . . . ";"
   30:  3: . . . . )
   30:  3: . . . )
   30:  3: . . )
   30:  3: . )
   30:  3: )
=== RUN   TestFromTestdata/funcdecl1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/funcdecl1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  5: . . . Parameters (
    1:  5: . . . . "("
    1:  6: . . . . ")"
    1:  8: . . . )
    1:  8: . . . Parameters (
    1:  8: . . . . "("
    1:  9: . . . . ParameterList (
    1:  9: . . . . . ParamDeclOrNil (
    1:  9: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 12: . . . . . )
    1: 12: . . . . . ","
    1: 14: . . . . . ParamDeclOrNil (
    1: 14: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 17: . . . . . )
    1: 17: . . . . )
    1: 17: . . . . ")"
    1: 19: . . . )
    1: 19: . . . Body (
    1: 19: . . . . "{"
    2:  2: . . . . StatementList (
    2:  2: . . . . . Statement (
    2:  2: . . . . . . ReturnStmt (
    2:  2: . . . . . . . "return"
    2:  9: . . . . . . . ExpressionList (
    2:  9: . . . . . . . . Expression (
    2:  9: . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . )
    2: 10: . . . . . . . . . )
    2: 10: . . . . . . . . )
    2: 10: . . . . . . . . ","
    2: 12: . . . . . . . . Expression (
    2: 12: . . . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 13: . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . )
    2: 13: . . . . . . . . . . )
    2: 13: . . . . . . . . . )
    2: 13: . . . . . . . . )
    2: 13: . . . . . . . )
    2: 13: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . )
    3:  1: . . . . )
    3:  1: . . . . "}"
    3:  2: . . . )
    3:  2: . . . CallOrConversion (
    3:  2: . . . . "("
    3:  3: . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc0002246e0 0xc0004c58f0}, Ellipsis: false, isCmd: false}
    3:  4: . . . )
    3:  4: . . . ";"
    3:  5: . . )
    3:  5: . . StatementList (
    3:  5: . . )
    3:  5: . )
    3:  5: )
=== RUN   TestFromTestdata/funcdecl2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/funcdecl2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  5: . . . Parameters (
    1:  5: . . . . "("
    1:  6: . . . . ")"
    1:  8: . . . )
    1:  8: . . . Body (
    1:  8: . . . . "{"
    2:  1: . . . . StatementList (
    2:  1: . . . . )
    2:  1: . . . . "}"
    2:  2: . . . )
    2:  2: . . . CallOrConversion (
    2:  2: . . . . "("
    2:  3: . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc0002247e0 0xc0004c5bf0}, Ellipsis: false, isCmd: false}
    2:  4: . . . )
    2:  4: . . . ";"
    2:  5: . . )
    2:  5: . . StatementList (
    2:  5: . . )
    2:  5: . )
    2:  5: )
=== RUN   TestFromTestdata/funcdecl3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/funcdecl3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  5: . . . Parameters (
    1:  5: . . . . "("
    1:  6: . . . . ")"
    1:  8: . . . )
    1:  8: . . . TypeName (
    1:  8: . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 12: . . . )
    1: 12: . . . Body (
    1: 12: . . . . "{"
    2:  2: . . . . StatementList (
    2:  2: . . . . . Statement (
    2:  2: . . . . . . ReturnStmt (
    2:  2: . . . . . . . "return"
    2:  9: . . . . . . . ExpressionList (
    2:  9: . . . . . . . . Expression (
    2:  9: . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . )
    2: 10: . . . . . . . . . )
    2: 10: . . . . . . . . )
    2: 10: . . . . . . . )
    2: 10: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . )
    3:  1: . . . . )
    3:  1: . . . . "}"
    3:  2: . . . )
    3:  2: . . . CallOrConversion (
    3:  2: . . . . "("
    3:  3: . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc000224920 0xc0004c5f50}, Ellipsis: false, isCmd: false}
    3:  4: . . . )
    3:  4: . . . ";"
    3:  5: . . )
    3:  5: . . StatementList (
    3:  5: . . )
    3:  5: . )
    3:  5: )
=== RUN   TestFromTestdata/funcdoc
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/funcdoc
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    1: 12: . ";"
    3:  1: . COMMENT
    4:  1: . COMMENT
    5:  1: . Declaration (
    5:  1: . . FunctionDeclOrCall (
    5:  1: . . . "func"
    5:  6: . . . IDENT test
 /app/parser/parser.go:713: ast.Ident{Name: test}
    5: 10: . . . Signature (
    5: 10: . . . . Parameters (
    5: 10: . . . . . "("
    5: 11: . . . . . ParameterList (
    5: 11: . . . . . . ParamDeclOrNil (
    5: 11: . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
    5: 13: . . . . . . . Type (
    5: 13: . . . . . . . . TypeName (
    5: 13: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 19: . . . . . . . . )
    5: 19: . . . . . . . )
    5: 19: . . . . . . )
    5: 19: . . . . . . ","
    5: 21: . . . . . . ParamDeclOrNil (
    5: 21: . . . . . . . IDENT p
 /app/parser/parser.go:713: ast.Ident{Name: p}
    5: 22: . . . . . . )
    5: 22: . . . . . . ","
    5: 24: . . . . . . ParamDeclOrNil (
    5: 24: . . . . . . . IDENT q
 /app/parser/parser.go:713: ast.Ident{Name: q}
    5: 26: . . . . . . . Type (
    5: 26: . . . . . . . . TypeName (
    5: 26: . . . . . . . . . IDENT uintptr
 /app/parser/parser.go:713: ast.Ident{Name: uintptr}
    5: 33: . . . . . . . . )
    5: 33: . . . . . . . )
    5: 33: . . . . . . )
    5: 33: . . . . . . ","
    5: 35: . . . . . . ParamDeclOrNil (
    5: 35: . . . . . . . IDENT rest
 /app/parser/parser.go:713: ast.Ident{Name: rest}
    5: 40: . . . . . . . DotsType (
    5: 40: . . . . . . . . "..."
    5: 43: . . . . . . . . Type (
    5: 43: . . . . . . . . . TypeName (
    5: 43: . . . . . . . . . . IDENT uintptr
 /app/parser/parser.go:713: ast.Ident{Name: uintptr}
    5: 50: . . . . . . . . . )
    5: 50: . . . . . . . . )
    5: 50: . . . . . . . )
    5: 50: . . . . . . )
    5: 50: . . . . . )
    5: 50: . . . . . ")"
    5: 52: . . . . )
    5: 52: . . . . Result (
    5: 52: . . . . . TypeName (
    5: 52: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 56: . . . . . )
    5: 56: . . . . )
    5: 56: . . . )
    5: 56: . . . Body (
    5: 56: . . . . "{"
    6:  1: . . . . StatementList (
    6:  1: . . . . )
    6:  1: . . . . "}"
    6:  2: . . . )
    6:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
    6:  3: . . )
    6:  3: . )
    6:  3: )
=== RUN   TestFromTestdata/funclit
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/funclit
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  5: . . . Parameters (
    1:  5: . . . . "("
    1:  6: . . . . ParameterList (
    1:  6: . . . . . ParamDeclOrNil (
    1:  6: . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  7: . . . . . )
    1:  7: . . . . . ","
    1:  9: . . . . . ParamDeclOrNil (
    1:  9: . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    1: 11: . . . . . . Type (
    1: 11: . . . . . . . TypeName (
    1: 11: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 14: . . . . . . . )
    1: 14: . . . . . . )
    1: 14: . . . . . )
    1: 14: . . . . )
    1: 14: . . . . ")"
    1: 16: . . . )
    1: 16: . . . "*"
    1: 16: . . . PointerType (
    1: 17: . . . . Type (
    1: 17: . . . . . TypeName (
    1: 17: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 21: . . . . . )
    1: 21: . . . . )
    1: 21: . . . )
    1: 21: . . . Body (
    1: 21: . . . . "{"
    2:  2: . . . . StatementList (
    2:  2: . . . . . Statement (
    2:  2: . . . . . . ReturnStmt (
    2:  2: . . . . . . . "return"
    2:  9: . . . . . . . ExpressionList (
    2:  9: . . . . . . . . Expression (
    2:  9: . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    2: 12: . . . . . . . . . . . . )
    2: 12: . . . . . . . . . . . )
    2: 12: . . . . . . . . . . )
    2: 12: . . . . . . . . . )
    2: 12: . . . . . . . . )
    2: 12: . . . . . . . )
    2: 12: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . )
    3:  1: . . . . )
    3:  1: . . . . "}"
    3:  2: . . . )
    3:  2: . . . CallOrConversion (
    3:  2: . . . . "("
    3:  3: . . . . Expression (
    3:  3: . . . . . BinaryExpr (
    3:  3: . . . . . . UnaryExpr (
    3:  3: . . . . . . . PrimaryExpr (
    3:  3: . . . . . . . . Operand (
    3:  3: . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
    3:  6: . . . . . . . . )
    3:  6: . . . . . . . )
    3:  6: . . . . . . )
    3:  6: . . . . . )
    3:  6: . . . . )
    3:  6: . . . . ","
    3:  8: . . . . Expression (
    3:  8: . . . . . BinaryExpr (
    3:  8: . . . . . . UnaryExpr (
    3:  8: . . . . . . . PrimaryExpr (
    3:  8: . . . . . . . . Operand (
    3:  8: . . . . . . . . . INT 200
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 200}
    3: 11: . . . . . . . . )
    3: 11: . . . . . . . )
    3: 11: . . . . . . )
    3: 11: . . . . . )
    3: 11: . . . . )
    3: 11: . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc000224d60 0xc000221c50}, Ellipsis: false, isCmd: false}
    3: 12: . . . )
    3: 12: . . . ";"
    5:  1: . . )
    5:  1: . . StatementList (
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  9: . . . . . . . . . . )
    5:  9: . . . . . . . . . . CallOrConversion (
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . STRING "hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
    5: 16: . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 16: . . . . . . . . . . )
    5: 16: . . . . . . . . . )
    5: 16: . . . . . . . . )
    5: 16: . . . . . . . )
    5: 16: . . . . . . )
    5: 16: . . . . . )
    5: 16: . . . . )
    5: 16: . . . . ";"
    5: 17: . . . )
    5: 17: . . )
    5: 17: . )
    5: 17: )
=== RUN   TestFromTestdata/functype
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/functype
    1:  1: COMMENT
   17:  1: File (
   17:  1: . Declaration (
   17:  1: . . GenDecl(type) (
   17:  1: . . . "type"
   17:  6: . . . TypeSpec (
   17:  6: . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   17:  8: . . . . Type (
   17:  8: . . . . . StructType (
   17:  8: . . . . . . "struct"
   17: 15: . . . . . . "{"
   18:  2: . . . . . . FieldDecl (
   18:  2: . . . . . . . "*"
   18:  3: . . . . . . . QualifiedIdent (
   18:  3: . . . . . . . . TypeName (
   18:  3: . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   18:  4: . . . . . . . . )
   18:  4: . . . . . . . )
   18:  4: . . . . . . . ";"
   19:  2: . . . . . . )
   19:  2: . . . . . . FieldDecl (
   19:  2: . . . . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
   19:  4: . . . . . . . Type (
   19:  4: . . . . . . . . TypeName (
   19:  4: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   19:  8: . . . . . . . . )
   19:  8: . . . . . . . )
   19:  8: . . . . . . . STRING `json:"a"`
   19: 18: . . . . . . . ";"
   20:  1: . . . . . . )
   20:  1: . . . . . . "}"
   20:  2: . . . . . )
   20:  2: . . . . )
   20:  2: . . . . ";"
   22:  1: . . . )
   22:  1: . . )
   22:  1: . )
   22:  1: . Declaration (
   22:  1: . . FunctionDeclOrCall (
   22:  1: . . . "func"
   22:  6: . . . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
   22:  9: . . . Signature (
   22:  9: . . . . Parameters (
   22:  9: . . . . . "("
   22: 10: . . . . . ParameterList (
   22: 10: . . . . . . ParamDeclOrNil (
   22: 10: . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   22: 12: . . . . . . . Type (
   22: 12: . . . . . . . . ChanType (
   22: 12: . . . . . . . . . "chan"
   22: 17: . . . . . . . . . Type (
   22: 17: . . . . . . . . . . TypeName (
   22: 17: . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   22: 21: . . . . . . . . . . )
   22: 21: . . . . . . . . . )
   22: 21: . . . . . . . . )
   22: 21: . . . . . . . )
   22: 21: . . . . . . )
   22: 21: . . . . . )
   22: 21: . . . . . ")"
   22: 23: . . . . )
   22: 23: . . . . Result (
   22: 23: . . . . . Parameters (
   22: 23: . . . . . . "("
   22: 24: . . . . . . ParameterList (
   22: 24: . . . . . . . ParamDeclOrNil (
   22: 24: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   22: 27: . . . . . . . )
   22: 27: . . . . . . . ","
   22: 29: . . . . . . . ParamDeclOrNil (
   22: 29: . . . . . . . . Type (
   22: 29: . . . . . . . . . ChanType (
   22: 29: . . . . . . . . . . "<-"
   22: 31: . . . . . . . . . . "chan"
   22: 36: . . . . . . . . . . Type (
   22: 36: . . . . . . . . . . . TypeName (
   22: 36: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   22: 41: . . . . . . . . . . . )
   22: 41: . . . . . . . . . . )
   22: 41: . . . . . . . . . )
   22: 41: . . . . . . . . )
   22: 41: . . . . . . . )
   22: 41: . . . . . . )
   22: 41: . . . . . . ")"
   22: 43: . . . . . )
   22: 43: . . . . )
   22: 43: . . . )
   22: 43: . . . Body (
   22: 43: . . . . "{"
   23:  2: . . . . StatementList (
   23:  2: . . . . . Statement (
   23:  2: . . . . . . SimpleStmt (
   23:  2: . . . . . . . ExpressionList (
   23:  2: . . . . . . . . Expression (
   23:  2: . . . . . . . . . BinaryExpr (
   23:  2: . . . . . . . . . . UnaryExpr (
   23:  2: . . . . . . . . . . . PrimaryExpr (
   23:  2: . . . . . . . . . . . . Operand (
   23:  2: . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   23:  4: . . . . . . . . . . . . )
   23:  4: . . . . . . . . . . . . "<-"
   23:  4: . . . . . . . . . . . )
   23:  4: . . . . . . . . . . )
   23:  4: . . . . . . . . . )
   23:  4: . . . . . . . . )
   23:  4: . . . . . . . )
   23:  7: . . . . . . . Expression (
   23:  7: . . . . . . . . BinaryExpr (
   23:  7: . . . . . . . . . UnaryExpr (
   23:  7: . . . . . . . . . . PrimaryExpr (
   23:  7: . . . . . . . . . . . Operand (
   23:  7: . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   23: 11: . . . . . . . . . . . )
   23: 11: . . . . . . . . . . )
   23: 11: . . . . . . . . . )
   23: 11: . . . . . . . . )
   23: 11: . . . . . . . )
   23: 11: . . . . . . )
   23: 11: . . . . . . ";"
   24:  2: . . . . . )
   24:  2: . . . . . Statement (
   24:  2: . . . . . . SimpleStmt (
   24:  2: . . . . . . . ExpressionList (
   24:  2: . . . . . . . . Expression (
   24:  2: . . . . . . . . . BinaryExpr (
   24:  2: . . . . . . . . . . UnaryExpr (
   24:  2: . . . . . . . . . . . "<-"
   24:  4: . . . . . . . . . . . UnaryExpr (
   24:  4: . . . . . . . . . . . . PrimaryExpr (
   24:  4: . . . . . . . . . . . . . Operand (
   24:  4: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   24:  5: . . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . )
   24:  5: . . . . . . . . . . )
   24:  5: . . . . . . . . . )
   24:  5: . . . . . . . . )
   24:  5: . . . . . . . )
   24:  5: . . . . . . )
   24:  5: . . . . . . ";"
   25:  2: . . . . . )
   25:  2: . . . . . Statement (
   25:  2: . . . . . . ReturnStmt (
   25:  2: . . . . . . . "return"
   25:  9: . . . . . . . ExpressionList (
   25:  9: . . . . . . . . Expression (
   25:  9: . . . . . . . . . BinaryExpr (
   25:  9: . . . . . . . . . . UnaryExpr (
   25:  9: . . . . . . . . . . . PrimaryExpr (
   25:  9: . . . . . . . . . . . . Operand (
   25:  9: . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   25: 10: . . . . . . . . . . . . )
   25: 10: . . . . . . . . . . . )
   25: 10: . . . . . . . . . . )
   25: 10: . . . . . . . . . )
   25: 10: . . . . . . . . )
   25: 10: . . . . . . . . ","
   25: 12: . . . . . . . . Expression (
   25: 12: . . . . . . . . . BinaryExpr (
   25: 12: . . . . . . . . . . UnaryExpr (
   25: 12: . . . . . . . . . . . PrimaryExpr (
   25: 12: . . . . . . . . . . . . Operand (
   25: 12: . . . . . . . . . . . . . "("
   25: 13: . . . . . . . . . . . . . Expression (
   25: 13: . . . . . . . . . . . . . . BinaryExpr (
   25: 13: . . . . . . . . . . . . . . . UnaryExpr (
   25: 13: . . . . . . . . . . . . . . . . "<-"
   25: 15: . . . . . . . . . . . . . . . . UnaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . . Operand (
   25: 15: . . . . . . . . . . . . . . . . . . . ChanType (
   25: 15: . . . . . . . . . . . . . . . . . . . . "chan"
   25: 20: . . . . . . . . . . . . . . . . . . . . Type (
   25: 20: . . . . . . . . . . . . . . . . . . . . . TypeName (
   25: 20: . . . . . . . . . . . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   25: 25: . . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
   25: 26: . . . . . . . . . . . . )
   25: 26: . . . . . . . . . . . . CallOrConversion (
   25: 26: . . . . . . . . . . . . . "("
   25: 27: . . . . . . . . . . . . . Expression (
   25: 27: . . . . . . . . . . . . . . BinaryExpr (
   25: 27: . . . . . . . . . . . . . . . UnaryExpr (
   25: 27: . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 27: . . . . . . . . . . . . . . . . . Operand (
   25: 27: . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   25: 30: . . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0000f8180 762}, Ellipsis: false, isCmd: false}
   25: 31: . . . . . . . . . . . . )
   25: 31: . . . . . . . . . . . )
   25: 31: . . . . . . . . . . )
   25: 31: . . . . . . . . . )
   25: 31: . . . . . . . . )
   25: 31: . . . . . . . )
   25: 31: . . . . . . . ";"
   26:  1: . . . . . . )
   26:  1: . . . . . )
   26:  1: . . . . )
   26:  1: . . . . "}"
   26:  2: . . . )
   26:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
   28:  1: . . )
   28:  1: . )
   28:  1: . Declaration (
   28:  1: . . FunctionDeclOrCall (
   28:  1: . . . "func"
   28:  6: . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   28:  9: . . . Signature (
   28:  9: . . . . Parameters (
   28:  9: . . . . . "("
   28: 10: . . . . . ParameterList (
   28: 10: . . . . . . ParamDeclOrNil (
   28: 10: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   28: 12: . . . . . . . Type (
   28: 12: . . . . . . . . FuncType (
   28: 12: . . . . . . . . . "func"
   28: 16: . . . . . . . . . Signature (
   28: 16: . . . . . . . . . . Parameters (
   28: 16: . . . . . . . . . . . "("
   28: 17: . . . . . . . . . . . ParameterList (
   28: 17: . . . . . . . . . . . . ParamDeclOrNil (
   28: 17: . . . . . . . . . . . . . Type (
   28: 17: . . . . . . . . . . . . . . ArrayType (
   28: 17: . . . . . . . . . . . . . . . "["
   28: 18: . . . . . . . . . . . . . . . "]"
   28: 19: . . . . . . . . . . . . . . . Type (
   28: 19: . . . . . . . . . . . . . . . . TypeName (
   28: 19: . . . . . . . . . . . . . . . . . IDENT byte
 /app/parser/parser.go:713: ast.Ident{Name: byte}
   28: 23: . . . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
   28: 23: . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . ","
   28: 25: . . . . . . . . . . . . ParamDeclOrNil (
   28: 25: . . . . . . . . . . . . . Type (
   28: 25: . . . . . . . . . . . . . . PointerType (
   28: 25: . . . . . . . . . . . . . . . "*"
   28: 26: . . . . . . . . . . . . . . . Type (
   28: 26: . . . . . . . . . . . . . . . . TypeName (
   28: 26: . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   28: 32: . . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . ","
   28: 34: . . . . . . . . . . . . ParamDeclOrNil (
   28: 34: . . . . . . . . . . . . . DotsType (
   28: 34: . . . . . . . . . . . . . . "..."
   28: 37: . . . . . . . . . . . . . . Type (
   28: 37: . . . . . . . . . . . . . . . TypeName (
   28: 37: . . . . . . . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   28: 38: . . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . ")"
   28: 40: . . . . . . . . . . )
   28: 40: . . . . . . . . . . Result (
   28: 40: . . . . . . . . . . . ChanType (
   28: 40: . . . . . . . . . . . . "chan"
   28: 44: . . . . . . . . . . . . "<-"
   28: 47: . . . . . . . . . . . . Type (
   28: 47: . . . . . . . . . . . . . TypeName (
   28: 47: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 50: . . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . )
   28: 50: . . . . . . . . . . )
   28: 50: . . . . . . . . . )
   28: 50: . . . . . . . . )
   28: 50: . . . . . . . )
   28: 50: . . . . . . )
   28: 50: . . . . . )
   28: 50: . . . . . ")"
   28: 52: . . . . )
   28: 52: . . . . Result (
   28: 52: . . . . . Parameters (
   28: 52: . . . . . . "("
   28: 53: . . . . . . ParameterList (
   28: 53: . . . . . . . ParamDeclOrNil (
   28: 53: . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   28: 55: . . . . . . . . Type (
   28: 55: . . . . . . . . . TypeName (
   28: 55: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 58: . . . . . . . . . )
   28: 58: . . . . . . . . )
   28: 58: . . . . . . . )
   28: 58: . . . . . . . ","
   28: 60: . . . . . . . ParamDeclOrNil (
   28: 60: . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   28: 64: . . . . . . . . Type (
   28: 64: . . . . . . . . . TypeName (
   28: 64: . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   28: 69: . . . . . . . . . )
   28: 69: . . . . . . . . )
   28: 69: . . . . . . . )
   28: 69: . . . . . . )
   28: 69: . . . . . . ")"
   28: 71: . . . . . )
   28: 71: . . . . )
   28: 71: . . . )
   28: 71: . . . Body (
   28: 71: . . . . "{"
   29:  2: . . . . StatementList (
   29:  2: . . . . . Statement (
   29:  2: . . . . . . ReturnStmt (
   29:  2: . . . . . . . "return"
   29:  8: . . . . . . . ";"
   30:  1: . . . . . . )
   30:  1: . . . . . )
   30:  1: . . . . )
   30:  1: . . . . "}"
   30:  2: . . . )
   30:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
   30:  3: . . )
   30:  3: . )
   30:  3: )
=== RUN   TestFromTestdata/gmxtest
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/gmxtest
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . )
    1:  7: . . . . ";"
    1:  8: . . . )
    1:  8: . . )
    1:  8: . )
    1:  8: )
=== RUN   TestFromTestdata/goto1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/goto1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . BranchStmt (
    1:  1: . . . . . "goto"
    1:  1: . . . . . SimpleStmt (
    1:  1: . . . . . . ExpressionList (
    1:  1: . . . . . . . Expression (
    1:  1: . . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: goto}
    1:  6: . . . . . . . . . . . )
    1:  6: . . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . . STRING "a"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a"}
    1:  9: . . . . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: true}
    1:  9: . . . . . . . . . . . )
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . )
    1:  9: . . . . . . )
    1:  9: . . . . . )
    1:  9: . . . . . ";"
    2:  1: . . . . )
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . BranchStmt (
    2:  1: . . . . . "goto"
    2:  1: . . . . . SimpleStmt (
    2:  1: . . . . . . ExpressionList (
    2:  1: . . . . . . . Expression (
    2:  1: . . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: goto}
    2:  6: . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . CallOrConversion (
    2:  6: . . . . . . . . . . . . Expression (
    2:  6: . . . . . . . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2:  7: . . . . . . . . . . . . . . . . )
    2:  7: . . . . . . . . . . . . . . . )
    2:  7: . . . . . . . . . . . . . . )
    2:  7: . . . . . . . . . . . . . )
    2:  7: . . . . . . . . . . . . )
    2:  7: . . . . . . . . . . . . ","
    2:  9: . . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 10: . . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: true}
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . )
    2: 10: . . . . . . . . . )
    2: 10: . . . . . . . . )
    2: 10: . . . . . . . )
    2: 10: . . . . . . )
    2: 10: . . . . . )
    2: 10: . . . . . ";"
    3:  1: . . . . )
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . BranchStmt (
    3:  1: . . . . . "goto"
    3:  1: . . . . . SimpleStmt (
    3:  1: . . . . . . ExpressionList (
    3:  1: . . . . . . . Expression (
    3:  1: . . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: goto}
    3:  6: . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . CallOrConversion (
    3:  6: . . . . . . . . . . . . Expression (
    3:  6: . . . . . . . . . . . . . BinaryExpr (
    3:  6: . . . . . . . . . . . . . . UnaryExpr (
    3:  6: . . . . . . . . . . . . . . . PrimaryExpr (
    3:  6: . . . . . . . . . . . . . . . . Operand (
    3:  6: . . . . . . . . . . . . . . . . . "("
    3:  7: . . . . . . . . . . . . . . . . . Expression (
    3:  7: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  7: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  7: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  7: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  7: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3:  8: . . . . . . . . . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . . . . . . . "+"
    3:  9: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  9: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  9: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  9: . . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  9: . . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    3: 10: . . . . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{0xc0000f8930 27 + 0xc0000f8960}}
    3: 11: . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . "*"
    3: 12: . . . . . . . . . . . . . . BinaryExpr (
    3: 12: . . . . . . . . . . . . . . . UnaryExpr (
    3: 12: . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 12: . . . . . . . . . . . . . . . . . Operand (
    3: 12: . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    3: 13: . . . . . . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: true}
    3: 13: . . . . . . . . . . . )
    3: 13: . . . . . . . . . . )
    3: 13: . . . . . . . . . )
    3: 13: . . . . . . . . )
    3: 13: . . . . . . . )
    3: 13: . . . . . . )
    3: 13: . . . . . )
    3: 13: . . . . . ";"
    3: 14: . . . . )
    3: 14: . . . )
    3: 14: . . )
    3: 14: . )
    3: 14: )
=== RUN   TestFromTestdata/goto2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/goto2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . BranchStmt (
    1:  1: . . . . . "goto"
    1:  6: . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  6: . . . . . PrimaryExpr (
    1:  6: . . . . . . CallOrConversion (
    1:  6: . . . . . . . Expression (
    1:  6: . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  7: . . . . . . . . . . . )
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . . "+"
    1:  8: . . . . . . . . . BinaryExpr (
    1:  8: . . . . . . . . . . UnaryExpr (
    1:  8: . . . . . . . . . . . PrimaryExpr (
    1:  8: . . . . . . . . . . . . Operand (
    1:  8: . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    1:  9: . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . )
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: true}
    1:  9: . . . . . . )
    1:  9: . . . . . )
    1:  9: . . . . . ";"
    2:  1: . . . . )
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . BranchStmt (
    2:  1: . . . . . "goto"
    2:  6: . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  6: . . . . . PrimaryExpr (
    2:  6: . . . . . . CallOrConversion (
    2:  6: . . . . . . . Expression (
    2:  6: . . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  7: . . . . . . . . . . . )
    2:  7: . . . . . . . . . . )
    2:  7: . . . . . . . . . )
    2:  7: . . . . . . . . )
    2:  7: . . . . . . . )
    2:  7: . . . . . . . ","
    2:  9: . . . . . . . Expression (
    2:  9: . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . )
    2: 10: . . . . . . . . . )
    2: 10: . . . . . . . . )
    2: 10: . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: true}
    2: 10: . . . . . . )
    2: 10: . . . . . )
    2: 10: . . . . . ";"
    2: 11: . . . . )
    2: 11: . . . )
    2: 11: . . )
    2: 11: . )
    2: 11: )
=== RUN   TestFromTestdata/goxtest1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/goxtest1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(var) (
    1:  1: . . . "var"
    1:  5: . . . "("
    2:  2: . . . varSpec (
    2:  2: . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
    2:  4: . . . . STRING `json:"a"`
    2: 14: . . . . ";"
    3:  2: . . . )
    3:  2: . . . varSpec (
    3:  2: . . . . "*"
    3:  3: . . . . IDENT B
 /app/parser/parser.go:713: ast.Ident{Name: B}
    3:  4: . . . . ";"
    4:  2: . . . )
    4:  2: . . . varSpec (
    4:  2: . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4:  3: . . . . ","
    4:  5: . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    4:  7: . . . . TypeName (
    4:  7: . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    4: 13: . . . . )
    4: 13: . . . . ";"
    5:  2: . . . )
    5:  2: . . . varSpec (
    5:  2: . . . . IDENT C
 /app/parser/parser.go:713: ast.Ident{Name: C}
    5:  3: . . . . "."
    5:  4: . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
    5:  7: . . . . STRING `json:"ca"`
    5: 18: . . . . ";"
    6:  2: . . . )
    6:  2: . . . varSpec (
    6:  2: . . . . "*"
    6:  3: . . . . IDENT C
 /app/parser/parser.go:713: ast.Ident{Name: C}
    6:  4: . . . . "."
    6:  5: . . . . IDENT B
 /app/parser/parser.go:713: ast.Ident{Name: B}
    6:  7: . . . . STRING `json:"b"`
    6: 17: . . . . ";"
    7:  2: . . . )
    7:  2: . . . varSpec (
    7:  2: . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    7:  7: . . . . TypeName (
    7:  7: . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 11: . . . . )
    7: 11: . . . . STRING `json:"v"`
    7: 21: . . . . ";"
    8:  1: . . . )
    8:  1: . . . ")"
    8:  2: . . . ";"
   10:  1: . . )
   10:  1: . )
   10:  1: . Declaration (
   10:  1: . . GenDecl(type) (
   10:  1: . . . "type"
   10:  6: . . . TypeSpec (
   10:  6: . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
   10:  8: . . . . Type (
   10:  8: . . . . . StructType (
   10:  8: . . . . . . "struct"
   10: 14: . . . . . . "{"
   10: 15: . . . . . . "}"
   10: 16: . . . . . )
   10: 16: . . . . )
   10: 16: . . . . ";"
   12:  1: . . . )
   12:  1: . . )
   12:  1: . )
   12:  1: . Declaration (
   12:  1: . . GenDecl(type) (
   12:  1: . . . "type"
   12:  6: . . . TypeSpec (
   12:  6: . . . . IDENT B
 /app/parser/parser.go:713: ast.Ident{Name: B}
   12:  8: . . . . Type (
   12:  8: . . . . . StructType (
   12:  8: . . . . . . "struct"
   12: 14: . . . . . . "{"
   12: 15: . . . . . . "}"
   12: 16: . . . . . )
   12: 16: . . . . )
   12: 16: . . . . ";"
   12: 17: . . . )
   12: 17: . . )
   12: 17: . )
   12: 17: )
=== RUN   TestFromTestdata/goxtest2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/goxtest2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(var) (
    1:  1: . . . "var"
    1:  5: . . . "("
    2:  2: . . . varSpec (
    2:  2: . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  3: . . . . "."
    2:  4: . . . . IDENT App
 /app/parser/parser.go:713: ast.Ident{Name: App}
    2:  7: . . . . ";"
    3:  1: . . . )
    3:  1: . . . ")"
    3:  2: . . . ";"
    3:  3: . . )
    3:  3: . )
    3:  3: )
=== RUN   TestFromTestdata/kwargs1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/kwargs1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT playSound
 /app/parser/parser.go:713: ast.Ident{Name: playSound}
    1: 11: . . . . . . . . . . )
    1: 11: . . . . . . . . . . CallOrConversion (
    1: 11: . . . . . . . . . . . Expression (
    1: 11: . . . . . . . . . . . . BinaryExpr (
    1: 11: . . . . . . . . . . . . . UnaryExpr (
    1: 11: . . . . . . . . . . . . . . PrimaryExpr (
    1: 11: . . . . . . . . . . . . . . . Operand (
    1: 11: . . . . . . . . . . . . . . . . IDENT getUrl
 /app/parser/parser.go:713: ast.Ident{Name: getUrl}
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . CallOrConversion (
    1: 17: . . . . . . . . . . . . . . . . "("
    1: 18: . . . . . . . . . . . . . . . . Expression (
    1: 18: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 18: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 18: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 18: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 18: . . . . . . . . . . . . . . . . . . . . . STRING "1.mp3"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "1.mp3"}
    1: 25: . . . . . . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . . . ","
    1: 27: . . . . . . . . . . . . . . . . Expression (
    1: 27: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 27: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 27: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 27: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 27: . . . . . . . . . . . . . . . . . . . . . IDENT cache
 /app/parser/parser.go:713: ast.Ident{Name: cache}
    1: 33: . . . . . . . . . . . . . . . . . . . . )
    1: 33: . . . . . . . . . . . . . . . . . . . . "="
    1: 35: . . . . . . . . . . . . . . . . . . . . Expression (
    1: 35: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 35: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 35: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 35: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 35: . . . . . . . . . . . . . . . . . . . . . . . . . IDENT false
 /app/parser/parser.go:713: ast.Ident{Name: false}
    1: 40: . . . . . . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: getUrl, Ellipsis: false, isCmd: false}
    1: 41: . . . . . . . . . . . . . . . )
    1: 41: . . . . . . . . . . . . . . )
    1: 41: . . . . . . . . . . . . . )
    1: 41: . . . . . . . . . . . . )
    1: 41: . . . . . . . . . . . )
    1: 41: . . . . . . . . . . . ","
    1: 43: . . . . . . . . . . . Expression (
    1: 43: . . . . . . . . . . . . BinaryExpr (
    1: 43: . . . . . . . . . . . . . UnaryExpr (
    1: 43: . . . . . . . . . . . . . . PrimaryExpr (
    1: 43: . . . . . . . . . . . . . . . Operand (
    1: 43: . . . . . . . . . . . . . . . . IDENT loop
 /app/parser/parser.go:713: ast.Ident{Name: loop}
    1: 48: . . . . . . . . . . . . . . . )
    1: 48: . . . . . . . . . . . . . . . "="
    1: 50: . . . . . . . . . . . . . . . Expression (
    1: 50: . . . . . . . . . . . . . . . . BinaryExpr (
    1: 50: . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 50: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 50: . . . . . . . . . . . . . . . . . . . Operand (
    1: 50: . . . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
    1: 54: . . . . . . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: playSound, Ellipsis: false, isCmd: true}
    1: 54: . . . . . . . . . . )
    1: 54: . . . . . . . . . )
    1: 54: . . . . . . . . )
    1: 54: . . . . . . . )
    1: 54: . . . . . . )
    1: 54: . . . . . )
    1: 54: . . . . )
    1: 54: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT listDir
 /app/parser/parser.go:713: ast.Ident{Name: listDir}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT withHidden
 /app/parser/parser.go:713: ast.Ident{Name: withHidden}
    2: 20: . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . "="
    2: 22: . . . . . . . . . . . . . . . Expression (
    2: 22: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . . Operand (
    2: 22: . . . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
    2: 26: . . . . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . ","
    2: 28: . . . . . . . . . . . Expression (
    2: 28: . . . . . . . . . . . . BinaryExpr (
    2: 28: . . . . . . . . . . . . . UnaryExpr (
    2: 28: . . . . . . . . . . . . . . PrimaryExpr (
    2: 28: . . . . . . . . . . . . . . . Operand (
    2: 28: . . . . . . . . . . . . . . . . IDENT recursive
 /app/parser/parser.go:713: ast.Ident{Name: recursive}
    2: 38: . . . . . . . . . . . . . . . )
    2: 38: . . . . . . . . . . . . . . . "="
    2: 40: . . . . . . . . . . . . . . . Expression (
    2: 40: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 40: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 40: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 40: . . . . . . . . . . . . . . . . . . . Operand (
    2: 40: . . . . . . . . . . . . . . . . . . . . IDENT false
 /app/parser/parser.go:713: ast.Ident{Name: false}
    2: 45: . . . . . . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: listDir, Ellipsis: false, isCmd: true}
    2: 45: . . . . . . . . . . )
    2: 45: . . . . . . . . . )
    2: 45: . . . . . . . . )
    2: 45: . . . . . . . )
    2: 45: . . . . . . )
    2: 45: . . . . . )
    2: 45: . . . . )
    2: 45: . . . . ";"
    2: 46: . . . )
    2: 46: . . )
    2: 46: . )
    2: 46: )
=== RUN   TestFromTestdata/lambda1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/lambda1
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . SimpleStmt (
    4:  2: . . . . . . . ExpressionList (
    4:  2: . . . . . . . . Expression (
    4:  2: . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4:  5: . . . . . . . . . . . . )
    4:  5: . . . . . . . . . . . . CallOrConversion (
    4:  5: . . . . . . . . . . . . . "("
    4:  6: . . . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . . . "=>"
    4:  9: . . . . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . . . . Operand (
    4:  9: . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    4: 13: . . . . . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
    4: 13: . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    4: 14: . . . . . . . . . . . . )
    4: 14: . . . . . . . . . . . )
    4: 14: . . . . . . . . . . )
    4: 14: . . . . . . . . . )
    4: 14: . . . . . . . . )
    4: 14: . . . . . . . )
    4: 14: . . . . . . )
    4: 14: . . . . . . ";"
    5:  2: . . . . . )
    5:  2: . . . . . Statement (
    5:  2: . . . . . . SimpleStmt (
    5:  2: . . . . . . . ExpressionList (
    5:  2: . . . . . . . . Expression (
    5:  2: . . . . . . . . . BinaryExpr (
    5:  2: . . . . . . . . . . UnaryExpr (
    5:  2: . . . . . . . . . . . PrimaryExpr (
    5:  2: . . . . . . . . . . . . Operand (
    5:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    5:  5: . . . . . . . . . . . . )
    5:  5: . . . . . . . . . . . . CallOrConversion (
    5:  5: . . . . . . . . . . . . . "("
    5:  6: . . . . . . . . . . . . . Expression (
    5:  6: . . . . . . . . . . . . . . BinaryExpr (
    5:  6: . . . . . . . . . . . . . . . UnaryExpr (
    5:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    5:  6: . . . . . . . . . . . . . . . . . Operand (
    5:  6: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5:  8: . . . . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . "=>"
    5: 11: . . . . . . . . . . . . . . Expression (
    5: 11: . . . . . . . . . . . . . . . BinaryExpr (
    5: 11: . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5: 13: . . . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . . "*"
    5: 15: . . . . . . . . . . . . . . . . BinaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . . . Operand (
    5: 15: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5: 16: . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
    5: 16: . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    5: 17: . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . )
    5: 17: . . . . . . . . . . )
    5: 17: . . . . . . . . . )
    5: 17: . . . . . . . . )
    5: 17: . . . . . . . )
    5: 17: . . . . . . )
    5: 17: . . . . . . ";"
    6:  2: . . . . . )
    6:  2: . . . . . Statement (
    6:  2: . . . . . . SimpleStmt (
    6:  2: . . . . . . . ExpressionList (
    6:  2: . . . . . . . . Expression (
    6:  2: . . . . . . . . . BinaryExpr (
    6:  2: . . . . . . . . . . UnaryExpr (
    6:  2: . . . . . . . . . . . PrimaryExpr (
    6:  2: . . . . . . . . . . . . Operand (
    6:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    6:  5: . . . . . . . . . . . . )
    6:  5: . . . . . . . . . . . . CallOrConversion (
    6:  5: . . . . . . . . . . . . . "("
    6:  6: . . . . . . . . . . . . . Expression (
    6:  6: . . . . . . . . . . . . . . BinaryExpr (
    6:  6: . . . . . . . . . . . . . . . UnaryExpr (
    6:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    6:  6: . . . . . . . . . . . . . . . . . Operand (
    6:  6: . . . . . . . . . . . . . . . . . . "("
    6:  7: . . . . . . . . . . . . . . . . . . Expression (
    6:  7: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6:  7: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6:  7: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6:  7: . . . . . . . . . . . . . . . . . . . . . . Operand (
    6:  7: . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6:  8: . . . . . . . . . . . . . . . . . . . . . . )
    6:  8: . . . . . . . . . . . . . . . . . . . . . )
    6:  8: . . . . . . . . . . . . . . . . . . . . )
    6:  8: . . . . . . . . . . . . . . . . . . . )
    6:  8: . . . . . . . . . . . . . . . . . . )
    6:  8: . . . . . . . . . . . . . . . . . . ","
    6: 10: . . . . . . . . . . . . . . . . . . Expression (
    6: 10: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 10: . . . . . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    6: 11: . . . . . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . ")"
    6: 13: . . . . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . . "=>"
    6: 16: . . . . . . . . . . . . . . Expression (
    6: 16: . . . . . . . . . . . . . . . BinaryExpr (
    6: 16: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 16: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 16: . . . . . . . . . . . . . . . . . . Operand (
    6: 16: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 18: . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . "+"
    6: 20: . . . . . . . . . . . . . . . . BinaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . . . Operand (
    6: 20: . . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    6: 21: . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x y]}
    6: 21: . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    6: 22: . . . . . . . . . . . . )
    6: 22: . . . . . . . . . . . )
    6: 22: . . . . . . . . . . )
    6: 22: . . . . . . . . . )
    6: 22: . . . . . . . . )
    6: 22: . . . . . . . )
    6: 22: . . . . . . )
    6: 22: . . . . . . ";"
    7:  2: . . . . . )
    7:  2: . . . . . Statement (
    7:  2: . . . . . . SimpleStmt (
    7:  2: . . . . . . . ExpressionList (
    7:  2: . . . . . . . . Expression (
    7:  2: . . . . . . . . . BinaryExpr (
    7:  2: . . . . . . . . . . UnaryExpr (
    7:  2: . . . . . . . . . . . PrimaryExpr (
    7:  2: . . . . . . . . . . . . Operand (
    7:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    7:  5: . . . . . . . . . . . . )
    7:  5: . . . . . . . . . . . . CallOrConversion (
    7:  5: . . . . . . . . . . . . . "("
    7:  6: . . . . . . . . . . . . . Expression (
    7:  6: . . . . . . . . . . . . . . BinaryExpr (
    7:  6: . . . . . . . . . . . . . . . UnaryExpr (
    7:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  6: . . . . . . . . . . . . . . . . . Operand (
    7:  6: . . . . . . . . . . . . . . . . . . "("
    7:  7: . . . . . . . . . . . . . . . . . . Expression (
    7:  7: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7:  7: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7:  7: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  7: . . . . . . . . . . . . . . . . . . . . . . Operand (
    7:  7: . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  8: . . . . . . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: x}
    7: 10: . . . . . . . . . . . . . . . . . )
    7: 10: . . . . . . . . . . . . . . . . )
    7: 10: . . . . . . . . . . . . . . . )
    7: 10: . . . . . . . . . . . . . . )
    7: 10: . . . . . . . . . . . . . . "=>"
    7: 13: . . . . . . . . . . . . . . "("
    7: 14: . . . . . . . . . . . . . . Expression (
    7: 14: . . . . . . . . . . . . . . . BinaryExpr (
    7: 14: . . . . . . . . . . . . . . . . UnaryExpr (
    7: 14: . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 14: . . . . . . . . . . . . . . . . . . Operand (
    7: 14: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7: 15: . . . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . ","
    7: 17: . . . . . . . . . . . . . . Expression (
    7: 17: . . . . . . . . . . . . . . . BinaryExpr (
    7: 17: . . . . . . . . . . . . . . . . UnaryExpr (
    7: 17: . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 17: . . . . . . . . . . . . . . . . . . Operand (
    7: 17: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7: 19: . . . . . . . . . . . . . . . . . . )
    7: 19: . . . . . . . . . . . . . . . . . )
    7: 19: . . . . . . . . . . . . . . . . )
    7: 19: . . . . . . . . . . . . . . . . "*"
    7: 21: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 21: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 21: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 21: . . . . . . . . . . . . . . . . . . . Operand (
    7: 21: . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    7: 22: . . . . . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
    7: 23: . . . . . . . . . . . . . )
    7: 23: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    7: 24: . . . . . . . . . . . . )
    7: 24: . . . . . . . . . . . )
    7: 24: . . . . . . . . . . )
    7: 24: . . . . . . . . . )
    7: 24: . . . . . . . . )
    7: 24: . . . . . . . )
    7: 24: . . . . . . )
    7: 24: . . . . . . ";"
    8:  2: . . . . . )
    8:  2: . . . . . Statement (
    8:  2: . . . . . . SimpleStmt (
    8:  2: . . . . . . . ExpressionList (
    8:  2: . . . . . . . . Expression (
    8:  2: . . . . . . . . . BinaryExpr (
    8:  2: . . . . . . . . . . UnaryExpr (
    8:  2: . . . . . . . . . . . PrimaryExpr (
    8:  2: . . . . . . . . . . . . Operand (
    8:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    8:  5: . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . CallOrConversion (
    8:  5: . . . . . . . . . . . . . "("
    8:  6: . . . . . . . . . . . . . Expression (
    8:  6: . . . . . . . . . . . . . . BinaryExpr (
    8:  6: . . . . . . . . . . . . . . . UnaryExpr (
    8:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    8:  6: . . . . . . . . . . . . . . . . . Operand (
    8:  6: . . . . . . . . . . . . . . . . . . "("
    8:  7: . . . . . . . . . . . . . . . . . . ")"
    8:  9: . . . . . . . . . . . . . . . . . )
    8:  9: . . . . . . . . . . . . . . . . )
    8:  9: . . . . . . . . . . . . . . . )
    8:  9: . . . . . . . . . . . . . . )
    8:  9: . . . . . . . . . . . . . . "=>"
    8: 12: . . . . . . . . . . . . . . Expression (
    8: 12: . . . . . . . . . . . . . . . BinaryExpr (
    8: 12: . . . . . . . . . . . . . . . . UnaryExpr (
    8: 12: . . . . . . . . . . . . . . . . . PrimaryExpr (
    8: 12: . . . . . . . . . . . . . . . . . . Operand (
    8: 12: . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    8: 16: . . . . . . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
    8: 16: . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    8: 17: . . . . . . . . . . . . )
    8: 17: . . . . . . . . . . . )
    8: 17: . . . . . . . . . . )
    8: 17: . . . . . . . . . )
    8: 17: . . . . . . . . )
    8: 17: . . . . . . . )
    8: 17: . . . . . . )
    8: 17: . . . . . . ";"
    9:  1: . . . . . )
    9:  1: . . . . )
    9:  1: . . . . "}"
    9:  2: . . . )
    9:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
    9:  3: . . )
    9:  3: . )
    9:  3: )
=== RUN   TestFromTestdata/lambda2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/lambda2
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . SimpleStmt (
    4:  2: . . . . . . . ExpressionList (
    4:  2: . . . . . . . . Expression (
    4:  2: . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4:  5: . . . . . . . . . . . . )
    4:  5: . . . . . . . . . . . . CallOrConversion (
    4:  5: . . . . . . . . . . . . . "("
    4:  6: . . . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . . . "=>"
    4:  9: . . . . . . . . . . . . . . BlockStmt (
    4:  9: . . . . . . . . . . . . . . . "{"
    5:  3: . . . . . . . . . . . . . . . StatementList (
    5:  3: . . . . . . . . . . . . . . . . Statement (
    5:  3: . . . . . . . . . . . . . . . . . SimpleStmt (
    5:  3: . . . . . . . . . . . . . . . . . . ExpressionList (
    5:  3: . . . . . . . . . . . . . . . . . . . Expression (
    5:  3: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 10: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    5: 10: . . . . . . . . . . . . . . . . . . . . . . . . "("
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 16: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . ";"
    6:  2: . . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . . "}"
    6:  3: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
    6:  3: . . . . . . . . . . . . . )
    6:  3: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    6:  4: . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . )
    6:  4: . . . . . . . . . . )
    6:  4: . . . . . . . . . )
    6:  4: . . . . . . . . )
    6:  4: . . . . . . . )
    6:  4: . . . . . . )
    6:  4: . . . . . . ";"
    7:  2: . . . . . )
    7:  2: . . . . . Statement (
    7:  2: . . . . . . SimpleStmt (
    7:  2: . . . . . . . ExpressionList (
    7:  2: . . . . . . . . Expression (
    7:  2: . . . . . . . . . BinaryExpr (
    7:  2: . . . . . . . . . . UnaryExpr (
    7:  2: . . . . . . . . . . . PrimaryExpr (
    7:  2: . . . . . . . . . . . . Operand (
    7:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    7:  5: . . . . . . . . . . . . )
    7:  5: . . . . . . . . . . . . CallOrConversion (
    7:  5: . . . . . . . . . . . . . "("
    7:  6: . . . . . . . . . . . . . Expression (
    7:  6: . . . . . . . . . . . . . . BinaryExpr (
    7:  6: . . . . . . . . . . . . . . . UnaryExpr (
    7:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  6: . . . . . . . . . . . . . . . . . Operand (
    7:  6: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  8: . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . "=>"
    7: 11: . . . . . . . . . . . . . . BlockStmt (
    7: 11: . . . . . . . . . . . . . . . "{"
    8:  3: . . . . . . . . . . . . . . . StatementList (
    8:  3: . . . . . . . . . . . . . . . . Statement (
    8:  3: . . . . . . . . . . . . . . . . . SimpleStmt (
    8:  3: . . . . . . . . . . . . . . . . . . ExpressionList (
    8:  3: . . . . . . . . . . . . . . . . . . . Expression (
    8:  3: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . . Operand (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    8: 10: . . . . . . . . . . . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    8: 10: . . . . . . . . . . . . . . . . . . . . . . . . "("
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    8: 13: . . . . . . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . ";"
    9:  2: . . . . . . . . . . . . . . . . )
    9:  2: . . . . . . . . . . . . . . . )
    9:  2: . . . . . . . . . . . . . . . "}"
    9:  3: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
    9:  3: . . . . . . . . . . . . . )
    9:  3: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    9:  4: . . . . . . . . . . . . )
    9:  4: . . . . . . . . . . . )
    9:  4: . . . . . . . . . . )
    9:  4: . . . . . . . . . )
    9:  4: . . . . . . . . )
    9:  4: . . . . . . . )
    9:  4: . . . . . . )
    9:  4: . . . . . . ";"
   10:  2: . . . . . )
   10:  2: . . . . . Statement (
   10:  2: . . . . . . SimpleStmt (
   10:  2: . . . . . . . ExpressionList (
   10:  2: . . . . . . . . Expression (
   10:  2: . . . . . . . . . BinaryExpr (
   10:  2: . . . . . . . . . . UnaryExpr (
   10:  2: . . . . . . . . . . . PrimaryExpr (
   10:  2: . . . . . . . . . . . . Operand (
   10:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   10:  5: . . . . . . . . . . . . )
   10:  5: . . . . . . . . . . . . CallOrConversion (
   10:  5: . . . . . . . . . . . . . "("
   10:  6: . . . . . . . . . . . . . Expression (
   10:  6: . . . . . . . . . . . . . . BinaryExpr (
   10:  6: . . . . . . . . . . . . . . . UnaryExpr (
   10:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
   10:  6: . . . . . . . . . . . . . . . . . Operand (
   10:  6: . . . . . . . . . . . . . . . . . . "("
   10:  7: . . . . . . . . . . . . . . . . . . Expression (
   10:  7: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10:  7: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10:  7: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10:  7: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10:  7: . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   10:  8: . . . . . . . . . . . . . . . . . . . . . . )
   10:  8: . . . . . . . . . . . . . . . . . . . . . )
   10:  8: . . . . . . . . . . . . . . . . . . . . )
   10:  8: . . . . . . . . . . . . . . . . . . . )
   10:  8: . . . . . . . . . . . . . . . . . . )
   10:  8: . . . . . . . . . . . . . . . . . . ","
   10: 10: . . . . . . . . . . . . . . . . . . Expression (
   10: 10: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 10: . . . . . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
   10: 11: . . . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . ")"
   10: 13: . . . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . "=>"
   10: 16: . . . . . . . . . . . . . . BlockStmt (
   10: 16: . . . . . . . . . . . . . . . "{"
   11:  3: . . . . . . . . . . . . . . . StatementList (
   11:  3: . . . . . . . . . . . . . . . . Statement (
   11:  3: . . . . . . . . . . . . . . . . . SimpleStmt (
   11:  3: . . . . . . . . . . . . . . . . . . ExpressionList (
   11:  3: . . . . . . . . . . . . . . . . . . . Expression (
   11:  3: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11:  3: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11:  3: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11:  3: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11:  3: . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . . "("
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . ","
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   11: 16: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . ";"
   12:  2: . . . . . . . . . . . . . . . . )
   12:  2: . . . . . . . . . . . . . . . )
   12:  2: . . . . . . . . . . . . . . . "}"
   12:  3: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x y]}
   12:  3: . . . . . . . . . . . . . )
   12:  3: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
   12:  4: . . . . . . . . . . . . )
   12:  4: . . . . . . . . . . . )
   12:  4: . . . . . . . . . . )
   12:  4: . . . . . . . . . )
   12:  4: . . . . . . . . )
   12:  4: . . . . . . . )
   12:  4: . . . . . . )
   12:  4: . . . . . . ";"
   13:  1: . . . . . )
   13:  1: . . . . )
   13:  1: . . . . "}"
   13:  2: . . . )
   13:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   13:  3: . . )
   13:  3: . )
   13:  3: )
=== RUN   TestFromTestdata/lambda3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/lambda3
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . SimpleStmt (
    4:  2: . . . . . . . ExpressionList (
    4:  2: . . . . . . . . Expression (
    4:  2: . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4:  6: . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . CallOrConversion (
    4:  6: . . . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . . . "=>"
    4:  9: . . . . . . . . . . . . . . BlockStmt (
    4:  9: . . . . . . . . . . . . . . . "{"
    5:  3: . . . . . . . . . . . . . . . StatementList (
    5:  3: . . . . . . . . . . . . . . . . Statement (
    5:  3: . . . . . . . . . . . . . . . . . SimpleStmt (
    5:  3: . . . . . . . . . . . . . . . . . . ExpressionList (
    5:  3: . . . . . . . . . . . . . . . . . . . Expression (
    5:  3: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . ";"
    6:  2: . . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . . "}"
    6:  3: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
    6:  3: . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: true}
    6:  3: . . . . . . . . . . . . )
    6:  3: . . . . . . . . . . . )
    6:  3: . . . . . . . . . . )
    6:  3: . . . . . . . . . )
    6:  3: . . . . . . . . )
    6:  3: . . . . . . . )
    6:  3: . . . . . . )
    6:  3: . . . . . . ";"
    7:  2: . . . . . )
    7:  2: . . . . . Statement (
    7:  2: . . . . . . SimpleStmt (
    7:  2: . . . . . . . ExpressionList (
    7:  2: . . . . . . . . Expression (
    7:  2: . . . . . . . . . BinaryExpr (
    7:  2: . . . . . . . . . . UnaryExpr (
    7:  2: . . . . . . . . . . . PrimaryExpr (
    7:  2: . . . . . . . . . . . . Operand (
    7:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    7:  6: . . . . . . . . . . . . )
    7:  6: . . . . . . . . . . . . CallOrConversion (
    7:  6: . . . . . . . . . . . . . Expression (
    7:  6: . . . . . . . . . . . . . . BinaryExpr (
    7:  6: . . . . . . . . . . . . . . . UnaryExpr (
    7:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  6: . . . . . . . . . . . . . . . . . Operand (
    7:  6: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  8: . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . "=>"
    7: 11: . . . . . . . . . . . . . . BlockStmt (
    7: 11: . . . . . . . . . . . . . . . "{"
    8:  3: . . . . . . . . . . . . . . . StatementList (
    8:  3: . . . . . . . . . . . . . . . . Statement (
    8:  3: . . . . . . . . . . . . . . . . . SimpleStmt (
    8:  3: . . . . . . . . . . . . . . . . . . ExpressionList (
    8:  3: . . . . . . . . . . . . . . . . . . . Expression (
    8:  3: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . . Operand (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . )
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . ";"
    9:  2: . . . . . . . . . . . . . . . . )
    9:  2: . . . . . . . . . . . . . . . )
    9:  2: . . . . . . . . . . . . . . . "}"
    9:  3: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
    9:  3: . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: true}
    9:  3: . . . . . . . . . . . . )
    9:  3: . . . . . . . . . . . )
    9:  3: . . . . . . . . . . )
    9:  3: . . . . . . . . . )
    9:  3: . . . . . . . . )
    9:  3: . . . . . . . )
    9:  3: . . . . . . )
    9:  3: . . . . . . ";"
   10:  1: . . . . . )
   10:  1: . . . . )
   10:  1: . . . . "}"
   10:  2: . . . )
   10:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   10:  3: . . )
   10:  3: . )
   10:  3: )
=== RUN   TestFromTestdata/lambda4
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/lambda4
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(type) (
    1:  1: . . . "type"
    1:  6: . . . TypeSpec (
    1:  6: . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
    1: 10: . . . . Type (
    1: 10: . . . . . StructType (
    1: 10: . . . . . . "struct"
    1: 17: . . . . . . "{"
    2:  2: . . . . . . FieldDecl (
    2:  2: . . . . . . . IDENT Plot
 /app/parser/parser.go:713: ast.Ident{Name: Plot}
    2:  7: . . . . . . . Type (
    2:  7: . . . . . . . . FuncType (
    2:  7: . . . . . . . . . "func"
    2: 11: . . . . . . . . . Signature (
    2: 11: . . . . . . . . . . Parameters (
    2: 11: . . . . . . . . . . . "("
    2: 12: . . . . . . . . . . . ParameterList (
    2: 12: . . . . . . . . . . . . ParamDeclOrNil (
    2: 12: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 14: . . . . . . . . . . . . . Type (
    2: 14: . . . . . . . . . . . . . . TypeName (
    2: 14: . . . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    2: 21: . . . . . . . . . . . . . . )
    2: 21: . . . . . . . . . . . . . )
    2: 21: . . . . . . . . . . . . )
    2: 21: . . . . . . . . . . . )
    2: 21: . . . . . . . . . . . ")"
    2: 23: . . . . . . . . . . )
    2: 23: . . . . . . . . . . Result (
    2: 23: . . . . . . . . . . . Parameters (
    2: 23: . . . . . . . . . . . . "("
    2: 24: . . . . . . . . . . . . ParameterList (
    2: 24: . . . . . . . . . . . . . ParamDeclOrNil (
    2: 24: . . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    2: 31: . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . ","
    2: 33: . . . . . . . . . . . . . ParamDeclOrNil (
    2: 33: . . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    2: 40: . . . . . . . . . . . . . )
    2: 40: . . . . . . . . . . . . )
    2: 40: . . . . . . . . . . . . ")"
    2: 41: . . . . . . . . . . . )
    2: 41: . . . . . . . . . . )
    2: 41: . . . . . . . . . )
    2: 41: . . . . . . . . )
    2: 41: . . . . . . . )
    2: 41: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . . "}"
    3:  2: . . . . . )
    3:  2: . . . . )
    3:  2: . . . . ";"
    5:  1: . . . )
    5:  1: . . )
    5:  1: . )
    5:  1: . Declaration (
    5:  1: . . StatementList (
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . "&"
    5:  2: . . . . . . . . . UnaryExpr (
    5:  2: . . . . . . . . . . PrimaryExpr (
    5:  2: . . . . . . . . . . . Operand (
    5:  2: . . . . . . . . . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
    5:  5: . . . . . . . . . . . )
    5:  5: . . . . . . . . . . . LiteralValue (
    5:  5: . . . . . . . . . . . . "{"
    6:  2: . . . . . . . . . . . . ElementList (
    6:  2: . . . . . . . . . . . . . Element (
    6:  2: . . . . . . . . . . . . . . Element (
    6:  2: . . . . . . . . . . . . . . . Expression (
    6:  2: . . . . . . . . . . . . . . . . BinaryExpr (
    6:  2: . . . . . . . . . . . . . . . . . UnaryExpr (
    6:  2: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6:  2: . . . . . . . . . . . . . . . . . . . Operand (
    6:  2: . . . . . . . . . . . . . . . . . . . . IDENT Plot
 /app/parser/parser.go:713: ast.Ident{Name: Plot}
    6:  6: . . . . . . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . ":"
    6:  8: . . . . . . . . . . . . . . Element (
    6:  8: . . . . . . . . . . . . . . . Expression (
    6:  8: . . . . . . . . . . . . . . . . BinaryExpr (
    6:  8: . . . . . . . . . . . . . . . . . UnaryExpr (
    6:  8: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6:  8: . . . . . . . . . . . . . . . . . . . Operand (
    6:  8: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 10: . . . . . . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . . . "=>"
    6: 13: . . . . . . . . . . . . . . . . "("
    6: 14: . . . . . . . . . . . . . . . . Expression (
    6: 14: . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 14: . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 14: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 14: . . . . . . . . . . . . . . . . . . . . Operand (
    6: 14: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 16: . . . . . . . . . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . . . . . . . "*"
    6: 18: . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 18: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 18: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 18: . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 18: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    6: 19: . . . . . . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . ","
    6: 21: . . . . . . . . . . . . . . . . Expression (
    6: 21: . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 21: . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 21: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 21: . . . . . . . . . . . . . . . . . . . . Operand (
    6: 21: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 23: . . . . . . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . . . . . "*"
    6: 25: . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 25: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 25: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 25: . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 25: . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 26: . . . . . . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
    6: 27: . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . ","
    7:  1: . . . . . . . . . . . . )
    7:  1: . . . . . . . . . . . . "}"
    7:  2: . . . . . . . . . . . )
    7:  2: . . . . . . . . . . )
    7:  2: . . . . . . . . . )
    7:  2: . . . . . . . . )
    7:  2: . . . . . . . )
    7:  2: . . . . . . )
    7:  2: . . . . . )
    7:  2: . . . . )
    7:  2: . . . . ";"
    9:  1: . . . )
    9:  1: . . . Statement (
    9:  1: . . . . SimpleStmt (
    9:  1: . . . . . ExpressionList (
    9:  1: . . . . . . Expression (
    9:  1: . . . . . . . BinaryExpr (
    9:  1: . . . . . . . . UnaryExpr (
    9:  1: . . . . . . . . . "&"
    9:  2: . . . . . . . . . UnaryExpr (
    9:  2: . . . . . . . . . . PrimaryExpr (
    9:  2: . . . . . . . . . . . Operand (
    9:  2: . . . . . . . . . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
    9:  5: . . . . . . . . . . . )
    9:  5: . . . . . . . . . . . LiteralValue (
    9:  5: . . . . . . . . . . . . "{"
   10:  2: . . . . . . . . . . . . ElementList (
   10:  2: . . . . . . . . . . . . . Element (
   10:  2: . . . . . . . . . . . . . . Element (
   10:  2: . . . . . . . . . . . . . . . Expression (
   10:  2: . . . . . . . . . . . . . . . . BinaryExpr (
   10:  2: . . . . . . . . . . . . . . . . . UnaryExpr (
   10:  2: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10:  2: . . . . . . . . . . . . . . . . . . . Operand (
   10:  2: . . . . . . . . . . . . . . . . . . . . IDENT Plot
 /app/parser/parser.go:713: ast.Ident{Name: Plot}
   10:  6: . . . . . . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . ":"
   10:  8: . . . . . . . . . . . . . . Element (
   10:  8: . . . . . . . . . . . . . . . Expression (
   10:  8: . . . . . . . . . . . . . . . . BinaryExpr (
   10:  8: . . . . . . . . . . . . . . . . . UnaryExpr (
   10:  8: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10:  8: . . . . . . . . . . . . . . . . . . . Operand (
   10:  8: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   10: 10: . . . . . . . . . . . . . . . . . . . )
   10: 10: . . . . . . . . . . . . . . . . . . )
   10: 10: . . . . . . . . . . . . . . . . . )
   10: 10: . . . . . . . . . . . . . . . . )
   10: 10: . . . . . . . . . . . . . . . . "=>"
   10: 13: . . . . . . . . . . . . . . . . BlockStmt (
   10: 13: . . . . . . . . . . . . . . . . . "{"
   11:  3: . . . . . . . . . . . . . . . . . StatementList (
   11:  3: . . . . . . . . . . . . . . . . . . Statement (
   11:  3: . . . . . . . . . . . . . . . . . . . ReturnStmt (
   11:  3: . . . . . . . . . . . . . . . . . . . . "return"
   11: 10: . . . . . . . . . . . . . . . . . . . . ExpressionList (
   11: 10: . . . . . . . . . . . . . . . . . . . . . Expression (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . "*"
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . ","
   11: 17: . . . . . . . . . . . . . . . . . . . . . Expression (
   11: 17: . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 19: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 19: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 19: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 19: . . . . . . . . . . . . . . . . . . . . . . . "*"
   11: 21: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 21: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 21: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 21: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 21: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 22: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . ";"
   12:  2: . . . . . . . . . . . . . . . . . . . )
   12:  2: . . . . . . . . . . . . . . . . . . )
   12:  2: . . . . . . . . . . . . . . . . . )
   12:  2: . . . . . . . . . . . . . . . . . "}"
   12:  3: . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
   12:  3: . . . . . . . . . . . . . . . )
   12:  3: . . . . . . . . . . . . . . )
   12:  3: . . . . . . . . . . . . . )
   12:  3: . . . . . . . . . . . . . ","
   13:  1: . . . . . . . . . . . . )
   13:  1: . . . . . . . . . . . . "}"
   13:  2: . . . . . . . . . . . )
   13:  2: . . . . . . . . . . )
   13:  2: . . . . . . . . . )
   13:  2: . . . . . . . . )
   13:  2: . . . . . . . )
   13:  2: . . . . . . )
   13:  2: . . . . . )
   13:  2: . . . . )
   13:  2: . . . . ";"
   13:  3: . . . )
   13:  3: . . )
   13:  3: . )
   13:  3: )
=== RUN   TestFromTestdata/listcompr
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/listcompr
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . "*"
    1:  9: . . . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 11: . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ForPhrase (
    1: 11: . . . . . . . . . . . . . "for"
    1: 15: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 17: . . . . . . . . . . . . . IDENT in
    1: 20: . . . . . . . . . . . . . Expression (
    1: 20: . . . . . . . . . . . . . . RangeExpr (
    1: 20: . . . . . . . . . . . . . . . BinaryExpr (
    1: 20: . . . . . . . . . . . . . . . . UnaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . . Operand (
    1: 20: . . . . . . . . . . . . . . . . . . . ArrayType (
    1: 20: . . . . . . . . . . . . . . . . . . . . "["
    1: 21: . . . . . . . . . . . . . . . . . . . . Expression (
    1: 21: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 22: . . . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00040c540]}
    1: 23: . . . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{x 8 * x}, Fors: [0xc000232900]}
    1: 24: . . . . . . . . . . . )
    1: 24: . . . . . . . . . . )
    1: 24: . . . . . . . . . )
    1: 24: . . . . . . . . )
    1: 24: . . . . . . . )
    1: 24: . . . . . . )
    1: 24: . . . . . )
    1: 24: . . . . )
    1: 24: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  8: . . . . . . . . . . )
    2:  8: . . . . . . . . . . CallOrConversion (
    2:  8: . . . . . . . . . . . "("
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2: 10: . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    2: 11: . . . . . . . . . . )
    2: 11: . . . . . . . . . )
    2: 11: . . . . . . . . )
    2: 11: . . . . . . . )
    2: 11: . . . . . . )
    2: 11: . . . . . )
    2: 11: . . . . )
    2: 11: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    4:  3: . . . . . . . . . . )
    4:  3: . . . . . . . . . )
    4:  3: . . . . . . . . )
    4:  3: . . . . . . . )
    4:  3: . . . . . . )
    4:  3: . . . . . )
    4:  3: . . . . . "="
    4:  5: . . . . . ExpressionList (
    4:  5: . . . . . . Expression (
    4:  5: . . . . . . . BinaryExpr (
    4:  5: . . . . . . . . UnaryExpr (
    4:  5: . . . . . . . . . PrimaryExpr (
    4:  5: . . . . . . . . . . Operand (
    4:  5: . . . . . . . . . . . ArrayType (
    4:  5: . . . . . . . . . . . . "["
    4:  6: . . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4:  7: . . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . "*"
    4:  8: . . . . . . . . . . . . . . BinaryExpr (
    4:  8: . . . . . . . . . . . . . . . UnaryExpr (
    4:  8: . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  8: . . . . . . . . . . . . . . . . . Operand (
    4:  8: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 10: . . . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . ForPhrase (
    4: 10: . . . . . . . . . . . . . "for"
    4: 14: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 16: . . . . . . . . . . . . . IDENT in
    4: 19: . . . . . . . . . . . . . Expression (
    4: 19: . . . . . . . . . . . . . . RangeExpr (
    4: 19: . . . . . . . . . . . . . . . BinaryExpr (
    4: 19: . . . . . . . . . . . . . . . . UnaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . . Operand (
    4: 19: . . . . . . . . . . . . . . . . . . . ArrayType (
    4: 19: . . . . . . . . . . . . . . . . . . . . "["
    4: 20: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 20: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    4: 21: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . ","
    4: 23: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 23: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    4: 24: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . ","
    4: 26: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 26: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    4: 27: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . ","
    4: 29: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 29: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . ","
    4: 32: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 32: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    4: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . "]"
    4: 36: . . . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . "if"
    4: 39: . . . . . . . . . . . . . SimpleStmt (
    4: 39: . . . . . . . . . . . . . . ExpressionList (
    4: 39: . . . . . . . . . . . . . . . Expression (
    4: 39: . . . . . . . . . . . . . . . . BinaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . . . Operand (
    4: 39: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 41: . . . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . ">"
    4: 43: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 43: . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    4: 44: . . . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{x 43 * x}, Fors: [0xc0002329c0]}
    4: 45: . . . . . . . . . . . )
    4: 45: . . . . . . . . . . )
    4: 45: . . . . . . . . . )
    4: 45: . . . . . . . . )
    4: 45: . . . . . . . )
    4: 45: . . . . . . )
    4: 45: . . . . . )
    4: 45: . . . . )
    4: 45: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  8: . . . . . . . . . . )
    5:  8: . . . . . . . . . . CallOrConversion (
    5:  8: . . . . . . . . . . . "("
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    5: 10: . . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 11: . . . . . . . . . . )
    5: 11: . . . . . . . . . )
    5: 11: . . . . . . . . )
    5: 11: . . . . . . . )
    5: 11: . . . . . . )
    5: 11: . . . . . )
    5: 11: . . . . )
    5: 11: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . SimpleStmt (
    7:  1: . . . . . ExpressionList (
    7:  1: . . . . . . Expression (
    7:  1: . . . . . . . BinaryExpr (
    7:  1: . . . . . . . . UnaryExpr (
    7:  1: . . . . . . . . . PrimaryExpr (
    7:  1: . . . . . . . . . . Operand (
    7:  1: . . . . . . . . . . . IDENT z
 /app/parser/parser.go:713: ast.Ident{Name: z}
    7:  3: . . . . . . . . . . )
    7:  3: . . . . . . . . . )
    7:  3: . . . . . . . . )
    7:  3: . . . . . . . )
    7:  3: . . . . . . )
    7:  3: . . . . . )
    7:  3: . . . . . ":="
    7:  6: . . . . . ExpressionList (
    7:  6: . . . . . . Expression (
    7:  6: . . . . . . . BinaryExpr (
    7:  6: . . . . . . . . UnaryExpr (
    7:  6: . . . . . . . . . PrimaryExpr (
    7:  6: . . . . . . . . . . Operand (
    7:  6: . . . . . . . . . . . ArrayType (
    7:  6: . . . . . . . . . . . . "["
    7:  7: . . . . . . . . . . . . Expression (
    7:  7: . . . . . . . . . . . . . BinaryExpr (
    7:  7: . . . . . . . . . . . . . . UnaryExpr (
    7:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    7:  7: . . . . . . . . . . . . . . . . Operand (
    7:  7: . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7:  8: . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . "+"
    7:  9: . . . . . . . . . . . . . . BinaryExpr (
    7:  9: . . . . . . . . . . . . . . . UnaryExpr (
    7:  9: . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  9: . . . . . . . . . . . . . . . . . Operand (
    7:  9: . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    7: 11: . . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . ForPhrase (
    7: 11: . . . . . . . . . . . . . "for"
    7: 15: . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7: 16: . . . . . . . . . . . . . ","
    7: 18: . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    7: 20: . . . . . . . . . . . . . IDENT in
    7: 23: . . . . . . . . . . . . . Expression (
    7: 23: . . . . . . . . . . . . . . RangeExpr (
    7: 23: . . . . . . . . . . . . . . . BinaryExpr (
    7: 23: . . . . . . . . . . . . . . . . UnaryExpr (
    7: 23: . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 23: . . . . . . . . . . . . . . . . . . Operand (
    7: 23: . . . . . . . . . . . . . . . . . . . ArrayType (
    7: 23: . . . . . . . . . . . . . . . . . . . . "["
    7: 24: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 24: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 25: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . ","
    7: 27: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 27: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    7: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . ","
    7: 30: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 30: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    7: 31: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . ","
    7: 33: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 33: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    7: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . ","
    7: 36: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 36: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    7: 38: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . "]"
    7: 40: . . . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . "if"
    7: 43: . . . . . . . . . . . . . SimpleStmt (
    7: 43: . . . . . . . . . . . . . . ExpressionList (
    7: 43: . . . . . . . . . . . . . . . Expression (
    7: 43: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . . . Operand (
    7: 43: . . . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
    7: 45: . . . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . ":="
    7: 48: . . . . . . . . . . . . . . ExpressionList (
    7: 48: . . . . . . . . . . . . . . . Expression (
    7: 48: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . . . Operand (
    7: 48: . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7: 50: . . . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . "%"
    7: 52: . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . . . Operand (
    7: 52: . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    7: 53: . . . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . ";"
    7: 55: . . . . . . . . . . . . . SimpleStmt (
    7: 55: . . . . . . . . . . . . . . ExpressionList (
    7: 55: . . . . . . . . . . . . . . . Expression (
    7: 55: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . . . Operand (
    7: 55: . . . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
    7: 57: . . . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . "=="
    7: 60: . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . . . Operand (
    7: 60: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 61: . . . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{i 101 + v}, Fors: [0xc000232a80]}
    7: 62: . . . . . . . . . . . )
    7: 62: . . . . . . . . . . )
    7: 62: . . . . . . . . . )
    7: 62: . . . . . . . . )
    7: 62: . . . . . . . )
    7: 62: . . . . . . )
    7: 62: . . . . . )
    7: 62: . . . . )
    7: 62: . . . . ";"
    8:  1: . . . )
    8:  1: . . . Statement (
    8:  1: . . . . SimpleStmt (
    8:  1: . . . . . ExpressionList (
    8:  1: . . . . . . Expression (
    8:  1: . . . . . . . BinaryExpr (
    8:  1: . . . . . . . . UnaryExpr (
    8:  1: . . . . . . . . . PrimaryExpr (
    8:  1: . . . . . . . . . . Operand (
    8:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    8:  8: . . . . . . . . . . )
    8:  8: . . . . . . . . . . CallOrConversion (
    8:  8: . . . . . . . . . . . "("
    8:  9: . . . . . . . . . . . Expression (
    8:  9: . . . . . . . . . . . . BinaryExpr (
    8:  9: . . . . . . . . . . . . . UnaryExpr (
    8:  9: . . . . . . . . . . . . . . PrimaryExpr (
    8:  9: . . . . . . . . . . . . . . . Operand (
    8:  9: . . . . . . . . . . . . . . . . IDENT z
 /app/parser/parser.go:713: ast.Ident{Name: z}
    8: 10: . . . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    8: 11: . . . . . . . . . . )
    8: 11: . . . . . . . . . )
    8: 11: . . . . . . . . )
    8: 11: . . . . . . . )
    8: 11: . . . . . . )
    8: 11: . . . . . )
    8: 11: . . . . )
    8: 11: . . . . ";"
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   10:  8: . . . . . . . . . . )
   10:  8: . . . . . . . . . . CallOrConversion (
   10:  8: . . . . . . . . . . . "("
   10:  9: . . . . . . . . . . . Expression (
   10:  9: . . . . . . . . . . . . BinaryExpr (
   10:  9: . . . . . . . . . . . . . UnaryExpr (
   10:  9: . . . . . . . . . . . . . . PrimaryExpr (
   10:  9: . . . . . . . . . . . . . . . Operand (
   10:  9: . . . . . . . . . . . . . . . . ArrayType (
   10:  9: . . . . . . . . . . . . . . . . . "["
   10: 10: . . . . . . . . . . . . . . . . . Expression (
   10: 10: . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 10: . . . . . . . . . . . . . . . . . . . . . . IDENT k
 /app/parser/parser.go:713: ast.Ident{Name: k}
   10: 11: . . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . "+"
   10: 12: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 12: . . . . . . . . . . . . . . . . . . . . . . . STRING ","
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: ","}
   10: 15: . . . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . "+"
   10: 16: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 16: . . . . . . . . . . . . . . . . . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   10: 18: . . . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . ForPhrase (
   10: 18: . . . . . . . . . . . . . . . . . . "for"
   10: 22: . . . . . . . . . . . . . . . . . . IDENT k
 /app/parser/parser.go:713: ast.Ident{Name: k}
   10: 23: . . . . . . . . . . . . . . . . . . ","
   10: 25: . . . . . . . . . . . . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   10: 27: . . . . . . . . . . . . . . . . . . IDENT in
   10: 30: . . . . . . . . . . . . . . . . . . Expression (
   10: 30: . . . . . . . . . . . . . . . . . . . RangeExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . . . "{"
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . ElementList (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hello"}
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "xsw"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "xsw"}
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . ","
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "XGo"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "XGo"}
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . "}"
   10: 59: . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{0xc00040ca80 182 + s}, Fors: [0xc000232b40]}
   10: 60: . . . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   10: 61: . . . . . . . . . . )
   10: 61: . . . . . . . . . )
   10: 61: . . . . . . . . )
   10: 61: . . . . . . . )
   10: 61: . . . . . . )
   10: 61: . . . . . )
   10: 61: . . . . )
   10: 61: . . . . ";"
   12:  1: . . . )
   12:  1: . . . Statement (
   12:  1: . . . . SimpleStmt (
   12:  1: . . . . . ExpressionList (
   12:  1: . . . . . . Expression (
   12:  1: . . . . . . . BinaryExpr (
   12:  1: . . . . . . . . UnaryExpr (
   12:  1: . . . . . . . . . PrimaryExpr (
   12:  1: . . . . . . . . . . Operand (
   12:  1: . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   12:  5: . . . . . . . . . . )
   12:  5: . . . . . . . . . )
   12:  5: . . . . . . . . )
   12:  5: . . . . . . . )
   12:  5: . . . . . . )
   12:  5: . . . . . )
   12:  5: . . . . . ":="
   12:  8: . . . . . ExpressionList (
   12:  8: . . . . . . Expression (
   12:  8: . . . . . . . BinaryExpr (
   12:  8: . . . . . . . . UnaryExpr (
   12:  8: . . . . . . . . . PrimaryExpr (
   12:  8: . . . . . . . . . . Operand (
   12:  8: . . . . . . . . . . . ArrayType (
   12:  8: . . . . . . . . . . . . "["
   12:  9: . . . . . . . . . . . . Expression (
   12:  9: . . . . . . . . . . . . . BinaryExpr (
   12:  9: . . . . . . . . . . . . . . UnaryExpr (
   12:  9: . . . . . . . . . . . . . . . PrimaryExpr (
   12:  9: . . . . . . . . . . . . . . . . Operand (
   12:  9: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   12: 10: . . . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . ","
   12: 12: . . . . . . . . . . . . Expression (
   12: 12: . . . . . . . . . . . . . BinaryExpr (
   12: 12: . . . . . . . . . . . . . . UnaryExpr (
   12: 12: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 12: . . . . . . . . . . . . . . . . Operand (
   12: 12: . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   12: 13: . . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . ","
   12: 15: . . . . . . . . . . . . Expression (
   12: 15: . . . . . . . . . . . . . BinaryExpr (
   12: 15: . . . . . . . . . . . . . . UnaryExpr (
   12: 15: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 15: . . . . . . . . . . . . . . . . Operand (
   12: 15: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   12: 16: . . . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . ","
   12: 18: . . . . . . . . . . . . Expression (
   12: 18: . . . . . . . . . . . . . BinaryExpr (
   12: 18: . . . . . . . . . . . . . . UnaryExpr (
   12: 18: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 18: . . . . . . . . . . . . . . . . Operand (
   12: 18: . . . . . . . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
   12: 19: . . . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . ","
   12: 21: . . . . . . . . . . . . Expression (
   12: 21: . . . . . . . . . . . . . BinaryExpr (
   12: 21: . . . . . . . . . . . . . . UnaryExpr (
   12: 21: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 21: . . . . . . . . . . . . . . . . Operand (
   12: 21: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   12: 22: . . . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . ","
   12: 24: . . . . . . . . . . . . Expression (
   12: 24: . . . . . . . . . . . . . BinaryExpr (
   12: 24: . . . . . . . . . . . . . . UnaryExpr (
   12: 24: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 24: . . . . . . . . . . . . . . . . Operand (
   12: 24: . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
   12: 25: . . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . "]"
   12: 26: . . . . . . . . . . . )
   12: 26: . . . . . . . . . . )
   12: 26: . . . . . . . . . )
   12: 26: . . . . . . . . )
   12: 26: . . . . . . . )
   12: 26: . . . . . . )
   12: 26: . . . . . )
   12: 26: . . . . )
   12: 26: . . . . ";"
   13:  1: . . . )
   13:  1: . . . Statement (
   13:  1: . . . . SimpleStmt (
   13:  1: . . . . . ExpressionList (
   13:  1: . . . . . . Expression (
   13:  1: . . . . . . . BinaryExpr (
   13:  1: . . . . . . . . UnaryExpr (
   13:  1: . . . . . . . . . PrimaryExpr (
   13:  1: . . . . . . . . . . Operand (
   13:  1: . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   13:  3: . . . . . . . . . . )
   13:  3: . . . . . . . . . )
   13:  3: . . . . . . . . )
   13:  3: . . . . . . . )
   13:  3: . . . . . . )
   13:  3: . . . . . )
   13:  3: . . . . . ":="
   13:  6: . . . . . ExpressionList (
   13:  6: . . . . . . Expression (
   13:  6: . . . . . . . BinaryExpr (
   13:  6: . . . . . . . . UnaryExpr (
   13:  6: . . . . . . . . . PrimaryExpr (
   13:  6: . . . . . . . . . . Operand (
   13:  6: . . . . . . . . . . . ArrayType (
   13:  6: . . . . . . . . . . . . "["
   13:  7: . . . . . . . . . . . . Expression (
   13:  7: . . . . . . . . . . . . . BinaryExpr (
   13:  7: . . . . . . . . . . . . . . UnaryExpr (
   13:  7: . . . . . . . . . . . . . . . PrimaryExpr (
   13:  7: . . . . . . . . . . . . . . . . Operand (
   13:  7: . . . . . . . . . . . . . . . . . ArrayType (
   13:  7: . . . . . . . . . . . . . . . . . . "["
   13:  8: . . . . . . . . . . . . . . . . . . Expression (
   13:  8: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . . . Operand (
   13:  8: . . . . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13:  9: . . . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . ","
   13: 11: . . . . . . . . . . . . . . . . . . Expression (
   13: 11: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 12: . . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . "]"
   13: 14: . . . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . ForPhrase (
   13: 14: . . . . . . . . . . . . . "for"
   13: 18: . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13: 20: . . . . . . . . . . . . . IDENT in
   13: 23: . . . . . . . . . . . . . Expression (
   13: 23: . . . . . . . . . . . . . . RangeExpr (
   13: 23: . . . . . . . . . . . . . . . BinaryExpr (
   13: 23: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 23: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 23: . . . . . . . . . . . . . . . . . . Operand (
   13: 23: . . . . . . . . . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   13: 27: . . . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . "if"
   13: 30: . . . . . . . . . . . . . SimpleStmt (
   13: 30: . . . . . . . . . . . . . . ExpressionList (
   13: 30: . . . . . . . . . . . . . . . Expression (
   13: 30: . . . . . . . . . . . . . . . . BinaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . . . Operand (
   13: 30: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13: 32: . . . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . "<"
   13: 34: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 34: . . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 36: . . . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . ForPhrase (
   13: 36: . . . . . . . . . . . . . "for"
   13: 40: . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 42: . . . . . . . . . . . . . IDENT in
   13: 45: . . . . . . . . . . . . . Expression (
   13: 45: . . . . . . . . . . . . . . RangeExpr (
   13: 45: . . . . . . . . . . . . . . . BinaryExpr (
   13: 45: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 45: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 45: . . . . . . . . . . . . . . . . . . Operand (
   13: 45: . . . . . . . . . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   13: 49: . . . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . "if"
   13: 52: . . . . . . . . . . . . . SimpleStmt (
   13: 52: . . . . . . . . . . . . . . ExpressionList (
   13: 52: . . . . . . . . . . . . . . . Expression (
   13: 52: . . . . . . . . . . . . . . . . BinaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . . . Operand (
   13: 52: . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 54: . . . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . ">"
   13: 56: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 56: . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   13: 57: . . . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{262 [a b] 267 false}, Fors: [0xc000232c00 0xc000232c60]}
   13: 58: . . . . . . . . . . . )
   13: 58: . . . . . . . . . . )
   13: 58: . . . . . . . . . )
   13: 58: . . . . . . . . )
   13: 58: . . . . . . . )
   13: 58: . . . . . . )
   13: 58: . . . . . )
   13: 58: . . . . )
   13: 58: . . . . ";"
   14:  1: . . . )
   14:  1: . . . Statement (
   14:  1: . . . . SimpleStmt (
   14:  1: . . . . . ExpressionList (
   14:  1: . . . . . . Expression (
   14:  1: . . . . . . . BinaryExpr (
   14:  1: . . . . . . . . UnaryExpr (
   14:  1: . . . . . . . . . PrimaryExpr (
   14:  1: . . . . . . . . . . Operand (
   14:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   14:  8: . . . . . . . . . . )
   14:  8: . . . . . . . . . . CallOrConversion (
   14:  8: . . . . . . . . . . . "("
   14:  9: . . . . . . . . . . . Expression (
   14:  9: . . . . . . . . . . . . BinaryExpr (
   14:  9: . . . . . . . . . . . . . UnaryExpr (
   14:  9: . . . . . . . . . . . . . . PrimaryExpr (
   14:  9: . . . . . . . . . . . . . . . Operand (
   14:  9: . . . . . . . . . . . . . . . . STRING "x:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x:"}
   14: 13: . . . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . ","
   14: 15: . . . . . . . . . . . Expression (
   14: 15: . . . . . . . . . . . . BinaryExpr (
   14: 15: . . . . . . . . . . . . . UnaryExpr (
   14: 15: . . . . . . . . . . . . . . PrimaryExpr (
   14: 15: . . . . . . . . . . . . . . . Operand (
   14: 15: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   14: 16: . . . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   14: 17: . . . . . . . . . . )
   14: 17: . . . . . . . . . )
   14: 17: . . . . . . . . )
   14: 17: . . . . . . . )
   14: 17: . . . . . . )
   14: 17: . . . . . )
   14: 17: . . . . )
   14: 17: . . . . ";"
   14: 18: . . . )
   14: 18: . . )
   14: 18: . )
   14: 18: )
=== RUN   TestFromTestdata/mapfunc
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/mapfunc
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . "map"
 /app/parser/parser.go:713: ast.Ident{Name: map}
    1:  5: . . . . . . . . . . )
    1:  5: . . . . . . . . . . CallOrConversion (
    1:  5: . . . . . . . . . . . Expression (
    1:  5: . . . . . . . . . . . . BinaryExpr (
    1:  5: . . . . . . . . . . . . . UnaryExpr (
    1:  5: . . . . . . . . . . . . . . PrimaryExpr (
    1:  5: . . . . . . . . . . . . . . . Operand (
    1:  5: . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
    1:  9: . . . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . ","
    1: 11: . . . . . . . . . . . Expression (
    1: 11: . . . . . . . . . . . . BinaryExpr (
    1: 11: . . . . . . . . . . . . . UnaryExpr (
    1: 11: . . . . . . . . . . . . . . PrimaryExpr (
    1: 11: . . . . . . . . . . . . . . . Operand (
    1: 11: . . . . . . . . . . . . . . . . IDENT toUpper
 /app/parser/parser.go:713: ast.Ident{Name: toUpper}
    1: 18: . . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: map, Ellipsis: false, isCmd: true}
    1: 18: . . . . . . . . . . )
    1: 18: . . . . . . . . . )
    1: 18: . . . . . . . . )
    1: 18: . . . . . . . )
    1: 18: . . . . . . )
    1: 18: . . . . . )
    1: 18: . . . . )
    1: 18: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . "map"
 /app/parser/parser.go:713: ast.Ident{Name: map}
    2:  5: . . . . . . . . . . )
    2:  5: . . . . . . . . . . CallOrConversion (
    2:  5: . . . . . . . . . . . Expression (
    2:  5: . . . . . . . . . . . . BinaryExpr (
    2:  5: . . . . . . . . . . . . . UnaryExpr (
    2:  5: . . . . . . . . . . . . . . PrimaryExpr (
    2:  5: . . . . . . . . . . . . . . . Operand (
    2:  5: . . . . . . . . . . . . . . . . ArrayType (
    2:  5: . . . . . . . . . . . . . . . . . "["
    2:  6: . . . . . . . . . . . . . . . . . Expression (
    2:  6: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . . . . . . . . . . . . STRING "hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
    2: 13: . . . . . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . ","
    2: 15: . . . . . . . . . . . . . . . . . Expression (
    2: 15: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . . . . . . . . STRING "world"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "world"}
    2: 22: . . . . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . "]"
    2: 23: . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . ","
    2: 25: . . . . . . . . . . . Expression (
    2: 25: . . . . . . . . . . . . BinaryExpr (
    2: 25: . . . . . . . . . . . . . UnaryExpr (
    2: 25: . . . . . . . . . . . . . . PrimaryExpr (
    2: 25: . . . . . . . . . . . . . . . Operand (
    2: 25: . . . . . . . . . . . . . . . . IDENT toUpper
 /app/parser/parser.go:713: ast.Ident{Name: toUpper}
    2: 32: . . . . . . . . . . . . . . . )
    2: 32: . . . . . . . . . . . . . . )
    2: 32: . . . . . . . . . . . . . )
    2: 32: . . . . . . . . . . . . )
    2: 32: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: map, Ellipsis: false, isCmd: true}
    2: 32: . . . . . . . . . . )
    2: 32: . . . . . . . . . )
    2: 32: . . . . . . . . )
    2: 32: . . . . . . . )
    2: 32: . . . . . . )
    2: 32: . . . . . )
    2: 32: . . . . )
    2: 32: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . "map"
    3:  1: . . . . . . . . . . . MapType (
    3:  4: . . . . . . . . . . . . "["
    3:  5: . . . . . . . . . . . . Type (
    3:  5: . . . . . . . . . . . . . TypeName (
    3:  5: . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    3: 11: . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . "]"
    3: 12: . . . . . . . . . . . . Type (
    3: 12: . . . . . . . . . . . . . TypeName (
    3: 12: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 15: . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: string, Value: int}
    3: 15: . . . . . . . . . . . )
    3: 15: . . . . . . . . . . )
    3: 15: . . . . . . . . . . LiteralValue (
    3: 15: . . . . . . . . . . . "{"
    3: 16: . . . . . . . . . . . ElementList (
    3: 16: . . . . . . . . . . . . Element (
    3: 16: . . . . . . . . . . . . . Element (
    3: 16: . . . . . . . . . . . . . . Expression (
    3: 16: . . . . . . . . . . . . . . . BinaryExpr (
    3: 16: . . . . . . . . . . . . . . . . UnaryExpr (
    3: 16: . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 16: . . . . . . . . . . . . . . . . . . Operand (
    3: 16: . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    3: 20: . . . . . . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . ":"
    3: 22: . . . . . . . . . . . . . Element (
    3: 22: . . . . . . . . . . . . . . Expression (
    3: 22: . . . . . . . . . . . . . . . BinaryExpr (
    3: 22: . . . . . . . . . . . . . . . . UnaryExpr (
    3: 22: . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 22: . . . . . . . . . . . . . . . . . . Operand (
    3: 22: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3: 23: . . . . . . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . "}"
    3: 24: . . . . . . . . . . )
    3: 24: . . . . . . . . . )
    3: 24: . . . . . . . . )
    3: 24: . . . . . . . )
    3: 24: . . . . . . )
    3: 24: . . . . . )
    3: 24: . . . . )
    3: 24: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  9: . . . . . . . . . . )
    4:  9: . . . . . . . . . . CallOrConversion (
    4:  9: . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . Operand (
    4:  9: . . . . . . . . . . . . . . . . "map"
 /app/parser/parser.go:713: ast.Ident{Name: map}
    4: 12: . . . . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . . . . . CallOrConversion (
    4: 12: . . . . . . . . . . . . . . . . "("
    4: 13: . . . . . . . . . . . . . . . . Expression (
    4: 13: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 13: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 13: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 13: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 13: . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
    4: 17: . . . . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . ","
    4: 19: . . . . . . . . . . . . . . . . Expression (
    4: 19: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 19: . . . . . . . . . . . . . . . . . . . . . IDENT strings
 /app/parser/parser.go:713: ast.Ident{Name: strings}
    4: 26: . . . . . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . . . . . "."
    4: 27: . . . . . . . . . . . . . . . . . . . . Selector (
    4: 27: . . . . . . . . . . . . . . . . . . . . . IDENT ToUpper
 /app/parser/parser.go:713: ast.Ident{Name: ToUpper}
    4: 34: . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: map, Ellipsis: false, isCmd: false}
    4: 35: . . . . . . . . . . . . . . . )
    4: 35: . . . . . . . . . . . . . . )
    4: 35: . . . . . . . . . . . . . )
    4: 35: . . . . . . . . . . . . )
    4: 35: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 35: . . . . . . . . . . )
    4: 35: . . . . . . . . . )
    4: 35: . . . . . . . . )
    4: 35: . . . . . . . )
    4: 35: . . . . . . )
    4: 35: . . . . . )
    4: 35: . . . . )
    4: 35: . . . . ";"
    4: 36: . . . )
    4: 36: . . )
    4: 36: . )
    4: 36: )
=== RUN   TestFromTestdata/matrix1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/matrix1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . . . . . . "["
    2:  2: . . . . . . . . . . . . . . . . . Expression (
    2:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  2: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2:  3: . . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . ","
    2:  5: . . . . . . . . . . . . . . . . . Expression (
    2:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  5: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2:  6: . . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . ","
    2:  8: . . . . . . . . . . . . . . . . . Expression (
    2:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  8: . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2:  9: . . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . ";"
    3:  2: . . . . . . . . . . . . . . . . . Expression (
    3:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  2: . . . . . . . . . . . . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
    3:  3: . . . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . ","
    3:  5: . . . . . . . . . . . . . . . . . Expression (
    3:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  5: . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    3:  6: . . . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . ","
    3:  8: . . . . . . . . . . . . . . . . . Expression (
    3:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  8: . . . . . . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
    3:  9: . . . . . . . . . . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . . . . . . ";"
    4:  1: . . . . . . . . . . . . . . . . . "]"
    4:  2: . . . . . . . . . . . . . . . . )
    4:  2: . . . . . . . . . . . . . . . )
    4:  2: . . . . . . . . . . . . . . )
    4:  2: . . . . . . . . . . . . . )
    4:  2: . . . . . . . . . . . . )
    4:  2: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    4:  2: . . . . . . . . . . )
    4:  2: . . . . . . . . . )
    4:  2: . . . . . . . . )
    4:  2: . . . . . . . )
    4:  2: . . . . . . )
    4:  2: . . . . . )
    4:  2: . . . . )
    4:  2: . . . . ";"
    4:  3: . . . )
    4:  3: . . )
    4:  3: . )
    4:  3: )
=== RUN   TestFromTestdata/matrix2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/matrix2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . . . . . . "["
    2:  2: . . . . . . . . . . . . . . . . . Expression (
    2:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  2: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2:  3: . . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . ","
    2:  5: . . . . . . . . . . . . . . . . . Expression (
    2:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  5: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2:  6: . . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . ","
    2:  8: . . . . . . . . . . . . . . . . . Expression (
    2:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  8: . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2:  9: . . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . ";"
    3:  2: . . . . . . . . . . . . . . . . . Expression (
    3:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  2: . . . . . . . . . . . . . . . . . . . . . . IDENT row
 /app/parser/parser.go:713: ast.Ident{Name: row}
    3:  5: . . . . . . . . . . . . . . . . . . . . . )
    3:  5: . . . . . . . . . . . . . . . . . . . . )
    3:  5: . . . . . . . . . . . . . . . . . . . )
    3:  5: . . . . . . . . . . . . . . . . . . )
    3:  5: . . . . . . . . . . . . . . . . . )
    3:  5: . . . . . . . . . . . . . . . . . "..."
    3:  8: . . . . . . . . . . . . . . . . . ";"
    4:  2: . . . . . . . . . . . . . . . . . Expression (
    4:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    4:  3: . . . . . . . . . . . . . . . . . . . . . )
    4:  3: . . . . . . . . . . . . . . . . . . . . )
    4:  3: . . . . . . . . . . . . . . . . . . . )
    4:  3: . . . . . . . . . . . . . . . . . . )
    4:  3: . . . . . . . . . . . . . . . . . )
    4:  3: . . . . . . . . . . . . . . . . . ","
    4:  5: . . . . . . . . . . . . . . . . . Expression (
    4:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    4:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    4:  5: . . . . . . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    4:  6: . . . . . . . . . . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . . . . . . ","
    4:  8: . . . . . . . . . . . . . . . . . Expression (
    4:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    4:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    4:  8: . . . . . . . . . . . . . . . . . . . . . . INT 9
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 9}
    4:  9: . . . . . . . . . . . . . . . . . . . . . )
    4:  9: . . . . . . . . . . . . . . . . . . . . )
    4:  9: . . . . . . . . . . . . . . . . . . . )
    4:  9: . . . . . . . . . . . . . . . . . . )
    4:  9: . . . . . . . . . . . . . . . . . )
    4:  9: . . . . . . . . . . . . . . . . . ";"
    5:  1: . . . . . . . . . . . . . . . . . "]"
    5:  2: . . . . . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    5:  2: . . . . . . . . . . )
    5:  2: . . . . . . . . . )
    5:  2: . . . . . . . . )
    5:  2: . . . . . . . )
    5:  2: . . . . . . )
    5:  2: . . . . . )
    5:  2: . . . . )
    5:  2: . . . . ";"
    5:  3: . . . )
    5:  3: . . )
    5:  3: . )
    5:  3: )
=== RUN   TestFromTestdata/mytest
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/mytest
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT demo
 /app/parser/parser.go:713: ast.Ident{Name: demo}
    1: 13: . ";"
    3:  1: . GenDecl(import) (
    3:  1: . . "import"
    3:  8: . . "("
    4:  2: . . ImportSpec (
    4:  2: . . . STRING "go/token"
    4: 12: . . . ";"
    5:  2: . . )
    5:  2: . . ImportSpec (
    5:  2: . . . STRING "os"
    5:  6: . . . ";"
    6:  1: . . )
    6:  1: . . ")"
    6:  2: . . ";"
    8:  1: . )
    8:  1: . Declaration (
    8:  1: . . GenDecl(var) (
    8:  1: . . . "var"
    8:  5: . . . varSpec (
    8:  5: . . . . IdentList (
    8:  5: . . . . . IDENT stmtStart
 /app/parser/parser.go:713: ast.Ident{Name: stmtStart}
    8: 15: . . . . )
    8: 15: . . . . "="
    8: 17: . . . . ExpressionList (
    8: 17: . . . . . Expression (
    8: 17: . . . . . . BinaryExpr (
    8: 17: . . . . . . . UnaryExpr (
    8: 17: . . . . . . . . PrimaryExpr (
    8: 17: . . . . . . . . . Operand (
    8: 17: . . . . . . . . . . "map"
    8: 17: . . . . . . . . . . MapType (
    8: 20: . . . . . . . . . . . "["
    8: 21: . . . . . . . . . . . Type (
    8: 21: . . . . . . . . . . . . TypeName (
    8: 21: . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
    8: 26: . . . . . . . . . . . . . "."
    8: 27: . . . . . . . . . . . . . IDENT Token
 /app/parser/parser.go:713: ast.Ident{Name: Token}
    8: 32: . . . . . . . . . . . . )
    8: 32: . . . . . . . . . . . )
    8: 32: . . . . . . . . . . . "]"
    8: 33: . . . . . . . . . . . Type (
    8: 33: . . . . . . . . . . . . TypeName (
    8: 33: . . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
    8: 37: . . . . . . . . . . . . )
    8: 37: . . . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: &{token Token}, Value: bool}
    8: 37: . . . . . . . . . . )
    8: 37: . . . . . . . . . )
    8: 37: . . . . . . . . . LiteralValue (
    8: 37: . . . . . . . . . . "{"
    9:  2: . . . . . . . . . . ElementList (
    9:  2: . . . . . . . . . . . Element (
    9:  2: . . . . . . . . . . . . Element (
    9:  2: . . . . . . . . . . . . . Expression (
    9:  2: . . . . . . . . . . . . . . BinaryExpr (
    9:  2: . . . . . . . . . . . . . . . UnaryExpr (
    9:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
    9:  2: . . . . . . . . . . . . . . . . . Operand (
    9:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
    9:  7: . . . . . . . . . . . . . . . . . )
    9:  7: . . . . . . . . . . . . . . . . . "."
    9:  8: . . . . . . . . . . . . . . . . . Selector (
    9:  8: . . . . . . . . . . . . . . . . . . IDENT BREAK
 /app/parser/parser.go:713: ast.Ident{Name: BREAK}
    9: 13: . . . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . ":"
    9: 21: . . . . . . . . . . . . Element (
    9: 21: . . . . . . . . . . . . . Expression (
    9: 21: . . . . . . . . . . . . . . BinaryExpr (
    9: 21: . . . . . . . . . . . . . . . UnaryExpr (
    9: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 21: . . . . . . . . . . . . . . . . . Operand (
    9: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
    9: 25: . . . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . ","
   10:  2: . . . . . . . . . . . Element (
   10:  2: . . . . . . . . . . . . Element (
   10:  2: . . . . . . . . . . . . . Expression (
   10:  2: . . . . . . . . . . . . . . BinaryExpr (
   10:  2: . . . . . . . . . . . . . . . UnaryExpr (
   10:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   10:  2: . . . . . . . . . . . . . . . . . Operand (
   10:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   10:  7: . . . . . . . . . . . . . . . . . )
   10:  7: . . . . . . . . . . . . . . . . . "."
   10:  8: . . . . . . . . . . . . . . . . . Selector (
   10:  8: . . . . . . . . . . . . . . . . . . IDENT CONST
 /app/parser/parser.go:713: ast.Ident{Name: CONST}
   10: 13: . . . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . ":"
   10: 21: . . . . . . . . . . . . Element (
   10: 21: . . . . . . . . . . . . . Expression (
   10: 21: . . . . . . . . . . . . . . BinaryExpr (
   10: 21: . . . . . . . . . . . . . . . UnaryExpr (
   10: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 21: . . . . . . . . . . . . . . . . . Operand (
   10: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   10: 25: . . . . . . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . ","
   11:  2: . . . . . . . . . . . Element (
   11:  2: . . . . . . . . . . . . Element (
   11:  2: . . . . . . . . . . . . . Expression (
   11:  2: . . . . . . . . . . . . . . BinaryExpr (
   11:  2: . . . . . . . . . . . . . . . UnaryExpr (
   11:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   11:  2: . . . . . . . . . . . . . . . . . Operand (
   11:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   11:  7: . . . . . . . . . . . . . . . . . )
   11:  7: . . . . . . . . . . . . . . . . . "."
   11:  8: . . . . . . . . . . . . . . . . . Selector (
   11:  8: . . . . . . . . . . . . . . . . . . IDENT CONTINUE
 /app/parser/parser.go:713: ast.Ident{Name: CONTINUE}
   11: 16: . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . ":"
   11: 21: . . . . . . . . . . . . Element (
   11: 21: . . . . . . . . . . . . . Expression (
   11: 21: . . . . . . . . . . . . . . BinaryExpr (
   11: 21: . . . . . . . . . . . . . . . UnaryExpr (
   11: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 21: . . . . . . . . . . . . . . . . . Operand (
   11: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   11: 25: . . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . ","
   12:  2: . . . . . . . . . . . Element (
   12:  2: . . . . . . . . . . . . Element (
   12:  2: . . . . . . . . . . . . . Expression (
   12:  2: . . . . . . . . . . . . . . BinaryExpr (
   12:  2: . . . . . . . . . . . . . . . UnaryExpr (
   12:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   12:  2: . . . . . . . . . . . . . . . . . Operand (
   12:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   12:  7: . . . . . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . . . . . "."
   12:  8: . . . . . . . . . . . . . . . . . Selector (
   12:  8: . . . . . . . . . . . . . . . . . . IDENT DEFER
 /app/parser/parser.go:713: ast.Ident{Name: DEFER}
   12: 13: . . . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . ":"
   12: 21: . . . . . . . . . . . . Element (
   12: 21: . . . . . . . . . . . . . Expression (
   12: 21: . . . . . . . . . . . . . . BinaryExpr (
   12: 21: . . . . . . . . . . . . . . . UnaryExpr (
   12: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   12: 21: . . . . . . . . . . . . . . . . . Operand (
   12: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   12: 25: . . . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . ","
   13:  2: . . . . . . . . . . . Element (
   13:  2: . . . . . . . . . . . . Element (
   13:  2: . . . . . . . . . . . . . Expression (
   13:  2: . . . . . . . . . . . . . . BinaryExpr (
   13:  2: . . . . . . . . . . . . . . . UnaryExpr (
   13:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  2: . . . . . . . . . . . . . . . . . Operand (
   13:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   13:  7: . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . . "."
   13:  8: . . . . . . . . . . . . . . . . . Selector (
   13:  8: . . . . . . . . . . . . . . . . . . IDENT FALLTHROUGH
 /app/parser/parser.go:713: ast.Ident{Name: FALLTHROUGH}
   13: 19: . . . . . . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . ":"
   13: 21: . . . . . . . . . . . . Element (
   13: 21: . . . . . . . . . . . . . Expression (
   13: 21: . . . . . . . . . . . . . . BinaryExpr (
   13: 21: . . . . . . . . . . . . . . . UnaryExpr (
   13: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 21: . . . . . . . . . . . . . . . . . Operand (
   13: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   13: 25: . . . . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . ","
   14:  2: . . . . . . . . . . . Element (
   14:  2: . . . . . . . . . . . . Element (
   14:  2: . . . . . . . . . . . . . Expression (
   14:  2: . . . . . . . . . . . . . . BinaryExpr (
   14:  2: . . . . . . . . . . . . . . . UnaryExpr (
   14:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   14:  2: . . . . . . . . . . . . . . . . . Operand (
   14:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   14:  7: . . . . . . . . . . . . . . . . . )
   14:  7: . . . . . . . . . . . . . . . . . "."
   14:  8: . . . . . . . . . . . . . . . . . Selector (
   14:  8: . . . . . . . . . . . . . . . . . . IDENT FOR
 /app/parser/parser.go:713: ast.Ident{Name: FOR}
   14: 11: . . . . . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . ":"
   14: 21: . . . . . . . . . . . . Element (
   14: 21: . . . . . . . . . . . . . Expression (
   14: 21: . . . . . . . . . . . . . . BinaryExpr (
   14: 21: . . . . . . . . . . . . . . . UnaryExpr (
   14: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   14: 21: . . . . . . . . . . . . . . . . . Operand (
   14: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   14: 25: . . . . . . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . ","
   15:  2: . . . . . . . . . . . Element (
   15:  2: . . . . . . . . . . . . Element (
   15:  2: . . . . . . . . . . . . . Expression (
   15:  2: . . . . . . . . . . . . . . BinaryExpr (
   15:  2: . . . . . . . . . . . . . . . UnaryExpr (
   15:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   15:  2: . . . . . . . . . . . . . . . . . Operand (
   15:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   15:  7: . . . . . . . . . . . . . . . . . )
   15:  7: . . . . . . . . . . . . . . . . . "."
   15:  8: . . . . . . . . . . . . . . . . . Selector (
   15:  8: . . . . . . . . . . . . . . . . . . IDENT GO
 /app/parser/parser.go:713: ast.Ident{Name: GO}
   15: 10: . . . . . . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . ":"
   15: 21: . . . . . . . . . . . . Element (
   15: 21: . . . . . . . . . . . . . Expression (
   15: 21: . . . . . . . . . . . . . . BinaryExpr (
   15: 21: . . . . . . . . . . . . . . . UnaryExpr (
   15: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   15: 21: . . . . . . . . . . . . . . . . . Operand (
   15: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   15: 25: . . . . . . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . ","
   16:  2: . . . . . . . . . . . Element (
   16:  2: . . . . . . . . . . . . Element (
   16:  2: . . . . . . . . . . . . . Expression (
   16:  2: . . . . . . . . . . . . . . BinaryExpr (
   16:  2: . . . . . . . . . . . . . . . UnaryExpr (
   16:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   16:  2: . . . . . . . . . . . . . . . . . Operand (
   16:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   16:  7: . . . . . . . . . . . . . . . . . )
   16:  7: . . . . . . . . . . . . . . . . . "."
   16:  8: . . . . . . . . . . . . . . . . . Selector (
   16:  8: . . . . . . . . . . . . . . . . . . IDENT GOTO
 /app/parser/parser.go:713: ast.Ident{Name: GOTO}
   16: 12: . . . . . . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . ":"
   16: 21: . . . . . . . . . . . . Element (
   16: 21: . . . . . . . . . . . . . Expression (
   16: 21: . . . . . . . . . . . . . . BinaryExpr (
   16: 21: . . . . . . . . . . . . . . . UnaryExpr (
   16: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 21: . . . . . . . . . . . . . . . . . Operand (
   16: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   16: 25: . . . . . . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . ","
   17:  2: . . . . . . . . . . . Element (
   17:  2: . . . . . . . . . . . . Element (
   17:  2: . . . . . . . . . . . . . Expression (
   17:  2: . . . . . . . . . . . . . . BinaryExpr (
   17:  2: . . . . . . . . . . . . . . . UnaryExpr (
   17:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   17:  2: . . . . . . . . . . . . . . . . . Operand (
   17:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   17:  7: . . . . . . . . . . . . . . . . . )
   17:  7: . . . . . . . . . . . . . . . . . "."
   17:  8: . . . . . . . . . . . . . . . . . Selector (
   17:  8: . . . . . . . . . . . . . . . . . . IDENT IF
 /app/parser/parser.go:713: ast.Ident{Name: IF}
   17: 10: . . . . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . ":"
   17: 21: . . . . . . . . . . . . Element (
   17: 21: . . . . . . . . . . . . . Expression (
   17: 21: . . . . . . . . . . . . . . BinaryExpr (
   17: 21: . . . . . . . . . . . . . . . UnaryExpr (
   17: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 21: . . . . . . . . . . . . . . . . . Operand (
   17: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   17: 25: . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . ","
   18:  2: . . . . . . . . . . . Element (
   18:  2: . . . . . . . . . . . . Element (
   18:  2: . . . . . . . . . . . . . Expression (
   18:  2: . . . . . . . . . . . . . . BinaryExpr (
   18:  2: . . . . . . . . . . . . . . . UnaryExpr (
   18:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   18:  2: . . . . . . . . . . . . . . . . . Operand (
   18:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   18:  7: . . . . . . . . . . . . . . . . . )
   18:  7: . . . . . . . . . . . . . . . . . "."
   18:  8: . . . . . . . . . . . . . . . . . Selector (
   18:  8: . . . . . . . . . . . . . . . . . . IDENT RETURN
 /app/parser/parser.go:713: ast.Ident{Name: RETURN}
   18: 14: . . . . . . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . ":"
   18: 21: . . . . . . . . . . . . Element (
   18: 21: . . . . . . . . . . . . . Expression (
   18: 21: . . . . . . . . . . . . . . BinaryExpr (
   18: 21: . . . . . . . . . . . . . . . UnaryExpr (
   18: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   18: 21: . . . . . . . . . . . . . . . . . Operand (
   18: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   18: 25: . . . . . . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . ","
   19:  2: . . . . . . . . . . . Element (
   19:  2: . . . . . . . . . . . . Element (
   19:  2: . . . . . . . . . . . . . Expression (
   19:  2: . . . . . . . . . . . . . . BinaryExpr (
   19:  2: . . . . . . . . . . . . . . . UnaryExpr (
   19:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   19:  2: . . . . . . . . . . . . . . . . . Operand (
   19:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   19:  7: . . . . . . . . . . . . . . . . . )
   19:  7: . . . . . . . . . . . . . . . . . "."
   19:  8: . . . . . . . . . . . . . . . . . Selector (
   19:  8: . . . . . . . . . . . . . . . . . . IDENT SELECT
 /app/parser/parser.go:713: ast.Ident{Name: SELECT}
   19: 14: . . . . . . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . ":"
   19: 21: . . . . . . . . . . . . Element (
   19: 21: . . . . . . . . . . . . . Expression (
   19: 21: . . . . . . . . . . . . . . BinaryExpr (
   19: 21: . . . . . . . . . . . . . . . UnaryExpr (
   19: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   19: 21: . . . . . . . . . . . . . . . . . Operand (
   19: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   19: 25: . . . . . . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . ","
   20:  2: . . . . . . . . . . . Element (
   20:  2: . . . . . . . . . . . . Element (
   20:  2: . . . . . . . . . . . . . Expression (
   20:  2: . . . . . . . . . . . . . . BinaryExpr (
   20:  2: . . . . . . . . . . . . . . . UnaryExpr (
   20:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   20:  2: . . . . . . . . . . . . . . . . . Operand (
   20:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   20:  7: . . . . . . . . . . . . . . . . . )
   20:  7: . . . . . . . . . . . . . . . . . "."
   20:  8: . . . . . . . . . . . . . . . . . Selector (
   20:  8: . . . . . . . . . . . . . . . . . . IDENT SWITCH
 /app/parser/parser.go:713: ast.Ident{Name: SWITCH}
   20: 14: . . . . . . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . ":"
   20: 21: . . . . . . . . . . . . Element (
   20: 21: . . . . . . . . . . . . . Expression (
   20: 21: . . . . . . . . . . . . . . BinaryExpr (
   20: 21: . . . . . . . . . . . . . . . UnaryExpr (
   20: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   20: 21: . . . . . . . . . . . . . . . . . Operand (
   20: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   20: 25: . . . . . . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . ","
   21:  2: . . . . . . . . . . . Element (
   21:  2: . . . . . . . . . . . . Element (
   21:  2: . . . . . . . . . . . . . Expression (
   21:  2: . . . . . . . . . . . . . . BinaryExpr (
   21:  2: . . . . . . . . . . . . . . . UnaryExpr (
   21:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   21:  2: . . . . . . . . . . . . . . . . . Operand (
   21:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   21:  7: . . . . . . . . . . . . . . . . . )
   21:  7: . . . . . . . . . . . . . . . . . "."
   21:  8: . . . . . . . . . . . . . . . . . Selector (
   21:  8: . . . . . . . . . . . . . . . . . . IDENT TYPE
 /app/parser/parser.go:713: ast.Ident{Name: TYPE}
   21: 12: . . . . . . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . ":"
   21: 21: . . . . . . . . . . . . Element (
   21: 21: . . . . . . . . . . . . . Expression (
   21: 21: . . . . . . . . . . . . . . BinaryExpr (
   21: 21: . . . . . . . . . . . . . . . UnaryExpr (
   21: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   21: 21: . . . . . . . . . . . . . . . . . Operand (
   21: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   21: 25: . . . . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . ","
   22:  2: . . . . . . . . . . . Element (
   22:  2: . . . . . . . . . . . . Element (
   22:  2: . . . . . . . . . . . . . Expression (
   22:  2: . . . . . . . . . . . . . . BinaryExpr (
   22:  2: . . . . . . . . . . . . . . . UnaryExpr (
   22:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   22:  2: . . . . . . . . . . . . . . . . . Operand (
   22:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   22:  7: . . . . . . . . . . . . . . . . . )
   22:  7: . . . . . . . . . . . . . . . . . "."
   22:  8: . . . . . . . . . . . . . . . . . Selector (
   22:  8: . . . . . . . . . . . . . . . . . . IDENT VAR
 /app/parser/parser.go:713: ast.Ident{Name: VAR}
   22: 11: . . . . . . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . ":"
   22: 21: . . . . . . . . . . . . Element (
   22: 21: . . . . . . . . . . . . . Expression (
   22: 21: . . . . . . . . . . . . . . BinaryExpr (
   22: 21: . . . . . . . . . . . . . . . UnaryExpr (
   22: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   22: 21: . . . . . . . . . . . . . . . . . Operand (
   22: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   22: 25: . . . . . . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . ","
   23:  1: . . . . . . . . . . )
   23:  1: . . . . . . . . . . "}"
   23:  2: . . . . . . . . . )
   23:  2: . . . . . . . . )
   23:  2: . . . . . . . )
   23:  2: . . . . . . )
   23:  2: . . . . . )
   23:  2: . . . . )
   23:  2: . . . . ";"
   25:  1: . . . )
   25:  1: . . )
   25:  1: . )
   25:  1: . Declaration (
   25:  1: . . GenDecl(type) (
   25:  1: . . . "type"
   25:  6: . . . TypeSpec (
   25:  6: . . . . IDENT Mode
 /app/parser/parser.go:713: ast.Ident{Name: Mode}
   25: 11: . . . . Type (
   25: 11: . . . . . TypeName (
   25: 11: . . . . . . IDENT uint
 /app/parser/parser.go:713: ast.Ident{Name: uint}
   25: 15: . . . . . )
   25: 15: . . . . )
   25: 15: . . . . ";"
   27:  1: . . . )
   27:  1: . . )
   27:  1: . )
   27:  1: . Declaration (
   27:  1: . . GenDecl(const) (
   27:  1: . . . "const"
   27:  7: . . . "("
   28:  2: . . . COMMENT
   29:  2: . . . constSpec (
   29:  2: . . . . IdentList (
   29:  2: . . . . . IDENT PackageClauseOnly
 /app/parser/parser.go:713: ast.Ident{Name: PackageClauseOnly}
   29: 20: . . . . )
   29: 20: . . . . TypeName (
   29: 20: . . . . . IDENT Mode
 /app/parser/parser.go:713: ast.Ident{Name: Mode}
   29: 25: . . . . )
   29: 25: . . . . "="
   29: 27: . . . . ExpressionList (
   29: 27: . . . . . Expression (
   29: 27: . . . . . . BinaryExpr (
   29: 27: . . . . . . . UnaryExpr (
   29: 27: . . . . . . . . PrimaryExpr (
   29: 27: . . . . . . . . . Operand (
   29: 27: . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   29: 29: . . . . . . . . . )
   29: 29: . . . . . . . . )
   29: 29: . . . . . . . )
   29: 29: . . . . . . . "<<"
   29: 32: . . . . . . . BinaryExpr (
   29: 32: . . . . . . . . UnaryExpr (
   29: 32: . . . . . . . . . PrimaryExpr (
   29: 32: . . . . . . . . . . Operand (
   29: 32: . . . . . . . . . . . IDENT iota
 /app/parser/parser.go:713: ast.Ident{Name: iota}
   29: 36: . . . . . . . . . . )
   29: 36: . . . . . . . . . )
   29: 36: . . . . . . . . )
   29: 36: . . . . . . . )
   29: 36: . . . . . . )
   29: 36: . . . . . )
   29: 36: . . . . )
   29: 36: . . . . ";"
   30:  2: . . . . COMMENT
   31:  2: . . . )
   31:  2: . . . constSpec (
   31:  2: . . . . IdentList (
   31:  2: . . . . . IDENT ImportsOnly
 /app/parser/parser.go:713: ast.Ident{Name: ImportsOnly}
   31: 13: . . . . )
   31: 13: . . . . ";"
   32:  2: . . . . COMMENT
   33:  2: . . . )
   33:  2: . . . constSpec (
   33:  2: . . . . IdentList (
   33:  2: . . . . . IDENT ParseComments
 /app/parser/parser.go:713: ast.Ident{Name: ParseComments}
   33: 15: . . . . )
   33: 15: . . . . ";"
   34:  2: . . . . COMMENT
   35:  2: . . . )
   35:  2: . . . constSpec (
   35:  2: . . . . IdentList (
   35:  2: . . . . . IDENT Trace
 /app/parser/parser.go:713: ast.Ident{Name: Trace}
   35:  7: . . . . )
   35:  7: . . . . ";"
   36:  2: . . . . COMMENT
   37:  2: . . . )
   37:  2: . . . constSpec (
   37:  2: . . . . IdentList (
   37:  2: . . . . . IDENT DeclarationErrors
 /app/parser/parser.go:713: ast.Ident{Name: DeclarationErrors}
   37: 19: . . . . )
   37: 19: . . . . ";"
   38:  2: . . . . COMMENT
   39:  2: . . . )
   39:  2: . . . constSpec (
   39:  2: . . . . IdentList (
   39:  2: . . . . . IDENT AllErrors
 /app/parser/parser.go:713: ast.Ident{Name: AllErrors}
   39: 11: . . . . )
   39: 11: . . . . ";"
   40:  1: . . . )
   40:  1: . . . ")"
   40:  2: . . . ";"
   42:  1: . . . COMMENT
   43:  1: . . )
   43:  1: . )
   43:  1: . Declaration (
   43:  1: . . GenDecl(type) (
   43:  1: . . . "type"
   43:  6: . . . TypeSpec (
   43:  6: . . . . IDENT FileSystem
 /app/parser/parser.go:713: ast.Ident{Name: FileSystem}
   43: 17: . . . . Type (
   43: 17: . . . . . InterfaceType (
   43: 17: . . . . . . "interface"
   43: 27: . . . . . . "{"
   44:  2: . . . . . . MethodSpec (
   44:  2: . . . . . . . TypeName (
   44:  2: . . . . . . . . IDENT ReadDir
 /app/parser/parser.go:713: ast.Ident{Name: ReadDir}
   44:  9: . . . . . . . )
   44:  9: . . . . . . . Signature (
   44:  9: . . . . . . . . Parameters (
   44:  9: . . . . . . . . . "("
   44: 10: . . . . . . . . . ParameterList (
   44: 10: . . . . . . . . . . ParamDeclOrNil (
   44: 10: . . . . . . . . . . . IDENT dirname
 /app/parser/parser.go:713: ast.Ident{Name: dirname}
   44: 18: . . . . . . . . . . . Type (
   44: 18: . . . . . . . . . . . . TypeName (
   44: 18: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   44: 24: . . . . . . . . . . . . )
   44: 24: . . . . . . . . . . . )
   44: 24: . . . . . . . . . . )
   44: 24: . . . . . . . . . )
   44: 24: . . . . . . . . . ")"
   44: 26: . . . . . . . . )
   44: 26: . . . . . . . . Result (
   44: 26: . . . . . . . . . Parameters (
   44: 26: . . . . . . . . . . "("
   44: 27: . . . . . . . . . . ParameterList (
   44: 27: . . . . . . . . . . . ParamDeclOrNil (
   44: 27: . . . . . . . . . . . . Type (
   44: 27: . . . . . . . . . . . . . ArrayType (
   44: 27: . . . . . . . . . . . . . . "["
   44: 28: . . . . . . . . . . . . . . "]"
   44: 29: . . . . . . . . . . . . . . Type (
   44: 29: . . . . . . . . . . . . . . . TypeName (
   44: 29: . . . . . . . . . . . . . . . . IDENT os
 /app/parser/parser.go:713: ast.Ident{Name: os}
   44: 31: . . . . . . . . . . . . . . . . "."
   44: 32: . . . . . . . . . . . . . . . . IDENT FileInfo
 /app/parser/parser.go:713: ast.Ident{Name: FileInfo}
   44: 40: . . . . . . . . . . . . . . . )
   44: 40: . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{os FileInfo}}
   44: 40: . . . . . . . . . . . . . )
   44: 40: . . . . . . . . . . . . )
   44: 40: . . . . . . . . . . . )
   44: 40: . . . . . . . . . . . ","
   44: 42: . . . . . . . . . . . ParamDeclOrNil (
   44: 42: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   44: 47: . . . . . . . . . . . )
   44: 47: . . . . . . . . . . )
   44: 47: . . . . . . . . . . ")"
   44: 48: . . . . . . . . . )
   44: 48: . . . . . . . . )
   44: 48: . . . . . . . )
   44: 48: . . . . . . . ";"
   45:  2: . . . . . . )
   45:  2: . . . . . . MethodSpec (
   45:  2: . . . . . . . TypeName (
   45:  2: . . . . . . . . IDENT ReadFile
 /app/parser/parser.go:713: ast.Ident{Name: ReadFile}
   45: 10: . . . . . . . )
   45: 10: . . . . . . . Signature (
   45: 10: . . . . . . . . Parameters (
   45: 10: . . . . . . . . . "("
   45: 11: . . . . . . . . . ParameterList (
   45: 11: . . . . . . . . . . ParamDeclOrNil (
   45: 11: . . . . . . . . . . . IDENT filename
 /app/parser/parser.go:713: ast.Ident{Name: filename}
   45: 20: . . . . . . . . . . . Type (
   45: 20: . . . . . . . . . . . . TypeName (
   45: 20: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   45: 26: . . . . . . . . . . . . )
   45: 26: . . . . . . . . . . . )
   45: 26: . . . . . . . . . . )
   45: 26: . . . . . . . . . )
   45: 26: . . . . . . . . . ")"
   45: 28: . . . . . . . . )
   45: 28: . . . . . . . . Result (
   45: 28: . . . . . . . . . Parameters (
   45: 28: . . . . . . . . . . "("
   45: 29: . . . . . . . . . . ParameterList (
   45: 29: . . . . . . . . . . . ParamDeclOrNil (
   45: 29: . . . . . . . . . . . . Type (
   45: 29: . . . . . . . . . . . . . ArrayType (
   45: 29: . . . . . . . . . . . . . . "["
   45: 30: . . . . . . . . . . . . . . "]"
   45: 31: . . . . . . . . . . . . . . Type (
   45: 31: . . . . . . . . . . . . . . . TypeName (
   45: 31: . . . . . . . . . . . . . . . . IDENT byte
 /app/parser/parser.go:713: ast.Ident{Name: byte}
   45: 35: . . . . . . . . . . . . . . . )
   45: 35: . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
   45: 35: . . . . . . . . . . . . . )
   45: 35: . . . . . . . . . . . . )
   45: 35: . . . . . . . . . . . )
   45: 35: . . . . . . . . . . . ","
   45: 37: . . . . . . . . . . . ParamDeclOrNil (
   45: 37: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   45: 42: . . . . . . . . . . . )
   45: 42: . . . . . . . . . . )
   45: 42: . . . . . . . . . . ")"
   45: 43: . . . . . . . . . )
   45: 43: . . . . . . . . )
   45: 43: . . . . . . . )
   45: 43: . . . . . . . ";"
   46:  2: . . . . . . )
   46:  2: . . . . . . MethodSpec (
   46:  2: . . . . . . . TypeName (
   46:  2: . . . . . . . . IDENT Join
 /app/parser/parser.go:713: ast.Ident{Name: Join}
   46:  6: . . . . . . . )
   46:  6: . . . . . . . Signature (
   46:  6: . . . . . . . . Parameters (
   46:  6: . . . . . . . . . "("
   46:  7: . . . . . . . . . ParameterList (
   46:  7: . . . . . . . . . . ParamDeclOrNil (
   46:  7: . . . . . . . . . . . IDENT elem
 /app/parser/parser.go:713: ast.Ident{Name: elem}
   46: 12: . . . . . . . . . . . DotsType (
   46: 12: . . . . . . . . . . . . "..."
   46: 15: . . . . . . . . . . . . Type (
   46: 15: . . . . . . . . . . . . . TypeName (
   46: 15: . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   46: 21: . . . . . . . . . . . . . )
   46: 21: . . . . . . . . . . . . )
   46: 21: . . . . . . . . . . . )
   46: 21: . . . . . . . . . . )
   46: 21: . . . . . . . . . )
   46: 21: . . . . . . . . . ")"
   46: 23: . . . . . . . . )
   46: 23: . . . . . . . . Result (
   46: 23: . . . . . . . . . TypeName (
   46: 23: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   46: 29: . . . . . . . . . )
   46: 29: . . . . . . . . )
   46: 29: . . . . . . . )
   46: 29: . . . . . . . ";"
   47:  1: . . . . . . )
   47:  1: . . . . . . "}"
   47:  2: . . . . . )
   47:  2: . . . . )
   47:  2: . . . . ";"
   49:  1: . . . )
   49:  1: . . )
   49:  1: . )
   49:  1: . Declaration (
   49:  1: . . GenDecl(type) (
   49:  1: . . . "type"
   49:  6: . . . TypeSpec (
   49:  6: . . . . IDENT IF
 /app/parser/parser.go:713: ast.Ident{Name: IF}
   49:  9: . . . . "="
   49: 11: . . . . Type (
   49: 11: . . . . . TypeName (
   49: 11: . . . . . . IDENT FileSystem
 /app/parser/parser.go:713: ast.Ident{Name: FileSystem}
   49: 21: . . . . . )
   49: 21: . . . . )
   49: 21: . . . . ";"
   51:  1: . . . )
   51:  1: . . )
   51:  1: . )
   51:  1: . Declaration (
   51:  1: . . GenDecl(type) (
   51:  1: . . . "type"
   51:  6: . . . TypeSpec (
   51:  6: . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
   51: 10: . . . . Type (
   51: 10: . . . . . StructType (
   51: 10: . . . . . . "struct"
   51: 17: . . . . . . "{"
   52:  2: . . . . . . FieldDecl (
   52:  2: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   52:  3: . . . . . . . ","
   52:  5: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   52:  7: . . . . . . . Type (
   52:  7: . . . . . . . . MapType (
   52:  7: . . . . . . . . . "map"
   52: 10: . . . . . . . . . "["
   52: 11: . . . . . . . . . Type (
   52: 11: . . . . . . . . . . TypeName (
   52: 11: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   52: 17: . . . . . . . . . . )
   52: 17: . . . . . . . . . )
   52: 17: . . . . . . . . . "]"
   52: 18: . . . . . . . . . Type (
   52: 18: . . . . . . . . . . StructType (
   52: 18: . . . . . . . . . . . "struct"
   52: 24: . . . . . . . . . . . "{"
   52: 25: . . . . . . . . . . . "}"
   52: 26: . . . . . . . . . . )
   52: 26: . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: string, Value: &{1171 0xc0002b4300 false}}
   52: 26: . . . . . . . . )
   52: 26: . . . . . . . )
   52: 26: . . . . . . . ";"
   53:  1: . . . . . . )
   53:  1: . . . . . . "}"
   53:  2: . . . . . )
   53:  2: . . . . )
   53:  2: . . . . ";"
   55:  1: . . . )
   55:  1: . . )
   55:  1: . )
   55:  1: . Declaration (
   55:  1: . . FunctionDeclOrCall (
   55:  1: . . . "func"
   55:  6: . . . Parameters (
   55:  6: . . . . "("
   55:  7: . . . . ParameterList (
   55:  7: . . . . . ParamDeclOrNil (
   55:  7: . . . . . . IDENT p
 /app/parser/parser.go:713: ast.Ident{Name: p}
   55:  9: . . . . . . Type (
   55:  9: . . . . . . . PointerType (
   55:  9: . . . . . . . . "*"
   55: 10: . . . . . . . . Type (
   55: 10: . . . . . . . . . TypeName (
   55: 10: . . . . . . . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
   55: 13: . . . . . . . . . )
   55: 13: . . . . . . . . )
   55: 13: . . . . . . . )
   55: 13: . . . . . . )
   55: 13: . . . . . )
   55: 13: . . . . )
   55: 13: . . . . ")"
   55: 15: . . . )
   55: 15: . . . TypeName (
   55: 15: . . . . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
   55: 18: . . . )
   55: 18: . . . Signature (
   55: 18: . . . . Parameters (
   55: 18: . . . . . "("
   55: 19: . . . . . ")"
   55: 21: . . . . )
   55: 21: . . . . Result (
   55: 21: . . . . )
   55: 21: . . . )
   55: 21: . . . Body (
   55: 21: . . . . "{"
   56:  1: . . . . StatementList (
   56:  1: . . . . )
   56:  1: . . . . "}"
   56:  2: . . . )
   56:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
   58:  1: . . )
   58:  1: . )
   58:  1: . Declaration (
   58:  1: . . FunctionDeclOrCall (
   58:  1: . . . "func"
   58:  6: . . . IDENT init
 /app/parser/parser.go:713: ast.Ident{Name: init}
   58: 10: . . . Signature (
   58: 10: . . . . Parameters (
   58: 10: . . . . . "("
   58: 11: . . . . . ")"
   58: 13: . . . . )
   58: 13: . . . . Result (
   58: 13: . . . . )
   58: 13: . . . )
   58: 13: . . . Body (
   58: 13: . . . . "{"
   59:  2: . . . . StatementList (
   59:  2: . . . . . Statement (
   59:  2: . . . . . . SimpleStmt (
   59:  2: . . . . . . . ExpressionList (
   59:  2: . . . . . . . . Expression (
   59:  2: . . . . . . . . . BinaryExpr (
   59:  2: . . . . . . . . . . UnaryExpr (
   59:  2: . . . . . . . . . . . PrimaryExpr (
   59:  2: . . . . . . . . . . . . Operand (
   59:  2: . . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   59:  3: . . . . . . . . . . . . )
   59:  3: . . . . . . . . . . . )
   59:  3: . . . . . . . . . . )
   59:  3: . . . . . . . . . )
   59:  3: . . . . . . . . )
   59:  3: . . . . . . . . ","
   59:  5: . . . . . . . . Expression (
   59:  5: . . . . . . . . . BinaryExpr (
   59:  5: . . . . . . . . . . UnaryExpr (
   59:  5: . . . . . . . . . . . PrimaryExpr (
   59:  5: . . . . . . . . . . . . Operand (
   59:  5: . . . . . . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   59:  9: . . . . . . . . . . . . )
   59:  9: . . . . . . . . . . . )
   59:  9: . . . . . . . . . . )
   59:  9: . . . . . . . . . )
   59:  9: . . . . . . . . )
   59:  9: . . . . . . . )
   59:  9: . . . . . . . ":="
   59: 12: . . . . . . . ExpressionList (
   59: 12: . . . . . . . . Expression (
   59: 12: . . . . . . . . . BinaryExpr (
   59: 12: . . . . . . . . . . UnaryExpr (
   59: 12: . . . . . . . . . . . PrimaryExpr (
   59: 12: . . . . . . . . . . . . Operand (
   59: 12: . . . . . . . . . . . . . IDENT os
 /app/parser/parser.go:713: ast.Ident{Name: os}
   59: 14: . . . . . . . . . . . . )
   59: 14: . . . . . . . . . . . . "."
   59: 15: . . . . . . . . . . . . Selector (
   59: 15: . . . . . . . . . . . . . IDENT Open
 /app/parser/parser.go:713: ast.Ident{Name: Open}
   59: 19: . . . . . . . . . . . . )
   59: 19: . . . . . . . . . . . . CallOrConversion (
   59: 19: . . . . . . . . . . . . . "("
   59: 20: . . . . . . . . . . . . . Expression (
   59: 20: . . . . . . . . . . . . . . BinaryExpr (
   59: 20: . . . . . . . . . . . . . . . UnaryExpr (
   59: 20: . . . . . . . . . . . . . . . . PrimaryExpr (
   59: 20: . . . . . . . . . . . . . . . . . Operand (
   59: 20: . . . . . . . . . . . . . . . . . . STRING "a"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a"}
   59: 23: . . . . . . . . . . . . . . . . . )
   59: 23: . . . . . . . . . . . . . . . . )
   59: 23: . . . . . . . . . . . . . . . )
   59: 23: . . . . . . . . . . . . . . )
   59: 23: . . . . . . . . . . . . . )
   59: 23: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{os Open}, Ellipsis: false, isCmd: false}
   59: 24: . . . . . . . . . . . . )
   59: 24: . . . . . . . . . . . )
   59: 24: . . . . . . . . . . )
   59: 24: . . . . . . . . . )
   59: 24: . . . . . . . . )
   59: 24: . . . . . . . )
   59: 24: . . . . . . )
   59: 24: . . . . . . ";"
   60:  2: . . . . . )
   60:  2: . . . . . Statement (
   60:  2: . . . . . . IfStmt (
   60:  2: . . . . . . . "if"
   60:  5: . . . . . . . SimpleStmt (
   60:  5: . . . . . . . . ExpressionList (
   60:  5: . . . . . . . . . Expression (
   60:  5: . . . . . . . . . . BinaryExpr (
   60:  5: . . . . . . . . . . . UnaryExpr (
   60:  5: . . . . . . . . . . . . PrimaryExpr (
   60:  5: . . . . . . . . . . . . . Operand (
   60:  5: . . . . . . . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   60:  9: . . . . . . . . . . . . . )
   60:  9: . . . . . . . . . . . . )
   60:  9: . . . . . . . . . . . )
   60:  9: . . . . . . . . . . . "!="
   60: 12: . . . . . . . . . . . BinaryExpr (
   60: 12: . . . . . . . . . . . . UnaryExpr (
   60: 12: . . . . . . . . . . . . . PrimaryExpr (
   60: 12: . . . . . . . . . . . . . . Operand (
   60: 12: . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   60: 16: . . . . . . . . . . . . . . )
   60: 16: . . . . . . . . . . . . . )
   60: 16: . . . . . . . . . . . . )
   60: 16: . . . . . . . . . . . )
   60: 16: . . . . . . . . . . )
   60: 16: . . . . . . . . . )
   60: 16: . . . . . . . . )
   60: 16: . . . . . . . )
   60: 16: . . . . . . . BlockStmt (
   60: 16: . . . . . . . . "{"
   61:  3: . . . . . . . . StatementList (
   61:  3: . . . . . . . . . Statement (
   61:  3: . . . . . . . . . . ReturnStmt (
   61:  3: . . . . . . . . . . . "return"
   61:  9: . . . . . . . . . . . ";"
   62:  2: . . . . . . . . . . )
   62:  2: . . . . . . . . . )
   62:  2: . . . . . . . . )
   62:  2: . . . . . . . . "}"
   62:  3: . . . . . . . )
   62:  3: . . . . . . . ";"
   63:  2: . . . . . . )
   63:  2: . . . . . )
   63:  2: . . . . . Statement (
   63:  2: . . . . . . DeferStmt (
   63:  2: . . . . . . . "defer"
   63:  8: . . . . . . . Expression (
   63:  8: . . . . . . . . BinaryExpr (
   63:  8: . . . . . . . . . UnaryExpr (
   63:  8: . . . . . . . . . . PrimaryExpr (
   63:  8: . . . . . . . . . . . Operand (
   63:  8: . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   63:  9: . . . . . . . . . . . )
   63:  9: . . . . . . . . . . . "."
   63: 10: . . . . . . . . . . . Selector (
   63: 10: . . . . . . . . . . . . IDENT Close
 /app/parser/parser.go:713: ast.Ident{Name: Close}
   63: 15: . . . . . . . . . . . )
   63: 15: . . . . . . . . . . . CallOrConversion (
   63: 15: . . . . . . . . . . . . "("
   63: 16: . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{f Close}, Ellipsis: false, isCmd: false}
   63: 17: . . . . . . . . . . . )
   63: 17: . . . . . . . . . . )
   63: 17: . . . . . . . . . )
   63: 17: . . . . . . . . )
   63: 17: . . . . . . . )
   63: 17: . . . . . . . ";"
   65:  2: . . . . . . )
   65:  2: . . . . . )
   65:  2: . . . . . Statement (
   65:  2: . . . . . . SimpleStmt (
   65:  2: . . . . . . . ExpressionList (
   65:  2: . . . . . . . . Expression (
   65:  2: . . . . . . . . . BinaryExpr (
   65:  2: . . . . . . . . . . UnaryExpr (
   65:  2: . . . . . . . . . . . PrimaryExpr (
   65:  2: . . . . . . . . . . . . Operand (
   65:  2: . . . . . . . . . . . . . IDENT ch
 /app/parser/parser.go:713: ast.Ident{Name: ch}
   65:  5: . . . . . . . . . . . . )
   65:  5: . . . . . . . . . . . )
   65:  5: . . . . . . . . . . )
   65:  5: . . . . . . . . . )
   65:  5: . . . . . . . . )
   65:  5: . . . . . . . )
   65:  5: . . . . . . . ":="
   65:  8: . . . . . . . ExpressionList (
   65:  8: . . . . . . . . Expression (
   65:  8: . . . . . . . . . BinaryExpr (
   65:  8: . . . . . . . . . . UnaryExpr (
   65:  8: . . . . . . . . . . . PrimaryExpr (
   65:  8: . . . . . . . . . . . . Operand (
   65:  8: . . . . . . . . . . . . . IDENT make
 /app/parser/parser.go:713: ast.Ident{Name: make}
   65: 12: . . . . . . . . . . . . )
   65: 12: . . . . . . . . . . . . CallOrConversion (
   65: 12: . . . . . . . . . . . . . "("
   65: 13: . . . . . . . . . . . . . Expression (
   65: 13: . . . . . . . . . . . . . . BinaryExpr (
   65: 13: . . . . . . . . . . . . . . . UnaryExpr (
   65: 13: . . . . . . . . . . . . . . . . PrimaryExpr (
   65: 13: . . . . . . . . . . . . . . . . . Operand (
   65: 13: . . . . . . . . . . . . . . . . . . ChanType (
   65: 13: . . . . . . . . . . . . . . . . . . . "chan"
   65: 18: . . . . . . . . . . . . . . . . . . . Type (
   65: 18: . . . . . . . . . . . . . . . . . . . . TypeName (
   65: 18: . . . . . . . . . . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   65: 22: . . . . . . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . ","
   65: 24: . . . . . . . . . . . . . Expression (
   65: 24: . . . . . . . . . . . . . . BinaryExpr (
   65: 24: . . . . . . . . . . . . . . . UnaryExpr (
   65: 24: . . . . . . . . . . . . . . . . PrimaryExpr (
   65: 24: . . . . . . . . . . . . . . . . . Operand (
   65: 24: . . . . . . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
   65: 27: . . . . . . . . . . . . . . . . . )
   65: 27: . . . . . . . . . . . . . . . . )
   65: 27: . . . . . . . . . . . . . . . )
   65: 27: . . . . . . . . . . . . . . )
   65: 27: . . . . . . . . . . . . . )
   65: 27: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: make, Ellipsis: false, isCmd: false}
   65: 28: . . . . . . . . . . . . )
   65: 28: . . . . . . . . . . . )
   65: 28: . . . . . . . . . . )
   65: 28: . . . . . . . . . )
   65: 28: . . . . . . . . )
   65: 28: . . . . . . . )
   65: 28: . . . . . . )
   65: 28: . . . . . . ";"
   66:  2: . . . . . )
   66:  2: . . . . . Statement (
   66:  2: . . . . . . SelectStmt (
   66:  2: . . . . . . . "select"
   66:  9: . . . . . . . "{"
   67:  2: . . . . . . . CommClause (
   67:  2: . . . . . . . . "case"
   67:  7: . . . . . . . . ExpressionList (
   67:  7: . . . . . . . . . Expression (
   67:  7: . . . . . . . . . . BinaryExpr (
   67:  7: . . . . . . . . . . . UnaryExpr (
   67:  7: . . . . . . . . . . . . "<-"
   67:  9: . . . . . . . . . . . . UnaryExpr (
   67:  9: . . . . . . . . . . . . . PrimaryExpr (
   67:  9: . . . . . . . . . . . . . . Operand (
   67:  9: . . . . . . . . . . . . . . . IDENT ch
 /app/parser/parser.go:713: ast.Ident{Name: ch}
   67: 11: . . . . . . . . . . . . . . )
   67: 11: . . . . . . . . . . . . . )
   67: 11: . . . . . . . . . . . . )
   67: 11: . . . . . . . . . . . )
   67: 11: . . . . . . . . . . )
   67: 11: . . . . . . . . . )
   67: 11: . . . . . . . . )
   67: 11: . . . . . . . . ":"
   68:  3: . . . . . . . . StatementList (
   68:  3: . . . . . . . . . Statement (
   68:  3: . . . . . . . . . . SimpleStmt (
   68:  3: . . . . . . . . . . . ExpressionList (
   68:  3: . . . . . . . . . . . . Expression (
   68:  3: . . . . . . . . . . . . . BinaryExpr (
   68:  3: . . . . . . . . . . . . . . UnaryExpr (
   68:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   68:  3: . . . . . . . . . . . . . . . . Operand (
   68:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   68: 10: . . . . . . . . . . . . . . . . )
   68: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   68: 10: . . . . . . . . . . . . . . . . . "("
   68: 11: . . . . . . . . . . . . . . . . . Expression (
   68: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   68: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   68: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   68: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   68: 11: . . . . . . . . . . . . . . . . . . . . . . STRING "1"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "1"}
   68: 14: . . . . . . . . . . . . . . . . . . . . . )
   68: 14: . . . . . . . . . . . . . . . . . . . . )
   68: 14: . . . . . . . . . . . . . . . . . . . )
   68: 14: . . . . . . . . . . . . . . . . . . )
   68: 14: . . . . . . . . . . . . . . . . . )
   68: 14: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   68: 15: . . . . . . . . . . . . . . . . )
   68: 15: . . . . . . . . . . . . . . . )
   68: 15: . . . . . . . . . . . . . . )
   68: 15: . . . . . . . . . . . . . )
   68: 15: . . . . . . . . . . . . )
   68: 15: . . . . . . . . . . . )
   68: 15: . . . . . . . . . . )
   68: 15: . . . . . . . . . . ";"
   69:  2: . . . . . . . . . )
   69:  2: . . . . . . . . )
   69:  2: . . . . . . . )
   69:  2: . . . . . . . CommClause (
   69:  2: . . . . . . . . "case"
   69:  7: . . . . . . . . ExpressionList (
   69:  7: . . . . . . . . . Expression (
   69:  7: . . . . . . . . . . BinaryExpr (
   69:  7: . . . . . . . . . . . UnaryExpr (
   69:  7: . . . . . . . . . . . . PrimaryExpr (
   69:  7: . . . . . . . . . . . . . Operand (
   69:  7: . . . . . . . . . . . . . . IDENT ch
 /app/parser/parser.go:713: ast.Ident{Name: ch}
   69: 10: . . . . . . . . . . . . . )
   69: 10: . . . . . . . . . . . . )
   69: 10: . . . . . . . . . . . )
   69: 10: . . . . . . . . . . )
   69: 10: . . . . . . . . . )
   69: 10: . . . . . . . . )
   69: 10: . . . . . . . . "<-"
   69: 13: . . . . . . . . Expression (
   69: 13: . . . . . . . . . BinaryExpr (
   69: 13: . . . . . . . . . . UnaryExpr (
   69: 13: . . . . . . . . . . . PrimaryExpr (
   69: 13: . . . . . . . . . . . . Operand (
   69: 13: . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   69: 17: . . . . . . . . . . . . )
   69: 17: . . . . . . . . . . . )
   69: 17: . . . . . . . . . . )
   69: 17: . . . . . . . . . )
   69: 17: . . . . . . . . )
   69: 17: . . . . . . . . ":"
   70:  3: . . . . . . . . StatementList (
   70:  3: . . . . . . . . . Statement (
   70:  3: . . . . . . . . . . SimpleStmt (
   70:  3: . . . . . . . . . . . ExpressionList (
   70:  3: . . . . . . . . . . . . Expression (
   70:  3: . . . . . . . . . . . . . BinaryExpr (
   70:  3: . . . . . . . . . . . . . . UnaryExpr (
   70:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   70:  3: . . . . . . . . . . . . . . . . Operand (
   70:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   70: 10: . . . . . . . . . . . . . . . . )
   70: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   70: 10: . . . . . . . . . . . . . . . . . "("
   70: 11: . . . . . . . . . . . . . . . . . Expression (
   70: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   70: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   70: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   70: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   70: 11: . . . . . . . . . . . . . . . . . . . . . . STRING "2"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "2"}
   70: 14: . . . . . . . . . . . . . . . . . . . . . )
   70: 14: . . . . . . . . . . . . . . . . . . . . )
   70: 14: . . . . . . . . . . . . . . . . . . . )
   70: 14: . . . . . . . . . . . . . . . . . . )
   70: 14: . . . . . . . . . . . . . . . . . )
   70: 14: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   70: 15: . . . . . . . . . . . . . . . . )
   70: 15: . . . . . . . . . . . . . . . )
   70: 15: . . . . . . . . . . . . . . )
   70: 15: . . . . . . . . . . . . . )
   70: 15: . . . . . . . . . . . . )
   70: 15: . . . . . . . . . . . )
   70: 15: . . . . . . . . . . )
   70: 15: . . . . . . . . . . ";"
   71:  2: . . . . . . . . . )
   71:  2: . . . . . . . . )
   71:  2: . . . . . . . )
   71:  2: . . . . . . . "}"
   71:  3: . . . . . . . ";"
   73:  2: . . . . . . )
   73:  2: . . . . . )
   73:  2: . . . . . Statement (
   73:  2: . . . . . . GoStmt (
   73:  2: . . . . . . . "go"
   73:  5: . . . . . . . Expression (
   73:  5: . . . . . . . . BinaryExpr (
   73:  5: . . . . . . . . . UnaryExpr (
   73:  5: . . . . . . . . . . PrimaryExpr (
   73:  5: . . . . . . . . . . . Operand (
   73:  5: . . . . . . . . . . . . FuncTypeOrLit (
   73:  5: . . . . . . . . . . . . . FuncType (
   73:  5: . . . . . . . . . . . . . . "func"
   73:  9: . . . . . . . . . . . . . . Signature (
   73:  9: . . . . . . . . . . . . . . . Parameters (
   73:  9: . . . . . . . . . . . . . . . . "("
   73: 10: . . . . . . . . . . . . . . . . ParameterList (
   73: 10: . . . . . . . . . . . . . . . . . ParamDeclOrNil (
   73: 10: . . . . . . . . . . . . . . . . . . IDENT fs
 /app/parser/parser.go:713: ast.Ident{Name: fs}
   73: 13: . . . . . . . . . . . . . . . . . . Type (
   73: 13: . . . . . . . . . . . . . . . . . . . TypeName (
   73: 13: . . . . . . . . . . . . . . . . . . . . IDENT FileSystem
 /app/parser/parser.go:713: ast.Ident{Name: FileSystem}
   73: 23: . . . . . . . . . . . . . . . . . . . )
   73: 23: . . . . . . . . . . . . . . . . . . )
   73: 23: . . . . . . . . . . . . . . . . . )
   73: 23: . . . . . . . . . . . . . . . . )
   73: 23: . . . . . . . . . . . . . . . . ")"
   73: 25: . . . . . . . . . . . . . . . )
   73: 25: . . . . . . . . . . . . . . . Result (
   73: 25: . . . . . . . . . . . . . . . )
   73: 25: . . . . . . . . . . . . . . )
   73: 25: . . . . . . . . . . . . . )
   73: 25: . . . . . . . . . . . . . Body (
   73: 25: . . . . . . . . . . . . . . "{"
   74:  3: . . . . . . . . . . . . . . StatementList (
   74:  3: . . . . . . . . . . . . . . . Statement (
   74:  3: . . . . . . . . . . . . . . . . IfStmt (
   74:  3: . . . . . . . . . . . . . . . . . "if"
   74:  6: . . . . . . . . . . . . . . . . . SimpleStmt (
   74:  6: . . . . . . . . . . . . . . . . . . ExpressionList (
   74:  6: . . . . . . . . . . . . . . . . . . . Expression (
   74:  6: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   74:  6: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   74:  6: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   74:  6: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   74:  6: . . . . . . . . . . . . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   74:  9: . . . . . . . . . . . . . . . . . . . . . . . )
   74:  9: . . . . . . . . . . . . . . . . . . . . . . )
   74:  9: . . . . . . . . . . . . . . . . . . . . . )
   74:  9: . . . . . . . . . . . . . . . . . . . . )
   74:  9: . . . . . . . . . . . . . . . . . . . )
   74:  9: . . . . . . . . . . . . . . . . . . . ","
   74: 11: . . . . . . . . . . . . . . . . . . . Expression (
   74: 11: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   74: 11: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   74: 11: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   74: 11: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   74: 11: . . . . . . . . . . . . . . . . . . . . . . . . IDENT ok
 /app/parser/parser.go:713: ast.Ident{Name: ok}
   74: 14: . . . . . . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . ":="
   74: 17: . . . . . . . . . . . . . . . . . . ExpressionList (
   74: 17: . . . . . . . . . . . . . . . . . . . Expression (
   74: 17: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   74: 17: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   74: 17: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   74: 17: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   74: 17: . . . . . . . . . . . . . . . . . . . . . . . . IDENT fs
 /app/parser/parser.go:713: ast.Ident{Name: fs}
   74: 19: . . . . . . . . . . . . . . . . . . . . . . . )
   74: 19: . . . . . . . . . . . . . . . . . . . . . . . "."
   74: 20: . . . . . . . . . . . . . . . . . . . . . . . TypeAssertion (
   74: 20: . . . . . . . . . . . . . . . . . . . . . . . . "("
   74: 21: . . . . . . . . . . . . . . . . . . . . . . . . Type (
   74: 21: . . . . . . . . . . . . . . . . . . . . . . . . . PointerType (
   74: 21: . . . . . . . . . . . . . . . . . . . . . . . . . . "*"
   74: 22: . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
   74: 22: . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
   74: 22: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
   74: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   74: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   74: 25: . . . . . . . . . . . . . . . . . . . . . . . . . )
   74: 25: . . . . . . . . . . . . . . . . . . . . . . . . )
   74: 25: . . . . . . . . . . . . . . . . . . . . . . . . ")"
   74: 26: . . . . . . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . ";"
   74: 28: . . . . . . . . . . . . . . . . . SimpleStmt (
   74: 28: . . . . . . . . . . . . . . . . . . ExpressionList (
   74: 28: . . . . . . . . . . . . . . . . . . . Expression (
   74: 28: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   74: 28: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   74: 28: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   74: 28: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   74: 28: . . . . . . . . . . . . . . . . . . . . . . . . IDENT ok
 /app/parser/parser.go:713: ast.Ident{Name: ok}
   74: 31: . . . . . . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . BlockStmt (
   74: 31: . . . . . . . . . . . . . . . . . . "{"
   75:  4: . . . . . . . . . . . . . . . . . . StatementList (
   75:  4: . . . . . . . . . . . . . . . . . . . Statement (
   75:  4: . . . . . . . . . . . . . . . . . . . . SimpleStmt (
   75:  4: . . . . . . . . . . . . . . . . . . . . . ExpressionList (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . Expression (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   75: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   75: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   75: 16: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . ";"
   76:  3: . . . . . . . . . . . . . . . . . . . )
   76:  3: . . . . . . . . . . . . . . . . . . )
   76:  3: . . . . . . . . . . . . . . . . . . "}"
   76:  4: . . . . . . . . . . . . . . . . . )
   76:  4: . . . . . . . . . . . . . . . . . ";"
   77:  2: . . . . . . . . . . . . . . . . )
   77:  2: . . . . . . . . . . . . . . . )
   77:  2: . . . . . . . . . . . . . . )
   77:  2: . . . . . . . . . . . . . . "}"
   77:  3: . . . . . . . . . . . . . )
   77:  3: . . . . . . . . . . . . )
   77:  3: . . . . . . . . . . . )
   77:  3: . . . . . . . . . . . CallOrConversion (
   77:  3: . . . . . . . . . . . . "("
   77:  4: . . . . . . . . . . . . Expression (
   77:  4: . . . . . . . . . . . . . BinaryExpr (
   77:  4: . . . . . . . . . . . . . . UnaryExpr (
   77:  4: . . . . . . . . . . . . . . . PrimaryExpr (
   77:  4: . . . . . . . . . . . . . . . . Operand (
   77:  4: . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   77:  7: . . . . . . . . . . . . . . . . )
   77:  7: . . . . . . . . . . . . . . . )
   77:  7: . . . . . . . . . . . . . . )
   77:  7: . . . . . . . . . . . . . )
   77:  7: . . . . . . . . . . . . )
   77:  7: . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc0002b88c0 0xc0002b4900}, Ellipsis: false, isCmd: false}
   77:  8: . . . . . . . . . . . )
   77:  8: . . . . . . . . . . )
   77:  8: . . . . . . . . . )
   77:  8: . . . . . . . . )
   77:  8: . . . . . . . )
   77:  8: . . . . . . . ";"
   78:  1: . . . . . . )
   78:  1: . . . . . )
   78:  1: . . . . )
   78:  1: . . . . "}"
   78:  2: . . . )
   78:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: init, ...}
   78:  3: . . )
   78:  3: . )
   78:  3: )
=== RUN   TestFromTestdata/optparam
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/optparam
    1:  1: COMMENT
    2:  1: File (
    2:  1: . Declaration (
    2:  1: . . FunctionDeclOrCall (
    2:  1: . . . "func"
    2:  6: . . . IDENT single
 /app/parser/parser.go:713: ast.Ident{Name: single}
    2: 12: . . . Signature (
    2: 12: . . . . Parameters (
    2: 12: . . . . . "("
    2: 13: . . . . . ParameterList (
    2: 13: . . . . . . ParamDeclOrNil (
    2: 13: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 15: . . . . . . . Type (
    2: 15: . . . . . . . . TypeName (
    2: 15: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    2: 18: . . . . . . . . )
    2: 18: . . . . . . . )
    2: 18: . . . . . . . "?"
    2: 19: . . . . . . )
    2: 19: . . . . . )
    2: 19: . . . . . ")"
    2: 20: . . . . )
    2: 20: . . . . Result (
    2: 20: . . . . )
    2: 20: . . . )
    2: 20: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: single, ...}
    4:  1: . . )
    4:  1: . )
    4:  1: . Declaration (
    4:  1: . . FunctionDeclOrCall (
    4:  1: . . . "func"
    4:  6: . . . IDENT multiple
 /app/parser/parser.go:713: ast.Ident{Name: multiple}
    4: 14: . . . Signature (
    4: 14: . . . . Parameters (
    4: 14: . . . . . "("
    4: 15: . . . . . ParameterList (
    4: 15: . . . . . . ParamDeclOrNil (
    4: 15: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4: 17: . . . . . . . Type (
    4: 17: . . . . . . . . TypeName (
    4: 17: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    4: 20: . . . . . . . . )
    4: 20: . . . . . . . )
    4: 20: . . . . . . )
    4: 20: . . . . . . ","
    4: 22: . . . . . . ParamDeclOrNil (
    4: 22: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4: 24: . . . . . . . Type (
    4: 24: . . . . . . . . TypeName (
    4: 24: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    4: 30: . . . . . . . . )
    4: 30: . . . . . . . )
    4: 30: . . . . . . . "?"
    4: 31: . . . . . . )
    4: 31: . . . . . . ","
    4: 33: . . . . . . ParamDeclOrNil (
    4: 33: . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
    4: 35: . . . . . . . Type (
    4: 35: . . . . . . . . TypeName (
    4: 35: . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
    4: 39: . . . . . . . . )
    4: 39: . . . . . . . )
    4: 39: . . . . . . . "?"
    4: 40: . . . . . . )
    4: 40: . . . . . )
    4: 40: . . . . . ")"
    4: 41: . . . . )
    4: 41: . . . . Result (
    4: 41: . . . . )
    4: 41: . . . )
    4: 41: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: multiple, ...}
    6:  1: . . )
    6:  1: . )
    6:  1: . Declaration (
    6:  1: . . FunctionDeclOrCall (
    6:  1: . . . "func"
    6:  6: . . . IDENT mixed
 /app/parser/parser.go:713: ast.Ident{Name: mixed}
    6: 11: . . . Signature (
    6: 11: . . . . Parameters (
    6: 11: . . . . . "("
    6: 12: . . . . . ParameterList (
    6: 12: . . . . . . ParamDeclOrNil (
    6: 12: . . . . . . . IDENT name
 /app/parser/parser.go:713: ast.Ident{Name: name}
    6: 17: . . . . . . . Type (
    6: 17: . . . . . . . . TypeName (
    6: 17: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    6: 23: . . . . . . . . )
    6: 23: . . . . . . . )
    6: 23: . . . . . . )
    6: 23: . . . . . . ","
    6: 25: . . . . . . ParamDeclOrNil (
    6: 25: . . . . . . . IDENT age
 /app/parser/parser.go:713: ast.Ident{Name: age}
    6: 29: . . . . . . . Type (
    6: 29: . . . . . . . . TypeName (
    6: 29: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    6: 32: . . . . . . . . )
    6: 32: . . . . . . . )
    6: 32: . . . . . . . "?"
    6: 33: . . . . . . )
    6: 33: . . . . . . ","
    6: 35: . . . . . . ParamDeclOrNil (
    6: 35: . . . . . . . IDENT active
 /app/parser/parser.go:713: ast.Ident{Name: active}
    6: 42: . . . . . . . Type (
    6: 42: . . . . . . . . TypeName (
    6: 42: . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
    6: 46: . . . . . . . . )
    6: 46: . . . . . . . )
    6: 46: . . . . . . . "?"
    6: 47: . . . . . . )
    6: 47: . . . . . . ","
    6: 49: . . . . . . ParamDeclOrNil (
    6: 49: . . . . . . . IDENT data
 /app/parser/parser.go:713: ast.Ident{Name: data}
    6: 54: . . . . . . . ArrayFieldOrTypeInstance (
    6: 54: . . . . . . . . "["
    6: 55: . . . . . . . . "]"
    6: 56: . . . . . . . . Type (
    6: 56: . . . . . . . . . TypeName (
    6: 56: . . . . . . . . . . IDENT byte
 /app/parser/parser.go:713: ast.Ident{Name: byte}
    6: 60: . . . . . . . . . )
    6: 60: . . . . . . . . )
    6: 60: . . . . . . . )
    6: 60: . . . . . . )
    6: 60: . . . . . )
    6: 60: . . . . . ")"
    6: 61: . . . . )
    6: 61: . . . . Result (
    6: 61: . . . . )
    6: 61: . . . )
    6: 61: . . . ";"
    8:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: mixed, ...}
    9:  1: . . )
    9:  1: . )
    9:  1: . Declaration (
    9:  1: . . FunctionDeclOrCall (
    9:  1: . . . "func"
    9:  6: . . . IDENT pointer
 /app/parser/parser.go:713: ast.Ident{Name: pointer}
    9: 13: . . . Signature (
    9: 13: . . . . Parameters (
    9: 13: . . . . . "("
    9: 14: . . . . . ParameterList (
    9: 14: . . . . . . ParamDeclOrNil (
    9: 14: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    9: 16: . . . . . . . Type (
    9: 16: . . . . . . . . PointerType (
    9: 16: . . . . . . . . . "*"
    9: 17: . . . . . . . . . Type (
    9: 17: . . . . . . . . . . TypeName (
    9: 17: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 20: . . . . . . . . . . )
    9: 20: . . . . . . . . . )
    9: 20: . . . . . . . . )
    9: 20: . . . . . . . )
    9: 20: . . . . . . . "?"
    9: 21: . . . . . . )
    9: 21: . . . . . . ","
    9: 23: . . . . . . ParamDeclOrNil (
    9: 23: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    9: 25: . . . . . . . Type (
    9: 25: . . . . . . . . PointerType (
    9: 25: . . . . . . . . . "*"
    9: 26: . . . . . . . . . Type (
    9: 26: . . . . . . . . . . PointerType (
    9: 26: . . . . . . . . . . . "*"
    9: 27: . . . . . . . . . . . Type (
    9: 27: . . . . . . . . . . . . TypeName (
    9: 27: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    9: 33: . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . )
    9: 33: . . . . . . . . . . )
    9: 33: . . . . . . . . . )
    9: 33: . . . . . . . . )
    9: 33: . . . . . . . )
    9: 33: . . . . . . . "?"
    9: 34: . . . . . . )
    9: 34: . . . . . )
    9: 34: . . . . . ")"
    9: 35: . . . . )
    9: 35: . . . . Result (
    9: 35: . . . . )
    9: 35: . . . )
    9: 35: . . . ";"
   11:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: pointer, ...}
   12:  1: . . )
   12:  1: . )
   12:  1: . Declaration (
   12:  1: . . FunctionDeclOrCall (
   12:  1: . . . "func"
   12:  6: . . . IDENT complex
 /app/parser/parser.go:713: ast.Ident{Name: complex}
   12: 13: . . . Signature (
   12: 13: . . . . Parameters (
   12: 13: . . . . . "("
   12: 14: . . . . . ParameterList (
   12: 14: . . . . . . ParamDeclOrNil (
   12: 14: . . . . . . . IDENT m
 /app/parser/parser.go:713: ast.Ident{Name: m}
   12: 16: . . . . . . . Type (
   12: 16: . . . . . . . . MapType (
   12: 16: . . . . . . . . . "map"
   12: 19: . . . . . . . . . "["
   12: 20: . . . . . . . . . Type (
   12: 20: . . . . . . . . . . TypeName (
   12: 20: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   12: 26: . . . . . . . . . . )
   12: 26: . . . . . . . . . )
   12: 26: . . . . . . . . . "]"
   12: 27: . . . . . . . . . Type (
   12: 27: . . . . . . . . . . TypeName (
   12: 27: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   12: 30: . . . . . . . . . . )
   12: 30: . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: string, Value: int}
   12: 30: . . . . . . . . )
   12: 30: . . . . . . . )
   12: 30: . . . . . . . "?"
   12: 31: . . . . . . )
   12: 31: . . . . . . ","
   12: 33: . . . . . . ParamDeclOrNil (
   12: 33: . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   12: 35: . . . . . . . ArrayFieldOrTypeInstance (
   12: 35: . . . . . . . . "["
   12: 36: . . . . . . . . "]"
   12: 37: . . . . . . . . Type (
   12: 37: . . . . . . . . . TypeName (
   12: 37: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   12: 40: . . . . . . . . . )
   12: 40: . . . . . . . . )
   12: 40: . . . . . . . )
   12: 40: . . . . . . . "?"
   12: 41: . . . . . . )
   12: 41: . . . . . . ","
   12: 43: . . . . . . ParamDeclOrNil (
   12: 43: . . . . . . . IDENT ch
 /app/parser/parser.go:713: ast.Ident{Name: ch}
   12: 46: . . . . . . . Type (
   12: 46: . . . . . . . . ChanType (
   12: 46: . . . . . . . . . "chan"
   12: 51: . . . . . . . . . Type (
   12: 51: . . . . . . . . . . TypeName (
   12: 51: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   12: 54: . . . . . . . . . . )
   12: 54: . . . . . . . . . )
   12: 54: . . . . . . . . )
   12: 54: . . . . . . . )
   12: 54: . . . . . . . "?"
   12: 55: . . . . . . )
   12: 55: . . . . . )
   12: 55: . . . . . ")"
   12: 56: . . . . )
   12: 56: . . . . Result (
   12: 56: . . . . )
   12: 56: . . . )
   12: 56: . . . ";"
   14:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: complex, ...}
   15:  1: . . )
   15:  1: . )
   15:  1: . Declaration (
   15:  1: . . FunctionDeclOrCall (
   15:  1: . . . "func"
   15:  6: . . . IDENT arrays
 /app/parser/parser.go:713: ast.Ident{Name: arrays}
   15: 12: . . . Signature (
   15: 12: . . . . Parameters (
   15: 12: . . . . . "("
   15: 13: . . . . . ParameterList (
   15: 13: . . . . . . ParamDeclOrNil (
   15: 13: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   15: 15: . . . . . . . ArrayFieldOrTypeInstance (
   15: 15: . . . . . . . . "["
   15: 16: . . . . . . . . Expression (
   15: 16: . . . . . . . . . BinaryExpr (
   15: 16: . . . . . . . . . . UnaryExpr (
   15: 16: . . . . . . . . . . . PrimaryExpr (
   15: 16: . . . . . . . . . . . . Operand (
   15: 16: . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
   15: 18: . . . . . . . . . . . . )
   15: 18: . . . . . . . . . . . )
   15: 18: . . . . . . . . . . )
   15: 18: . . . . . . . . . )
   15: 18: . . . . . . . . )
   15: 18: . . . . . . . . "]"
   15: 19: . . . . . . . . TypeName (
   15: 19: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   15: 22: . . . . . . . . )
   15: 22: . . . . . . . )
   15: 22: . . . . . . . "?"
   15: 23: . . . . . . )
   15: 23: . . . . . . ","
   15: 25: . . . . . . ParamDeclOrNil (
   15: 25: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   15: 27: . . . . . . . ArrayFieldOrTypeInstance (
   15: 27: . . . . . . . . "["
   15: 28: . . . . . . . . Expression (
   15: 28: . . . . . . . . . BinaryExpr (
   15: 28: . . . . . . . . . . UnaryExpr (
   15: 28: . . . . . . . . . . . PrimaryExpr (
   15: 28: . . . . . . . . . . . . Operand (
   15: 28: . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   15: 29: . . . . . . . . . . . . )
   15: 29: . . . . . . . . . . . )
   15: 29: . . . . . . . . . . )
   15: 29: . . . . . . . . . )
   15: 29: . . . . . . . . )
   15: 29: . . . . . . . . "]"
   15: 30: . . . . . . . . TypeName (
   15: 30: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   15: 36: . . . . . . . . )
   15: 36: . . . . . . . )
   15: 36: . . . . . . . "?"
   15: 37: . . . . . . )
   15: 37: . . . . . )
   15: 37: . . . . . ")"
   15: 38: . . . . )
   15: 38: . . . . Result (
   15: 38: . . . . )
   15: 38: . . . )
   15: 38: . . . ";"
   17:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: arrays, ...}
   18:  1: . . )
   18:  1: . )
   18:  1: . Declaration (
   18:  1: . . FunctionDeclOrCall (
   18:  1: . . . "func"
   18:  6: . . . IDENT interfaces
 /app/parser/parser.go:713: ast.Ident{Name: interfaces}
   18: 16: . . . Signature (
   18: 16: . . . . Parameters (
   18: 16: . . . . . "("
   18: 17: . . . . . ParameterList (
   18: 17: . . . . . . ParamDeclOrNil (
   18: 17: . . . . . . . IDENT io
 /app/parser/parser.go:713: ast.Ident{Name: io}
   18: 19: . . . . . . . QualifiedIdent (
   18: 19: . . . . . . . . TypeName (
   18: 19: . . . . . . . . . "."
   18: 20: . . . . . . . . . IDENT Reader
 /app/parser/parser.go:713: ast.Ident{Name: Reader}
   18: 26: . . . . . . . . )
   18: 26: . . . . . . . )
   18: 26: . . . . . . . "?"
   18: 27: . . . . . . )
   18: 27: . . . . . . ","
   18: 29: . . . . . . ParamDeclOrNil (
   18: 29: . . . . . . . IDENT io
 /app/parser/parser.go:713: ast.Ident{Name: io}
   18: 31: . . . . . . . QualifiedIdent (
   18: 31: . . . . . . . . TypeName (
   18: 31: . . . . . . . . . "."
   18: 32: . . . . . . . . . IDENT Writer
 /app/parser/parser.go:713: ast.Ident{Name: Writer}
   18: 38: . . . . . . . . )
   18: 38: . . . . . . . )
   18: 38: . . . . . . . "?"
   18: 39: . . . . . . )
   18: 39: . . . . . )
   18: 39: . . . . . ")"
   18: 40: . . . . )
   18: 40: . . . . Result (
   18: 40: . . . . )
   18: 40: . . . )
   18: 40: . . . ";"
   20:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: interfaces, ...}
   21:  1: . . )
   21:  1: . )
   21:  1: . Declaration (
   21:  1: . . FunctionDeclOrCall (
   21:  1: . . . "func"
   21:  6: . . . IDENT structs
 /app/parser/parser.go:713: ast.Ident{Name: structs}
   21: 13: . . . Signature (
   21: 13: . . . . Parameters (
   21: 13: . . . . . "("
   21: 14: . . . . . ParameterList (
   21: 14: . . . . . . ParamDeclOrNil (
   21: 14: . . . . . . . IDENT p
 /app/parser/parser.go:713: ast.Ident{Name: p}
   21: 16: . . . . . . . Type (
   21: 16: . . . . . . . . StructType (
   21: 16: . . . . . . . . . "struct"
   21: 22: . . . . . . . . . "{"
   21: 24: . . . . . . . . . FieldDecl (
   21: 24: . . . . . . . . . . IDENT X
 /app/parser/parser.go:713: ast.Ident{Name: X}
   21: 26: . . . . . . . . . . Type (
   21: 26: . . . . . . . . . . . TypeName (
   21: 26: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   21: 30: . . . . . . . . . . . )
   21: 30: . . . . . . . . . . )
   21: 30: . . . . . . . . . )
   21: 30: . . . . . . . . . "}"
   21: 31: . . . . . . . . )
   21: 31: . . . . . . . )
   21: 31: . . . . . . . "?"
   21: 32: . . . . . . )
   21: 32: . . . . . . ","
   21: 34: . . . . . . ParamDeclOrNil (
   21: 34: . . . . . . . IDENT q
 /app/parser/parser.go:713: ast.Ident{Name: q}
   21: 36: . . . . . . . Type (
   21: 36: . . . . . . . . StructType (
   21: 36: . . . . . . . . . "struct"
   21: 42: . . . . . . . . . "{"
   21: 44: . . . . . . . . . FieldDecl (
   21: 44: . . . . . . . . . . IDENT Y
 /app/parser/parser.go:713: ast.Ident{Name: Y}
   21: 46: . . . . . . . . . . Type (
   21: 46: . . . . . . . . . . . TypeName (
   21: 46: . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   21: 53: . . . . . . . . . . . )
   21: 53: . . . . . . . . . . )
   21: 53: . . . . . . . . . )
   21: 53: . . . . . . . . . "}"
   21: 54: . . . . . . . . )
   21: 54: . . . . . . . )
   21: 54: . . . . . . . "?"
   21: 55: . . . . . . )
   21: 55: . . . . . )
   21: 55: . . . . . ")"
   21: 56: . . . . )
   21: 56: . . . . Result (
   21: 56: . . . . )
   21: 56: . . . )
   21: 56: . . . ";"
   23:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: structs, ...}
   24:  1: . . )
   24:  1: . )
   24:  1: . Declaration (
   24:  1: . . FunctionDeclOrCall (
   24:  1: . . . "func"
   24:  6: . . . IDENT funcs
 /app/parser/parser.go:713: ast.Ident{Name: funcs}
   24: 11: . . . Signature (
   24: 11: . . . . Parameters (
   24: 11: . . . . . "("
   24: 12: . . . . . ParameterList (
   24: 12: . . . . . . ParamDeclOrNil (
   24: 12: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   24: 14: . . . . . . . Type (
   24: 14: . . . . . . . . FuncType (
   24: 14: . . . . . . . . . "func"
   24: 18: . . . . . . . . . Signature (
   24: 18: . . . . . . . . . . Parameters (
   24: 18: . . . . . . . . . . . "("
   24: 19: . . . . . . . . . . . ParameterList (
   24: 19: . . . . . . . . . . . . ParamDeclOrNil (
   24: 19: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   24: 22: . . . . . . . . . . . . )
   24: 22: . . . . . . . . . . . )
   24: 22: . . . . . . . . . . . ")"
   24: 24: . . . . . . . . . . )
   24: 24: . . . . . . . . . . Result (
   24: 24: . . . . . . . . . . . TypeName (
   24: 24: . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   24: 30: . . . . . . . . . . . )
   24: 30: . . . . . . . . . . )
   24: 30: . . . . . . . . . )
   24: 30: . . . . . . . . )
   24: 30: . . . . . . . )
   24: 30: . . . . . . . "?"
   24: 31: . . . . . . )
   24: 31: . . . . . . ","
   24: 33: . . . . . . ParamDeclOrNil (
   24: 33: . . . . . . . IDENT g
 /app/parser/parser.go:713: ast.Ident{Name: g}
   24: 35: . . . . . . . Type (
   24: 35: . . . . . . . . FuncType (
   24: 35: . . . . . . . . . "func"
   24: 39: . . . . . . . . . Signature (
   24: 39: . . . . . . . . . . Parameters (
   24: 39: . . . . . . . . . . . "("
   24: 40: . . . . . . . . . . . ParameterList (
   24: 40: . . . . . . . . . . . . ParamDeclOrNil (
   24: 40: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   24: 46: . . . . . . . . . . . . )
   24: 46: . . . . . . . . . . . )
   24: 46: . . . . . . . . . . . ")"
   24: 48: . . . . . . . . . . )
   24: 48: . . . . . . . . . . Result (
   24: 48: . . . . . . . . . . . TypeName (
   24: 48: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   24: 53: . . . . . . . . . . . )
   24: 53: . . . . . . . . . . )
   24: 53: . . . . . . . . . )
   24: 53: . . . . . . . . )
   24: 53: . . . . . . . )
   24: 53: . . . . . . . "?"
   24: 54: . . . . . . )
   24: 54: . . . . . )
   24: 54: . . . . . ")"
   24: 55: . . . . )
   24: 55: . . . . Result (
   24: 55: . . . . )
   24: 55: . . . )
   24: 55: . . . ";"
   26:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: funcs, ...}
   27:  1: . . )
   27:  1: . )
   27:  1: . Declaration (
   27:  1: . . FunctionDeclOrCall (
   27:  1: . . . "func"
   27:  6: . . . IDENT qualified
 /app/parser/parser.go:713: ast.Ident{Name: qualified}
   27: 15: . . . Signature (
   27: 15: . . . . Parameters (
   27: 15: . . . . . "("
   27: 16: . . . . . ParameterList (
   27: 16: . . . . . . ParamDeclOrNil (
   27: 16: . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
   27: 18: . . . . . . . Type (
   27: 18: . . . . . . . . TypeName (
   27: 18: . . . . . . . . . IDENT time
 /app/parser/parser.go:713: ast.Ident{Name: time}
   27: 22: . . . . . . . . . "."
   27: 23: . . . . . . . . . IDENT Time
 /app/parser/parser.go:713: ast.Ident{Name: Time}
   27: 27: . . . . . . . . )
   27: 27: . . . . . . . )
   27: 27: . . . . . . . "?"
   27: 28: . . . . . . )
   27: 28: . . . . . . ","
   27: 30: . . . . . . ParamDeclOrNil (
   27: 30: . . . . . . . IDENT d
 /app/parser/parser.go:713: ast.Ident{Name: d}
   27: 32: . . . . . . . Type (
   27: 32: . . . . . . . . TypeName (
   27: 32: . . . . . . . . . IDENT time
 /app/parser/parser.go:713: ast.Ident{Name: time}
   27: 36: . . . . . . . . . "."
   27: 37: . . . . . . . . . IDENT Duration
 /app/parser/parser.go:713: ast.Ident{Name: Duration}
   27: 45: . . . . . . . . )
   27: 45: . . . . . . . )
   27: 45: . . . . . . . "?"
   27: 46: . . . . . . )
   27: 46: . . . . . )
   27: 46: . . . . . ")"
   27: 47: . . . . )
   27: 47: . . . . Result (
   27: 47: . . . . )
   27: 47: . . . )
   27: 47: . . . ";"
   29:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: qualified, ...}
   30:  1: . . )
   30:  1: . )
   30:  1: . Declaration (
   30:  1: . . FunctionDeclOrCall (
   30:  1: . . . "func"
   30:  6: . . . IDENT unnamed
 /app/parser/parser.go:713: ast.Ident{Name: unnamed}
   30: 13: . . . Signature (
   30: 13: . . . . Parameters (
   30: 13: . . . . . "("
   30: 14: . . . . . ParameterList (
   30: 14: . . . . . . ParamDeclOrNil (
   30: 14: . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   30: 17: . . . . . . . "?"
   30: 18: . . . . . . )
   30: 18: . . . . . . ","
   30: 20: . . . . . . ParamDeclOrNil (
   30: 20: . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   30: 26: . . . . . . . "?"
   30: 27: . . . . . . )
   30: 27: . . . . . . ","
   30: 29: . . . . . . ParamDeclOrNil (
   30: 29: . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   30: 33: . . . . . . )
   30: 33: . . . . . )
   30: 33: . . . . . ")"
   30: 34: . . . . )
   30: 34: . . . . Result (
   30: 34: . . . . )
   30: 34: . . . )
   30: 34: . . . ";"
   32:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: unnamed, ...}
   33:  1: . . )
   33:  1: . )
   33:  1: . Declaration (
   33:  1: . . FunctionDeclOrCall (
   33:  1: . . . "func"
   33:  6: . . . IDENT allOptional
 /app/parser/parser.go:713: ast.Ident{Name: allOptional}
   33: 17: . . . Signature (
   33: 17: . . . . Parameters (
   33: 17: . . . . . "("
   33: 18: . . . . . ParameterList (
   33: 18: . . . . . . ParamDeclOrNil (
   33: 18: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   33: 20: . . . . . . . Type (
   33: 20: . . . . . . . . TypeName (
   33: 20: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   33: 23: . . . . . . . . )
   33: 23: . . . . . . . )
   33: 23: . . . . . . . "?"
   33: 24: . . . . . . )
   33: 24: . . . . . . ","
   33: 26: . . . . . . ParamDeclOrNil (
   33: 26: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   33: 28: . . . . . . . Type (
   33: 28: . . . . . . . . TypeName (
   33: 28: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   33: 34: . . . . . . . . )
   33: 34: . . . . . . . )
   33: 34: . . . . . . . "?"
   33: 35: . . . . . . )
   33: 35: . . . . . . ","
   33: 37: . . . . . . ParamDeclOrNil (
   33: 37: . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
   33: 39: . . . . . . . Type (
   33: 39: . . . . . . . . TypeName (
   33: 39: . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   33: 43: . . . . . . . . )
   33: 43: . . . . . . . )
   33: 43: . . . . . . . "?"
   33: 44: . . . . . . )
   33: 44: . . . . . )
   33: 44: . . . . . ")"
   33: 45: . . . . )
   33: 45: . . . . Result (
   33: 45: . . . . )
   33: 45: . . . )
   33: 45: . . . ";"
   35:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: allOptional, ...}
   36:  1: . . )
   36:  1: . )
   36:  1: . Declaration (
   36:  1: . . FunctionDeclOrCall (
   36:  1: . . . "func"
   36:  6: . . . IDENT withVariadic
 /app/parser/parser.go:713: ast.Ident{Name: withVariadic}
   36: 18: . . . Signature (
   36: 18: . . . . Parameters (
   36: 18: . . . . . "("
   36: 19: . . . . . ParameterList (
   36: 19: . . . . . . ParamDeclOrNil (
   36: 19: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   36: 21: . . . . . . . Type (
   36: 21: . . . . . . . . TypeName (
   36: 21: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   36: 24: . . . . . . . . )
   36: 24: . . . . . . . )
   36: 24: . . . . . . . "?"
   36: 25: . . . . . . )
   36: 25: . . . . . . ","
   36: 27: . . . . . . ParamDeclOrNil (
   36: 27: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   36: 29: . . . . . . . DotsType (
   36: 29: . . . . . . . . "..."
   36: 32: . . . . . . . . Type (
   36: 32: . . . . . . . . . TypeName (
   36: 32: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   36: 38: . . . . . . . . . )
   36: 38: . . . . . . . . )
   36: 38: . . . . . . . )
   36: 38: . . . . . . )
   36: 38: . . . . . )
   36: 38: . . . . . ")"
   36: 39: . . . . )
   36: 39: . . . . Result (
   36: 39: . . . . )
   36: 39: . . . )
   36: 39: . . . ";"
   38:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: withVariadic, ...}
   39:  1: . . )
   39:  1: . )
   39:  1: . Declaration (
   39:  1: . . GenDecl(type) (
   39:  1: . . . "type"
   39:  6: . . . TypeSpec (
   39:  6: . . . . IDENT Handler
 /app/parser/parser.go:713: ast.Ident{Name: Handler}
   39: 14: . . . . Type (
   39: 14: . . . . . FuncType (
   39: 14: . . . . . . "func"
   39: 18: . . . . . . Signature (
   39: 18: . . . . . . . Parameters (
   39: 18: . . . . . . . . "("
   39: 19: . . . . . . . . ParameterList (
   39: 19: . . . . . . . . . ParamDeclOrNil (
   39: 19: . . . . . . . . . . IDENT req
 /app/parser/parser.go:713: ast.Ident{Name: req}
   39: 23: . . . . . . . . . . Type (
   39: 23: . . . . . . . . . . . PointerType (
   39: 23: . . . . . . . . . . . . "*"
   39: 24: . . . . . . . . . . . . Type (
   39: 24: . . . . . . . . . . . . . TypeName (
   39: 24: . . . . . . . . . . . . . . IDENT Request
 /app/parser/parser.go:713: ast.Ident{Name: Request}
   39: 31: . . . . . . . . . . . . . )
   39: 31: . . . . . . . . . . . . )
   39: 31: . . . . . . . . . . . )
   39: 31: . . . . . . . . . . )
   39: 31: . . . . . . . . . . "?"
   39: 32: . . . . . . . . . )
   39: 32: . . . . . . . . . ","
   39: 34: . . . . . . . . . ParamDeclOrNil (
   39: 34: . . . . . . . . . . IDENT resp
 /app/parser/parser.go:713: ast.Ident{Name: resp}
   39: 39: . . . . . . . . . . Type (
   39: 39: . . . . . . . . . . . PointerType (
   39: 39: . . . . . . . . . . . . "*"
   39: 40: . . . . . . . . . . . . Type (
   39: 40: . . . . . . . . . . . . . TypeName (
   39: 40: . . . . . . . . . . . . . . IDENT Response
 /app/parser/parser.go:713: ast.Ident{Name: Response}
   39: 48: . . . . . . . . . . . . . )
   39: 48: . . . . . . . . . . . . )
   39: 48: . . . . . . . . . . . )
   39: 48: . . . . . . . . . . )
   39: 48: . . . . . . . . . . "?"
   39: 49: . . . . . . . . . )
   39: 49: . . . . . . . . )
   39: 49: . . . . . . . . ")"
   39: 51: . . . . . . . )
   39: 51: . . . . . . . Result (
   39: 51: . . . . . . . . TypeName (
   39: 51: . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   39: 56: . . . . . . . . )
   39: 56: . . . . . . . )
   39: 56: . . . . . . )
   39: 56: . . . . . )
   39: 56: . . . . )
   39: 56: . . . . ";"
   41:  1: . . . )
   41:  1: . . )
   41:  1: . )
   41:  1: . Declaration (
   41:  1: . . GenDecl(type) (
   41:  1: . . . "type"
   41:  6: . . . TypeSpec (
   41:  6: . . . . IDENT Callback
 /app/parser/parser.go:713: ast.Ident{Name: Callback}
   41: 15: . . . . Type (
   41: 15: . . . . . FuncType (
   41: 15: . . . . . . "func"
   41: 19: . . . . . . Signature (
   41: 19: . . . . . . . Parameters (
   41: 19: . . . . . . . . "("
   41: 20: . . . . . . . . ParameterList (
   41: 20: . . . . . . . . . ParamDeclOrNil (
   41: 20: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   41: 23: . . . . . . . . . . "?"
   41: 24: . . . . . . . . . )
   41: 24: . . . . . . . . . ","
   41: 26: . . . . . . . . . ParamDeclOrNil (
   41: 26: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   41: 32: . . . . . . . . . . "?"
   41: 33: . . . . . . . . . )
   41: 33: . . . . . . . . )
   41: 33: . . . . . . . . ")"
   41: 35: . . . . . . . )
   41: 35: . . . . . . . Result (
   41: 35: . . . . . . . . TypeName (
   41: 35: . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   41: 39: . . . . . . . . )
   41: 39: . . . . . . . )
   41: 39: . . . . . . )
   41: 39: . . . . . )
   41: 39: . . . . )
   41: 39: . . . . ";"
   43:  1: . . . . COMMENT
   44:  1: . . . )
   44:  1: . . )
   44:  1: . )
   44:  1: . Declaration (
   44:  1: . . GenDecl(type) (
   44:  1: . . . "type"
   44:  6: . . . TypeSpec (
   44:  6: . . . . IDENT Server
 /app/parser/parser.go:713: ast.Ident{Name: Server}
   44: 13: . . . . Type (
   44: 13: . . . . . StructType (
   44: 13: . . . . . . "struct"
   44: 19: . . . . . . "{"
   44: 20: . . . . . . "}"
   44: 21: . . . . . )
   44: 21: . . . . )
   44: 21: . . . . ";"
   46:  1: . . . )
   46:  1: . . )
   46:  1: . )
   46:  1: . Declaration (
   46:  1: . . FunctionDeclOrCall (
   46:  1: . . . "func"
   46:  6: . . . Parameters (
   46:  6: . . . . "("
   46:  7: . . . . ParameterList (
   46:  7: . . . . . ParamDeclOrNil (
   46:  7: . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   46:  9: . . . . . . Type (
   46:  9: . . . . . . . PointerType (
   46:  9: . . . . . . . . "*"
   46: 10: . . . . . . . . Type (
   46: 10: . . . . . . . . . TypeName (
   46: 10: . . . . . . . . . . IDENT Server
 /app/parser/parser.go:713: ast.Ident{Name: Server}
   46: 16: . . . . . . . . . )
   46: 16: . . . . . . . . )
   46: 16: . . . . . . . )
   46: 16: . . . . . . )
   46: 16: . . . . . )
   46: 16: . . . . )
   46: 16: . . . . ")"
   46: 18: . . . )
   46: 18: . . . TypeName (
   46: 18: . . . . IDENT Handle
 /app/parser/parser.go:713: ast.Ident{Name: Handle}
   46: 24: . . . )
   46: 24: . . . Signature (
   46: 24: . . . . Parameters (
   46: 24: . . . . . "("
   46: 25: . . . . . ParameterList (
   46: 25: . . . . . . ParamDeclOrNil (
   46: 25: . . . . . . . IDENT req
 /app/parser/parser.go:713: ast.Ident{Name: req}
   46: 29: . . . . . . . Type (
   46: 29: . . . . . . . . PointerType (
   46: 29: . . . . . . . . . "*"
   46: 30: . . . . . . . . . Type (
   46: 30: . . . . . . . . . . TypeName (
   46: 30: . . . . . . . . . . . IDENT Request
 /app/parser/parser.go:713: ast.Ident{Name: Request}
   46: 37: . . . . . . . . . . )
   46: 37: . . . . . . . . . )
   46: 37: . . . . . . . . )
   46: 37: . . . . . . . )
   46: 37: . . . . . . . "?"
   46: 38: . . . . . . )
   46: 38: . . . . . . ","
   46: 40: . . . . . . ParamDeclOrNil (
   46: 40: . . . . . . . IDENT opts
 /app/parser/parser.go:713: ast.Ident{Name: opts}
   46: 45: . . . . . . . Type (
   46: 45: . . . . . . . . PointerType (
   46: 45: . . . . . . . . . "*"
   46: 46: . . . . . . . . . Type (
   46: 46: . . . . . . . . . . TypeName (
   46: 46: . . . . . . . . . . . IDENT Options
 /app/parser/parser.go:713: ast.Ident{Name: Options}
   46: 53: . . . . . . . . . . )
   46: 53: . . . . . . . . . )
   46: 53: . . . . . . . . )
   46: 53: . . . . . . . )
   46: 53: . . . . . . . "?"
   46: 54: . . . . . . )
   46: 54: . . . . . )
   46: 54: . . . . . ")"
   46: 56: . . . . )
   46: 56: . . . . Result (
   46: 56: . . . . . TypeName (
   46: 56: . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   46: 62: . . . . . )
   46: 62: . . . . )
   46: 62: . . . )
   46: 62: . . . Body (
   46: 62: . . . . "{"
   47:  2: . . . . StatementList (
   47:  2: . . . . . Statement (
   47:  2: . . . . . . ReturnStmt (
   47:  2: . . . . . . . "return"
   47:  9: . . . . . . . ExpressionList (
   47:  9: . . . . . . . . Expression (
   47:  9: . . . . . . . . . BinaryExpr (
   47:  9: . . . . . . . . . . UnaryExpr (
   47:  9: . . . . . . . . . . . PrimaryExpr (
   47:  9: . . . . . . . . . . . . Operand (
   47:  9: . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   47: 12: . . . . . . . . . . . . )
   47: 12: . . . . . . . . . . . )
   47: 12: . . . . . . . . . . )
   47: 12: . . . . . . . . . )
   47: 12: . . . . . . . . )
   47: 12: . . . . . . . )
   47: 12: . . . . . . . ";"
   48:  1: . . . . . . )
   48:  1: . . . . . )
   48:  1: . . . . )
   48:  1: . . . . "}"
   48:  2: . . . )
   48:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Handle, ...}
   48:  3: . . )
   48:  3: . )
   48:  3: )
=== RUN   TestFromTestdata/overload1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/overload1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    1: 10: . . . "="
    1: 12: . . . "("
    2:  2: . . . FuncTypeOrLit (
    2:  2: . . . . FuncType (
    2:  2: . . . . . "func"
    2:  6: . . . . . Signature (
    2:  6: . . . . . . Parameters (
    2:  6: . . . . . . . "("
    2:  7: . . . . . . . ParameterList (
    2:  7: . . . . . . . . ParamDeclOrNil (
    2:  7: . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2:  8: . . . . . . . . )
    2:  8: . . . . . . . . ","
    2: 10: . . . . . . . . ParamDeclOrNil (
    2: 10: . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    2: 12: . . . . . . . . . Type (
    2: 12: . . . . . . . . . . TypeName (
    2: 12: . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    2: 19: . . . . . . . . . . )
    2: 19: . . . . . . . . . )
    2: 19: . . . . . . . . )
    2: 19: . . . . . . . )
    2: 19: . . . . . . . ")"
    2: 21: . . . . . . )
    2: 21: . . . . . . Result (
    2: 21: . . . . . . . TypeName (
    2: 21: . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    2: 29: . . . . . . . )
    2: 29: . . . . . . )
    2: 29: . . . . . )
    2: 29: . . . . )
    2: 29: . . . . Body (
    2: 29: . . . . . "{"
    3:  3: . . . . . StatementList (
    3:  3: . . . . . . Statement (
    3:  3: . . . . . . . ReturnStmt (
    3:  3: . . . . . . . . "return"
    3: 10: . . . . . . . . ExpressionList (
    3: 10: . . . . . . . . . Expression (
    3: 10: . . . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    3: 12: . . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . "+"
    3: 14: . . . . . . . . . . . BinaryExpr (
    3: 14: . . . . . . . . . . . . UnaryExpr (
    3: 14: . . . . . . . . . . . . . PrimaryExpr (
    3: 14: . . . . . . . . . . . . . . Operand (
    3: 14: . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    3: 15: . . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . )
    3: 15: . . . . . . . . . . )
    3: 15: . . . . . . . . . )
    3: 15: . . . . . . . . )
    3: 15: . . . . . . . . ";"
    4:  2: . . . . . . . )
    4:  2: . . . . . . )
    4:  2: . . . . . )
    4:  2: . . . . . "}"
    4:  3: . . . . )
    4:  3: . . . )
    4:  3: . . . ";"
    5:  2: . . . FuncTypeOrLit (
    5:  2: . . . . FuncType (
    5:  2: . . . . . "func"
    5:  6: . . . . . Signature (
    5:  6: . . . . . . Parameters (
    5:  6: . . . . . . . "("
    5:  7: . . . . . . . ParameterList (
    5:  7: . . . . . . . . ParamDeclOrNil (
    5:  7: . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    5:  8: . . . . . . . . )
    5:  8: . . . . . . . . ","
    5: 10: . . . . . . . . ParamDeclOrNil (
    5: 10: . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    5: 12: . . . . . . . . . Type (
    5: 12: . . . . . . . . . . TypeName (
    5: 12: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 18: . . . . . . . . . . )
    5: 18: . . . . . . . . . )
    5: 18: . . . . . . . . )
    5: 18: . . . . . . . )
    5: 18: . . . . . . . ")"
    5: 20: . . . . . . )
    5: 20: . . . . . . Result (
    5: 20: . . . . . . . TypeName (
    5: 20: . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 27: . . . . . . . )
    5: 27: . . . . . . )
    5: 27: . . . . . )
    5: 27: . . . . )
    5: 27: . . . . Body (
    5: 27: . . . . . "{"
    6:  3: . . . . . StatementList (
    6:  3: . . . . . . Statement (
    6:  3: . . . . . . . ReturnStmt (
    6:  3: . . . . . . . . "return"
    6: 10: . . . . . . . . ExpressionList (
    6: 10: . . . . . . . . . Expression (
    6: 10: . . . . . . . . . . BinaryExpr (
    6: 10: . . . . . . . . . . . UnaryExpr (
    6: 10: . . . . . . . . . . . . PrimaryExpr (
    6: 10: . . . . . . . . . . . . . Operand (
    6: 10: . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    6: 12: . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . "+"
    6: 14: . . . . . . . . . . . BinaryExpr (
    6: 14: . . . . . . . . . . . . UnaryExpr (
    6: 14: . . . . . . . . . . . . . PrimaryExpr (
    6: 14: . . . . . . . . . . . . . . Operand (
    6: 14: . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    6: 15: . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . )
    6: 15: . . . . . . . . . . )
    6: 15: . . . . . . . . . )
    6: 15: . . . . . . . . )
    6: 15: . . . . . . . . ";"
    7:  2: . . . . . . . )
    7:  2: . . . . . . )
    7:  2: . . . . . )
    7:  2: . . . . . "}"
    7:  3: . . . . )
    7:  3: . . . )
    7:  3: . . . ";"
    8:  1: . . . ")"
    8:  2: . . . ";"
 /app/parser/parser.go:3917: ast.OverloadFuncDecl{Recv: <nil>, Name: foo, ...}
   10:  1: . . )
   10:  1: . )
   10:  1: . Declaration (
   10:  1: . . FunctionDeclOrCall (
   10:  1: . . . "func"
   10:  6: . . . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
   10: 10: . . . "="
   10: 12: . . . "("
   11:  2: . . . IDENT addComplex
 /app/parser/parser.go:713: ast.Ident{Name: addComplex}
   11: 12: . . . ";"
   12:  2: . . . PrimaryExpr (
   12:  2: . . . . Operand (
   12:  2: . . . . . "("
   12:  3: . . . . . Expression (
   12:  3: . . . . . . BinaryExpr (
   12:  3: . . . . . . . UnaryExpr (
   12:  3: . . . . . . . . PrimaryExpr (
   12:  3: . . . . . . . . . Operand (
   12:  3: . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   12:  4: . . . . . . . . . )
   12:  4: . . . . . . . . )
   12:  4: . . . . . . . )
   12:  4: . . . . . . )
   12:  4: . . . . . )
   12:  4: . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: T}
   12:  5: . . . . )
   12:  5: . . . . "."
   12:  6: . . . . Selector (
   12:  6: . . . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
   12:  9: . . . . )
   12:  9: . . . )
   12:  9: . . . ";"
   13:  1: . . . ")"
   13:  2: . . . ";"
 /app/parser/parser.go:3917: ast.OverloadFuncDecl{Recv: <nil>, Name: bar, ...}
   13:  3: . . )
   13:  3: . )
   13:  3: )
=== RUN   TestFromTestdata/overload2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/overload2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . Parameters (
    1:  6: . . . . "("
    1:  7: . . . . ParameterList (
    1:  7: . . . . . ParamDeclOrNil (
    1:  7: . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    1:  8: . . . . . )
    1:  8: . . . . )
    1:  8: . . . . ")"
    1:  9: . . . )
    1:  9: . . . "."
    1: 10: . . . "*"
 /app/parser/parser.go:639: ast.Ident{Tok: *}
    1: 12: . . . "="
    1: 14: . . . "("
    2:  2: . . . IDENT mul1
 /app/parser/parser.go:713: ast.Ident{Name: mul1}
    2:  6: . . . ";"
    3:  2: . . . IDENT mul2
 /app/parser/parser.go:713: ast.Ident{Name: mul2}
    3:  6: . . . ";"
    4:  1: . . . ")"
    4:  2: . . . ";"
 /app/parser/parser.go:3917: ast.OverloadFuncDecl{Recv: T, Name: *, ...}
    6:  1: . . )
    6:  1: . )
    6:  1: . Declaration (
    6:  1: . . FunctionDeclOrCall (
    6:  1: . . . "func"
    6:  6: . . . Parameters (
    6:  6: . . . . "("
    6:  7: . . . . ParameterList (
    6:  7: . . . . . ParamDeclOrNil (
    6:  7: . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    6:  8: . . . . . )
    6:  8: . . . . )
    6:  8: . . . . ")"
    6:  9: . . . )
    6:  9: . . . "."
    6: 10: . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
    6: 14: . . . "="
    6: 16: . . . "("
    7:  2: . . . IDENT add1
 /app/parser/parser.go:713: ast.Ident{Name: add1}
    7:  6: . . . ";"
    8:  2: . . . FuncTypeOrLit (
    8:  2: . . . . FuncType (
    8:  2: . . . . . "func"
    8:  6: . . . . . Signature (
    8:  6: . . . . . . Parameters (
    8:  6: . . . . . . . "("
    8:  7: . . . . . . . ParameterList (
    8:  7: . . . . . . . . ParamDeclOrNil (
    8:  7: . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    8:  8: . . . . . . . . )
    8:  8: . . . . . . . . ","
    8: 10: . . . . . . . . ParamDeclOrNil (
    8: 10: . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    8: 12: . . . . . . . . . Type (
    8: 12: . . . . . . . . . . TypeName (
    8: 12: . . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    8: 13: . . . . . . . . . . )
    8: 13: . . . . . . . . . )
    8: 13: . . . . . . . . )
    8: 13: . . . . . . . )
    8: 13: . . . . . . . ")"
    8: 15: . . . . . . )
    8: 15: . . . . . . Result (
    8: 15: . . . . . . . TypeName (
    8: 15: . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    8: 17: . . . . . . . )
    8: 17: . . . . . . )
    8: 17: . . . . . )
    8: 17: . . . . )
    8: 17: . . . . Body (
    8: 17: . . . . . "{"
    9:  3: . . . . . StatementList (
    9:  3: . . . . . . Statement (
    9:  3: . . . . . . . ReturnStmt (
    9:  3: . . . . . . . . "return"
    9: 10: . . . . . . . . ExpressionList (
    9: 10: . . . . . . . . . Expression (
    9: 10: . . . . . . . . . . BinaryExpr (
    9: 10: . . . . . . . . . . . UnaryExpr (
    9: 10: . . . . . . . . . . . . PrimaryExpr (
    9: 10: . . . . . . . . . . . . . Operand (
    9: 10: . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    9: 12: . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . "+"
    9: 14: . . . . . . . . . . . BinaryExpr (
    9: 14: . . . . . . . . . . . . UnaryExpr (
    9: 14: . . . . . . . . . . . . . PrimaryExpr (
    9: 14: . . . . . . . . . . . . . . Operand (
    9: 14: . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    9: 15: . . . . . . . . . . . . . . )
    9: 15: . . . . . . . . . . . . . )
    9: 15: . . . . . . . . . . . . )
    9: 15: . . . . . . . . . . . )
    9: 15: . . . . . . . . . . )
    9: 15: . . . . . . . . . )
    9: 15: . . . . . . . . )
    9: 15: . . . . . . . . ";"
   10:  2: . . . . . . . )
   10:  2: . . . . . . )
   10:  2: . . . . . )
   10:  2: . . . . . "}"
   10:  3: . . . . )
   10:  3: . . . )
   10:  3: . . . ";"
   11:  1: . . . ")"
   11:  2: . . . ";"
 /app/parser/parser.go:3917: ast.OverloadFuncDecl{Recv: T, Name: add, ...}
   11:  3: . . )
   11:  3: . )
   11:  3: )
=== RUN   TestFromTestdata/overloadop
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/overloadop
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(type) (
    1:  1: . . . "type"
    1:  6: . . . TypeSpec (
    1:  6: . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    1: 10: . . . . Type (
    1: 10: . . . . . StructType (
    1: 10: . . . . . . "struct"
    1: 17: . . . . . . "{"
    2:  1: . . . . . . "}"
    2:  2: . . . . . )
    2:  2: . . . . )
    2:  2: . . . . ";"
    4:  1: . . . )
    4:  1: . . )
    4:  1: . )
    4:  1: . Declaration (
    4:  1: . . FunctionDeclOrCall (
    4:  1: . . . "func"
    4:  6: . . . Parameters (
    4:  6: . . . . "("
    4:  7: . . . . ParameterList (
    4:  7: . . . . . ParamDeclOrNil (
    4:  7: . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4:  9: . . . . . . Type (
    4:  9: . . . . . . . PointerType (
    4:  9: . . . . . . . . "*"
    4: 10: . . . . . . . . Type (
    4: 10: . . . . . . . . . TypeName (
    4: 10: . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4: 13: . . . . . . . . . )
    4: 13: . . . . . . . . )
    4: 13: . . . . . . . )
    4: 13: . . . . . . )
    4: 13: . . . . . )
    4: 13: . . . . )
    4: 13: . . . . ")"
    4: 15: . . . )
    4: 15: . . . "*"
    4: 17: . . . Signature (
    4: 17: . . . . Parameters (
    4: 17: . . . . . "("
    4: 18: . . . . . ParameterList (
    4: 18: . . . . . . ParamDeclOrNil (
    4: 18: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4: 20: . . . . . . . Type (
    4: 20: . . . . . . . . PointerType (
    4: 20: . . . . . . . . . "*"
    4: 21: . . . . . . . . . Type (
    4: 21: . . . . . . . . . . TypeName (
    4: 21: . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4: 24: . . . . . . . . . . )
    4: 24: . . . . . . . . . )
    4: 24: . . . . . . . . )
    4: 24: . . . . . . . )
    4: 24: . . . . . . )
    4: 24: . . . . . )
    4: 24: . . . . . ")"
    4: 26: . . . . )
    4: 26: . . . . Result (
    4: 26: . . . . . PointerType (
    4: 26: . . . . . . "*"
    4: 27: . . . . . . Type (
    4: 27: . . . . . . . TypeName (
    4: 27: . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4: 30: . . . . . . . )
    4: 30: . . . . . . )
    4: 30: . . . . . )
    4: 30: . . . . )
    4: 30: . . . )
    4: 30: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: *, ...}
    6:  1: . . )
    6:  1: . )
    6:  1: . Declaration (
    6:  1: . . FunctionDeclOrCall (
    6:  1: . . . "func"
    6:  6: . . . Parameters (
    6:  6: . . . . "("
    6:  7: . . . . ParameterList (
    6:  7: . . . . . ParamDeclOrNil (
    6:  7: . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    6:  9: . . . . . . Type (
    6:  9: . . . . . . . PointerType (
    6:  9: . . . . . . . . "*"
    6: 10: . . . . . . . . Type (
    6: 10: . . . . . . . . . TypeName (
    6: 10: . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    6: 13: . . . . . . . . . )
    6: 13: . . . . . . . . )
    6: 13: . . . . . . . )
    6: 13: . . . . . . )
    6: 13: . . . . . )
    6: 13: . . . . )
    6: 13: . . . . ")"
    6: 15: . . . )
    6: 15: . . . "+"
    6: 17: . . . Signature (
    6: 17: . . . . Parameters (
    6: 17: . . . . . "("
    6: 18: . . . . . ParameterList (
    6: 18: . . . . . . ParamDeclOrNil (
    6: 18: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    6: 20: . . . . . . . Type (
    6: 20: . . . . . . . . PointerType (
    6: 20: . . . . . . . . . "*"
    6: 21: . . . . . . . . . Type (
    6: 21: . . . . . . . . . . TypeName (
    6: 21: . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    6: 24: . . . . . . . . . . )
    6: 24: . . . . . . . . . )
    6: 24: . . . . . . . . )
    6: 24: . . . . . . . )
    6: 24: . . . . . . )
    6: 24: . . . . . )
    6: 24: . . . . . ")"
    6: 26: . . . . )
    6: 26: . . . . Result (
    6: 26: . . . . . PointerType (
    6: 26: . . . . . . "*"
    6: 27: . . . . . . Type (
    6: 27: . . . . . . . TypeName (
    6: 27: . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    6: 31: . . . . . . . )
    6: 31: . . . . . . )
    6: 31: . . . . . )
    6: 31: . . . . )
    6: 31: . . . )
    6: 31: . . . Body (
    6: 31: . . . . "{"
    7:  2: . . . . StatementList (
    7:  2: . . . . . Statement (
    7:  2: . . . . . . SimpleStmt (
    7:  2: . . . . . . . ExpressionList (
    7:  2: . . . . . . . . Expression (
    7:  2: . . . . . . . . . BinaryExpr (
    7:  2: . . . . . . . . . . UnaryExpr (
    7:  2: . . . . . . . . . . . PrimaryExpr (
    7:  2: . . . . . . . . . . . . Operand (
    7:  2: . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    7:  9: . . . . . . . . . . . . )
    7:  9: . . . . . . . . . . . . CallOrConversion (
    7:  9: . . . . . . . . . . . . . "("
    7: 10: . . . . . . . . . . . . . Expression (
    7: 10: . . . . . . . . . . . . . . BinaryExpr (
    7: 10: . . . . . . . . . . . . . . . UnaryExpr (
    7: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 10: . . . . . . . . . . . . . . . . . Operand (
    7: 10: . . . . . . . . . . . . . . . . . . STRING "a + b"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a + b"}
    7: 17: . . . . . . . . . . . . . . . . . )
    7: 17: . . . . . . . . . . . . . . . . )
    7: 17: . . . . . . . . . . . . . . . )
    7: 17: . . . . . . . . . . . . . . )
    7: 17: . . . . . . . . . . . . . )
    7: 17: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    7: 18: . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . )
    7: 18: . . . . . . . . . . )
    7: 18: . . . . . . . . . )
    7: 18: . . . . . . . . )
    7: 18: . . . . . . . )
    7: 18: . . . . . . )
    7: 18: . . . . . . ";"
    8:  2: . . . . . )
    8:  2: . . . . . Statement (
    8:  2: . . . . . . ReturnStmt (
    8:  2: . . . . . . . "return"
    8:  9: . . . . . . . ExpressionList (
    8:  9: . . . . . . . . Expression (
    8:  9: . . . . . . . . . BinaryExpr (
    8:  9: . . . . . . . . . . UnaryExpr (
    8:  9: . . . . . . . . . . . "&"
    8: 10: . . . . . . . . . . . UnaryExpr (
    8: 10: . . . . . . . . . . . . PrimaryExpr (
    8: 10: . . . . . . . . . . . . . Operand (
    8: 10: . . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    8: 13: . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . LiteralValue (
    8: 13: . . . . . . . . . . . . . . "{"
    8: 14: . . . . . . . . . . . . . . "}"
    8: 15: . . . . . . . . . . . . . )
    8: 15: . . . . . . . . . . . . )
    8: 15: . . . . . . . . . . . )
    8: 15: . . . . . . . . . . )
    8: 15: . . . . . . . . . )
    8: 15: . . . . . . . . )
    8: 15: . . . . . . . )
    8: 15: . . . . . . . ";"
    9:  1: . . . . . . )
    9:  1: . . . . . )
    9:  1: . . . . )
    9:  1: . . . . "}"
    9:  2: . . . )
    9:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: +, ...}
   11:  1: . . )
   11:  1: . )
   11:  1: . Declaration (
   11:  1: . . FunctionDeclOrCall (
   11:  1: . . . "func"
   11:  6: . . . Parameters (
   11:  6: . . . . "("
   11:  7: . . . . ParameterList (
   11:  7: . . . . . ParamDeclOrNil (
   11:  7: . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   11:  9: . . . . . . Type (
   11:  9: . . . . . . . TypeName (
   11:  9: . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   11: 12: . . . . . . . )
   11: 12: . . . . . . )
   11: 12: . . . . . )
   11: 12: . . . . )
   11: 12: . . . . ")"
   11: 14: . . . )
   11: 14: . . . "/"
   11: 16: . . . Signature (
   11: 16: . . . . Parameters (
   11: 16: . . . . . "("
   11: 17: . . . . . ParameterList (
   11: 17: . . . . . . ParamDeclOrNil (
   11: 17: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   11: 19: . . . . . . . Type (
   11: 19: . . . . . . . . TypeName (
   11: 19: . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   11: 22: . . . . . . . . )
   11: 22: . . . . . . . )
   11: 22: . . . . . . )
   11: 22: . . . . . )
   11: 22: . . . . . ")"
   11: 24: . . . . )
   11: 24: . . . . Result (
   11: 24: . . . . . TypeName (
   11: 24: . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   11: 28: . . . . . )
   11: 28: . . . . )
   11: 28: . . . )
   11: 28: . . . Body (
   11: 28: . . . . "{"
   12:  2: . . . . StatementList (
   12:  2: . . . . . Statement (
   12:  2: . . . . . . SimpleStmt (
   12:  2: . . . . . . . ExpressionList (
   12:  2: . . . . . . . . Expression (
   12:  2: . . . . . . . . . BinaryExpr (
   12:  2: . . . . . . . . . . UnaryExpr (
   12:  2: . . . . . . . . . . . PrimaryExpr (
   12:  2: . . . . . . . . . . . . Operand (
   12:  2: . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   12:  9: . . . . . . . . . . . . )
   12:  9: . . . . . . . . . . . . CallOrConversion (
   12:  9: . . . . . . . . . . . . . "("
   12: 10: . . . . . . . . . . . . . Expression (
   12: 10: . . . . . . . . . . . . . . BinaryExpr (
   12: 10: . . . . . . . . . . . . . . . UnaryExpr (
   12: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
   12: 10: . . . . . . . . . . . . . . . . . Operand (
   12: 10: . . . . . . . . . . . . . . . . . . STRING "a / b"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a / b"}
   12: 17: . . . . . . . . . . . . . . . . . )
   12: 17: . . . . . . . . . . . . . . . . )
   12: 17: . . . . . . . . . . . . . . . )
   12: 17: . . . . . . . . . . . . . . )
   12: 17: . . . . . . . . . . . . . )
   12: 17: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   12: 18: . . . . . . . . . . . . )
   12: 18: . . . . . . . . . . . )
   12: 18: . . . . . . . . . . )
   12: 18: . . . . . . . . . )
   12: 18: . . . . . . . . )
   12: 18: . . . . . . . )
   12: 18: . . . . . . )
   12: 18: . . . . . . ";"
   13:  2: . . . . . )
   13:  2: . . . . . Statement (
   13:  2: . . . . . . ReturnStmt (
   13:  2: . . . . . . . "return"
   13:  9: . . . . . . . ExpressionList (
   13:  9: . . . . . . . . Expression (
   13:  9: . . . . . . . . . BinaryExpr (
   13:  9: . . . . . . . . . . UnaryExpr (
   13:  9: . . . . . . . . . . . PrimaryExpr (
   13:  9: . . . . . . . . . . . . Operand (
   13:  9: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   13: 12: . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . LiteralValue (
   13: 12: . . . . . . . . . . . . . "{"
   13: 13: . . . . . . . . . . . . . "}"
   13: 14: . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . )
   13: 14: . . . . . . . . . . )
   13: 14: . . . . . . . . . )
   13: 14: . . . . . . . . )
   13: 14: . . . . . . . )
   13: 14: . . . . . . . ";"
   14:  1: . . . . . . )
   14:  1: . . . . . )
   14:  1: . . . . )
   14:  1: . . . . "}"
   14:  2: . . . )
   14:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: /, ...}
   16:  1: . . )
   16:  1: . )
   16:  1: . Declaration (
   16:  1: . . FunctionDeclOrCall (
   16:  1: . . . "func"
   16:  6: . . . "-"
 /app/parser/parser.go:639: ast.Ident{Tok: -}
   16:  7: . . . Signature (
   16:  7: . . . . Parameters (
   16:  7: . . . . . "("
   16:  8: . . . . . ParameterList (
   16:  8: . . . . . . ParamDeclOrNil (
   16:  8: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   16: 10: . . . . . . . Type (
   16: 10: . . . . . . . . TypeName (
   16: 10: . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   16: 13: . . . . . . . . )
   16: 13: . . . . . . . )
   16: 13: . . . . . . )
   16: 13: . . . . . )
   16: 13: . . . . . ")"
   16: 15: . . . . )
   16: 15: . . . . Result (
   16: 15: . . . . )
   16: 15: . . . )
   16: 15: . . . Body (
   16: 15: . . . . "{"
   17:  2: . . . . StatementList (
   17:  2: . . . . . Statement (
   17:  2: . . . . . . SimpleStmt (
   17:  2: . . . . . . . ExpressionList (
   17:  2: . . . . . . . . Expression (
   17:  2: . . . . . . . . . BinaryExpr (
   17:  2: . . . . . . . . . . UnaryExpr (
   17:  2: . . . . . . . . . . . PrimaryExpr (
   17:  2: . . . . . . . . . . . . Operand (
   17:  2: . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   17:  9: . . . . . . . . . . . . )
   17:  9: . . . . . . . . . . . . CallOrConversion (
   17:  9: . . . . . . . . . . . . . "("
   17: 10: . . . . . . . . . . . . . Expression (
   17: 10: . . . . . . . . . . . . . . BinaryExpr (
   17: 10: . . . . . . . . . . . . . . . UnaryExpr (
   17: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 10: . . . . . . . . . . . . . . . . . Operand (
   17: 10: . . . . . . . . . . . . . . . . . . STRING "-a"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "-a"}
   17: 14: . . . . . . . . . . . . . . . . . )
   17: 14: . . . . . . . . . . . . . . . . )
   17: 14: . . . . . . . . . . . . . . . )
   17: 14: . . . . . . . . . . . . . . )
   17: 14: . . . . . . . . . . . . . )
   17: 14: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   17: 15: . . . . . . . . . . . . )
   17: 15: . . . . . . . . . . . )
   17: 15: . . . . . . . . . . )
   17: 15: . . . . . . . . . )
   17: 15: . . . . . . . . )
   17: 15: . . . . . . . )
   17: 15: . . . . . . )
   17: 15: . . . . . . ";"
   18:  1: . . . . . )
   18:  1: . . . . )
   18:  1: . . . . "}"
   18:  2: . . . )
   18:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: -, ...}
   20:  1: . . )
   20:  1: . )
   20:  1: . Declaration (
   20:  1: . . FunctionDeclOrCall (
   20:  1: . . . "func"
   20:  6: . . . "++"
 /app/parser/parser.go:639: ast.Ident{Tok: ++}
   20:  8: . . . Signature (
   20:  8: . . . . Parameters (
   20:  8: . . . . . "("
   20:  9: . . . . . ParameterList (
   20:  9: . . . . . . ParamDeclOrNil (
   20:  9: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   20: 11: . . . . . . . Type (
   20: 11: . . . . . . . . TypeName (
   20: 11: . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   20: 14: . . . . . . . . )
   20: 14: . . . . . . . )
   20: 14: . . . . . . )
   20: 14: . . . . . )
   20: 14: . . . . . ")"
   20: 16: . . . . )
   20: 16: . . . . Result (
   20: 16: . . . . )
   20: 16: . . . )
   20: 16: . . . Body (
   20: 16: . . . . "{"
   21:  2: . . . . StatementList (
   21:  2: . . . . . Statement (
   21:  2: . . . . . . SimpleStmt (
   21:  2: . . . . . . . ExpressionList (
   21:  2: . . . . . . . . Expression (
   21:  2: . . . . . . . . . BinaryExpr (
   21:  2: . . . . . . . . . . UnaryExpr (
   21:  2: . . . . . . . . . . . PrimaryExpr (
   21:  2: . . . . . . . . . . . . Operand (
   21:  2: . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   21:  9: . . . . . . . . . . . . )
   21:  9: . . . . . . . . . . . . CallOrConversion (
   21:  9: . . . . . . . . . . . . . "("
   21: 10: . . . . . . . . . . . . . Expression (
   21: 10: . . . . . . . . . . . . . . BinaryExpr (
   21: 10: . . . . . . . . . . . . . . . UnaryExpr (
   21: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
   21: 10: . . . . . . . . . . . . . . . . . Operand (
   21: 10: . . . . . . . . . . . . . . . . . . STRING "a++"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a++"}
   21: 15: . . . . . . . . . . . . . . . . . )
   21: 15: . . . . . . . . . . . . . . . . )
   21: 15: . . . . . . . . . . . . . . . )
   21: 15: . . . . . . . . . . . . . . )
   21: 15: . . . . . . . . . . . . . )
   21: 15: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   21: 16: . . . . . . . . . . . . )
   21: 16: . . . . . . . . . . . )
   21: 16: . . . . . . . . . . )
   21: 16: . . . . . . . . . )
   21: 16: . . . . . . . . )
   21: 16: . . . . . . . )
   21: 16: . . . . . . )
   21: 16: . . . . . . ";"
   22:  1: . . . . . )
   22:  1: . . . . )
   22:  1: . . . . "}"
   22:  2: . . . )
   22:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: ++, ...}
   22:  3: . . )
   22:  3: . )
   22:  3: )
=== RUN   TestFromTestdata/printvariadic
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/printvariadic
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 10: . . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . "..."
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: true}
    1: 13: . . . . . . . . . . )
    1: 13: . . . . . . . . . )
    1: 13: . . . . . . . . )
    1: 13: . . . . . . . )
    1: 13: . . . . . . )
    1: 13: . . . . . )
    1: 13: . . . . )
    1: 13: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2: 10: . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . "..."
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: true}
    2: 13: . . . . . . . . . . )
    2: 13: . . . . . . . . . )
    2: 13: . . . . . . . . )
    2: 13: . . . . . . . )
    2: 13: . . . . . . )
    2: 13: . . . . . )
    2: 13: . . . . )
    2: 13: . . . . ";"
    2: 14: . . . )
    2: 14: . . )
    2: 14: . )
    2: 14: )
=== RUN   TestFromTestdata/pystr
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/pystr
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT print
 /app/parser/parser.go:713: ast.Ident{Name: print}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . . CallOrConversion (
    1:  7: . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . PYSTRING "Hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: PYSTRING, Value: "Hello"}
    1: 16: . . . . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: print, Ellipsis: false, isCmd: true}
    1: 16: . . . . . . . . . . )
    1: 16: . . . . . . . . . )
    1: 16: . . . . . . . . )
    1: 16: . . . . . . . )
    1: 16: . . . . . . )
    1: 16: . . . . . )
    1: 16: . . . . )
    1: 16: . . . . ";"
    1: 17: . . . )
    1: 17: . . )
    1: 17: . )
    1: 17: )
=== RUN   TestFromTestdata/rangeexpr1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/rangeexpr1
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . ForStmt (
    4:  2: . . . . . . . "for"
    4:  6: . . . . . . . SimpleStmt (
    4:  6: . . . . . . . . ExpressionList (
    4:  6: . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    4:  8: . . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . )
    4:  8: . . . . . . . . . . )
    4:  8: . . . . . . . . . )
    4:  8: . . . . . . . . )
    4:  8: . . . . . . . . ":="
    4: 11: . . . . . . . . "range"
    4: 17: . . . . . . . . Expression (
    4: 17: . . . . . . . . . RangeExpr (
    4: 17: . . . . . . . . . . ":"
    4: 18: . . . . . . . . . . BinaryExpr (
    4: 18: . . . . . . . . . . . UnaryExpr (
    4: 18: . . . . . . . . . . . . PrimaryExpr (
    4: 18: . . . . . . . . . . . . . Operand (
    4: 18: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    4: 21: . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . )
    4: 21: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{46 INT 10 <nil>}, Expr3: <nil>}
    4: 21: . . . . . . . . . )
    4: 21: . . . . . . . . )
    4: 21: . . . . . . . )
    4: 21: . . . . . . . BlockStmt (
    4: 21: . . . . . . . . "{"
    5:  3: . . . . . . . . StatementList (
    5:  3: . . . . . . . . . Statement (
    5:  3: . . . . . . . . . . SimpleStmt (
    5:  3: . . . . . . . . . . . ExpressionList (
    5:  3: . . . . . . . . . . . . Expression (
    5:  3: . . . . . . . . . . . . . BinaryExpr (
    5:  3: . . . . . . . . . . . . . . UnaryExpr (
    5:  3: . . . . . . . . . . . . . . . PrimaryExpr (
    5:  3: . . . . . . . . . . . . . . . . Operand (
    5:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 10: . . . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . . . CallOrConversion (
    5: 10: . . . . . . . . . . . . . . . . . "("
    5: 11: . . . . . . . . . . . . . . . . . Expression (
    5: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    5: 12: . . . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 13: . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . )
    5: 13: . . . . . . . . . . )
    5: 13: . . . . . . . . . . ";"
    6:  2: . . . . . . . . . )
    6:  2: . . . . . . . . )
    6:  2: . . . . . . . . "}"
    6:  3: . . . . . . . )
    6:  3: . . . . . . . ";"
    8:  2: . . . . . . )
    8:  2: . . . . . )
    8:  2: . . . . . Statement (
    8:  2: . . . . . . ForStmt (
    8:  2: . . . . . . . "for"
    8:  6: . . . . . . . SimpleStmt (
    8:  6: . . . . . . . . ExpressionList (
    8:  6: . . . . . . . . . Expression (
    8:  6: . . . . . . . . . . BinaryExpr (
    8:  6: . . . . . . . . . . . UnaryExpr (
    8:  6: . . . . . . . . . . . . PrimaryExpr (
    8:  6: . . . . . . . . . . . . . Operand (
    8:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    8:  8: . . . . . . . . . . . . . )
    8:  8: . . . . . . . . . . . . )
    8:  8: . . . . . . . . . . . )
    8:  8: . . . . . . . . . . )
    8:  8: . . . . . . . . . )
    8:  8: . . . . . . . . )
    8:  8: . . . . . . . . IDENT in
    8: 11: . . . . . . . . Expression (
    8: 11: . . . . . . . . . RangeExpr (
    8: 11: . . . . . . . . . . BinaryExpr (
    8: 11: . . . . . . . . . . . UnaryExpr (
    8: 11: . . . . . . . . . . . . PrimaryExpr (
    8: 11: . . . . . . . . . . . . . Operand (
    8: 11: . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    8: 12: . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . )
    8: 12: . . . . . . . . . . )
    8: 12: . . . . . . . . . . ":"
    8: 13: . . . . . . . . . . BinaryExpr (
    8: 13: . . . . . . . . . . . UnaryExpr (
    8: 13: . . . . . . . . . . . . PrimaryExpr (
    8: 13: . . . . . . . . . . . . . Operand (
    8: 13: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    8: 16: . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . )
    8: 16: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: &{78 INT 1 <nil>}, Last: &{80 INT 10 <nil>}, Expr3: <nil>}
    8: 16: . . . . . . . . . )
    8: 16: . . . . . . . . )
    8: 16: . . . . . . . )
    8: 16: . . . . . . . BlockStmt (
    8: 16: . . . . . . . . "{"
    9:  3: . . . . . . . . StatementList (
    9:  3: . . . . . . . . . Statement (
    9:  3: . . . . . . . . . . SimpleStmt (
    9:  3: . . . . . . . . . . . ExpressionList (
    9:  3: . . . . . . . . . . . . Expression (
    9:  3: . . . . . . . . . . . . . BinaryExpr (
    9:  3: . . . . . . . . . . . . . . UnaryExpr (
    9:  3: . . . . . . . . . . . . . . . PrimaryExpr (
    9:  3: . . . . . . . . . . . . . . . . Operand (
    9:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    9: 10: . . . . . . . . . . . . . . . . )
    9: 10: . . . . . . . . . . . . . . . . CallOrConversion (
    9: 10: . . . . . . . . . . . . . . . . . "("
    9: 11: . . . . . . . . . . . . . . . . . Expression (
    9: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    9: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    9: 12: . . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    9: 13: . . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . )
    9: 13: . . . . . . . . . . )
    9: 13: . . . . . . . . . . ";"
   10:  2: . . . . . . . . . )
   10:  2: . . . . . . . . )
   10:  2: . . . . . . . . "}"
   10:  3: . . . . . . . )
   10:  3: . . . . . . . ";"
   12:  2: . . . . . . )
   12:  2: . . . . . )
   12:  2: . . . . . Statement (
   12:  2: . . . . . . ForStmt (
   12:  2: . . . . . . . "for"
   12:  6: . . . . . . . SimpleStmt (
   12:  6: . . . . . . . . ExpressionList (
   12:  6: . . . . . . . . . Expression (
   12:  6: . . . . . . . . . . BinaryExpr (
   12:  6: . . . . . . . . . . . UnaryExpr (
   12:  6: . . . . . . . . . . . . PrimaryExpr (
   12:  6: . . . . . . . . . . . . . Operand (
   12:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   12:  8: . . . . . . . . . . . . . )
   12:  8: . . . . . . . . . . . . )
   12:  8: . . . . . . . . . . . )
   12:  8: . . . . . . . . . . )
   12:  8: . . . . . . . . . )
   12:  8: . . . . . . . . )
   12:  8: . . . . . . . . ":="
   12: 11: . . . . . . . . "range"
   12: 17: . . . . . . . . Expression (
   12: 17: . . . . . . . . . RangeExpr (
   12: 17: . . . . . . . . . . ":"
   12: 18: . . . . . . . . . . BinaryExpr (
   12: 18: . . . . . . . . . . . UnaryExpr (
   12: 18: . . . . . . . . . . . . PrimaryExpr (
   12: 18: . . . . . . . . . . . . . Operand (
   12: 18: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
   12: 20: . . . . . . . . . . . . . )
   12: 20: . . . . . . . . . . . . )
   12: 20: . . . . . . . . . . . )
   12: 20: . . . . . . . . . . )
   12: 20: . . . . . . . . . . ":"
   12: 21: . . . . . . . . . . BinaryExpr (
   12: 21: . . . . . . . . . . . UnaryExpr (
   12: 21: . . . . . . . . . . . . PrimaryExpr (
   12: 21: . . . . . . . . . . . . . Operand (
   12: 21: . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   12: 23: . . . . . . . . . . . . . )
   12: 23: . . . . . . . . . . . . )
   12: 23: . . . . . . . . . . . )
   12: 23: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{119 INT 10 <nil>}, Expr3: &{122 INT 2 <nil>}}
   12: 23: . . . . . . . . . )
   12: 23: . . . . . . . . )
   12: 23: . . . . . . . )
   12: 23: . . . . . . . BlockStmt (
   12: 23: . . . . . . . . "{"
   13:  3: . . . . . . . . StatementList (
   13:  3: . . . . . . . . . Statement (
   13:  3: . . . . . . . . . . SimpleStmt (
   13:  3: . . . . . . . . . . . ExpressionList (
   13:  3: . . . . . . . . . . . . Expression (
   13:  3: . . . . . . . . . . . . . BinaryExpr (
   13:  3: . . . . . . . . . . . . . . UnaryExpr (
   13:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   13:  3: . . . . . . . . . . . . . . . . Operand (
   13:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   13: 10: . . . . . . . . . . . . . . . . )
   13: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   13: 10: . . . . . . . . . . . . . . . . . "("
   13: 11: . . . . . . . . . . . . . . . . . Expression (
   13: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   13: 12: . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   13: 13: . . . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . )
   13: 13: . . . . . . . . . . )
   13: 13: . . . . . . . . . . ";"
   14:  2: . . . . . . . . . )
   14:  2: . . . . . . . . )
   14:  2: . . . . . . . . "}"
   14:  3: . . . . . . . )
   14:  3: . . . . . . . ";"
   16:  2: . . . . . . )
   16:  2: . . . . . )
   16:  2: . . . . . Statement (
   16:  2: . . . . . . ForStmt (
   16:  2: . . . . . . . "for"
   16:  6: . . . . . . . "range"
   16: 12: . . . . . . . Expression (
   16: 12: . . . . . . . . RangeExpr (
   16: 12: . . . . . . . . . ":"
   16: 13: . . . . . . . . . BinaryExpr (
   16: 13: . . . . . . . . . . UnaryExpr (
   16: 13: . . . . . . . . . . . PrimaryExpr (
   16: 13: . . . . . . . . . . . . Operand (
   16: 13: . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
   16: 16: . . . . . . . . . . . . )
   16: 16: . . . . . . . . . . . )
   16: 16: . . . . . . . . . . )
   16: 16: . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{155 INT 10 <nil>}, Expr3: <nil>}
   16: 16: . . . . . . . . )
   16: 16: . . . . . . . )
   16: 16: . . . . . . . BlockStmt (
   16: 16: . . . . . . . . "{"
   17:  3: . . . . . . . . StatementList (
   17:  3: . . . . . . . . . Statement (
   17:  3: . . . . . . . . . . SimpleStmt (
   17:  3: . . . . . . . . . . . ExpressionList (
   17:  3: . . . . . . . . . . . . Expression (
   17:  3: . . . . . . . . . . . . . BinaryExpr (
   17:  3: . . . . . . . . . . . . . . UnaryExpr (
   17:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   17:  3: . . . . . . . . . . . . . . . . Operand (
   17:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   17: 10: . . . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   17: 10: . . . . . . . . . . . . . . . . . "("
   17: 11: . . . . . . . . . . . . . . . . . Expression (
   17: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   17: 11: . . . . . . . . . . . . . . . . . . . . . . STRING "Range expression"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Range expression"}
   17: 29: . . . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   17: 30: . . . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . )
   17: 30: . . . . . . . . . . )
   17: 30: . . . . . . . . . . ";"
   18:  2: . . . . . . . . . )
   18:  2: . . . . . . . . )
   18:  2: . . . . . . . . "}"
   18:  3: . . . . . . . )
   18:  3: . . . . . . . ";"
   19:  1: . . . . . . )
   19:  1: . . . . . )
   19:  1: . . . . )
   19:  1: . . . . "}"
   19:  2: . . . )
   19:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   19:  3: . . )
   19:  3: . )
   19:  3: )
=== RUN   TestFromTestdata/rangeexpr2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/rangeexpr2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . ForStmt (
    1:  1: . . . . . "for"
    1:  5: . . . . . SimpleStmt (
    1:  5: . . . . . . RangeExpr (
    1:  5: . . . . . . . ":"
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{6 INT 10 <nil>}, Expr3: <nil>}
    1:  9: . . . . . . )
    1:  9: . . . . . )
    1:  9: . . . . . BlockStmt (
    1:  9: . . . . . . "{"
    2:  1: . . . . . . StatementList (
    2:  1: . . . . . . )
    2:  1: . . . . . . "}"
    2:  2: . . . . . )
    2:  2: . . . . . ";"
    2:  3: . . . . )
    2:  3: . . . )
    2:  3: . . )
    2:  3: . )
    2:  3: )
=== RUN   TestFromTestdata/rangeexpr3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/rangeexpr3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . ForStmt (
    1:  1: . . . . . "for"
    1:  5: . . . . . SimpleStmt (
    1:  5: . . . . . . ExpressionList (
    1:  5: . . . . . . . Expression (
    1:  5: . . . . . . . . BinaryExpr (
    1:  5: . . . . . . . . . UnaryExpr (
    1:  5: . . . . . . . . . . PrimaryExpr (
    1:  5: . . . . . . . . . . . Operand (
    1:  5: . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  6: . . . . . . . . . . . )
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . )
    1:  6: . . . . . . . . )
    1:  6: . . . . . . . )
    1:  6: . . . . . . )
    1:  6: . . . . . . RangeExpr (
    1:  6: . . . . . . . ":"
    1:  7: . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    1: 10: . . . . . . . . . . )
    1: 10: . . . . . . . . . )
    1: 10: . . . . . . . . )
    1: 10: . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: &{5 INT 1 <nil>}, Last: &{7 INT 10 <nil>}, Expr3: <nil>}
    1: 10: . . . . . . )
    1: 10: . . . . . )
    1: 10: . . . . . BlockStmt (
    1: 10: . . . . . . "{"
    2:  1: . . . . . . StatementList (
    2:  1: . . . . . . )
    2:  1: . . . . . . "}"
    2:  2: . . . . . )
    2:  2: . . . . . ";"
    2:  3: . . . . )
    2:  3: . . . )
    2:  3: . . )
    2:  3: . )
    2:  3: )
=== RUN   TestFromTestdata/rational
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/rational
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . RAT 1r
 /app/parser/parser.go:1862: ast.BasicLit{Kind: RAT, Value: 1r}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . . "<<"
    1: 12: . . . . . . . . BinaryExpr (
    1: 12: . . . . . . . . . UnaryExpr (
    1: 12: . . . . . . . . . . PrimaryExpr (
    1: 12: . . . . . . . . . . . Operand (
    1: 12: . . . . . . . . . . . . INT 65
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 65}
    1: 15: . . . . . . . . . . . )
    1: 15: . . . . . . . . . . )
    1: 15: . . . . . . . . . )
    1: 15: . . . . . . . . )
    1: 15: . . . . . . . )
    1: 15: . . . . . . )
    1: 15: . . . . . )
    1: 15: . . . . )
    1: 15: . . . . ";"
    1: 15: . . . . COMMENT
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    2:  3: . . . . . . . . . . )
    2:  3: . . . . . . . . . )
    2:  3: . . . . . . . . )
    2:  3: . . . . . . . )
    2:  3: . . . . . . )
    2:  3: . . . . . )
    2:  3: . . . . . ":="
    2:  6: . . . . . ExpressionList (
    2:  6: . . . . . . Expression (
    2:  6: . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
    2:  7: . . . . . . . . . . )
    2:  7: . . . . . . . . . )
    2:  7: . . . . . . . . )
    2:  7: . . . . . . . . "/"
    2:  8: . . . . . . . . BinaryExpr (
    2:  8: . . . . . . . . . UnaryExpr (
    2:  8: . . . . . . . . . . PrimaryExpr (
    2:  8: . . . . . . . . . . . Operand (
    2:  8: . . . . . . . . . . . . RAT 5r
 /app/parser/parser.go:1862: ast.BasicLit{Kind: RAT, Value: 5r}
    2: 15: . . . . . . . . . . . )
    2: 15: . . . . . . . . . . )
    2: 15: . . . . . . . . . )
    2: 15: . . . . . . . . )
    2: 15: . . . . . . . )
    2: 15: . . . . . . )
    2: 15: . . . . . )
    2: 15: . . . . )
    2: 15: . . . . ";"
    2: 15: . . . . COMMENT
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
    3:  3: . . . . . . . . . . )
    3:  3: . . . . . . . . . )
    3:  3: . . . . . . . . )
    3:  3: . . . . . . . )
    3:  3: . . . . . . )
    3:  3: . . . . . )
    3:  3: . . . . . ":="
    3:  6: . . . . . ExpressionList (
    3:  6: . . . . . . Expression (
    3:  6: . . . . . . . BinaryExpr (
    3:  6: . . . . . . . . UnaryExpr (
    3:  6: . . . . . . . . . PrimaryExpr (
    3:  6: . . . . . . . . . . Operand (
    3:  6: . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    3:  8: . . . . . . . . . . )
    3:  8: . . . . . . . . . )
    3:  8: . . . . . . . . )
    3:  8: . . . . . . . . "-"
    3: 10: . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3: 11: . . . . . . . . . . . )
    3: 11: . . . . . . . . . . )
    3: 11: . . . . . . . . . )
    3: 11: . . . . . . . . . "/"
    3: 12: . . . . . . . . . BinaryExpr (
    3: 12: . . . . . . . . . . UnaryExpr (
    3: 12: . . . . . . . . . . . PrimaryExpr (
    3: 12: . . . . . . . . . . . . Operand (
    3: 12: . . . . . . . . . . . . . RAT 3r
 /app/parser/parser.go:1862: ast.BasicLit{Kind: RAT, Value: 3r}
    3: 15: . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . )
    3: 15: . . . . . . . . . . )
    3: 15: . . . . . . . . . )
    3: 15: . . . . . . . . )
    3: 15: . . . . . . . . "+"
    3: 17: . . . . . . . . BinaryExpr (
    3: 17: . . . . . . . . . UnaryExpr (
    3: 17: . . . . . . . . . . PrimaryExpr (
    3: 17: . . . . . . . . . . . Operand (
    3: 17: . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    3: 18: . . . . . . . . . . . )
    3: 18: . . . . . . . . . . )
    3: 18: . . . . . . . . . )
    3: 18: . . . . . . . . . "*"
    3: 19: . . . . . . . . . BinaryExpr (
    3: 19: . . . . . . . . . . UnaryExpr (
    3: 19: . . . . . . . . . . . PrimaryExpr (
    3: 19: . . . . . . . . . . . . Operand (
    3: 19: . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3: 20: . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . )
    3: 20: . . . . . . . . . . )
    3: 20: . . . . . . . . . )
    3: 20: . . . . . . . . . "/"
    3: 21: . . . . . . . . . BinaryExpr (
    3: 21: . . . . . . . . . . UnaryExpr (
    3: 21: . . . . . . . . . . . PrimaryExpr (
    3: 21: . . . . . . . . . . . . Operand (
    3: 21: . . . . . . . . . . . . . RAT 2r
 /app/parser/parser.go:1862: ast.BasicLit{Kind: RAT, Value: 2r}
    3: 23: . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . )
    3: 23: . . . . . . . . . . )
    3: 23: . . . . . . . . . )
    3: 23: . . . . . . . . )
    3: 23: . . . . . . . )
    3: 23: . . . . . . )
    3: 23: . . . . . )
    3: 23: . . . . )
    3: 23: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  8: . . . . . . . . . . )
    4:  8: . . . . . . . . . . CallOrConversion (
    4:  8: . . . . . . . . . . . "("
    4:  9: . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . Operand (
    4:  9: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4: 10: . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . ","
    4: 12: . . . . . . . . . . . Expression (
    4: 12: . . . . . . . . . . . . BinaryExpr (
    4: 12: . . . . . . . . . . . . . UnaryExpr (
    4: 12: . . . . . . . . . . . . . . PrimaryExpr (
    4: 12: . . . . . . . . . . . . . . . Operand (
    4: 12: . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4: 13: . . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . ","
    4: 15: . . . . . . . . . . . Expression (
    4: 15: . . . . . . . . . . . . BinaryExpr (
    4: 15: . . . . . . . . . . . . . UnaryExpr (
    4: 15: . . . . . . . . . . . . . . PrimaryExpr (
    4: 15: . . . . . . . . . . . . . . . Operand (
    4: 15: . . . . . . . . . . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
    4: 16: . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    4: 17: . . . . . . . . . . )
    4: 17: . . . . . . . . . )
    4: 17: . . . . . . . . )
    4: 17: . . . . . . . )
    4: 17: . . . . . . )
    4: 17: . . . . . )
    4: 17: . . . . )
    4: 17: . . . . ";"
    4: 18: . . . )
    4: 18: . . )
    4: 18: . )
    4: 18: )
=== RUN   TestFromTestdata/selectdata
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/selectdata
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . ","
    1: 10: . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ","
    1: 13: . . . . . . . . . . . . Expression (
    1: 13: . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . ","
    1: 16: . . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . ","
    1: 19: . . . . . . . . . . . . Expression (
    1: 19: . . . . . . . . . . . . . BinaryExpr (
    1: 19: . . . . . . . . . . . . . . UnaryExpr (
    1: 19: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 19: . . . . . . . . . . . . . . . . Operand (
    1: 19: . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    1: 20: . . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . ","
    1: 22: . . . . . . . . . . . . Expression (
    1: 22: . . . . . . . . . . . . . BinaryExpr (
    1: 22: . . . . . . . . . . . . . . UnaryExpr (
    1: 22: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 22: . . . . . . . . . . . . . . . . Operand (
    1: 22: . . . . . . . . . . . . . . . . . INT 19
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 19}
    1: 24: . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . "]"
    1: 25: . . . . . . . . . . . )
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2:  3: . . . . . . . . . . )
    2:  3: . . . . . . . . . )
    2:  3: . . . . . . . . )
    2:  3: . . . . . . . )
    2:  3: . . . . . . )
    2:  3: . . . . . )
    2:  3: . . . . . ":="
    2:  6: . . . . . ExpressionList (
    2:  6: . . . . . . Expression (
    2:  6: . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . LiteralValue (
    2:  6: . . . . . . . . . . . . "{"
    2:  7: . . . . . . . . . . . . ElementList (
    2:  7: . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . . Expression (
    2:  7: . . . . . . . . . . . . . . . . BinaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . . Operand (
    2:  7: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  9: . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . ForPhrase (
    2:  9: . . . . . . . . . . . . . . "for"
    2: 13: . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 15: . . . . . . . . . . . . . . IDENT in
    2: 18: . . . . . . . . . . . . . . Expression (
    2: 18: . . . . . . . . . . . . . . . RangeExpr (
    2: 18: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . . . Operand (
    2: 18: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 20: . . . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . "if"
    2: 23: . . . . . . . . . . . . . . SimpleStmt (
    2: 23: . . . . . . . . . . . . . . . ExpressionList (
    2: 23: . . . . . . . . . . . . . . . . Expression (
    2: 23: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 23: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 24: . . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . "%"
    2: 25: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 25: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 27: . . . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . "=="
    2: 30: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 30: . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    2: 31: . . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . "}"
    2: 32: . . . . . . . . . . . )
    2: 32: . . . . . . . . . . )
    2: 32: . . . . . . . . . )
    2: 32: . . . . . . . . )
    2: 32: . . . . . . . )
    2: 32: . . . . . . )
    2: 32: . . . . . )
    2: 32: . . . . )
    2: 32: . . . . ";"
    2: 33: . . . )
    2: 33: . . )
    2: 33: . )
    2: 33: )
=== RUN   TestFromTestdata/slice1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/slice1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  8: . . . . . . . . . . )
    1:  8: . . . . . . . . . . CallOrConversion (
    1:  8: . . . . . . . . . . . "("
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . ArrayType (
    1:  9: . . . . . . . . . . . . . . . . . "["
    1: 10: . . . . . . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 11: . . . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . "]"
    1: 12: . . . . . . . . . . . . . . . . . ArrayType (
    1: 12: . . . . . . . . . . . . . . . . . . "["
    1: 13: . . . . . . . . . . . . . . . . . . Expression (
    1: 13: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    1: 14: . . . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:916: ast.IndexExpr{X: &{9 [0xc0003b2570] 11 false}, Index: &{13 INT 0 <nil>}}
    1: 15: . . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    1: 16: . . . . . . . . . . )
    1: 16: . . . . . . . . . )
    1: 16: . . . . . . . . )
    1: 16: . . . . . . . )
    1: 16: . . . . . . )
    1: 16: . . . . . )
    1: 16: . . . . )
    1: 16: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  8: . . . . . . . . . . )
    2:  8: . . . . . . . . . . CallOrConversion (
    2:  8: . . . . . . . . . . . "("
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . ArrayType (
    2:  9: . . . . . . . . . . . . . . . . . "["
    2: 10: . . . . . . . . . . . . . . . . . Expression (
    2: 10: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 10: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 11: . . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . "]"
    2: 12: . . . . . . . . . . . . . . . . . ArrayType (
    2: 12: . . . . . . . . . . . . . . . . . . "["
    2: 13: . . . . . . . . . . . . . . . . . . Expression (
    2: 13: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    2: 14: . . . . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . ":"
    2: 15: . . . . . . . . . . . . . . . . . . Expression (
    2: 15: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 16: . . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . "]"
    2: 17: . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    2: 18: . . . . . . . . . . )
    2: 18: . . . . . . . . . )
    2: 18: . . . . . . . . )
    2: 18: . . . . . . . )
    2: 18: . . . . . . )
    2: 18: . . . . . )
    2: 18: . . . . )
    2: 18: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    3:  8: . . . . . . . . . . )
    3:  8: . . . . . . . . . . CallOrConversion (
    3:  8: . . . . . . . . . . . "("
    3:  9: . . . . . . . . . . . Expression (
    3:  9: . . . . . . . . . . . . BinaryExpr (
    3:  9: . . . . . . . . . . . . . UnaryExpr (
    3:  9: . . . . . . . . . . . . . . PrimaryExpr (
    3:  9: . . . . . . . . . . . . . . . Operand (
    3:  9: . . . . . . . . . . . . . . . . ArrayType (
    3:  9: . . . . . . . . . . . . . . . . . "["
    3: 10: . . . . . . . . . . . . . . . . . Expression (
    3: 10: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3: 11: . . . . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . ","
    3: 13: . . . . . . . . . . . . . . . . . Expression (
    3: 13: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 13: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 13: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 13: . . . . . . . . . . . . . . . . . . . . . Operand (
    3: 13: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    3: 14: . . . . . . . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . . . . "]"
    3: 15: . . . . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . . . . IndexOrSlice (
    3: 15: . . . . . . . . . . . . . . . . "["
    3: 16: . . . . . . . . . . . . . . . . Expression (
    3: 16: . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 16: . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 16: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 16: . . . . . . . . . . . . . . . . . . . . Operand (
    3: 16: . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    3: 17: . . . . . . . . . . . . . . . . . . . . )
    3: 17: . . . . . . . . . . . . . . . . . . . )
    3: 17: . . . . . . . . . . . . . . . . . . )
    3: 17: . . . . . . . . . . . . . . . . . )
    3: 17: . . . . . . . . . . . . . . . . )
    3: 17: . . . . . . . . . . . . . . . . ":"
    3: 18: . . . . . . . . . . . . . . . . Expression (
    3: 18: . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 18: . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 18: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 18: . . . . . . . . . . . . . . . . . . . . Operand (
    3: 18: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3: 19: . . . . . . . . . . . . . . . . . . . . )
    3: 19: . . . . . . . . . . . . . . . . . . . )
    3: 19: . . . . . . . . . . . . . . . . . . )
    3: 19: . . . . . . . . . . . . . . . . . )
    3: 19: . . . . . . . . . . . . . . . . )
    3: 19: . . . . . . . . . . . . . . . . ":"
    3: 20: . . . . . . . . . . . . . . . . Expression (
    3: 20: . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . . . Operand (
    3: 20: . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    3: 21: . . . . . . . . . . . . . . . . . . . . )
    3: 21: . . . . . . . . . . . . . . . . . . . )
    3: 21: . . . . . . . . . . . . . . . . . . )
    3: 21: . . . . . . . . . . . . . . . . . )
    3: 21: . . . . . . . . . . . . . . . . )
    3: 21: . . . . . . . . . . . . . . . . "]"
    3: 22: . . . . . . . . . . . . . . . )
    3: 22: . . . . . . . . . . . . . . )
    3: 22: . . . . . . . . . . . . . )
    3: 22: . . . . . . . . . . . . )
    3: 22: . . . . . . . . . . . )
    3: 22: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    3: 23: . . . . . . . . . . )
    3: 23: . . . . . . . . . )
    3: 23: . . . . . . . . )
    3: 23: . . . . . . . )
    3: 23: . . . . . . )
    3: 23: . . . . . )
    3: 23: . . . . )
    3: 23: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    5:  3: . . . . . . . . . . )
    5:  3: . . . . . . . . . )
    5:  3: . . . . . . . . )
    5:  3: . . . . . . . )
    5:  3: . . . . . . )
    5:  3: . . . . . )
    5:  3: . . . . . ":="
    5:  6: . . . . . ExpressionList (
    5:  6: . . . . . . Expression (
    5:  6: . . . . . . . BinaryExpr (
    5:  6: . . . . . . . . UnaryExpr (
    5:  6: . . . . . . . . . PrimaryExpr (
    5:  6: . . . . . . . . . . Operand (
    5:  6: . . . . . . . . . . . ArrayType (
    5:  6: . . . . . . . . . . . . "["
    5:  7: . . . . . . . . . . . . Expression (
    5:  7: . . . . . . . . . . . . . BinaryExpr (
    5:  7: . . . . . . . . . . . . . . UnaryExpr (
    5:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    5:  7: . . . . . . . . . . . . . . . . Operand (
    5:  7: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    5:  8: . . . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc0003b2870]}
    5:  9: . . . . . . . . . . . )
    5:  9: . . . . . . . . . . )
    5:  9: . . . . . . . . . )
    5:  9: . . . . . . . . )
    5:  9: . . . . . . . )
    5:  9: . . . . . . )
    5:  9: . . . . . )
    5:  9: . . . . )
    5:  9: . . . . ";"
    6:  1: . . . )
    6:  1: . . . Statement (
    6:  1: . . . . SimpleStmt (
    6:  1: . . . . . ExpressionList (
    6:  1: . . . . . . Expression (
    6:  1: . . . . . . . BinaryExpr (
    6:  1: . . . . . . . . UnaryExpr (
    6:  1: . . . . . . . . . PrimaryExpr (
    6:  1: . . . . . . . . . . Operand (
    6:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    6:  8: . . . . . . . . . . )
    6:  8: . . . . . . . . . . CallOrConversion (
    6:  8: . . . . . . . . . . . "("
    6:  9: . . . . . . . . . . . Expression (
    6:  9: . . . . . . . . . . . . BinaryExpr (
    6:  9: . . . . . . . . . . . . . UnaryExpr (
    6:  9: . . . . . . . . . . . . . . PrimaryExpr (
    6:  9: . . . . . . . . . . . . . . . Operand (
    6:  9: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    6: 10: . . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . . IndexOrSlice (
    6: 10: . . . . . . . . . . . . . . . . "["
    6: 11: . . . . . . . . . . . . . . . . Expression (
    6: 11: . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 11: . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 11: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 11: . . . . . . . . . . . . . . . . . . . . Operand (
    6: 11: . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    6: 12: . . . . . . . . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: a, Index: &{78 INT 0 <nil>}}
    6: 13: . . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    6: 14: . . . . . . . . . . )
    6: 14: . . . . . . . . . )
    6: 14: . . . . . . . . )
    6: 14: . . . . . . . )
    6: 14: . . . . . . )
    6: 14: . . . . . )
    6: 14: . . . . )
    6: 14: . . . . ";"
    6: 15: . . . )
    6: 15: . . )
    6: 15: . )
    6: 15: )
=== RUN   TestFromTestdata/slice2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/slice2
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . SimpleStmt (
    4:  2: . . . . . . . ExpressionList (
    4:  2: . . . . . . . . Expression (
    4:  2: . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4:  4: . . . . . . . . . . . . )
    4:  4: . . . . . . . . . . . )
    4:  4: . . . . . . . . . . )
    4:  4: . . . . . . . . . )
    4:  4: . . . . . . . . )
    4:  4: . . . . . . . )
    4:  4: . . . . . . . ":="
    4:  7: . . . . . . . ExpressionList (
    4:  7: . . . . . . . . Expression (
    4:  7: . . . . . . . . . BinaryExpr (
    4:  7: . . . . . . . . . . UnaryExpr (
    4:  7: . . . . . . . . . . . PrimaryExpr (
    4:  7: . . . . . . . . . . . . Operand (
    4:  7: . . . . . . . . . . . . . ArrayType (
    4:  7: . . . . . . . . . . . . . . "["
    5:  3: . . . . . . . . . . . . . . Expression (
    5:  3: . . . . . . . . . . . . . . . BinaryExpr (
    5:  3: . . . . . . . . . . . . . . . . UnaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . Operand (
    5:  3: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    5:  4: . . . . . . . . . . . . . . . . . . )
    5:  4: . . . . . . . . . . . . . . . . . )
    5:  4: . . . . . . . . . . . . . . . . )
    5:  4: . . . . . . . . . . . . . . . )
    5:  4: . . . . . . . . . . . . . . )
    5:  4: . . . . . . . . . . . . . . ","
    6:  3: . . . . . . . . . . . . . . Expression (
    6:  3: . . . . . . . . . . . . . . . BinaryExpr (
    6:  3: . . . . . . . . . . . . . . . . UnaryExpr (
    6:  3: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6:  3: . . . . . . . . . . . . . . . . . . Operand (
    6:  3: . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    6:  4: . . . . . . . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . . . . ","
    7:  3: . . . . . . . . . . . . . . Expression (
    7:  3: . . . . . . . . . . . . . . . BinaryExpr (
    7:  3: . . . . . . . . . . . . . . . . UnaryExpr (
    7:  3: . . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  3: . . . . . . . . . . . . . . . . . . Operand (
    7:  3: . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    7:  4: . . . . . . . . . . . . . . . . . . )
    7:  4: . . . . . . . . . . . . . . . . . )
    7:  4: . . . . . . . . . . . . . . . . )
    7:  4: . . . . . . . . . . . . . . . )
    7:  4: . . . . . . . . . . . . . . )
    7:  4: . . . . . . . . . . . . . . ","
    8:  2: . . . . . . . . . . . . . . "]"
    8:  3: . . . . . . . . . . . . . )
    8:  3: . . . . . . . . . . . . )
    8:  3: . . . . . . . . . . . )
    8:  3: . . . . . . . . . . )
    8:  3: . . . . . . . . . )
    8:  3: . . . . . . . . )
    8:  3: . . . . . . . )
    8:  3: . . . . . . )
    8:  3: . . . . . . ";"
    9:  2: . . . . . )
    9:  2: . . . . . Statement (
    9:  2: . . . . . . SimpleStmt (
    9:  2: . . . . . . . ExpressionList (
    9:  2: . . . . . . . . Expression (
    9:  2: . . . . . . . . . BinaryExpr (
    9:  2: . . . . . . . . . . UnaryExpr (
    9:  2: . . . . . . . . . . . PrimaryExpr (
    9:  2: . . . . . . . . . . . . Operand (
    9:  2: . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    9:  9: . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . CallOrConversion (
    9:  9: . . . . . . . . . . . . . "("
    9: 10: . . . . . . . . . . . . . Expression (
    9: 10: . . . . . . . . . . . . . . BinaryExpr (
    9: 10: . . . . . . . . . . . . . . . UnaryExpr (
    9: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 10: . . . . . . . . . . . . . . . . . Operand (
    9: 10: . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    9: 11: . . . . . . . . . . . . . . . . . )
    9: 11: . . . . . . . . . . . . . . . . )
    9: 11: . . . . . . . . . . . . . . . )
    9: 11: . . . . . . . . . . . . . . )
    9: 11: . . . . . . . . . . . . . )
    9: 11: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    9: 12: . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . )
    9: 12: . . . . . . . . . . )
    9: 12: . . . . . . . . . )
    9: 12: . . . . . . . . )
    9: 12: . . . . . . . )
    9: 12: . . . . . . )
    9: 12: . . . . . . ";"
   10:  1: . . . . . )
   10:  1: . . . . )
   10:  1: . . . . "}"
   10:  2: . . . )
   10:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   10:  3: . . )
   10:  3: . )
   10:  3: )
=== RUN   TestFromTestdata/spxtest
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/spxtest
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . )
    1:  7: . . . . ";"
    1:  8: . . . )
    1:  8: . . )
    1:  8: . )
    1:  8: )
=== RUN   TestFromTestdata/staticmthd1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/staticmthd1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    1:  7: . . . "."
    1:  8: . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    1: 11: . . . Signature (
    1: 11: . . . . Parameters (
    1: 11: . . . . . "("
    1: 12: . . . . . ParameterList (
    1: 12: . . . . . . ParamDeclOrNil (
    1: 12: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1: 13: . . . . . . )
    1: 13: . . . . . . ","
    1: 15: . . . . . . ParamDeclOrNil (
    1: 15: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    1: 17: . . . . . . . Type (
    1: 17: . . . . . . . . TypeName (
    1: 17: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 20: . . . . . . . . )
    1: 20: . . . . . . . )
    1: 20: . . . . . . )
    1: 20: . . . . . )
    1: 20: . . . . . ")"
    1: 22: . . . . )
    1: 22: . . . . Result (
    1: 22: . . . . . TypeName (
    1: 22: . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    1: 29: . . . . . )
    1: 29: . . . . )
    1: 29: . . . )
    1: 29: . . . Body (
    1: 29: . . . . "{"
    2:  1: . . . . StatementList (
    2:  1: . . . . )
    2:  1: . . . . "}"
    2:  2: . . . )
    2:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
    2:  3: . . )
    2:  3: . )
    2:  3: )
=== RUN   TestFromTestdata/staticmthd2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/staticmthd2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . "."
    1:  7: . . . IDENT New
 /app/parser/parser.go:713: ast.Ident{Name: New}
    1: 10: . . . Signature (
    1: 10: . . . . Parameters (
    1: 10: . . . . . "("
    1: 11: . . . . . ")"
    1: 13: . . . . )
    1: 13: . . . . Result (
    1: 13: . . . . . PointerType (
    1: 13: . . . . . . "*"
    1: 14: . . . . . . Type (
    1: 14: . . . . . . . TypeName (
    1: 14: . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    1: 16: . . . . . . . )
    1: 16: . . . . . . )
    1: 16: . . . . . )
    1: 16: . . . . )
    1: 16: . . . )
    1: 16: . . . Body (
    1: 16: . . . . "{"
    2:  1: . . . . StatementList (
    2:  1: . . . . )
    2:  1: . . . . "}"
    2:  2: . . . )
    2:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: New, ...}
    2:  3: . . )
    2:  3: . )
    2:  3: )
=== RUN   TestFromTestdata/stdtype
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/stdtype
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
    1: 12: . ";"
    3:  1: . GenDecl(import) (
    3:  1: . . "import"
    3:  8: . . ImportSpec (
    3:  8: . . . STRING "io"
    3: 12: . . . ";"
    5:  1: . . )
    5:  1: . )
    5:  1: . Declaration (
    5:  1: . . StatementList (
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5:  3: . . . . . . . . . . )
    5:  3: . . . . . . . . . )
    5:  3: . . . . . . . . )
    5:  3: . . . . . . . )
    5:  3: . . . . . . )
    5:  3: . . . . . )
    5:  3: . . . . . ":="
    5:  6: . . . . . ExpressionList (
    5:  6: . . . . . . Expression (
    5:  6: . . . . . . . BinaryExpr (
    5:  6: . . . . . . . . UnaryExpr (
    5:  6: . . . . . . . . . PrimaryExpr (
    5:  6: . . . . . . . . . . Operand (
    5:  6: . . . . . . . . . . . ArrayType (
    5:  6: . . . . . . . . . . . . "["
    5:  7: . . . . . . . . . . . . "]"
    5:  8: . . . . . . . . . . . . TypeName (
    5:  8: . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    5: 15: . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: float64}
    5: 15: . . . . . . . . . . . )
    5: 15: . . . . . . . . . . )
    5: 15: . . . . . . . . . . LiteralValue (
    5: 15: . . . . . . . . . . . "{"
    5: 16: . . . . . . . . . . . ElementList (
    5: 16: . . . . . . . . . . . . Element (
    5: 16: . . . . . . . . . . . . . Element (
    5: 16: . . . . . . . . . . . . . . Expression (
    5: 16: . . . . . . . . . . . . . . . BinaryExpr (
    5: 16: . . . . . . . . . . . . . . . . UnaryExpr (
    5: 16: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 16: . . . . . . . . . . . . . . . . . . Operand (
    5: 16: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    5: 17: . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . ","
    5: 19: . . . . . . . . . . . . Element (
    5: 19: . . . . . . . . . . . . . Element (
    5: 19: . . . . . . . . . . . . . . Expression (
    5: 19: . . . . . . . . . . . . . . . BinaryExpr (
    5: 19: . . . . . . . . . . . . . . . . UnaryExpr (
    5: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 19: . . . . . . . . . . . . . . . . . . Operand (
    5: 19: . . . . . . . . . . . . . . . . . . . FLOAT 3.4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 3.4}
    5: 22: . . . . . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . ","
    5: 24: . . . . . . . . . . . . Element (
    5: 24: . . . . . . . . . . . . . Element (
    5: 24: . . . . . . . . . . . . . . Expression (
    5: 24: . . . . . . . . . . . . . . . BinaryExpr (
    5: 24: . . . . . . . . . . . . . . . . UnaryExpr (
    5: 24: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 24: . . . . . . . . . . . . . . . . . . Operand (
    5: 24: . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    5: 25: . . . . . . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . "}"
    5: 26: . . . . . . . . . . )
    5: 26: . . . . . . . . . )
    5: 26: . . . . . . . . )
    5: 26: . . . . . . . )
    5: 26: . . . . . . )
    5: 26: . . . . . )
    5: 26: . . . . )
    5: 26: . . . . ";"
    6:  1: . . . )
    6:  1: . . . Statement (
    6:  1: . . . . SimpleStmt (
    6:  1: . . . . . ExpressionList (
    6:  1: . . . . . . Expression (
    6:  1: . . . . . . . BinaryExpr (
    6:  1: . . . . . . . . UnaryExpr (
    6:  1: . . . . . . . . . PrimaryExpr (
    6:  1: . . . . . . . . . . Operand (
    6:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    6:  3: . . . . . . . . . . )
    6:  3: . . . . . . . . . )
    6:  3: . . . . . . . . )
    6:  3: . . . . . . . )
    6:  3: . . . . . . )
    6:  3: . . . . . )
    6:  3: . . . . . ":="
    6:  6: . . . . . ExpressionList (
    6:  6: . . . . . . Expression (
    6:  6: . . . . . . . BinaryExpr (
    6:  6: . . . . . . . . UnaryExpr (
    6:  6: . . . . . . . . . PrimaryExpr (
    6:  6: . . . . . . . . . . Operand (
    6:  6: . . . . . . . . . . . "map"
    6:  6: . . . . . . . . . . . MapType (
    6:  9: . . . . . . . . . . . . "["
    6: 10: . . . . . . . . . . . . Type (
    6: 10: . . . . . . . . . . . . . TypeName (
    6: 10: . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    6: 16: . . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . "]"
    6: 17: . . . . . . . . . . . . Type (
    6: 17: . . . . . . . . . . . . . TypeName (
    6: 17: . . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    6: 24: . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: string, Value: float64}
    6: 24: . . . . . . . . . . . )
    6: 24: . . . . . . . . . . )
    6: 24: . . . . . . . . . . LiteralValue (
    6: 24: . . . . . . . . . . . "{"
    6: 25: . . . . . . . . . . . ElementList (
    6: 25: . . . . . . . . . . . . Element (
    6: 25: . . . . . . . . . . . . . Element (
    6: 25: . . . . . . . . . . . . . . Expression (
    6: 25: . . . . . . . . . . . . . . . BinaryExpr (
    6: 25: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 25: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 25: . . . . . . . . . . . . . . . . . . Operand (
    6: 25: . . . . . . . . . . . . . . . . . . . STRING "Hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hello"}
    6: 32: . . . . . . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . ":"
    6: 34: . . . . . . . . . . . . . Element (
    6: 34: . . . . . . . . . . . . . . Expression (
    6: 34: . . . . . . . . . . . . . . . BinaryExpr (
    6: 34: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 34: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 34: . . . . . . . . . . . . . . . . . . Operand (
    6: 34: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    6: 35: . . . . . . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . ","
    6: 37: . . . . . . . . . . . . Element (
    6: 37: . . . . . . . . . . . . . Element (
    6: 37: . . . . . . . . . . . . . . Expression (
    6: 37: . . . . . . . . . . . . . . . BinaryExpr (
    6: 37: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 37: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 37: . . . . . . . . . . . . . . . . . . Operand (
    6: 37: . . . . . . . . . . . . . . . . . . . STRING "xsw"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "xsw"}
    6: 42: . . . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . ":"
    6: 44: . . . . . . . . . . . . . Element (
    6: 44: . . . . . . . . . . . . . . Expression (
    6: 44: . . . . . . . . . . . . . . . BinaryExpr (
    6: 44: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 44: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 44: . . . . . . . . . . . . . . . . . . Operand (
    6: 44: . . . . . . . . . . . . . . . . . . . FLOAT 3.4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 3.4}
    6: 47: . . . . . . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . "}"
    6: 48: . . . . . . . . . . )
    6: 48: . . . . . . . . . )
    6: 48: . . . . . . . . )
    6: 48: . . . . . . . )
    6: 48: . . . . . . )
    6: 48: . . . . . )
    6: 48: . . . . )
    6: 48: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . SimpleStmt (
    7:  1: . . . . . ExpressionList (
    7:  1: . . . . . . Expression (
    7:  1: . . . . . . . BinaryExpr (
    7:  1: . . . . . . . . UnaryExpr (
    7:  1: . . . . . . . . . PrimaryExpr (
    7:  1: . . . . . . . . . . Operand (
    7:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    7:  8: . . . . . . . . . . )
    7:  8: . . . . . . . . . . CallOrConversion (
    7:  8: . . . . . . . . . . . "("
    7:  9: . . . . . . . . . . . Expression (
    7:  9: . . . . . . . . . . . . BinaryExpr (
    7:  9: . . . . . . . . . . . . . UnaryExpr (
    7:  9: . . . . . . . . . . . . . . PrimaryExpr (
    7:  9: . . . . . . . . . . . . . . . Operand (
    7:  9: . . . . . . . . . . . . . . . . STRING "x:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x:"}
    7: 13: . . . . . . . . . . . . . . . )
    7: 13: . . . . . . . . . . . . . . )
    7: 13: . . . . . . . . . . . . . )
    7: 13: . . . . . . . . . . . . )
    7: 13: . . . . . . . . . . . )
    7: 13: . . . . . . . . . . . ","
    7: 15: . . . . . . . . . . . Expression (
    7: 15: . . . . . . . . . . . . BinaryExpr (
    7: 15: . . . . . . . . . . . . . UnaryExpr (
    7: 15: . . . . . . . . . . . . . . PrimaryExpr (
    7: 15: . . . . . . . . . . . . . . . Operand (
    7: 15: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7: 16: . . . . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . ","
    7: 18: . . . . . . . . . . . Expression (
    7: 18: . . . . . . . . . . . . BinaryExpr (
    7: 18: . . . . . . . . . . . . . UnaryExpr (
    7: 18: . . . . . . . . . . . . . . PrimaryExpr (
    7: 18: . . . . . . . . . . . . . . . Operand (
    7: 18: . . . . . . . . . . . . . . . . STRING "y:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "y:"}
    7: 22: . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . ","
    7: 24: . . . . . . . . . . . Expression (
    7: 24: . . . . . . . . . . . . BinaryExpr (
    7: 24: . . . . . . . . . . . . . UnaryExpr (
    7: 24: . . . . . . . . . . . . . . PrimaryExpr (
    7: 24: . . . . . . . . . . . . . . . Operand (
    7: 24: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    7: 25: . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    7: 26: . . . . . . . . . . )
    7: 26: . . . . . . . . . )
    7: 26: . . . . . . . . )
    7: 26: . . . . . . . )
    7: 26: . . . . . . )
    7: 26: . . . . . )
    7: 26: . . . . )
    7: 26: . . . . ";"
    9:  1: . . . )
    9:  1: . . . Statement (
    9:  1: . . . . SimpleStmt (
    9:  1: . . . . . ExpressionList (
    9:  1: . . . . . . Expression (
    9:  1: . . . . . . . BinaryExpr (
    9:  1: . . . . . . . . UnaryExpr (
    9:  1: . . . . . . . . . PrimaryExpr (
    9:  1: . . . . . . . . . . Operand (
    9:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    9:  3: . . . . . . . . . . )
    9:  3: . . . . . . . . . )
    9:  3: . . . . . . . . )
    9:  3: . . . . . . . )
    9:  3: . . . . . . )
    9:  3: . . . . . )
    9:  3: . . . . . ":="
    9:  6: . . . . . ExpressionList (
    9:  6: . . . . . . Expression (
    9:  6: . . . . . . . BinaryExpr (
    9:  6: . . . . . . . . UnaryExpr (
    9:  6: . . . . . . . . . PrimaryExpr (
    9:  6: . . . . . . . . . . Operand (
    9:  6: . . . . . . . . . . . ArrayType (
    9:  6: . . . . . . . . . . . . "["
    9:  7: . . . . . . . . . . . . "..."
    9: 10: . . . . . . . . . . . . "]"
    9: 11: . . . . . . . . . . . . TypeName (
    9: 11: . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    9: 18: . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: &{134 <nil>}, Elt: float64}
    9: 18: . . . . . . . . . . . )
    9: 18: . . . . . . . . . . )
    9: 18: . . . . . . . . . . LiteralValue (
    9: 18: . . . . . . . . . . . "{"
    9: 19: . . . . . . . . . . . ElementList (
    9: 19: . . . . . . . . . . . . Element (
    9: 19: . . . . . . . . . . . . . Element (
    9: 19: . . . . . . . . . . . . . . Expression (
    9: 19: . . . . . . . . . . . . . . . BinaryExpr (
    9: 19: . . . . . . . . . . . . . . . . UnaryExpr (
    9: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 19: . . . . . . . . . . . . . . . . . . Operand (
    9: 19: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    9: 20: . . . . . . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . ","
    9: 22: . . . . . . . . . . . . Element (
    9: 22: . . . . . . . . . . . . . Element (
    9: 22: . . . . . . . . . . . . . . Expression (
    9: 22: . . . . . . . . . . . . . . . BinaryExpr (
    9: 22: . . . . . . . . . . . . . . . . UnaryExpr (
    9: 22: . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 22: . . . . . . . . . . . . . . . . . . Operand (
    9: 22: . . . . . . . . . . . . . . . . . . . FLOAT 3.4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 3.4}
    9: 25: . . . . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . ","
    9: 27: . . . . . . . . . . . . Element (
    9: 27: . . . . . . . . . . . . . Element (
    9: 27: . . . . . . . . . . . . . . Expression (
    9: 27: . . . . . . . . . . . . . . . BinaryExpr (
    9: 27: . . . . . . . . . . . . . . . . UnaryExpr (
    9: 27: . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 27: . . . . . . . . . . . . . . . . . . Operand (
    9: 27: . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    9: 28: . . . . . . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . "}"
    9: 29: . . . . . . . . . . )
    9: 29: . . . . . . . . . )
    9: 29: . . . . . . . . )
    9: 29: . . . . . . . )
    9: 29: . . . . . . )
    9: 29: . . . . . )
    9: 29: . . . . )
    9: 29: . . . . ";"
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   10:  3: . . . . . . . . . . )
   10:  3: . . . . . . . . . )
   10:  3: . . . . . . . . )
   10:  3: . . . . . . . )
   10:  3: . . . . . . )
   10:  3: . . . . . )
   10:  3: . . . . . ":="
   10:  6: . . . . . ExpressionList (
   10:  6: . . . . . . Expression (
   10:  6: . . . . . . . BinaryExpr (
   10:  6: . . . . . . . . UnaryExpr (
   10:  6: . . . . . . . . . PrimaryExpr (
   10:  6: . . . . . . . . . . Operand (
   10:  6: . . . . . . . . . . . ArrayType (
   10:  6: . . . . . . . . . . . . "["
   10:  7: . . . . . . . . . . . . "..."
   10: 10: . . . . . . . . . . . . "]"
   10: 11: . . . . . . . . . . . . TypeName (
   10: 11: . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
   10: 18: . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: &{163 <nil>}, Elt: float64}
   10: 18: . . . . . . . . . . . )
   10: 18: . . . . . . . . . . )
   10: 18: . . . . . . . . . . LiteralValue (
   10: 18: . . . . . . . . . . . "{"
   10: 19: . . . . . . . . . . . ElementList (
   10: 19: . . . . . . . . . . . . Element (
   10: 19: . . . . . . . . . . . . . Element (
   10: 19: . . . . . . . . . . . . . . Expression (
   10: 19: . . . . . . . . . . . . . . . BinaryExpr (
   10: 19: . . . . . . . . . . . . . . . . UnaryExpr (
   10: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 19: . . . . . . . . . . . . . . . . . . Operand (
   10: 19: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   10: 20: . . . . . . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . ","
   10: 22: . . . . . . . . . . . . Element (
   10: 22: . . . . . . . . . . . . . Element (
   10: 22: . . . . . . . . . . . . . . Expression (
   10: 22: . . . . . . . . . . . . . . . BinaryExpr (
   10: 22: . . . . . . . . . . . . . . . . UnaryExpr (
   10: 22: . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 22: . . . . . . . . . . . . . . . . . . Operand (
   10: 22: . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   10: 23: . . . . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . ":"
   10: 25: . . . . . . . . . . . . . Element (
   10: 25: . . . . . . . . . . . . . . Expression (
   10: 25: . . . . . . . . . . . . . . . BinaryExpr (
   10: 25: . . . . . . . . . . . . . . . . UnaryExpr (
   10: 25: . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 25: . . . . . . . . . . . . . . . . . . Operand (
   10: 25: . . . . . . . . . . . . . . . . . . . FLOAT 3.4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 3.4}
   10: 28: . . . . . . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . ","
   10: 30: . . . . . . . . . . . . Element (
   10: 30: . . . . . . . . . . . . . Element (
   10: 30: . . . . . . . . . . . . . . Expression (
   10: 30: . . . . . . . . . . . . . . . BinaryExpr (
   10: 30: . . . . . . . . . . . . . . . . UnaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . Operand (
   10: 30: . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   10: 31: . . . . . . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . "}"
   10: 32: . . . . . . . . . . )
   10: 32: . . . . . . . . . )
   10: 32: . . . . . . . . )
   10: 32: . . . . . . . )
   10: 32: . . . . . . )
   10: 32: . . . . . )
   10: 32: . . . . )
   10: 32: . . . . ";"
   11:  1: . . . )
   11:  1: . . . Statement (
   11:  1: . . . . SimpleStmt (
   11:  1: . . . . . ExpressionList (
   11:  1: . . . . . . Expression (
   11:  1: . . . . . . . BinaryExpr (
   11:  1: . . . . . . . . UnaryExpr (
   11:  1: . . . . . . . . . PrimaryExpr (
   11:  1: . . . . . . . . . . Operand (
   11:  1: . . . . . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
   11:  3: . . . . . . . . . . )
   11:  3: . . . . . . . . . )
   11:  3: . . . . . . . . )
   11:  3: . . . . . . . )
   11:  3: . . . . . . )
   11:  3: . . . . . )
   11:  3: . . . . . ":="
   11:  6: . . . . . ExpressionList (
   11:  6: . . . . . . Expression (
   11:  6: . . . . . . . BinaryExpr (
   11:  6: . . . . . . . . UnaryExpr (
   11:  6: . . . . . . . . . PrimaryExpr (
   11:  6: . . . . . . . . . . Operand (
   11:  6: . . . . . . . . . . . ArrayType (
   11:  6: . . . . . . . . . . . . "["
   11:  7: . . . . . . . . . . . . "]"
   11:  8: . . . . . . . . . . . . TypeName (
   11:  8: . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
   11: 15: . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: float64}
   11: 15: . . . . . . . . . . . )
   11: 15: . . . . . . . . . . )
   11: 15: . . . . . . . . . . LiteralValue (
   11: 15: . . . . . . . . . . . "{"
   11: 16: . . . . . . . . . . . ElementList (
   11: 16: . . . . . . . . . . . . Element (
   11: 16: . . . . . . . . . . . . . Element (
   11: 16: . . . . . . . . . . . . . . Expression (
   11: 16: . . . . . . . . . . . . . . . BinaryExpr (
   11: 16: . . . . . . . . . . . . . . . . UnaryExpr (
   11: 16: . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 16: . . . . . . . . . . . . . . . . . . Operand (
   11: 16: . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   11: 17: . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . ":"
   11: 19: . . . . . . . . . . . . . Element (
   11: 19: . . . . . . . . . . . . . . Expression (
   11: 19: . . . . . . . . . . . . . . . BinaryExpr (
   11: 19: . . . . . . . . . . . . . . . . UnaryExpr (
   11: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 19: . . . . . . . . . . . . . . . . . . Operand (
   11: 19: . . . . . . . . . . . . . . . . . . . FLOAT 1.2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 1.2}
   11: 22: . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . ","
   11: 24: . . . . . . . . . . . . Element (
   11: 24: . . . . . . . . . . . . . Element (
   11: 24: . . . . . . . . . . . . . . Expression (
   11: 24: . . . . . . . . . . . . . . . BinaryExpr (
   11: 24: . . . . . . . . . . . . . . . . UnaryExpr (
   11: 24: . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 24: . . . . . . . . . . . . . . . . . . Operand (
   11: 24: . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   11: 25: . . . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . ","
   11: 27: . . . . . . . . . . . . Element (
   11: 27: . . . . . . . . . . . . . Element (
   11: 27: . . . . . . . . . . . . . . Expression (
   11: 27: . . . . . . . . . . . . . . . BinaryExpr (
   11: 27: . . . . . . . . . . . . . . . . UnaryExpr (
   11: 27: . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 27: . . . . . . . . . . . . . . . . . . Operand (
   11: 27: . . . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
   11: 28: . . . . . . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . ":"
   11: 30: . . . . . . . . . . . . . Element (
   11: 30: . . . . . . . . . . . . . . Expression (
   11: 30: . . . . . . . . . . . . . . . BinaryExpr (
   11: 30: . . . . . . . . . . . . . . . . UnaryExpr (
   11: 30: . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 30: . . . . . . . . . . . . . . . . . . Operand (
   11: 30: . . . . . . . . . . . . . . . . . . . FLOAT 4.5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 4.5}
   11: 33: . . . . . . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . "}"
   11: 34: . . . . . . . . . . )
   11: 34: . . . . . . . . . )
   11: 34: . . . . . . . . )
   11: 34: . . . . . . . )
   11: 34: . . . . . . )
   11: 34: . . . . . )
   11: 34: . . . . )
   11: 34: . . . . ";"
   12:  1: . . . )
   12:  1: . . . Statement (
   12:  1: . . . . SimpleStmt (
   12:  1: . . . . . ExpressionList (
   12:  1: . . . . . . Expression (
   12:  1: . . . . . . . BinaryExpr (
   12:  1: . . . . . . . . UnaryExpr (
   12:  1: . . . . . . . . . PrimaryExpr (
   12:  1: . . . . . . . . . . Operand (
   12:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   12:  8: . . . . . . . . . . )
   12:  8: . . . . . . . . . . CallOrConversion (
   12:  8: . . . . . . . . . . . "("
   12:  9: . . . . . . . . . . . Expression (
   12:  9: . . . . . . . . . . . . BinaryExpr (
   12:  9: . . . . . . . . . . . . . UnaryExpr (
   12:  9: . . . . . . . . . . . . . . PrimaryExpr (
   12:  9: . . . . . . . . . . . . . . . Operand (
   12:  9: . . . . . . . . . . . . . . . . STRING "a:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a:"}
   12: 13: . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . ","
   12: 15: . . . . . . . . . . . Expression (
   12: 15: . . . . . . . . . . . . BinaryExpr (
   12: 15: . . . . . . . . . . . . . UnaryExpr (
   12: 15: . . . . . . . . . . . . . . PrimaryExpr (
   12: 15: . . . . . . . . . . . . . . . Operand (
   12: 15: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   12: 16: . . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . ","
   12: 18: . . . . . . . . . . . Expression (
   12: 18: . . . . . . . . . . . . BinaryExpr (
   12: 18: . . . . . . . . . . . . . UnaryExpr (
   12: 18: . . . . . . . . . . . . . . PrimaryExpr (
   12: 18: . . . . . . . . . . . . . . . Operand (
   12: 18: . . . . . . . . . . . . . . . . STRING "b:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "b:"}
   12: 22: . . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . ","
   12: 24: . . . . . . . . . . . Expression (
   12: 24: . . . . . . . . . . . . BinaryExpr (
   12: 24: . . . . . . . . . . . . . UnaryExpr (
   12: 24: . . . . . . . . . . . . . . PrimaryExpr (
   12: 24: . . . . . . . . . . . . . . . Operand (
   12: 24: . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   12: 25: . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . ","
   12: 27: . . . . . . . . . . . Expression (
   12: 27: . . . . . . . . . . . . BinaryExpr (
   12: 27: . . . . . . . . . . . . . UnaryExpr (
   12: 27: . . . . . . . . . . . . . . PrimaryExpr (
   12: 27: . . . . . . . . . . . . . . . Operand (
   12: 27: . . . . . . . . . . . . . . . . STRING "c:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "c:"}
   12: 31: . . . . . . . . . . . . . . . )
   12: 31: . . . . . . . . . . . . . . )
   12: 31: . . . . . . . . . . . . . )
   12: 31: . . . . . . . . . . . . )
   12: 31: . . . . . . . . . . . )
   12: 31: . . . . . . . . . . . ","
   12: 33: . . . . . . . . . . . Expression (
   12: 33: . . . . . . . . . . . . BinaryExpr (
   12: 33: . . . . . . . . . . . . . UnaryExpr (
   12: 33: . . . . . . . . . . . . . . PrimaryExpr (
   12: 33: . . . . . . . . . . . . . . . Operand (
   12: 33: . . . . . . . . . . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
   12: 34: . . . . . . . . . . . . . . . )
   12: 34: . . . . . . . . . . . . . . )
   12: 34: . . . . . . . . . . . . . )
   12: 34: . . . . . . . . . . . . )
   12: 34: . . . . . . . . . . . )
   12: 34: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   12: 35: . . . . . . . . . . )
   12: 35: . . . . . . . . . )
   12: 35: . . . . . . . . )
   12: 35: . . . . . . . )
   12: 35: . . . . . . )
   12: 35: . . . . . )
   12: 35: . . . . )
   12: 35: . . . . ";"
   12: 36: . . . )
   12: 36: . . )
   12: 36: . )
   12: 36: )
=== RUN   TestFromTestdata/stringex1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/stringex1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . STRING "$"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "$"}
    1: 12: . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 12: . . . . . . . . . . )
    1: 12: . . . . . . . . . )
    1: 12: . . . . . . . . )
    1: 12: . . . . . . . )
    1: 12: . . . . . . )
    1: 12: . . . . . )
    1: 12: . . . . )
    1: 12: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . STRING "$$"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "$$"}
    2: 13: . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    2: 13: . . . . . . . . . . )
    2: 13: . . . . . . . . . )
    2: 13: . . . . . . . . )
    2: 13: . . . . . . . )
    2: 13: . . . . . . )
    2: 13: . . . . . )
    2: 13: . . . . )
    2: 13: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    3:  9: . . . . . . . . . . )
    3:  9: . . . . . . . . . . CallOrConversion (
    3:  9: . . . . . . . . . . . Expression (
    3:  9: . . . . . . . . . . . . BinaryExpr (
    3:  9: . . . . . . . . . . . . . UnaryExpr (
    3:  9: . . . . . . . . . . . . . . PrimaryExpr (
    3:  9: . . . . . . . . . . . . . . . Operand (
    3:  9: . . . . . . . . . . . . . . . . STRING "a$$b$"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a$$b$"}
    3: 16: . . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    3: 16: . . . . . . . . . . )
    3: 16: . . . . . . . . . )
    3: 16: . . . . . . . . )
    3: 16: . . . . . . . )
    3: 16: . . . . . . )
    3: 16: . . . . . )
    3: 16: . . . . )
    3: 16: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  9: . . . . . . . . . . )
    4:  9: . . . . . . . . . . CallOrConversion (
    4:  9: . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . Operand (
    4:  9: . . . . . . . . . . . . . . . . STRING "a$$b$$"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a$$b$$"}
    4: 17: . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 17: . . . . . . . . . . )
    4: 17: . . . . . . . . . )
    4: 17: . . . . . . . . )
    4: 17: . . . . . . . )
    4: 17: . . . . . . )
    4: 17: . . . . . )
    4: 17: . . . . )
    4: 17: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  9: . . . . . . . . . . )
    5:  9: . . . . . . . . . . CallOrConversion (
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . STRING "a$b$%"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a$b$%"}
    5: 16: . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 16: . . . . . . . . . . )
    5: 16: . . . . . . . . . )
    5: 16: . . . . . . . . )
    5: 16: . . . . . . . )
    5: 16: . . . . . . )
    5: 16: . . . . . )
    5: 16: . . . . )
    5: 16: . . . . ";"
    5: 17: . . . )
    5: 17: . . )
    5: 17: . )
    5: 17: )
=== RUN   TestFromTestdata/stringex2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/stringex2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . STRING "${"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "${"}
    1: 13: . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 13: . . . . . . . . . . )
    1: 13: . . . . . . . . . )
    1: 13: . . . . . . . . )
    1: 13: . . . . . . . )
    1: 13: . . . . . . )
    1: 13: . . . . . )
    1: 13: . . . . )
    1: 13: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: b}
    2:  9: . . . . . . . . . . . . . . . . STRING "${ b }"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "${ b }"}
    2: 17: . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    2: 17: . . . . . . . . . . )
    2: 17: . . . . . . . . . )
    2: 17: . . . . . . . . )
    2: 17: . . . . . . . )
    2: 17: . . . . . . )
    2: 17: . . . . . )
    2: 17: . . . . )
    2: 17: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    3:  9: . . . . . . . . . . )
    3:  9: . . . . . . . . . . CallOrConversion (
    3:  9: . . . . . . . . . . . Expression (
    3:  9: . . . . . . . . . . . . BinaryExpr (
    3:  9: . . . . . . . . . . . . . UnaryExpr (
    3:  9: . . . . . . . . . . . . . . PrimaryExpr (
    3:  9: . . . . . . . . . . . . . . . Operand (
    3:  9: . . . . . . . . . . . . . . . . STRING "a${"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a${"}
    3: 14: . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    3: 14: . . . . . . . . . . )
    3: 14: . . . . . . . . . )
    3: 14: . . . . . . . . )
    3: 14: . . . . . . . )
    3: 14: . . . . . . )
    3: 14: . . . . . )
    3: 14: . . . . )
    3: 14: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  9: . . . . . . . . . . )
    4:  9: . . . . . . . . . . CallOrConversion (
    4:  9: . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4:  9: . . . . . . . . . . . . . . . . STRING "a${b}c"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a${b}c"}
    4: 17: . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 17: . . . . . . . . . . )
    4: 17: . . . . . . . . . )
    4: 17: . . . . . . . . )
    4: 17: . . . . . . . )
    4: 17: . . . . . . )
    4: 17: . . . . . )
    4: 17: . . . . )
    4: 17: . . . . ";"
    4: 18: . . . )
    4: 18: . . )
    4: 18: . )
    4: 18: )
=== RUN   TestFromTestdata/stringex3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/stringex3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: args}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:2064: ast.IndexExpr{X: args, Index: &{22 INT 0 <nil>}}
 /app/parser/parser.go:713: ast.Ident{Name: query}
    1:  9: . . . . . . . . . . . . . . . . STRING "file:${args[0]}?${query}"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "file:${args[0]}?${query}"}
    1: 35: . . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 35: . . . . . . . . . . )
    1: 35: . . . . . . . . . )
    1: 35: . . . . . . . . )
    1: 35: . . . . . . . )
    1: 35: . . . . . . )
    1: 35: . . . . . )
    1: 35: . . . . )
    1: 35: . . . . ";"
    1: 36: . . . )
    1: 36: . . )
    1: 36: . )
    1: 36: )
=== RUN   TestFromTestdata/typeof
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/typeof
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . IDENT type
 /app/parser/parser.go:713: ast.Ident{Name: type}
    1: 10: . . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . . . CallOrConversion (
    1: 10: . . . . . . . . . . . . . . . . "("
    1: 11: . . . . . . . . . . . . . . . . Expression (
    1: 11: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 11: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 11: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 11: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 11: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 12: . . . . . . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: type, Ellipsis: false, isCmd: false}
    1: 13: . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . ","
    1: 15: . . . . . . . . . . . Expression (
    1: 15: . . . . . . . . . . . . BinaryExpr (
    1: 15: . . . . . . . . . . . . . UnaryExpr (
    1: 15: . . . . . . . . . . . . . . PrimaryExpr (
    1: 15: . . . . . . . . . . . . . . . Operand (
    1: 15: . . . . . . . . . . . . . . . . IDENT type
 /app/parser/parser.go:713: ast.Ident{Name: type}
    1: 19: . . . . . . . . . . . . . . . )
    1: 19: . . . . . . . . . . . . . . . CallOrConversion (
    1: 19: . . . . . . . . . . . . . . . . "("
    1: 20: . . . . . . . . . . . . . . . . Expression (
    1: 20: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 20: . . . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    1: 24: . . . . . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: type, Ellipsis: false, isCmd: false}
    1: 25: . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    1: 26: . . . )
    1: 26: . . )
    1: 26: . )
    1: 26: )
=== RUN   TestFromTestdata/typeswitch
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/typeswitch
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
    1:  9: . . . Signature (
    1:  9: . . . . Parameters (
    1:  9: . . . . . "("
    1: 10: . . . . . ParameterList (
    1: 10: . . . . . . ParamDeclOrNil (
    1: 10: . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    1: 12: . . . . . . . Type (
    1: 12: . . . . . . . . InterfaceType (
    1: 12: . . . . . . . . . "interface"
    1: 21: . . . . . . . . . "{"
    1: 22: . . . . . . . . . "}"
    1: 23: . . . . . . . . )
    1: 23: . . . . . . . )
    1: 23: . . . . . . )
    1: 23: . . . . . )
    1: 23: . . . . . ")"
    1: 25: . . . . )
    1: 25: . . . . Result (
    1: 25: . . . . )
    1: 25: . . . )
    1: 25: . . . Body (
    1: 25: . . . . "{"
    2:  2: . . . . StatementList (
    2:  2: . . . . . Statement (
    2:  2: . . . . . . SwitchStmt (
    2:  2: . . . . . . . "switch"
    2:  9: . . . . . . . SimpleStmt (
    2:  9: . . . . . . . . ExpressionList (
    2:  9: . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 11: . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . )
    2: 11: . . . . . . . . . . )
    2: 11: . . . . . . . . . )
    2: 11: . . . . . . . . )
    2: 11: . . . . . . . . ":="
    2: 14: . . . . . . . . ExpressionList (
    2: 14: . . . . . . . . . Expression (
    2: 14: . . . . . . . . . . BinaryExpr (
    2: 14: . . . . . . . . . . . UnaryExpr (
    2: 14: . . . . . . . . . . . . PrimaryExpr (
    2: 14: . . . . . . . . . . . . . Operand (
    2: 14: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    2: 15: . . . . . . . . . . . . . )
    2: 15: . . . . . . . . . . . . . "."
    2: 16: . . . . . . . . . . . . . TypeAssertion (
    2: 16: . . . . . . . . . . . . . . "("
    2: 17: . . . . . . . . . . . . . . "type"
    2: 21: . . . . . . . . . . . . . . ")"
    2: 23: . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . )
    2: 23: . . . . . . . . . . )
    2: 23: . . . . . . . . . )
    2: 23: . . . . . . . . )
    2: 23: . . . . . . . )
    2: 23: . . . . . . . "{"
    3:  2: . . . . . . . CaseClause (
    3:  2: . . . . . . . . "case"
    3:  7: . . . . . . . . TypeList (
    3:  7: . . . . . . . . . Type (
    3:  7: . . . . . . . . . . TypeName (
    3:  7: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 10: . . . . . . . . . . )
    3: 10: . . . . . . . . . )
    3: 10: . . . . . . . . . ","
    3: 12: . . . . . . . . . Type (
    3: 12: . . . . . . . . . . InterfaceType (
    3: 12: . . . . . . . . . . . "interface"
    3: 21: . . . . . . . . . . . "{"
    3: 23: . . . . . . . . . . . MethodSpec (
    3: 23: . . . . . . . . . . . . TypeName (
    3: 23: . . . . . . . . . . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
    3: 26: . . . . . . . . . . . . )
    3: 26: . . . . . . . . . . . . Signature (
    3: 26: . . . . . . . . . . . . . Parameters (
    3: 26: . . . . . . . . . . . . . . "("
    3: 27: . . . . . . . . . . . . . . ")"
    3: 29: . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . . Result (
    3: 29: . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . "}"
    3: 30: . . . . . . . . . . )
    3: 30: . . . . . . . . . )
    3: 30: . . . . . . . . )
    3: 30: . . . . . . . . ":"
    4:  2: . . . . . . . . StatementList (
    4:  2: . . . . . . . . )
    4:  2: . . . . . . . )
    4:  2: . . . . . . . CaseClause (
    4:  2: . . . . . . . . "case"
    4:  7: . . . . . . . . TypeList (
    4:  7: . . . . . . . . . Type (
    4:  7: . . . . . . . . . . PointerType (
    4:  7: . . . . . . . . . . . "*"
    4:  8: . . . . . . . . . . . Type (
    4:  8: . . . . . . . . . . . . TypeName (
    4:  8: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    4: 14: . . . . . . . . . . . . )
    4: 14: . . . . . . . . . . . )
    4: 14: . . . . . . . . . . )
    4: 14: . . . . . . . . . )
    4: 14: . . . . . . . . )
    4: 14: . . . . . . . . ":"
    5:  2: . . . . . . . . StatementList (
    5:  2: . . . . . . . . )
    5:  2: . . . . . . . )
    5:  2: . . . . . . . CaseClause (
    5:  2: . . . . . . . . "default"
    5:  9: . . . . . . . . ":"
    6:  2: . . . . . . . . StatementList (
    6:  2: . . . . . . . . )
    6:  2: . . . . . . . )
    6:  2: . . . . . . . "}"
    6:  3: . . . . . . . ";"
    7:  1: . . . . . . )
    7:  1: . . . . . )
    7:  1: . . . . )
    7:  1: . . . . "}"
    7:  2: . . . )
    7:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: add, ...}
    7:  3: . . )
    7:  3: . )
    7:  3: )
=== RUN   TestFromTestdata/unit
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/unit
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT wait
 /app/parser/parser.go:713: ast.Ident{Name: wait}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1856: ast.NumberUnitLit{Kind: INT, Value: 1, Unit: s}
    1:  7: . . . . . . . . . . . . . . . . UNIT
    1: 10: . . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: wait, Ellipsis: false, isCmd: true}
    1: 10: . . . . . . . . . . )
    1: 10: . . . . . . . . . )
    1: 10: . . . . . . . . )
    1: 10: . . . . . . . )
    1: 10: . . . . . . )
    1: 10: . . . . . )
    1: 10: . . . . )
    1: 10: . . . . ";"
    1: 11: . . . )
    1: 11: . . )
    1: 11: . )
    1: 11: )
--- PASS: TestFromTestdata (0.15s)
    --- PASS: TestFromTestdata/append1 (0.00s)
    --- PASS: TestFromTestdata/append2 (0.00s)
    --- PASS: TestFromTestdata/arrowop (0.00s)
    --- PASS: TestFromTestdata/autoprop (0.00s)
    --- PASS: TestFromTestdata/build (0.00s)
    --- PASS: TestFromTestdata/c2gohello (0.00s)
    --- PASS: TestFromTestdata/cmdlinestyle1 (0.00s)
    --- PASS: TestFromTestdata/cmdlinestyle2 (0.00s)
    --- PASS: TestFromTestdata/cmdlinestyle3 (0.00s)
    --- PASS: TestFromTestdata/cmdlinestyle4 (0.00s)
    --- PASS: TestFromTestdata/collection (0.02s)
    --- PASS: TestFromTestdata/complit (0.00s)
    --- PASS: TestFromTestdata/domainhuh (0.00s)
    --- PASS: TestFromTestdata/domaintext (0.00s)
    --- PASS: TestFromTestdata/domaintpl (0.00s)
    --- PASS: TestFromTestdata/embedded1 (0.00s)
    --- PASS: TestFromTestdata/envop1 (0.00s)
    --- PASS: TestFromTestdata/envop2 (0.00s)
    --- PASS: TestFromTestdata/errwrap1 (0.00s)
    --- PASS: TestFromTestdata/errwrap2 (0.00s)
    --- PASS: TestFromTestdata/errwrap3 (0.00s)
    --- PASS: TestFromTestdata/exists (0.00s)
    --- PASS: TestFromTestdata/fnbody (0.00s)
    --- PASS: TestFromTestdata/fncall (0.00s)
    --- PASS: TestFromTestdata/forloop (0.01s)
    --- PASS: TestFromTestdata/funcdecl1 (0.00s)
    --- PASS: TestFromTestdata/funcdecl2 (0.00s)
    --- PASS: TestFromTestdata/funcdecl3 (0.00s)
    --- PASS: TestFromTestdata/funcdoc (0.00s)
    --- PASS: TestFromTestdata/funclit (0.00s)
    --- PASS: TestFromTestdata/functype (0.00s)
    --- PASS: TestFromTestdata/gmxtest (0.00s)
    --- PASS: TestFromTestdata/goto1 (0.00s)
    --- PASS: TestFromTestdata/goto2 (0.00s)
    --- PASS: TestFromTestdata/goxtest1 (0.00s)
    --- PASS: TestFromTestdata/goxtest2 (0.00s)
    --- PASS: TestFromTestdata/kwargs1 (0.00s)
    --- PASS: TestFromTestdata/lambda1 (0.00s)
    --- PASS: TestFromTestdata/lambda2 (0.00s)
    --- PASS: TestFromTestdata/lambda3 (0.00s)
    --- PASS: TestFromTestdata/lambda4 (0.00s)
    --- PASS: TestFromTestdata/listcompr (0.01s)
    --- PASS: TestFromTestdata/mapfunc (0.00s)
    --- PASS: TestFromTestdata/matrix1 (0.00s)
    --- PASS: TestFromTestdata/matrix2 (0.00s)
    --- PASS: TestFromTestdata/mytest (0.01s)
    --- PASS: TestFromTestdata/optparam (0.01s)
    --- PASS: TestFromTestdata/overload1 (0.00s)
    --- PASS: TestFromTestdata/overload2 (0.00s)
    --- PASS: TestFromTestdata/overloadop (0.00s)
    --- PASS: TestFromTestdata/printvariadic (0.00s)
    --- PASS: TestFromTestdata/pystr (0.00s)
    --- PASS: TestFromTestdata/rangeexpr1 (0.00s)
    --- PASS: TestFromTestdata/rangeexpr2 (0.00s)
    --- PASS: TestFromTestdata/rangeexpr3 (0.00s)
    --- PASS: TestFromTestdata/rational (0.00s)
    --- PASS: TestFromTestdata/selectdata (0.00s)
    --- PASS: TestFromTestdata/slice1 (0.00s)
    --- PASS: TestFromTestdata/slice2 (0.00s)
    --- PASS: TestFromTestdata/spxtest (0.00s)
    --- PASS: TestFromTestdata/staticmthd1 (0.00s)
    --- PASS: TestFromTestdata/staticmthd2 (0.00s)
    --- PASS: TestFromTestdata/stdtype (0.01s)
    --- PASS: TestFromTestdata/stringex1 (0.00s)
    --- PASS: TestFromTestdata/stringex2 (0.00s)
    --- PASS: TestFromTestdata/stringex3 (0.00s)
    --- PASS: TestFromTestdata/typeof (0.00s)
    --- PASS: TestFromTestdata/typeswitch (0.00s)
    --- PASS: TestFromTestdata/unit (0.00s)
=== RUN   TestFromNofmt
=== RUN   TestFromNofmt/cmdlinestyle1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/cmdlinestyle1
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . SimpleStmt (
    4:  2: . . . . . . . ExpressionList (
    4:  2: . . . . . . . . Expression (
    4:  2: . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . IDENT changeYpos
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
    4: 13: . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . "-"
    4: 13: . . . . . . . . . . . . CallOrConversion (
    4: 13: . . . . . . . . . . . . . Expression (
    4: 13: . . . . . . . . . . . . . . BinaryExpr (
    4: 13: . . . . . . . . . . . . . . . UnaryExpr (
    4: 14: . . . . . . . . . . . . . . . . UnaryExpr (
    4: 14: . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 14: . . . . . . . . . . . . . . . . . . Operand (
    4: 14: . . . . . . . . . . . . . . . . . . . FLOAT 0.7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
    4: 17: . . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . ","
    4: 19: . . . . . . . . . . . . . Expression (
    4: 19: . . . . . . . . . . . . . . BinaryExpr (
    4: 19: . . . . . . . . . . . . . . . UnaryExpr (
    4: 19: . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . Operand (
    4: 19: . . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    4: 20: . . . . . . . . . . . . . . . . . )
    4: 20: . . . . . . . . . . . . . . . . )
    4: 20: . . . . . . . . . . . . . . . )
    4: 20: . . . . . . . . . . . . . . )
    4: 20: . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: changeYpos, Ellipsis: false, isCmd: true}
    4: 20: . . . . . . . . . . . . )
    4: 20: . . . . . . . . . . . )
    4: 20: . . . . . . . . . . )
    4: 20: . . . . . . . . . )
    4: 20: . . . . . . . . )
    4: 20: . . . . . . . )
    4: 20: . . . . . . )
    4: 20: . . . . . . ";"
    5:  2: . . . . . )
    5:  2: . . . . . Statement (
    5:  2: . . . . . . SimpleStmt (
    5:  2: . . . . . . . ExpressionList (
    5:  2: . . . . . . . . Expression (
    5:  2: . . . . . . . . . BinaryExpr (
    5:  2: . . . . . . . . . . UnaryExpr (
    5:  2: . . . . . . . . . . . PrimaryExpr (
    5:  2: . . . . . . . . . . . . Operand (
    5:  2: . . . . . . . . . . . . . IDENT changeYpos
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . "-"
    5: 13: . . . . . . . . . . . . CallOrConversion (
    5: 13: . . . . . . . . . . . . . Expression (
    5: 13: . . . . . . . . . . . . . . BinaryExpr (
    5: 13: . . . . . . . . . . . . . . . UnaryExpr (
    5: 14: . . . . . . . . . . . . . . . . UnaryExpr (
    5: 14: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 14: . . . . . . . . . . . . . . . . . . Operand (
    5: 14: . . . . . . . . . . . . . . . . . . . FLOAT 0.7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
    5: 17: . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: changeYpos, Ellipsis: false, isCmd: true}
    5: 17: . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . )
    5: 17: . . . . . . . . . . )
    5: 17: . . . . . . . . . )
    5: 17: . . . . . . . . )
    5: 17: . . . . . . . )
    5: 17: . . . . . . )
    5: 17: . . . . . . ";"
    6:  2: . . . . . )
    6:  2: . . . . . Statement (
    6:  2: . . . . . . SimpleStmt (
    6:  2: . . . . . . . ExpressionList (
    6:  2: . . . . . . . . Expression (
    6:  2: . . . . . . . . . BinaryExpr (
    6:  2: . . . . . . . . . . UnaryExpr (
    6:  2: . . . . . . . . . . . PrimaryExpr (
    6:  2: . . . . . . . . . . . . Operand (
    6:  2: . . . . . . . . . . . . . IDENT changeYpos
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
    6: 13: . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . "-"
    6: 13: . . . . . . . . . . . )
    6: 13: . . . . . . . . . . )
    6: 15: . . . . . . . . . . BinaryExpr (
    6: 15: . . . . . . . . . . . UnaryExpr (
    6: 15: . . . . . . . . . . . . PrimaryExpr (
    6: 15: . . . . . . . . . . . . . Operand (
    6: 15: . . . . . . . . . . . . . . FLOAT 0.7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
    6: 18: . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . )
    6: 18: . . . . . . . . . . )
    6: 18: . . . . . . . . . )
    6: 18: . . . . . . . . )
    6: 18: . . . . . . . )
    6: 18: . . . . . . )
    6: 18: . . . . . . ";"
    7:  2: . . . . . )
    7:  2: . . . . . Statement (
    7:  2: . . . . . . SimpleStmt (
    7:  2: . . . . . . . ExpressionList (
    7:  2: . . . . . . . . Expression (
    7:  2: . . . . . . . . . BinaryExpr (
    7:  2: . . . . . . . . . . UnaryExpr (
    7:  2: . . . . . . . . . . . PrimaryExpr (
    7:  2: . . . . . . . . . . . . Operand (
    7:  2: . . . . . . . . . . . . . IDENT changeYpos
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
    7: 12: . . . . . . . . . . . . )
    7: 12: . . . . . . . . . . . )
    7: 12: . . . . . . . . . . )
    7: 12: . . . . . . . . . . "-"
    7: 13: . . . . . . . . . . BinaryExpr (
    7: 13: . . . . . . . . . . . UnaryExpr (
    7: 13: . . . . . . . . . . . . PrimaryExpr (
    7: 13: . . . . . . . . . . . . . Operand (
    7: 13: . . . . . . . . . . . . . . FLOAT 0.7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
    7: 16: . . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . )
    7: 16: . . . . . . . . . . )
    7: 16: . . . . . . . . . )
    7: 16: . . . . . . . . )
    7: 16: . . . . . . . )
    7: 16: . . . . . . )
    7: 16: . . . . . . ";"
    8:  2: . . . . . )
    8:  2: . . . . . Statement (
    8:  2: . . . . . . SimpleStmt (
    8:  2: . . . . . . . ExpressionList (
    8:  2: . . . . . . . . Expression (
    8:  2: . . . . . . . . . BinaryExpr (
    8:  2: . . . . . . . . . . UnaryExpr (
    8:  2: . . . . . . . . . . . PrimaryExpr (
    8:  2: . . . . . . . . . . . . Operand (
    8:  2: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    8:  3: . . . . . . . . . . . . )
    8:  3: . . . . . . . . . . . . IndexOrSlice (
    8:  3: . . . . . . . . . . . . . "["
    8:  4: . . . . . . . . . . . . . Expression (
    8:  4: . . . . . . . . . . . . . . BinaryExpr (
    8:  4: . . . . . . . . . . . . . . . UnaryExpr (
    8:  4: . . . . . . . . . . . . . . . . PrimaryExpr (
    8:  4: . . . . . . . . . . . . . . . . . Operand (
    8:  4: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    8:  5: . . . . . . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: x, Index: &{103 INT 1 <nil>}}
    8:  6: . . . . . . . . . . . . )
    8:  6: . . . . . . . . . . . )
    8:  6: . . . . . . . . . . )
    8:  6: . . . . . . . . . )
    8:  6: . . . . . . . . )
    8:  6: . . . . . . . )
    8:  6: . . . . . . )
    8:  6: . . . . . . ";"
    9:  2: . . . . . )
    9:  2: . . . . . Statement (
    9:  2: . . . . . . SimpleStmt (
    9:  2: . . . . . . . ExpressionList (
    9:  2: . . . . . . . . Expression (
    9:  2: . . . . . . . . . BinaryExpr (
    9:  2: . . . . . . . . . . UnaryExpr (
    9:  2: . . . . . . . . . . . PrimaryExpr (
    9:  2: . . . . . . . . . . . . Operand (
    9:  2: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    9:  4: . . . . . . . . . . . . )
    9:  4: . . . . . . . . . . . . CallOrConversion (
    9:  4: . . . . . . . . . . . . . Expression (
    9:  4: . . . . . . . . . . . . . . BinaryExpr (
    9:  4: . . . . . . . . . . . . . . . UnaryExpr (
    9:  4: . . . . . . . . . . . . . . . . PrimaryExpr (
    9:  4: . . . . . . . . . . . . . . . . . Operand (
    9:  4: . . . . . . . . . . . . . . . . . . ArrayType (
    9:  4: . . . . . . . . . . . . . . . . . . . "["
    9:  5: . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: []}
    9:  6: . . . . . . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . "..."
 /app/parser/parser.go:2160: ast.CallExpr{Fun: x, Ellipsis: true, isCmd: true}
    9:  9: . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . )
    9:  9: . . . . . . . . . . )
    9:  9: . . . . . . . . . )
    9:  9: . . . . . . . . )
    9:  9: . . . . . . . )
    9:  9: . . . . . . )
    9:  9: . . . . . . ";"
   10:  1: . . . . . )
   10:  1: . . . . )
   10:  1: . . . . "}"
   10:  2: . . . )
   10:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   10:  3: . . )
   10:  3: . )
   10:  3: )
=== RUN   TestFromNofmt/cmdlinestyle2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/cmdlinestyle2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
    1:  4: . . . . . . . . . . )
    1:  4: . . . . . . . . . . CallOrConversion (
    1:  4: . . . . . . . . . . . "("
    1:  5: . . . . . . . . . . . Expression (
    1:  5: . . . . . . . . . . . . BinaryExpr (
    1:  5: . . . . . . . . . . . . . UnaryExpr (
    1:  5: . . . . . . . . . . . . . . PrimaryExpr (
    1:  5: . . . . . . . . . . . . . . . Operand (
    1:  5: . . . . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . ","
    1: 10: . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . INT 200
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 200}
    1: 13: . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: add, Ellipsis: false, isCmd: false}
    1: 15: . . . . . . . . . . )
    1: 15: . . . . . . . . . . CallOrConversion (
    1: 15: . . . . . . . . . . . "("
    1: 16: . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{add 4 [0xc0003fd7a0 0xc0003fd7d0] 0 [] 13 0}, Ellipsis: false, isCmd: false}
    1: 18: . . . . . . . . . . )
    1: 18: . . . . . . . . . . "."
    1: 19: . . . . . . . . . . Selector (
    1: 19: . . . . . . . . . . . IDENT Test
 /app/parser/parser.go:713: ast.Ident{Name: Test}
    1: 23: . . . . . . . . . . )
    1: 23: . . . . . . . . . . CallOrConversion (
    1: 23: . . . . . . . . . . . "("
    1: 24: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc0003d7620 Test}, Ellipsis: false, isCmd: false}
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    1: 26: . . . )
    1: 26: . . )
    1: 26: . )
    1: 26: )
=== RUN   TestFromNofmt/cmdlinestyle3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/cmdlinestyle3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . "("
    1: 10: . . . . . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 11: . . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . "+"
    1: 12: . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 12: . . . . . . . . . . . . . . . . . . . . . . IMAG 2i
 /app/parser/parser.go:1862: ast.BasicLit{Kind: IMAG, Value: 2i}
    1: 14: . . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . ","
    1: 16: . . . . . . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    1: 17: . . . . . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . . ")"
    1: 18: . . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 18: . . . . . . . . . . )
    1: 18: . . . . . . . . . )
    1: 18: . . . . . . . . )
    1: 18: . . . . . . . )
    1: 18: . . . . . . )
    1: 18: . . . . . )
    1: 18: . . . . )
    1: 18: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . "("
    2: 10: . . . . . . . . . . . . . . . . Expression (
    2: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 10: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 11: . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . ","
    2: 13: . . . . . . . . . . . . . . . . Expression (
    2: 13: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 13: . . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 14: . . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . "..."
    2: 17: . . . . . . . . . . . . . . . . ")"
    2: 18: . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: true}
    2: 18: . . . . . . . . . . )
    2: 18: . . . . . . . . . )
    2: 18: . . . . . . . . )
    2: 18: . . . . . . . )
    2: 18: . . . . . . )
    2: 18: . . . . . )
    2: 18: . . . . )
    2: 18: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    3:  9: . . . . . . . . . . )
    3:  9: . . . . . . . . . . CallOrConversion (
    3:  9: . . . . . . . . . . . Expression (
    3:  9: . . . . . . . . . . . . BinaryExpr (
    3:  9: . . . . . . . . . . . . . UnaryExpr (
    3:  9: . . . . . . . . . . . . . . PrimaryExpr (
    3:  9: . . . . . . . . . . . . . . . Operand (
    3:  9: . . . . . . . . . . . . . . . . "("
    3: 10: . . . . . . . . . . . . . . . . Expression (
    3: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    3: 11: . . . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . "..."
    3: 14: . . . . . . . . . . . . . . . . ")"
    3: 15: . . . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: true}
    3: 15: . . . . . . . . . . )
    3: 15: . . . . . . . . . )
    3: 15: . . . . . . . . )
    3: 15: . . . . . . . )
    3: 15: . . . . . . )
    3: 15: . . . . . )
    3: 15: . . . . )
    3: 15: . . . . ";"
    3: 16: . . . )
    3: 16: . . )
    3: 16: . )
    3: 16: )
=== RUN   TestFromNofmt/exists
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/exists
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . ","
    1: 10: . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ","
    1: 13: . . . . . . . . . . . . Expression (
    1: 13: . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . ","
    1: 16: . . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . ","
    1: 19: . . . . . . . . . . . . Expression (
    1: 19: . . . . . . . . . . . . . BinaryExpr (
    1: 19: . . . . . . . . . . . . . . UnaryExpr (
    1: 19: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 19: . . . . . . . . . . . . . . . . Operand (
    1: 19: . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    1: 20: . . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . ","
    1: 22: . . . . . . . . . . . . Expression (
    1: 22: . . . . . . . . . . . . . BinaryExpr (
    1: 22: . . . . . . . . . . . . . . UnaryExpr (
    1: 22: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 22: . . . . . . . . . . . . . . . . Operand (
    1: 22: . . . . . . . . . . . . . . . . . INT 19
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 19}
    1: 24: . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . "]"
    1: 25: . . . . . . . . . . . )
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT hasEven
 /app/parser/parser.go:713: ast.Ident{Name: hasEven}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . )
    2:  9: . . . . . . . . )
    2:  9: . . . . . . . )
    2:  9: . . . . . . )
    2:  9: . . . . . )
    2:  9: . . . . . ":="
    2: 12: . . . . . ExpressionList (
    2: 12: . . . . . . Expression (
    2: 12: . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . LiteralValue (
    2: 12: . . . . . . . . . . . . "{"
    2: 13: . . . . . . . . . . . . ElementList (
    2: 13: . . . . . . . . . . . . . ForPhrase (
    2: 13: . . . . . . . . . . . . . . "for"
    2: 17: . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 19: . . . . . . . . . . . . . . "<-"
    2: 22: . . . . . . . . . . . . . . Expression (
    2: 22: . . . . . . . . . . . . . . . RangeExpr (
    2: 22: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . . Operand (
    2: 22: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 24: . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . "if"
    2: 27: . . . . . . . . . . . . . . SimpleStmt (
    2: 27: . . . . . . . . . . . . . . . ExpressionList (
    2: 27: . . . . . . . . . . . . . . . . Expression (
    2: 27: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 27: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 28: . . . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . "%"
    2: 29: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 29: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 31: . . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . "=="
    2: 34: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 34: . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    2: 35: . . . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . "}"
    2: 36: . . . . . . . . . . . )
    2: 36: . . . . . . . . . . )
    2: 36: . . . . . . . . . )
    2: 36: . . . . . . . . )
    2: 36: . . . . . . . )
    2: 36: . . . . . . )
    2: 36: . . . . . )
    2: 36: . . . . )
    2: 36: . . . . ";"
    2: 37: . . . )
    2: 37: . . )
    2: 37: . )
    2: 37: )
=== RUN   TestFromNofmt/forloop
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/forloop
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . )
    1:  7: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . ForStmt (
    2:  1: . . . . . "for"
    2:  5: . . . . . "range"
    2: 11: . . . . . Expression (
    2: 11: . . . . . . RangeExpr (
    2: 11: . . . . . . . BinaryExpr (
    2: 11: . . . . . . . . UnaryExpr (
    2: 11: . . . . . . . . . PrimaryExpr (
    2: 11: . . . . . . . . . . Operand (
    2: 11: . . . . . . . . . . . ArrayType (
    2: 11: . . . . . . . . . . . . "["
    2: 12: . . . . . . . . . . . . Expression (
    2: 12: . . . . . . . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 13: . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . ","
    2: 15: . . . . . . . . . . . . Expression (
    2: 15: . . . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2: 16: . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . ","
    2: 18: . . . . . . . . . . . . Expression (
    2: 18: . . . . . . . . . . . . . BinaryExpr (
    2: 18: . . . . . . . . . . . . . . UnaryExpr (
    2: 18: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 18: . . . . . . . . . . . . . . . . Operand (
    2: 18: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    2: 19: . . . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . ","
    2: 21: . . . . . . . . . . . . Expression (
    2: 21: . . . . . . . . . . . . . BinaryExpr (
    2: 21: . . . . . . . . . . . . . . UnaryExpr (
    2: 21: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 21: . . . . . . . . . . . . . . . . Operand (
    2: 21: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    2: 22: . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . ","
    2: 24: . . . . . . . . . . . . Expression (
    2: 24: . . . . . . . . . . . . . BinaryExpr (
    2: 24: . . . . . . . . . . . . . . UnaryExpr (
    2: 24: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 24: . . . . . . . . . . . . . . . . Operand (
    2: 24: . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    2: 26: . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . "]"
    2: 28: . . . . . . . . . . . )
    2: 28: . . . . . . . . . . )
    2: 28: . . . . . . . . . )
    2: 28: . . . . . . . . )
    2: 28: . . . . . . . )
    2: 28: . . . . . . )
    2: 28: . . . . . )
    2: 28: . . . . . BlockStmt (
    2: 28: . . . . . . "{"
    3:  2: . . . . . . StatementList (
    3:  2: . . . . . . . Statement (
    3:  2: . . . . . . . . SimpleStmt (
    3:  2: . . . . . . . . . ExpressionList (
    3:  2: . . . . . . . . . . Expression (
    3:  2: . . . . . . . . . . . BinaryExpr (
    3:  2: . . . . . . . . . . . . UnaryExpr (
    3:  2: . . . . . . . . . . . . . PrimaryExpr (
    3:  2: . . . . . . . . . . . . . . Operand (
    3:  2: . . . . . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    3:  3: . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . )
    3:  3: . . . . . . . . . . )
    3:  3: . . . . . . . . . )
    3:  3: . . . . . . . . . "++"
    3:  5: . . . . . . . . )
    3:  5: . . . . . . . . ";"
    4:  1: . . . . . . . )
    4:  1: . . . . . . )
    4:  1: . . . . . . "}"
    4:  2: . . . . . )
    4:  2: . . . . . ";"
    5:  1: . . . . )
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  8: . . . . . . . . . . )
    5:  8: . . . . . . . . . . CallOrConversion (
    5:  8: . . . . . . . . . . . "("
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . STRING "n:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "n:"}
    5: 13: . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . ","
    5: 15: . . . . . . . . . . . Expression (
    5: 15: . . . . . . . . . . . . BinaryExpr (
    5: 15: . . . . . . . . . . . . . UnaryExpr (
    5: 15: . . . . . . . . . . . . . . PrimaryExpr (
    5: 15: . . . . . . . . . . . . . . . Operand (
    5: 15: . . . . . . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    5: 16: . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 17: . . . . . . . . . . )
    5: 17: . . . . . . . . . )
    5: 17: . . . . . . . . )
    5: 17: . . . . . . . )
    5: 17: . . . . . . )
    5: 17: . . . . . )
    5: 17: . . . . )
    5: 17: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . ForStmt (
    7:  1: . . . . . "for"
    7:  5: . . . . . SimpleStmt (
    7:  5: . . . . . . ExpressionList (
    7:  5: . . . . . . . Expression (
    7:  5: . . . . . . . . BinaryExpr (
    7:  5: . . . . . . . . . UnaryExpr (
    7:  5: . . . . . . . . . . PrimaryExpr (
    7:  5: . . . . . . . . . . . Operand (
    7:  5: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  7: . . . . . . . . . . . )
    7:  7: . . . . . . . . . . )
    7:  7: . . . . . . . . . )
    7:  7: . . . . . . . . )
    7:  7: . . . . . . . )
    7:  7: . . . . . . )
    7:  7: . . . . . . ":="
    7: 10: . . . . . . "range"
    7: 16: . . . . . . Expression (
    7: 16: . . . . . . . RangeExpr (
    7: 16: . . . . . . . . BinaryExpr (
    7: 16: . . . . . . . . . UnaryExpr (
    7: 16: . . . . . . . . . . PrimaryExpr (
    7: 16: . . . . . . . . . . . Operand (
    7: 16: . . . . . . . . . . . . ArrayType (
    7: 16: . . . . . . . . . . . . . "["
    7: 17: . . . . . . . . . . . . . Expression (
    7: 17: . . . . . . . . . . . . . . BinaryExpr (
    7: 17: . . . . . . . . . . . . . . . UnaryExpr (
    7: 17: . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 17: . . . . . . . . . . . . . . . . . Operand (
    7: 17: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 18: . . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00044e4e0]}
    7: 20: . . . . . . . . . . . . )
    7: 20: . . . . . . . . . . . )
    7: 20: . . . . . . . . . . )
    7: 20: . . . . . . . . . )
    7: 20: . . . . . . . . )
    7: 20: . . . . . . . )
    7: 20: . . . . . . )
    7: 20: . . . . . )
    7: 20: . . . . . BlockStmt (
    7: 20: . . . . . . "{"
    8:  1: . . . . . . StatementList (
    8:  1: . . . . . . )
    8:  1: . . . . . . "}"
    8:  2: . . . . . )
    8:  2: . . . . . ";"
   10:  1: . . . . )
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   10:  5: . . . . . . . . . . )
   10:  5: . . . . . . . . . )
   10:  5: . . . . . . . . )
   10:  5: . . . . . . . )
   10:  5: . . . . . . )
   10:  5: . . . . . )
   10:  5: . . . . . ":="
   10:  8: . . . . . ExpressionList (
   10:  8: . . . . . . Expression (
   10:  8: . . . . . . . BinaryExpr (
   10:  8: . . . . . . . . UnaryExpr (
   10:  8: . . . . . . . . . PrimaryExpr (
   10:  8: . . . . . . . . . . Operand (
   10:  8: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   10:  9: . . . . . . . . . . )
   10:  9: . . . . . . . . . )
   10:  9: . . . . . . . . )
   10:  9: . . . . . . . )
   10:  9: . . . . . . )
   10:  9: . . . . . )
   10:  9: . . . . )
   10:  9: . . . . ";"
   11:  1: . . . )
   11:  1: . . . Statement (
   11:  1: . . . . ForStmt (
   11:  1: . . . . . "for"
   11:  5: . . . . . SimpleStmt (
   11:  5: . . . . . . ExpressionList (
   11:  5: . . . . . . . Expression (
   11:  5: . . . . . . . . BinaryExpr (
   11:  5: . . . . . . . . . UnaryExpr (
   11:  5: . . . . . . . . . . PrimaryExpr (
   11:  5: . . . . . . . . . . . Operand (
   11:  5: . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
   11:  6: . . . . . . . . . . . )
   11:  6: . . . . . . . . . . )
   11:  6: . . . . . . . . . )
   11:  6: . . . . . . . . )
   11:  6: . . . . . . . )
   11:  6: . . . . . . . ","
   11:  8: . . . . . . . Expression (
   11:  8: . . . . . . . . BinaryExpr (
   11:  8: . . . . . . . . . UnaryExpr (
   11:  8: . . . . . . . . . . PrimaryExpr (
   11:  8: . . . . . . . . . . . Operand (
   11:  8: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 10: . . . . . . . . . . . )
   11: 10: . . . . . . . . . . )
   11: 10: . . . . . . . . . )
   11: 10: . . . . . . . . )
   11: 10: . . . . . . . )
   11: 10: . . . . . . )
   11: 10: . . . . . . ":="
   11: 13: . . . . . . "range"
   11: 19: . . . . . . Expression (
   11: 19: . . . . . . . RangeExpr (
   11: 19: . . . . . . . . BinaryExpr (
   11: 19: . . . . . . . . . UnaryExpr (
   11: 19: . . . . . . . . . . PrimaryExpr (
   11: 19: . . . . . . . . . . . Operand (
   11: 19: . . . . . . . . . . . . ArrayType (
   11: 19: . . . . . . . . . . . . . "["
   11: 20: . . . . . . . . . . . . . Expression (
   11: 20: . . . . . . . . . . . . . . BinaryExpr (
   11: 20: . . . . . . . . . . . . . . . UnaryExpr (
   11: 20: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 20: . . . . . . . . . . . . . . . . . Operand (
   11: 20: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   11: 21: . . . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . ","
   11: 23: . . . . . . . . . . . . . Expression (
   11: 23: . . . . . . . . . . . . . . BinaryExpr (
   11: 23: . . . . . . . . . . . . . . . UnaryExpr (
   11: 23: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 23: . . . . . . . . . . . . . . . . . Operand (
   11: 23: . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   11: 24: . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . ","
   11: 26: . . . . . . . . . . . . . Expression (
   11: 26: . . . . . . . . . . . . . . BinaryExpr (
   11: 26: . . . . . . . . . . . . . . . UnaryExpr (
   11: 26: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 26: . . . . . . . . . . . . . . . . . Operand (
   11: 26: . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   11: 27: . . . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . ","
   11: 29: . . . . . . . . . . . . . Expression (
   11: 29: . . . . . . . . . . . . . . BinaryExpr (
   11: 29: . . . . . . . . . . . . . . . UnaryExpr (
   11: 29: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 29: . . . . . . . . . . . . . . . . . Operand (
   11: 29: . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
   11: 30: . . . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . ","
   11: 32: . . . . . . . . . . . . . Expression (
   11: 32: . . . . . . . . . . . . . . BinaryExpr (
   11: 32: . . . . . . . . . . . . . . . UnaryExpr (
   11: 32: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 32: . . . . . . . . . . . . . . . . . Operand (
   11: 32: . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
   11: 34: . . . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . "]"
   11: 36: . . . . . . . . . . . . )
   11: 36: . . . . . . . . . . . )
   11: 36: . . . . . . . . . . )
   11: 36: . . . . . . . . . )
   11: 36: . . . . . . . . )
   11: 36: . . . . . . . )
   11: 36: . . . . . . )
   11: 36: . . . . . )
   11: 36: . . . . . BlockStmt (
   11: 36: . . . . . . "{"
   12:  2: . . . . . . StatementList (
   12:  2: . . . . . . . Statement (
   12:  2: . . . . . . . . IfStmt (
   12:  2: . . . . . . . . . "if"
   12:  5: . . . . . . . . . SimpleStmt (
   12:  5: . . . . . . . . . . ExpressionList (
   12:  5: . . . . . . . . . . . Expression (
   12:  5: . . . . . . . . . . . . BinaryExpr (
   12:  5: . . . . . . . . . . . . . UnaryExpr (
   12:  5: . . . . . . . . . . . . . . PrimaryExpr (
   12:  5: . . . . . . . . . . . . . . . Operand (
   12:  5: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   12:  7: . . . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . ">"
   12:  9: . . . . . . . . . . . . . BinaryExpr (
   12:  9: . . . . . . . . . . . . . . UnaryExpr (
   12:  9: . . . . . . . . . . . . . . . PrimaryExpr (
   12:  9: . . . . . . . . . . . . . . . . Operand (
   12:  9: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   12: 11: . . . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . )
   12: 11: . . . . . . . . . . )
   12: 11: . . . . . . . . . )
   12: 11: . . . . . . . . . BlockStmt (
   12: 11: . . . . . . . . . . "{"
   13:  3: . . . . . . . . . . StatementList (
   13:  3: . . . . . . . . . . . Statement (
   13:  3: . . . . . . . . . . . . SimpleStmt (
   13:  3: . . . . . . . . . . . . . ExpressionList (
   13:  3: . . . . . . . . . . . . . . Expression (
   13:  3: . . . . . . . . . . . . . . . BinaryExpr (
   13:  3: . . . . . . . . . . . . . . . . UnaryExpr (
   13:  3: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  3: . . . . . . . . . . . . . . . . . . Operand (
   13:  3: . . . . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   13:  7: . . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . "+="
   13: 10: . . . . . . . . . . . . . ExpressionList (
   13: 10: . . . . . . . . . . . . . . Expression (
   13: 10: . . . . . . . . . . . . . . . BinaryExpr (
   13: 10: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . . Operand (
   13: 10: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   13: 11: . . . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . ";"
   14:  2: . . . . . . . . . . . )
   14:  2: . . . . . . . . . . )
   14:  2: . . . . . . . . . . "}"
   14:  3: . . . . . . . . . )
   14:  3: . . . . . . . . . ";"
   15:  1: . . . . . . . . )
   15:  1: . . . . . . . )
   15:  1: . . . . . . )
   15:  1: . . . . . . "}"
   15:  2: . . . . . )
   15:  2: . . . . . ";"
   16:  1: . . . . )
   16:  1: . . . )
   16:  1: . . . Statement (
   16:  1: . . . . SimpleStmt (
   16:  1: . . . . . ExpressionList (
   16:  1: . . . . . . Expression (
   16:  1: . . . . . . . BinaryExpr (
   16:  1: . . . . . . . . UnaryExpr (
   16:  1: . . . . . . . . . PrimaryExpr (
   16:  1: . . . . . . . . . . Operand (
   16:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   16:  8: . . . . . . . . . . )
   16:  8: . . . . . . . . . . CallOrConversion (
   16:  8: . . . . . . . . . . . "("
   16:  9: . . . . . . . . . . . Expression (
   16:  9: . . . . . . . . . . . . BinaryExpr (
   16:  9: . . . . . . . . . . . . . UnaryExpr (
   16:  9: . . . . . . . . . . . . . . PrimaryExpr (
   16:  9: . . . . . . . . . . . . . . . Operand (
   16:  9: . . . . . . . . . . . . . . . . STRING "sum(1,3,5,7,11):"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "sum(1,3,5,7,11):"}
   16: 27: . . . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . ","
   16: 29: . . . . . . . . . . . Expression (
   16: 29: . . . . . . . . . . . . BinaryExpr (
   16: 29: . . . . . . . . . . . . . UnaryExpr (
   16: 29: . . . . . . . . . . . . . . PrimaryExpr (
   16: 29: . . . . . . . . . . . . . . . Operand (
   16: 29: . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   16: 32: . . . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   16: 33: . . . . . . . . . . )
   16: 33: . . . . . . . . . )
   16: 33: . . . . . . . . )
   16: 33: . . . . . . . )
   16: 33: . . . . . . )
   16: 33: . . . . . )
   16: 33: . . . . )
   16: 33: . . . . ";"
   18:  1: . . . )
   18:  1: . . . Statement (
   18:  1: . . . . SimpleStmt (
   18:  1: . . . . . ExpressionList (
   18:  1: . . . . . . Expression (
   18:  1: . . . . . . . BinaryExpr (
   18:  1: . . . . . . . . UnaryExpr (
   18:  1: . . . . . . . . . PrimaryExpr (
   18:  1: . . . . . . . . . . Operand (
   18:  1: . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   18:  5: . . . . . . . . . . )
   18:  5: . . . . . . . . . )
   18:  5: . . . . . . . . )
   18:  5: . . . . . . . )
   18:  5: . . . . . . )
   18:  5: . . . . . )
   18:  5: . . . . . "="
   18:  7: . . . . . ExpressionList (
   18:  7: . . . . . . Expression (
   18:  7: . . . . . . . BinaryExpr (
   18:  7: . . . . . . . . UnaryExpr (
   18:  7: . . . . . . . . . PrimaryExpr (
   18:  7: . . . . . . . . . . Operand (
   18:  7: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   18:  8: . . . . . . . . . . )
   18:  8: . . . . . . . . . )
   18:  8: . . . . . . . . )
   18:  8: . . . . . . . )
   18:  8: . . . . . . )
   18:  8: . . . . . )
   18:  8: . . . . )
   18:  8: . . . . ";"
   19:  1: . . . )
   19:  1: . . . Statement (
   19:  1: . . . . ForStmt (
   19:  1: . . . . . "for"
   19:  5: . . . . . SimpleStmt (
   19:  5: . . . . . . ExpressionList (
   19:  5: . . . . . . . Expression (
   19:  5: . . . . . . . . BinaryExpr (
   19:  5: . . . . . . . . . UnaryExpr (
   19:  5: . . . . . . . . . . PrimaryExpr (
   19:  5: . . . . . . . . . . . Operand (
   19:  5: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19:  7: . . . . . . . . . . . )
   19:  7: . . . . . . . . . . )
   19:  7: . . . . . . . . . )
   19:  7: . . . . . . . . )
   19:  7: . . . . . . . )
   19:  7: . . . . . . )
   19:  7: . . . . . . ":="
   19: 10: . . . . . . ExpressionList (
   19: 10: . . . . . . . Expression (
   19: 10: . . . . . . . . BinaryExpr (
   19: 10: . . . . . . . . . UnaryExpr (
   19: 10: . . . . . . . . . . PrimaryExpr (
   19: 10: . . . . . . . . . . . Operand (
   19: 10: . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   19: 11: . . . . . . . . . . . )
   19: 11: . . . . . . . . . . )
   19: 11: . . . . . . . . . )
   19: 11: . . . . . . . . )
   19: 11: . . . . . . . )
   19: 11: . . . . . . )
   19: 11: . . . . . )
   19: 11: . . . . . ";"
   19: 13: . . . . . SimpleStmt (
   19: 13: . . . . . . ExpressionList (
   19: 13: . . . . . . . Expression (
   19: 13: . . . . . . . . BinaryExpr (
   19: 13: . . . . . . . . . UnaryExpr (
   19: 13: . . . . . . . . . . PrimaryExpr (
   19: 13: . . . . . . . . . . . Operand (
   19: 13: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19: 15: . . . . . . . . . . . )
   19: 15: . . . . . . . . . . )
   19: 15: . . . . . . . . . )
   19: 15: . . . . . . . . . "<"
   19: 17: . . . . . . . . . BinaryExpr (
   19: 17: . . . . . . . . . . UnaryExpr (
   19: 17: . . . . . . . . . . . PrimaryExpr (
   19: 17: . . . . . . . . . . . . Operand (
   19: 17: . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
   19: 20: . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . )
   19: 20: . . . . . . . . . . )
   19: 20: . . . . . . . . . )
   19: 20: . . . . . . . . )
   19: 20: . . . . . . . )
   19: 20: . . . . . . )
   19: 20: . . . . . )
   19: 20: . . . . . ";"
   19: 22: . . . . . SimpleStmt (
   19: 22: . . . . . . ExpressionList (
   19: 22: . . . . . . . Expression (
   19: 22: . . . . . . . . BinaryExpr (
   19: 22: . . . . . . . . . UnaryExpr (
   19: 22: . . . . . . . . . . PrimaryExpr (
   19: 22: . . . . . . . . . . . Operand (
   19: 22: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19: 23: . . . . . . . . . . . )
   19: 23: . . . . . . . . . . )
   19: 23: . . . . . . . . . )
   19: 23: . . . . . . . . )
   19: 23: . . . . . . . )
   19: 23: . . . . . . )
   19: 23: . . . . . . "++"
   19: 26: . . . . . )
   19: 26: . . . . . BlockStmt (
   19: 26: . . . . . . "{"
   20:  2: . . . . . . StatementList (
   20:  2: . . . . . . . Statement (
   20:  2: . . . . . . . . SimpleStmt (
   20:  2: . . . . . . . . . ExpressionList (
   20:  2: . . . . . . . . . . Expression (
   20:  2: . . . . . . . . . . . BinaryExpr (
   20:  2: . . . . . . . . . . . . UnaryExpr (
   20:  2: . . . . . . . . . . . . . PrimaryExpr (
   20:  2: . . . . . . . . . . . . . . Operand (
   20:  2: . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   20:  6: . . . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . )
   20:  6: . . . . . . . . . . )
   20:  6: . . . . . . . . . )
   20:  6: . . . . . . . . . "+="
   20:  9: . . . . . . . . . ExpressionList (
   20:  9: . . . . . . . . . . Expression (
   20:  9: . . . . . . . . . . . BinaryExpr (
   20:  9: . . . . . . . . . . . . UnaryExpr (
   20:  9: . . . . . . . . . . . . . PrimaryExpr (
   20:  9: . . . . . . . . . . . . . . Operand (
   20:  9: . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   20: 10: . . . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . )
   20: 10: . . . . . . . . . . )
   20: 10: . . . . . . . . . )
   20: 10: . . . . . . . . )
   20: 10: . . . . . . . . ";"
   21:  1: . . . . . . . )
   21:  1: . . . . . . )
   21:  1: . . . . . . "}"
   21:  2: . . . . . )
   21:  2: . . . . . ";"
   22:  1: . . . . )
   22:  1: . . . )
   22:  1: . . . Statement (
   22:  1: . . . . SimpleStmt (
   22:  1: . . . . . ExpressionList (
   22:  1: . . . . . . Expression (
   22:  1: . . . . . . . BinaryExpr (
   22:  1: . . . . . . . . UnaryExpr (
   22:  1: . . . . . . . . . PrimaryExpr (
   22:  1: . . . . . . . . . . Operand (
   22:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   22:  8: . . . . . . . . . . )
   22:  8: . . . . . . . . . . CallOrConversion (
   22:  8: . . . . . . . . . . . "("
   22:  9: . . . . . . . . . . . Expression (
   22:  9: . . . . . . . . . . . . BinaryExpr (
   22:  9: . . . . . . . . . . . . . UnaryExpr (
   22:  9: . . . . . . . . . . . . . . PrimaryExpr (
   22:  9: . . . . . . . . . . . . . . . Operand (
   22:  9: . . . . . . . . . . . . . . . . STRING "sum(1-100):"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "sum(1-100):"}
   22: 22: . . . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . ","
   22: 24: . . . . . . . . . . . Expression (
   22: 24: . . . . . . . . . . . . BinaryExpr (
   22: 24: . . . . . . . . . . . . . UnaryExpr (
   22: 24: . . . . . . . . . . . . . . PrimaryExpr (
   22: 24: . . . . . . . . . . . . . . . Operand (
   22: 24: . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   22: 27: . . . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   22: 28: . . . . . . . . . . )
   22: 28: . . . . . . . . . )
   22: 28: . . . . . . . . )
   22: 28: . . . . . . . )
   22: 28: . . . . . . )
   22: 28: . . . . . )
   22: 28: . . . . )
   22: 28: . . . . ";"
   24:  1: . . . )
   24:  1: . . . Statement (
   24:  1: . . . . ForStmt (
   24:  1: . . . . . "for"
   24:  5: . . . . . SimpleStmt (
   24:  5: . . . . . . ExpressionList (
   24:  5: . . . . . . . Expression (
   24:  5: . . . . . . . . BinaryExpr (
   24:  5: . . . . . . . . . UnaryExpr (
   24:  5: . . . . . . . . . . PrimaryExpr (
   24:  5: . . . . . . . . . . . Operand (
   24:  5: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   24:  7: . . . . . . . . . . . )
   24:  7: . . . . . . . . . . )
   24:  7: . . . . . . . . . )
   24:  7: . . . . . . . . )
   24:  7: . . . . . . . )
   24:  7: . . . . . . )
   24:  7: . . . . . . "<-"
   24: 10: . . . . . . Expression (
   24: 10: . . . . . . . RangeExpr (
   24: 10: . . . . . . . . BinaryExpr (
   24: 10: . . . . . . . . . UnaryExpr (
   24: 10: . . . . . . . . . . PrimaryExpr (
   24: 10: . . . . . . . . . . . Operand (
   24: 10: . . . . . . . . . . . . ArrayType (
   24: 10: . . . . . . . . . . . . . "["
   24: 11: . . . . . . . . . . . . . Expression (
   24: 11: . . . . . . . . . . . . . . BinaryExpr (
   24: 11: . . . . . . . . . . . . . . . UnaryExpr (
   24: 11: . . . . . . . . . . . . . . . . PrimaryExpr (
   24: 11: . . . . . . . . . . . . . . . . . Operand (
   24: 11: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   24: 12: . . . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00044ea50]}
   24: 14: . . . . . . . . . . . . )
   24: 14: . . . . . . . . . . . )
   24: 14: . . . . . . . . . . )
   24: 14: . . . . . . . . . )
   24: 14: . . . . . . . . )
   24: 14: . . . . . . . )
   24: 14: . . . . . . )
   24: 14: . . . . . )
   24: 14: . . . . . BlockStmt (
   24: 14: . . . . . . "{"
   25:  2: . . . . . . StatementList (
   25:  2: . . . . . . . Statement (
   25:  2: . . . . . . . . SimpleStmt (
   25:  2: . . . . . . . . . ExpressionList (
   25:  2: . . . . . . . . . . Expression (
   25:  2: . . . . . . . . . . . BinaryExpr (
   25:  2: . . . . . . . . . . . . UnaryExpr (
   25:  2: . . . . . . . . . . . . . PrimaryExpr (
   25:  2: . . . . . . . . . . . . . . Operand (
   25:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   25:  9: . . . . . . . . . . . . . . )
   25:  9: . . . . . . . . . . . . . . CallOrConversion (
   25:  9: . . . . . . . . . . . . . . . "("
   25: 10: . . . . . . . . . . . . . . . Expression (
   25: 10: . . . . . . . . . . . . . . . . BinaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . . . Operand (
   25: 10: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   25: 11: . . . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   25: 12: . . . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . )
   25: 12: . . . . . . . . . . )
   25: 12: . . . . . . . . . )
   25: 12: . . . . . . . . )
   25: 12: . . . . . . . . ";"
   26:  1: . . . . . . . )
   26:  1: . . . . . . )
   26:  1: . . . . . . "}"
   26:  2: . . . . . )
   26:  2: . . . . . ";"
   28:  1: . . . . )
   28:  1: . . . )
   28:  1: . . . Statement (
   28:  1: . . . . ForStmt (
   28:  1: . . . . . "for"
   28:  5: . . . . . SimpleStmt (
   28:  5: . . . . . . ExpressionList (
   28:  5: . . . . . . . Expression (
   28:  5: . . . . . . . . BinaryExpr (
   28:  5: . . . . . . . . . UnaryExpr (
   28:  5: . . . . . . . . . . PrimaryExpr (
   28:  5: . . . . . . . . . . . Operand (
   28:  5: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   28:  6: . . . . . . . . . . . )
   28:  6: . . . . . . . . . . )
   28:  6: . . . . . . . . . )
   28:  6: . . . . . . . . )
   28:  6: . . . . . . . )
   28:  6: . . . . . . . ","
   28:  8: . . . . . . . Expression (
   28:  8: . . . . . . . . BinaryExpr (
   28:  8: . . . . . . . . . UnaryExpr (
   28:  8: . . . . . . . . . . PrimaryExpr (
   28:  8: . . . . . . . . . . . Operand (
   28:  8: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   28: 10: . . . . . . . . . . . )
   28: 10: . . . . . . . . . . )
   28: 10: . . . . . . . . . )
   28: 10: . . . . . . . . )
   28: 10: . . . . . . . )
   28: 10: . . . . . . )
   28: 10: . . . . . . "<-"
   28: 13: . . . . . . Expression (
   28: 13: . . . . . . . RangeExpr (
   28: 13: . . . . . . . . BinaryExpr (
   28: 13: . . . . . . . . . UnaryExpr (
   28: 13: . . . . . . . . . . PrimaryExpr (
   28: 13: . . . . . . . . . . . Operand (
   28: 13: . . . . . . . . . . . . ArrayType (
   28: 13: . . . . . . . . . . . . . "["
   28: 14: . . . . . . . . . . . . . Expression (
   28: 14: . . . . . . . . . . . . . . BinaryExpr (
   28: 14: . . . . . . . . . . . . . . . UnaryExpr (
   28: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   28: 14: . . . . . . . . . . . . . . . . . Operand (
   28: 14: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   28: 15: . . . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00044eb40]}
   28: 17: . . . . . . . . . . . . )
   28: 17: . . . . . . . . . . . )
   28: 17: . . . . . . . . . . )
   28: 17: . . . . . . . . . )
   28: 17: . . . . . . . . )
   28: 17: . . . . . . . )
   28: 17: . . . . . . )
   28: 17: . . . . . . "if"
   28: 20: . . . . . . Expression (
   28: 20: . . . . . . . BinaryExpr (
   28: 20: . . . . . . . . UnaryExpr (
   28: 20: . . . . . . . . . PrimaryExpr (
   28: 20: . . . . . . . . . . Operand (
   28: 20: . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   28: 21: . . . . . . . . . . )
   28: 21: . . . . . . . . . )
   28: 21: . . . . . . . . )
   28: 21: . . . . . . . . "%"
   28: 22: . . . . . . . . BinaryExpr (
   28: 22: . . . . . . . . . UnaryExpr (
   28: 22: . . . . . . . . . . PrimaryExpr (
   28: 22: . . . . . . . . . . . Operand (
   28: 22: . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   28: 24: . . . . . . . . . . . )
   28: 24: . . . . . . . . . . )
   28: 24: . . . . . . . . . )
   28: 24: . . . . . . . . )
   28: 24: . . . . . . . . "=="
   28: 27: . . . . . . . . BinaryExpr (
   28: 27: . . . . . . . . . UnaryExpr (
   28: 27: . . . . . . . . . . PrimaryExpr (
   28: 27: . . . . . . . . . . . Operand (
   28: 27: . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   28: 29: . . . . . . . . . . . )
   28: 29: . . . . . . . . . . )
   28: 29: . . . . . . . . . )
   28: 29: . . . . . . . . )
   28: 29: . . . . . . . )
   28: 29: . . . . . . )
   28: 29: . . . . . )
   28: 29: . . . . . BlockStmt (
   28: 29: . . . . . . "{"
   29:  2: . . . . . . StatementList (
   29:  2: . . . . . . . Statement (
   29:  2: . . . . . . . . SimpleStmt (
   29:  2: . . . . . . . . . ExpressionList (
   29:  2: . . . . . . . . . . Expression (
   29:  2: . . . . . . . . . . . BinaryExpr (
   29:  2: . . . . . . . . . . . . UnaryExpr (
   29:  2: . . . . . . . . . . . . . PrimaryExpr (
   29:  2: . . . . . . . . . . . . . . Operand (
   29:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   29:  9: . . . . . . . . . . . . . . )
   29:  9: . . . . . . . . . . . . . . CallOrConversion (
   29:  9: . . . . . . . . . . . . . . . "("
   29: 10: . . . . . . . . . . . . . . . Expression (
   29: 10: . . . . . . . . . . . . . . . . BinaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . . . Operand (
   29: 10: . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   29: 11: . . . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . ","
   29: 13: . . . . . . . . . . . . . . . Expression (
   29: 13: . . . . . . . . . . . . . . . . BinaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . UnaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . . . Operand (
   29: 13: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   29: 14: . . . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   29: 15: . . . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . )
   29: 15: . . . . . . . . . . )
   29: 15: . . . . . . . . . )
   29: 15: . . . . . . . . )
   29: 15: . . . . . . . . ";"
   30:  1: . . . . . . . )
   30:  1: . . . . . . )
   30:  1: . . . . . . "}"
   30:  2: . . . . . )
   30:  2: . . . . . ";"
   30:  3: . . . . )
   30:  3: . . . )
   30:  3: . . )
   30:  3: . )
   30:  3: )
=== RUN   TestFromNofmt/listcompr
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/listcompr
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . "*"
    1:  9: . . . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 11: . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ForPhrase (
    1: 11: . . . . . . . . . . . . . "for"
    1: 15: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 17: . . . . . . . . . . . . . "<-"
    1: 20: . . . . . . . . . . . . . Expression (
    1: 20: . . . . . . . . . . . . . . RangeExpr (
    1: 20: . . . . . . . . . . . . . . . BinaryExpr (
    1: 20: . . . . . . . . . . . . . . . . UnaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . . Operand (
    1: 20: . . . . . . . . . . . . . . . . . . . ArrayType (
    1: 20: . . . . . . . . . . . . . . . . . . . . "["
    1: 21: . . . . . . . . . . . . . . . . . . . . Expression (
    1: 21: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 22: . . . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00044e120]}
    1: 23: . . . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{x 8 * x}, Fors: [0xc000462240]}
    1: 24: . . . . . . . . . . . )
    1: 24: . . . . . . . . . . )
    1: 24: . . . . . . . . . )
    1: 24: . . . . . . . . )
    1: 24: . . . . . . . )
    1: 24: . . . . . . )
    1: 24: . . . . . )
    1: 24: . . . . )
    1: 24: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  8: . . . . . . . . . . )
    2:  8: . . . . . . . . . . CallOrConversion (
    2:  8: . . . . . . . . . . . "("
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2: 10: . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    2: 11: . . . . . . . . . . )
    2: 11: . . . . . . . . . )
    2: 11: . . . . . . . . )
    2: 11: . . . . . . . )
    2: 11: . . . . . . )
    2: 11: . . . . . )
    2: 11: . . . . )
    2: 11: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    4:  3: . . . . . . . . . . )
    4:  3: . . . . . . . . . )
    4:  3: . . . . . . . . )
    4:  3: . . . . . . . )
    4:  3: . . . . . . )
    4:  3: . . . . . )
    4:  3: . . . . . "="
    4:  5: . . . . . ExpressionList (
    4:  5: . . . . . . Expression (
    4:  5: . . . . . . . BinaryExpr (
    4:  5: . . . . . . . . UnaryExpr (
    4:  5: . . . . . . . . . PrimaryExpr (
    4:  5: . . . . . . . . . . Operand (
    4:  5: . . . . . . . . . . . ArrayType (
    4:  5: . . . . . . . . . . . . "["
    4:  6: . . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4:  7: . . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . "*"
    4:  8: . . . . . . . . . . . . . . BinaryExpr (
    4:  8: . . . . . . . . . . . . . . . UnaryExpr (
    4:  8: . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  8: . . . . . . . . . . . . . . . . . Operand (
    4:  8: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 10: . . . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . ForPhrase (
    4: 10: . . . . . . . . . . . . . "for"
    4: 14: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 16: . . . . . . . . . . . . . "<-"
    4: 19: . . . . . . . . . . . . . Expression (
    4: 19: . . . . . . . . . . . . . . RangeExpr (
    4: 19: . . . . . . . . . . . . . . . BinaryExpr (
    4: 19: . . . . . . . . . . . . . . . . UnaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . . Operand (
    4: 19: . . . . . . . . . . . . . . . . . . . ArrayType (
    4: 19: . . . . . . . . . . . . . . . . . . . . "["
    4: 20: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 20: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    4: 21: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . ","
    4: 23: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 23: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    4: 24: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . ","
    4: 26: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 26: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    4: 27: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . ","
    4: 29: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 29: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . ","
    4: 32: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 32: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    4: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . "]"
    4: 36: . . . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . "if"
    4: 39: . . . . . . . . . . . . . SimpleStmt (
    4: 39: . . . . . . . . . . . . . . ExpressionList (
    4: 39: . . . . . . . . . . . . . . . Expression (
    4: 39: . . . . . . . . . . . . . . . . BinaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . . . Operand (
    4: 39: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 41: . . . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . ">"
    4: 43: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 43: . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    4: 44: . . . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{x 43 * x}, Fors: [0xc000462300]}
    4: 45: . . . . . . . . . . . )
    4: 45: . . . . . . . . . . )
    4: 45: . . . . . . . . . )
    4: 45: . . . . . . . . )
    4: 45: . . . . . . . )
    4: 45: . . . . . . )
    4: 45: . . . . . )
    4: 45: . . . . )
    4: 45: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  8: . . . . . . . . . . )
    5:  8: . . . . . . . . . . CallOrConversion (
    5:  8: . . . . . . . . . . . "("
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    5: 10: . . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 11: . . . . . . . . . . )
    5: 11: . . . . . . . . . )
    5: 11: . . . . . . . . )
    5: 11: . . . . . . . )
    5: 11: . . . . . . )
    5: 11: . . . . . )
    5: 11: . . . . )
    5: 11: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . SimpleStmt (
    7:  1: . . . . . ExpressionList (
    7:  1: . . . . . . Expression (
    7:  1: . . . . . . . BinaryExpr (
    7:  1: . . . . . . . . UnaryExpr (
    7:  1: . . . . . . . . . PrimaryExpr (
    7:  1: . . . . . . . . . . Operand (
    7:  1: . . . . . . . . . . . IDENT z
 /app/parser/parser.go:713: ast.Ident{Name: z}
    7:  3: . . . . . . . . . . )
    7:  3: . . . . . . . . . )
    7:  3: . . . . . . . . )
    7:  3: . . . . . . . )
    7:  3: . . . . . . )
    7:  3: . . . . . )
    7:  3: . . . . . ":="
    7:  6: . . . . . ExpressionList (
    7:  6: . . . . . . Expression (
    7:  6: . . . . . . . BinaryExpr (
    7:  6: . . . . . . . . UnaryExpr (
    7:  6: . . . . . . . . . PrimaryExpr (
    7:  6: . . . . . . . . . . Operand (
    7:  6: . . . . . . . . . . . ArrayType (
    7:  6: . . . . . . . . . . . . "["
    7:  7: . . . . . . . . . . . . Expression (
    7:  7: . . . . . . . . . . . . . BinaryExpr (
    7:  7: . . . . . . . . . . . . . . UnaryExpr (
    7:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    7:  7: . . . . . . . . . . . . . . . . Operand (
    7:  7: . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7:  8: . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . "+"
    7:  9: . . . . . . . . . . . . . . BinaryExpr (
    7:  9: . . . . . . . . . . . . . . . UnaryExpr (
    7:  9: . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  9: . . . . . . . . . . . . . . . . . Operand (
    7:  9: . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    7: 11: . . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . ForPhrase (
    7: 11: . . . . . . . . . . . . . "for"
    7: 15: . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7: 16: . . . . . . . . . . . . . ","
    7: 18: . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    7: 20: . . . . . . . . . . . . . "<-"
    7: 23: . . . . . . . . . . . . . Expression (
    7: 23: . . . . . . . . . . . . . . RangeExpr (
    7: 23: . . . . . . . . . . . . . . . BinaryExpr (
    7: 23: . . . . . . . . . . . . . . . . UnaryExpr (
    7: 23: . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 23: . . . . . . . . . . . . . . . . . . Operand (
    7: 23: . . . . . . . . . . . . . . . . . . . ArrayType (
    7: 23: . . . . . . . . . . . . . . . . . . . . "["
    7: 24: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 24: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 25: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . ","
    7: 27: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 27: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    7: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . ","
    7: 30: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 30: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    7: 31: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . ","
    7: 33: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 33: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    7: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . ","
    7: 36: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 36: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    7: 38: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . "]"
    7: 40: . . . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . "if"
    7: 43: . . . . . . . . . . . . . SimpleStmt (
    7: 43: . . . . . . . . . . . . . . ExpressionList (
    7: 43: . . . . . . . . . . . . . . . Expression (
    7: 43: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . . . Operand (
    7: 43: . . . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
    7: 45: . . . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . ":="
    7: 48: . . . . . . . . . . . . . . ExpressionList (
    7: 48: . . . . . . . . . . . . . . . Expression (
    7: 48: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . . . Operand (
    7: 48: . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7: 50: . . . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . "%"
    7: 52: . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . . . Operand (
    7: 52: . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    7: 53: . . . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . ";"
    7: 55: . . . . . . . . . . . . . SimpleStmt (
    7: 55: . . . . . . . . . . . . . . ExpressionList (
    7: 55: . . . . . . . . . . . . . . . Expression (
    7: 55: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . . . Operand (
    7: 55: . . . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
    7: 57: . . . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . "=="
    7: 60: . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . . . Operand (
    7: 60: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 61: . . . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{i 101 + v}, Fors: [0xc0004623c0]}
    7: 62: . . . . . . . . . . . )
    7: 62: . . . . . . . . . . )
    7: 62: . . . . . . . . . )
    7: 62: . . . . . . . . )
    7: 62: . . . . . . . )
    7: 62: . . . . . . )
    7: 62: . . . . . )
    7: 62: . . . . )
    7: 62: . . . . ";"
    8:  1: . . . )
    8:  1: . . . Statement (
    8:  1: . . . . SimpleStmt (
    8:  1: . . . . . ExpressionList (
    8:  1: . . . . . . Expression (
    8:  1: . . . . . . . BinaryExpr (
    8:  1: . . . . . . . . UnaryExpr (
    8:  1: . . . . . . . . . PrimaryExpr (
    8:  1: . . . . . . . . . . Operand (
    8:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    8:  8: . . . . . . . . . . )
    8:  8: . . . . . . . . . . CallOrConversion (
    8:  8: . . . . . . . . . . . "("
    8:  9: . . . . . . . . . . . Expression (
    8:  9: . . . . . . . . . . . . BinaryExpr (
    8:  9: . . . . . . . . . . . . . UnaryExpr (
    8:  9: . . . . . . . . . . . . . . PrimaryExpr (
    8:  9: . . . . . . . . . . . . . . . Operand (
    8:  9: . . . . . . . . . . . . . . . . IDENT z
 /app/parser/parser.go:713: ast.Ident{Name: z}
    8: 10: . . . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    8: 11: . . . . . . . . . . )
    8: 11: . . . . . . . . . )
    8: 11: . . . . . . . . )
    8: 11: . . . . . . . )
    8: 11: . . . . . . )
    8: 11: . . . . . )
    8: 11: . . . . )
    8: 11: . . . . ";"
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   10:  8: . . . . . . . . . . )
   10:  8: . . . . . . . . . . CallOrConversion (
   10:  8: . . . . . . . . . . . "("
   10:  9: . . . . . . . . . . . Expression (
   10:  9: . . . . . . . . . . . . BinaryExpr (
   10:  9: . . . . . . . . . . . . . UnaryExpr (
   10:  9: . . . . . . . . . . . . . . PrimaryExpr (
   10:  9: . . . . . . . . . . . . . . . Operand (
   10:  9: . . . . . . . . . . . . . . . . ArrayType (
   10:  9: . . . . . . . . . . . . . . . . . "["
   10: 10: . . . . . . . . . . . . . . . . . Expression (
   10: 10: . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 10: . . . . . . . . . . . . . . . . . . . . . . IDENT k
 /app/parser/parser.go:713: ast.Ident{Name: k}
   10: 11: . . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . "+"
   10: 12: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 12: . . . . . . . . . . . . . . . . . . . . . . . STRING ","
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: ","}
   10: 15: . . . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . "+"
   10: 16: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 16: . . . . . . . . . . . . . . . . . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   10: 18: . . . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . ForPhrase (
   10: 18: . . . . . . . . . . . . . . . . . . "for"
   10: 22: . . . . . . . . . . . . . . . . . . IDENT k
 /app/parser/parser.go:713: ast.Ident{Name: k}
   10: 23: . . . . . . . . . . . . . . . . . . ","
   10: 25: . . . . . . . . . . . . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   10: 27: . . . . . . . . . . . . . . . . . . "<-"
   10: 30: . . . . . . . . . . . . . . . . . . Expression (
   10: 30: . . . . . . . . . . . . . . . . . . . RangeExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . . . "{"
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . ElementList (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hello"}
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "xsw"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "xsw"}
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . ","
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "XGo"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "XGo"}
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . "}"
   10: 59: . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{0xc00044efc0 182 + s}, Fors: [0xc000462480]}
   10: 60: . . . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   10: 61: . . . . . . . . . . )
   10: 61: . . . . . . . . . )
   10: 61: . . . . . . . . )
   10: 61: . . . . . . . )
   10: 61: . . . . . . )
   10: 61: . . . . . )
   10: 61: . . . . )
   10: 61: . . . . ";"
   12:  1: . . . )
   12:  1: . . . Statement (
   12:  1: . . . . SimpleStmt (
   12:  1: . . . . . ExpressionList (
   12:  1: . . . . . . Expression (
   12:  1: . . . . . . . BinaryExpr (
   12:  1: . . . . . . . . UnaryExpr (
   12:  1: . . . . . . . . . PrimaryExpr (
   12:  1: . . . . . . . . . . Operand (
   12:  1: . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   12:  5: . . . . . . . . . . )
   12:  5: . . . . . . . . . )
   12:  5: . . . . . . . . )
   12:  5: . . . . . . . )
   12:  5: . . . . . . )
   12:  5: . . . . . )
   12:  5: . . . . . ":="
   12:  8: . . . . . ExpressionList (
   12:  8: . . . . . . Expression (
   12:  8: . . . . . . . BinaryExpr (
   12:  8: . . . . . . . . UnaryExpr (
   12:  8: . . . . . . . . . PrimaryExpr (
   12:  8: . . . . . . . . . . Operand (
   12:  8: . . . . . . . . . . . ArrayType (
   12:  8: . . . . . . . . . . . . "["
   12:  9: . . . . . . . . . . . . Expression (
   12:  9: . . . . . . . . . . . . . BinaryExpr (
   12:  9: . . . . . . . . . . . . . . UnaryExpr (
   12:  9: . . . . . . . . . . . . . . . PrimaryExpr (
   12:  9: . . . . . . . . . . . . . . . . Operand (
   12:  9: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   12: 10: . . . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . ","
   12: 12: . . . . . . . . . . . . Expression (
   12: 12: . . . . . . . . . . . . . BinaryExpr (
   12: 12: . . . . . . . . . . . . . . UnaryExpr (
   12: 12: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 12: . . . . . . . . . . . . . . . . Operand (
   12: 12: . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   12: 13: . . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . ","
   12: 15: . . . . . . . . . . . . Expression (
   12: 15: . . . . . . . . . . . . . BinaryExpr (
   12: 15: . . . . . . . . . . . . . . UnaryExpr (
   12: 15: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 15: . . . . . . . . . . . . . . . . Operand (
   12: 15: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   12: 16: . . . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . ","
   12: 18: . . . . . . . . . . . . Expression (
   12: 18: . . . . . . . . . . . . . BinaryExpr (
   12: 18: . . . . . . . . . . . . . . UnaryExpr (
   12: 18: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 18: . . . . . . . . . . . . . . . . Operand (
   12: 18: . . . . . . . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
   12: 19: . . . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . ","
   12: 21: . . . . . . . . . . . . Expression (
   12: 21: . . . . . . . . . . . . . BinaryExpr (
   12: 21: . . . . . . . . . . . . . . UnaryExpr (
   12: 21: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 21: . . . . . . . . . . . . . . . . Operand (
   12: 21: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   12: 22: . . . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . ","
   12: 24: . . . . . . . . . . . . Expression (
   12: 24: . . . . . . . . . . . . . BinaryExpr (
   12: 24: . . . . . . . . . . . . . . UnaryExpr (
   12: 24: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 24: . . . . . . . . . . . . . . . . Operand (
   12: 24: . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
   12: 25: . . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . "]"
   12: 26: . . . . . . . . . . . )
   12: 26: . . . . . . . . . . )
   12: 26: . . . . . . . . . )
   12: 26: . . . . . . . . )
   12: 26: . . . . . . . )
   12: 26: . . . . . . )
   12: 26: . . . . . )
   12: 26: . . . . )
   12: 26: . . . . ";"
   13:  1: . . . )
   13:  1: . . . Statement (
   13:  1: . . . . SimpleStmt (
   13:  1: . . . . . ExpressionList (
   13:  1: . . . . . . Expression (
   13:  1: . . . . . . . BinaryExpr (
   13:  1: . . . . . . . . UnaryExpr (
   13:  1: . . . . . . . . . PrimaryExpr (
   13:  1: . . . . . . . . . . Operand (
   13:  1: . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   13:  3: . . . . . . . . . . )
   13:  3: . . . . . . . . . )
   13:  3: . . . . . . . . )
   13:  3: . . . . . . . )
   13:  3: . . . . . . )
   13:  3: . . . . . )
   13:  3: . . . . . ":="
   13:  6: . . . . . ExpressionList (
   13:  6: . . . . . . Expression (
   13:  6: . . . . . . . BinaryExpr (
   13:  6: . . . . . . . . UnaryExpr (
   13:  6: . . . . . . . . . PrimaryExpr (
   13:  6: . . . . . . . . . . Operand (
   13:  6: . . . . . . . . . . . ArrayType (
   13:  6: . . . . . . . . . . . . "["
   13:  7: . . . . . . . . . . . . Expression (
   13:  7: . . . . . . . . . . . . . BinaryExpr (
   13:  7: . . . . . . . . . . . . . . UnaryExpr (
   13:  7: . . . . . . . . . . . . . . . PrimaryExpr (
   13:  7: . . . . . . . . . . . . . . . . Operand (
   13:  7: . . . . . . . . . . . . . . . . . ArrayType (
   13:  7: . . . . . . . . . . . . . . . . . . "["
   13:  8: . . . . . . . . . . . . . . . . . . Expression (
   13:  8: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . . . Operand (
   13:  8: . . . . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13:  9: . . . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . ","
   13: 11: . . . . . . . . . . . . . . . . . . Expression (
   13: 11: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 12: . . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . "]"
   13: 14: . . . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . ForPhrase (
   13: 14: . . . . . . . . . . . . . "for"
   13: 18: . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13: 20: . . . . . . . . . . . . . "<-"
   13: 23: . . . . . . . . . . . . . Expression (
   13: 23: . . . . . . . . . . . . . . RangeExpr (
   13: 23: . . . . . . . . . . . . . . . BinaryExpr (
   13: 23: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 23: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 23: . . . . . . . . . . . . . . . . . . Operand (
   13: 23: . . . . . . . . . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   13: 27: . . . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . "if"
   13: 30: . . . . . . . . . . . . . SimpleStmt (
   13: 30: . . . . . . . . . . . . . . ExpressionList (
   13: 30: . . . . . . . . . . . . . . . Expression (
   13: 30: . . . . . . . . . . . . . . . . BinaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . . . Operand (
   13: 30: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13: 32: . . . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . "<"
   13: 34: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 34: . . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 36: . . . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . ForPhrase (
   13: 36: . . . . . . . . . . . . . "for"
   13: 40: . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 42: . . . . . . . . . . . . . "<-"
   13: 45: . . . . . . . . . . . . . Expression (
   13: 45: . . . . . . . . . . . . . . RangeExpr (
   13: 45: . . . . . . . . . . . . . . . BinaryExpr (
   13: 45: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 45: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 45: . . . . . . . . . . . . . . . . . . Operand (
   13: 45: . . . . . . . . . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   13: 49: . . . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . "if"
   13: 52: . . . . . . . . . . . . . SimpleStmt (
   13: 52: . . . . . . . . . . . . . . ExpressionList (
   13: 52: . . . . . . . . . . . . . . . Expression (
   13: 52: . . . . . . . . . . . . . . . . BinaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . . . Operand (
   13: 52: . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 54: . . . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . ">"
   13: 56: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 56: . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   13: 57: . . . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{262 [a b] 267 false}, Fors: [0xc000462540 0xc0004625a0]}
   13: 58: . . . . . . . . . . . )
   13: 58: . . . . . . . . . . )
   13: 58: . . . . . . . . . )
   13: 58: . . . . . . . . )
   13: 58: . . . . . . . )
   13: 58: . . . . . . )
   13: 58: . . . . . )
   13: 58: . . . . )
   13: 58: . . . . ";"
   14:  1: . . . )
   14:  1: . . . Statement (
   14:  1: . . . . SimpleStmt (
   14:  1: . . . . . ExpressionList (
   14:  1: . . . . . . Expression (
   14:  1: . . . . . . . BinaryExpr (
   14:  1: . . . . . . . . UnaryExpr (
   14:  1: . . . . . . . . . PrimaryExpr (
   14:  1: . . . . . . . . . . Operand (
   14:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   14:  8: . . . . . . . . . . )
   14:  8: . . . . . . . . . . CallOrConversion (
   14:  8: . . . . . . . . . . . "("
   14:  9: . . . . . . . . . . . Expression (
   14:  9: . . . . . . . . . . . . BinaryExpr (
   14:  9: . . . . . . . . . . . . . UnaryExpr (
   14:  9: . . . . . . . . . . . . . . PrimaryExpr (
   14:  9: . . . . . . . . . . . . . . . Operand (
   14:  9: . . . . . . . . . . . . . . . . STRING "x:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x:"}
   14: 13: . . . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . ","
   14: 15: . . . . . . . . . . . Expression (
   14: 15: . . . . . . . . . . . . BinaryExpr (
   14: 15: . . . . . . . . . . . . . UnaryExpr (
   14: 15: . . . . . . . . . . . . . . PrimaryExpr (
   14: 15: . . . . . . . . . . . . . . . Operand (
   14: 15: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   14: 16: . . . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   14: 17: . . . . . . . . . . )
   14: 17: . . . . . . . . . )
   14: 17: . . . . . . . . )
   14: 17: . . . . . . . )
   14: 17: . . . . . . )
   14: 17: . . . . . )
   14: 17: . . . . )
   14: 17: . . . . ";"
   14: 18: . . . )
   14: 18: . . )
   14: 18: . )
   14: 18: )
=== RUN   TestFromNofmt/matrix1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/matrix1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . . . . . . "["
    2:  2: . . . . . . . . . . . . . . . . . Expression (
    2:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  2: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2:  3: . . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . ","
    2:  5: . . . . . . . . . . . . . . . . . Expression (
    2:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  5: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2:  6: . . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . ","
    2:  8: . . . . . . . . . . . . . . . . . Expression (
    2:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  8: . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2:  9: . . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . ";"
    3:  2: . . . . . . . . . . . . . . . . . Expression (
    3:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  2: . . . . . . . . . . . . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
    3:  3: . . . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . ","
    3:  5: . . . . . . . . . . . . . . . . . Expression (
    3:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  5: . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    3:  6: . . . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . ","
    3:  8: . . . . . . . . . . . . . . . . . Expression (
    3:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  8: . . . . . . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
    3: 10: . . . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . "]"
    3: 11: . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    3: 11: . . . . . . . . . . )
    3: 11: . . . . . . . . . )
    3: 11: . . . . . . . . )
    3: 11: . . . . . . . )
    3: 11: . . . . . . )
    3: 11: . . . . . )
    3: 11: . . . . )
    3: 11: . . . . ";"
    3: 12: . . . )
    3: 12: . . )
    3: 12: . )
    3: 12: )
=== RUN   TestFromNofmt/printvariadic
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/printvariadic
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  8: . . . . . . . . . . )
    1:  8: . . . . . . . . . . CallOrConversion (
    1:  8: . . . . . . . . . . . "("
    2:  2: . . . . . . . . . . . Expression (
    2:  2: . . . . . . . . . . . . BinaryExpr (
    2:  2: . . . . . . . . . . . . . UnaryExpr (
    2:  2: . . . . . . . . . . . . . . PrimaryExpr (
    2:  2: . . . . . . . . . . . . . . . Operand (
    2:  2: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  3: . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . "..."
    3:  1: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: false}
    3:  2: . . . . . . . . . . )
    3:  2: . . . . . . . . . )
    3:  2: . . . . . . . . )
    3:  2: . . . . . . . )
    3:  2: . . . . . . )
    3:  2: . . . . . )
    3:  2: . . . . )
    3:  2: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  8: . . . . . . . . . . )
    4:  8: . . . . . . . . . . CallOrConversion (
    4:  8: . . . . . . . . . . . "("
    5:  2: . . . . . . . . . . . Expression (
    5:  2: . . . . . . . . . . . . BinaryExpr (
    5:  2: . . . . . . . . . . . . . UnaryExpr (
    5:  2: . . . . . . . . . . . . . . PrimaryExpr (
    5:  2: . . . . . . . . . . . . . . . Operand (
    5:  2: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    5:  3: . . . . . . . . . . . . . . . )
    5:  3: . . . . . . . . . . . . . . )
    5:  3: . . . . . . . . . . . . . )
    5:  3: . . . . . . . . . . . . )
    5:  3: . . . . . . . . . . . )
    5:  3: . . . . . . . . . . . "..."
    5:  6: . . . . . . . . . . . ","
    6:  1: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: false}
    6:  2: . . . . . . . . . . )
    6:  2: . . . . . . . . . )
    6:  2: . . . . . . . . )
    6:  2: . . . . . . . )
    6:  2: . . . . . . )
    6:  2: . . . . . )
    6:  2: . . . . )
    6:  2: . . . . ";"
    6:  3: . . . )
    6:  3: . . )
    6:  3: . )
    6:  3: )
=== RUN   TestFromNofmt/rangeexpr1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/rangeexpr1
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . ForStmt (
    4:  2: . . . . . . . "for"
    4:  6: . . . . . . . SimpleStmt (
    4:  6: . . . . . . . . ExpressionList (
    4:  6: . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    4:  8: . . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . )
    4:  8: . . . . . . . . . . )
    4:  8: . . . . . . . . . )
    4:  8: . . . . . . . . )
    4:  8: . . . . . . . . ":="
    4: 11: . . . . . . . . "range"
    4: 17: . . . . . . . . Expression (
    4: 17: . . . . . . . . . RangeExpr (
    4: 17: . . . . . . . . . . ":"
    4: 18: . . . . . . . . . . BinaryExpr (
    4: 18: . . . . . . . . . . . UnaryExpr (
    4: 18: . . . . . . . . . . . . PrimaryExpr (
    4: 18: . . . . . . . . . . . . . Operand (
    4: 18: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    4: 21: . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . )
    4: 21: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{46 INT 10 <nil>}, Expr3: <nil>}
    4: 21: . . . . . . . . . )
    4: 21: . . . . . . . . )
    4: 21: . . . . . . . )
    4: 21: . . . . . . . BlockStmt (
    4: 21: . . . . . . . . "{"
    5:  3: . . . . . . . . StatementList (
    5:  3: . . . . . . . . . Statement (
    5:  3: . . . . . . . . . . SimpleStmt (
    5:  3: . . . . . . . . . . . ExpressionList (
    5:  3: . . . . . . . . . . . . Expression (
    5:  3: . . . . . . . . . . . . . BinaryExpr (
    5:  3: . . . . . . . . . . . . . . UnaryExpr (
    5:  3: . . . . . . . . . . . . . . . PrimaryExpr (
    5:  3: . . . . . . . . . . . . . . . . Operand (
    5:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 10: . . . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . . . CallOrConversion (
    5: 10: . . . . . . . . . . . . . . . . . "("
    5: 11: . . . . . . . . . . . . . . . . . Expression (
    5: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    5: 12: . . . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 13: . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . )
    5: 13: . . . . . . . . . . )
    5: 13: . . . . . . . . . . ";"
    6:  2: . . . . . . . . . )
    6:  2: . . . . . . . . )
    6:  2: . . . . . . . . "}"
    6:  3: . . . . . . . )
    6:  3: . . . . . . . ";"
    8:  2: . . . . . . )
    8:  2: . . . . . )
    8:  2: . . . . . Statement (
    8:  2: . . . . . . ForStmt (
    8:  2: . . . . . . . "for"
    8:  6: . . . . . . . SimpleStmt (
    8:  6: . . . . . . . . ExpressionList (
    8:  6: . . . . . . . . . Expression (
    8:  6: . . . . . . . . . . BinaryExpr (
    8:  6: . . . . . . . . . . . UnaryExpr (
    8:  6: . . . . . . . . . . . . PrimaryExpr (
    8:  6: . . . . . . . . . . . . . Operand (
    8:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    8:  8: . . . . . . . . . . . . . )
    8:  8: . . . . . . . . . . . . )
    8:  8: . . . . . . . . . . . )
    8:  8: . . . . . . . . . . )
    8:  8: . . . . . . . . . )
    8:  8: . . . . . . . . )
    8:  8: . . . . . . . . "<-"
    8: 11: . . . . . . . . Expression (
    8: 11: . . . . . . . . . RangeExpr (
    8: 11: . . . . . . . . . . BinaryExpr (
    8: 11: . . . . . . . . . . . UnaryExpr (
    8: 11: . . . . . . . . . . . . PrimaryExpr (
    8: 11: . . . . . . . . . . . . . Operand (
    8: 11: . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    8: 12: . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . )
    8: 12: . . . . . . . . . . )
    8: 12: . . . . . . . . . . ":"
    8: 13: . . . . . . . . . . BinaryExpr (
    8: 13: . . . . . . . . . . . UnaryExpr (
    8: 13: . . . . . . . . . . . . PrimaryExpr (
    8: 13: . . . . . . . . . . . . . Operand (
    8: 13: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    8: 16: . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . )
    8: 16: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: &{78 INT 1 <nil>}, Last: &{80 INT 10 <nil>}, Expr3: <nil>}
    8: 16: . . . . . . . . . )
    8: 16: . . . . . . . . )
    8: 16: . . . . . . . )
    8: 16: . . . . . . . BlockStmt (
    8: 16: . . . . . . . . "{"
    9:  3: . . . . . . . . StatementList (
    9:  3: . . . . . . . . . Statement (
    9:  3: . . . . . . . . . . SimpleStmt (
    9:  3: . . . . . . . . . . . ExpressionList (
    9:  3: . . . . . . . . . . . . Expression (
    9:  3: . . . . . . . . . . . . . BinaryExpr (
    9:  3: . . . . . . . . . . . . . . UnaryExpr (
    9:  3: . . . . . . . . . . . . . . . PrimaryExpr (
    9:  3: . . . . . . . . . . . . . . . . Operand (
    9:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    9: 10: . . . . . . . . . . . . . . . . )
    9: 10: . . . . . . . . . . . . . . . . CallOrConversion (
    9: 10: . . . . . . . . . . . . . . . . . "("
    9: 11: . . . . . . . . . . . . . . . . . Expression (
    9: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    9: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    9: 12: . . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    9: 13: . . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . )
    9: 13: . . . . . . . . . . )
    9: 13: . . . . . . . . . . ";"
   10:  2: . . . . . . . . . )
   10:  2: . . . . . . . . )
   10:  2: . . . . . . . . "}"
   10:  3: . . . . . . . )
   10:  3: . . . . . . . ";"
   12:  2: . . . . . . )
   12:  2: . . . . . )
   12:  2: . . . . . Statement (
   12:  2: . . . . . . ForStmt (
   12:  2: . . . . . . . "for"
   12:  6: . . . . . . . SimpleStmt (
   12:  6: . . . . . . . . ExpressionList (
   12:  6: . . . . . . . . . Expression (
   12:  6: . . . . . . . . . . BinaryExpr (
   12:  6: . . . . . . . . . . . UnaryExpr (
   12:  6: . . . . . . . . . . . . PrimaryExpr (
   12:  6: . . . . . . . . . . . . . Operand (
   12:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   12:  8: . . . . . . . . . . . . . )
   12:  8: . . . . . . . . . . . . )
   12:  8: . . . . . . . . . . . )
   12:  8: . . . . . . . . . . )
   12:  8: . . . . . . . . . )
   12:  8: . . . . . . . . )
   12:  8: . . . . . . . . ":="
   12: 11: . . . . . . . . "range"
   12: 17: . . . . . . . . Expression (
   12: 17: . . . . . . . . . RangeExpr (
   12: 17: . . . . . . . . . . ":"
   12: 18: . . . . . . . . . . BinaryExpr (
   12: 18: . . . . . . . . . . . UnaryExpr (
   12: 18: . . . . . . . . . . . . PrimaryExpr (
   12: 18: . . . . . . . . . . . . . Operand (
   12: 18: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
   12: 20: . . . . . . . . . . . . . )
   12: 20: . . . . . . . . . . . . )
   12: 20: . . . . . . . . . . . )
   12: 20: . . . . . . . . . . )
   12: 20: . . . . . . . . . . ":"
   12: 21: . . . . . . . . . . BinaryExpr (
   12: 21: . . . . . . . . . . . UnaryExpr (
   12: 21: . . . . . . . . . . . . PrimaryExpr (
   12: 21: . . . . . . . . . . . . . Operand (
   12: 21: . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   12: 23: . . . . . . . . . . . . . )
   12: 23: . . . . . . . . . . . . )
   12: 23: . . . . . . . . . . . )
   12: 23: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{119 INT 10 <nil>}, Expr3: &{122 INT 2 <nil>}}
   12: 23: . . . . . . . . . )
   12: 23: . . . . . . . . )
   12: 23: . . . . . . . )
   12: 23: . . . . . . . BlockStmt (
   12: 23: . . . . . . . . "{"
   13:  3: . . . . . . . . StatementList (
   13:  3: . . . . . . . . . Statement (
   13:  3: . . . . . . . . . . SimpleStmt (
   13:  3: . . . . . . . . . . . ExpressionList (
   13:  3: . . . . . . . . . . . . Expression (
   13:  3: . . . . . . . . . . . . . BinaryExpr (
   13:  3: . . . . . . . . . . . . . . UnaryExpr (
   13:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   13:  3: . . . . . . . . . . . . . . . . Operand (
   13:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   13: 10: . . . . . . . . . . . . . . . . )
   13: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   13: 10: . . . . . . . . . . . . . . . . . "("
   13: 11: . . . . . . . . . . . . . . . . . Expression (
   13: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   13: 12: . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   13: 13: . . . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . )
   13: 13: . . . . . . . . . . )
   13: 13: . . . . . . . . . . ";"
   14:  2: . . . . . . . . . )
   14:  2: . . . . . . . . )
   14:  2: . . . . . . . . "}"
   14:  3: . . . . . . . )
   14:  3: . . . . . . . ";"
   16:  2: . . . . . . )
   16:  2: . . . . . )
   16:  2: . . . . . Statement (
   16:  2: . . . . . . ForStmt (
   16:  2: . . . . . . . "for"
   16:  6: . . . . . . . "range"
   16: 12: . . . . . . . Expression (
   16: 12: . . . . . . . . RangeExpr (
   16: 12: . . . . . . . . . ":"
   16: 13: . . . . . . . . . BinaryExpr (
   16: 13: . . . . . . . . . . UnaryExpr (
   16: 13: . . . . . . . . . . . PrimaryExpr (
   16: 13: . . . . . . . . . . . . Operand (
   16: 13: . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
   16: 16: . . . . . . . . . . . . )
   16: 16: . . . . . . . . . . . )
   16: 16: . . . . . . . . . . )
   16: 16: . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{155 INT 10 <nil>}, Expr3: <nil>}
   16: 16: . . . . . . . . )
   16: 16: . . . . . . . )
   16: 16: . . . . . . . BlockStmt (
   16: 16: . . . . . . . . "{"
   17:  3: . . . . . . . . StatementList (
   17:  3: . . . . . . . . . Statement (
   17:  3: . . . . . . . . . . SimpleStmt (
   17:  3: . . . . . . . . . . . ExpressionList (
   17:  3: . . . . . . . . . . . . Expression (
   17:  3: . . . . . . . . . . . . . BinaryExpr (
   17:  3: . . . . . . . . . . . . . . UnaryExpr (
   17:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   17:  3: . . . . . . . . . . . . . . . . Operand (
   17:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   17: 10: . . . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   17: 10: . . . . . . . . . . . . . . . . . "("
   17: 11: . . . . . . . . . . . . . . . . . Expression (
   17: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   17: 11: . . . . . . . . . . . . . . . . . . . . . . STRING "Range expression"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Range expression"}
   17: 29: . . . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   17: 30: . . . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . )
   17: 30: . . . . . . . . . . )
   17: 30: . . . . . . . . . . ";"
   18:  2: . . . . . . . . . )
   18:  2: . . . . . . . . )
   18:  2: . . . . . . . . "}"
   18:  3: . . . . . . . )
   18:  3: . . . . . . . ";"
   19:  1: . . . . . . )
   19:  1: . . . . . )
   19:  1: . . . . )
   19:  1: . . . . "}"
   19:  2: . . . )
   19:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   19:  3: . . )
   19:  3: . )
   19:  3: )
=== RUN   TestFromNofmt/selectdata
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/selectdata
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . ","
    1: 10: . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ","
    1: 13: . . . . . . . . . . . . Expression (
    1: 13: . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . ","
    1: 16: . . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . ","
    1: 19: . . . . . . . . . . . . Expression (
    1: 19: . . . . . . . . . . . . . BinaryExpr (
    1: 19: . . . . . . . . . . . . . . UnaryExpr (
    1: 19: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 19: . . . . . . . . . . . . . . . . Operand (
    1: 19: . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    1: 20: . . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . ","
    1: 22: . . . . . . . . . . . . Expression (
    1: 22: . . . . . . . . . . . . . BinaryExpr (
    1: 22: . . . . . . . . . . . . . . UnaryExpr (
    1: 22: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 22: . . . . . . . . . . . . . . . . Operand (
    1: 22: . . . . . . . . . . . . . . . . . INT 19
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 19}
    1: 24: . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . "]"
    1: 25: . . . . . . . . . . . )
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2:  3: . . . . . . . . . . )
    2:  3: . . . . . . . . . )
    2:  3: . . . . . . . . )
    2:  3: . . . . . . . )
    2:  3: . . . . . . )
    2:  3: . . . . . )
    2:  3: . . . . . ":="
    2:  6: . . . . . ExpressionList (
    2:  6: . . . . . . Expression (
    2:  6: . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . LiteralValue (
    2:  6: . . . . . . . . . . . . "{"
    2:  7: . . . . . . . . . . . . ElementList (
    2:  7: . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . . Expression (
    2:  7: . . . . . . . . . . . . . . . . BinaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . . Operand (
    2:  7: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  9: . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . ForPhrase (
    2:  9: . . . . . . . . . . . . . . "for"
    2: 13: . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 15: . . . . . . . . . . . . . . "<-"
    2: 18: . . . . . . . . . . . . . . Expression (
    2: 18: . . . . . . . . . . . . . . . RangeExpr (
    2: 18: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . . . Operand (
    2: 18: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 20: . . . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . "if"
    2: 23: . . . . . . . . . . . . . . SimpleStmt (
    2: 23: . . . . . . . . . . . . . . . ExpressionList (
    2: 23: . . . . . . . . . . . . . . . . Expression (
    2: 23: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 23: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 24: . . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . "%"
    2: 25: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 25: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 27: . . . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . "=="
    2: 30: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 30: . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    2: 31: . . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . "}"
    2: 32: . . . . . . . . . . . )
    2: 32: . . . . . . . . . . )
    2: 32: . . . . . . . . . )
    2: 32: . . . . . . . . )
    2: 32: . . . . . . . )
    2: 32: . . . . . . )
    2: 32: . . . . . )
    2: 32: . . . . )
    2: 32: . . . . ";"
    2: 33: . . . )
    2: 33: . . )
    2: 33: . )
    2: 33: )
--- PASS: TestFromNofmt (0.03s)
    --- PASS: TestFromNofmt/cmdlinestyle1 (0.00s)
    --- PASS: TestFromNofmt/cmdlinestyle2 (0.00s)
    --- PASS: TestFromNofmt/cmdlinestyle3 (0.00s)
    --- PASS: TestFromNofmt/exists (0.00s)
    --- PASS: TestFromNofmt/forloop (0.01s)
    --- PASS: TestFromNofmt/listcompr (0.01s)
    --- PASS: TestFromNofmt/matrix1 (0.00s)
    --- PASS: TestFromNofmt/printvariadic (0.00s)
    --- PASS: TestFromNofmt/rangeexpr1 (0.00s)
    --- PASS: TestFromNofmt/selectdata (0.00s)
PASS
coverage: 94.9% of statements
ok  	github.com/goplus/xgo/parser	0.249s	coverage: 94.9% of statements
	github.com/goplus/xgo/parser/fsx		coverage: 0.0% of statements
	github.com/goplus/xgo/parser/fsx/memfs		coverage: 0.0% of statements
	github.com/goplus/xgo/parser/iox		coverage: 0.0% of statements
	github.com/goplus/xgo/parser/parsertest		coverage: 0.0% of statements
=== RUN   TestLineComments
--- PASS: TestLineComments (0.00s)
=== RUN   TestBadComments
=== PAUSE TestBadComments
=== RUN   TestSourcePos
2025/10/11 16:12:18 ==> Format Func foo
--- PASS: TestSourcePos (0.00s)
=== RUN   TestIssue5945
2025/10/11 16:12:18 ==> Format Func f
2025/10/11 16:12:18 ==> Format Func g
--- PASS: TestIssue5945 (0.00s)
=== RUN   TestDeclLists
2025/10/11 16:12:18 ==> Format Func sum
--- PASS: TestDeclLists (0.00s)
=== RUN   TestStmtLists
2025/10/11 16:12:18 ==> AssignStmt [i]
--- PASS: TestStmtLists (0.00s)
=== RUN   TestBaseIndent
=== PAUSE TestBaseIndent
=== RUN   TestFuncType
2025/10/11 16:12:18 ==> Format Func f
--- PASS: TestFuncType (0.00s)
=== RUN   TestWriteErrors
=== PAUSE TestWriteErrors
=== RUN   TestX
2025/10/11 16:12:18 ==> Format Func _
--- PASS: TestX (0.00s)
=== RUN   TestCommentedNode
2025/10/11 16:12:18 ==> Format Func foo
--- PASS: TestCommentedNode (0.00s)
=== RUN   TestIssue11151
--- PASS: TestIssue11151 (0.00s)
=== RUN   TestParenthesizedDecl
--- PASS: TestParenthesizedDecl (0.00s)
=== RUN   TestIssue32854
--- PASS: TestIssue32854 (0.00s)
=== RUN   TestStripParens
--- PASS: TestStripParens (0.00s)
=== RUN   TestGoFormat
--- PASS: TestGoFormat (0.00s)
=== RUN   TestGopFormat
--- PASS: TestGopFormat (0.00s)
=== RUN   TestNoPkgDecl
--- PASS: TestNoPkgDecl (0.00s)
=== RUN   TestFuncs
2025/10/11 16:12:18 ==> Format Func foo
2025/10/11 16:12:18 ==> Format Func bar
--- PASS: TestFuncs (0.00s)
=== RUN   TestFromGopPrinter
=== RUN   TestFromGopPrinter/format.Source_nodes.go
2025/10/11 16:12:18 ==> Format Func SetDebug
2025/10/11 16:12:18 ==> AssignStmt [debugFormat]
2025/10/11 16:12:18 ==> Format Func linebreak
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [nbreaks]
2025/10/11 16:12:18 ==> AssignStmt [nbreaks]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func setComment
2025/10/11 16:12:18 ==> AssignStmt [0xc0001253f8]
2025/10/11 16:12:18 ==> ExprStmt &{p flush}
2025/10/11 16:12:18 ==> AssignStmt [0xc000125548]
2025/10/11 16:12:18 ==> ExprStmt &{p internalError}
2025/10/11 16:12:18 ==> AssignStmt [0xc0001a9da0]
2025/10/11 16:12:18 ==> AssignStmt [0xc0001255d8]
2025/10/11 16:12:18 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:18 ==> Format Func identList
2025/10/11 16:12:18 ==> AssignStmt [xlist]
2025/10/11 16:12:18 ==> AssignStmt [0xc0001cc1b0]
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> Format Func exprList
2025/10/11 16:12:18 ==> AssignStmt [prev]
2025/10/11 16:12:18 ==> AssignStmt [next]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [prev]
2025/10/11 16:12:18 ==> AssignStmt [next]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> AssignStmt [endLine]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [prevBreak]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [prevBreak]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [lnsum]
2025/10/11 16:12:18 ==> AssignStmt [count]
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> AssignStmt [useFF]
2025/10/11 16:12:18 ==> AssignStmt [prevSize]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [pair isPair]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [useFF]
2025/10/11 16:12:18 ==> AssignStmt [geomean]
2025/10/11 16:12:18 ==> AssignStmt [ratio]
2025/10/11 16:12:18 ==> AssignStmt [useFF]
2025/10/11 16:12:18 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> AssignStmt [nbreaks]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [prevBreak]
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> AssignStmt [lnsum]
2025/10/11 16:12:18 ==> AssignStmt [count]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> AssignStmt [lnsum]
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func parameters
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [parLineBeg]
2025/10/11 16:12:18 ==> AssignStmt [parLineBeg]
2025/10/11 16:12:18 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> AssignStmt [closing]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func signature
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> Format Func identListSize
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> Format Func isOneLineFieldList
2025/10/11 16:12:18 ==> AssignStmt [f]
2025/10/11 16:12:18 ==> AssignStmt [namesSize]
2025/10/11 16:12:18 ==> AssignStmt [namesSize]
2025/10/11 16:12:18 ==> AssignStmt [typeSize]
2025/10/11 16:12:18 ==> Format Func setLineComment
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> Format Func fieldList
2025/10/11 16:12:18 ==> AssignStmt [lbrace]
2025/10/11 16:12:18 ==> AssignStmt [list]
2025/10/11 16:12:18 ==> AssignStmt [rbrace]
2025/10/11 16:12:18 ==> AssignStmt [hasComments]
2025/10/11 16:12:18 ==> AssignStmt [srcIsOneLine]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [f]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [ftyp isFtyp]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [sep]
2025/10/11 16:12:18 ==> AssignStmt [sep]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p flush}
2025/10/11 16:12:18 ==> ExprStmt &{p setLineComment}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> AssignStmt [ftyp isFtyp]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p flush}
2025/10/11 16:12:18 ==> ExprStmt &{p setLineComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func walkBinary
2025/10/11 16:12:18 ==> AssignStmt [has4]
2025/10/11 16:12:18 ==> AssignStmt [has5]
2025/10/11 16:12:18 ==> AssignStmt [l]
2025/10/11 16:12:18 ==> AssignStmt [h4 h5 mp]
2025/10/11 16:12:18 ==> AssignStmt [has4]
2025/10/11 16:12:18 ==> AssignStmt [has5]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [r]
2025/10/11 16:12:18 ==> AssignStmt [h4 h5 mp]
2025/10/11 16:12:18 ==> AssignStmt [has4]
2025/10/11 16:12:18 ==> AssignStmt [has5]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> Format Func cutoff
2025/10/11 16:12:18 ==> AssignStmt [has4 has5 maxProblem]
2025/10/11 16:12:18 ==> Format Func diffPrec
2025/10/11 16:12:18 ==> AssignStmt [x ok]
2025/10/11 16:12:18 ==> Format Func reduceDepth
2025/10/11 16:12:18 ==> AssignStmt [depth]
2025/10/11 16:12:18 ==> Format Func binaryExpr
2025/10/11 16:12:18 ==> AssignStmt [prec]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [printBlank]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [xline]
2025/10/11 16:12:18 ==> AssignStmt [yline]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [printBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func isBinary
2025/10/11 16:12:18 ==> AssignStmt [_ ok]
2025/10/11 16:12:18 ==> Format Func expr1
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [x]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p internalError}
2025/10/11 16:12:18 ==> AssignStmt [depth]
2025/10/11 16:12:18 ==> AssignStmt [v ok]
2025/10/11 16:12:18 ==> ExprStmt &{p binaryExpr}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [startCol]
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p funcBody}
2025/10/11 16:12:18 ==> AssignStmt [_ hasParens]
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p selectorExpr}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [indices]
2025/10/11 16:12:18 ==> AssignStmt [indices]
2025/10/11 16:12:18 ==> AssignStmt [hasBinaries]
2025/10/11 16:12:18 ==> AssignStmt [needsBlanks]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [_ ok]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [wasIndented]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [wasIndented]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [incomplete]
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p fieldList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p fieldList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p listForPhrase}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [elt ok]
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p listForPhrase}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{log Fatalf}
2025/10/11 16:12:18 ==> Format Func listForPhrase
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> Format Func possibleSelectorExpr
2025/10/11 16:12:18 ==> AssignStmt [x ok]
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> Format Func selectorExpr
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func expr0
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> Format Func expr
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> Format Func stmtList
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [i]
2025/10/11 16:12:18 ==> AssignStmt [_ isEmpty]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> AssignStmt [lt _]
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func block
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func isTypeName
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> Format Func stripParens
2025/10/11 16:12:18 ==> AssignStmt [px strip]
2025/10/11 16:12:18 ==> ExprStmt &{ast Inspect}
2025/10/11 16:12:18 ==> AssignStmt [x]
2025/10/11 16:12:18 ==> AssignStmt [strip]
2025/10/11 16:12:18 ==> AssignStmt [x]
2025/10/11 16:12:18 ==> AssignStmt [strip]
2025/10/11 16:12:18 ==> Format Func stripParensAlways
2025/10/11 16:12:18 ==> AssignStmt [x ok]
2025/10/11 16:12:18 ==> Format Func controlClause
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func indentList
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> AssignStmt [xb]
2025/10/11 16:12:18 ==> AssignStmt [xe]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> Format Func stmt
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [s]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p decl}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [e isEmpty]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [e ok]
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p controlClause}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p controlClause}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [body]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p controlClause}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{log Printf}
2025/10/11 16:12:18 ==> Format Func keepTypeColumn
2025/10/11 16:12:18 ==> AssignStmt [m]
2025/10/11 16:12:18 ==> AssignStmt [populate]
2025/10/11 16:12:18 ==> AssignStmt [0xc0002ad410]
2025/10/11 16:12:18 ==> AssignStmt [0xc0002ad410]
2025/10/11 16:12:18 ==> AssignStmt [i0]
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> AssignStmt [i0]
2025/10/11 16:12:18 ==> AssignStmt [keepType]
2025/10/11 16:12:18 ==> ExprStmt populate
2025/10/11 16:12:18 ==> AssignStmt [i0]
2025/10/11 16:12:18 ==> AssignStmt [keepType]
2025/10/11 16:12:18 ==> ExprStmt populate
2025/10/11 16:12:18 ==> Format Func valueSpec
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> Format Func sanitizeImportPath
2025/10/11 16:12:18 ==> AssignStmt [s err]
2025/10/11 16:12:18 ==> AssignStmt [s]
2025/10/11 16:12:18 ==> Format Func spec
2025/10/11 16:12:18 ==> AssignStmt [s]
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p internalError}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt panic
2025/10/11 16:12:18 ==> Format Func genDecl
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p setPos}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setPos}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [keepType]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p valueSpec}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p spec}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setPos}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p spec}
2025/10/11 16:12:18 ==> Format Func nodeSize
2025/10/11 16:12:18 ==> AssignStmt [size found]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [0xc0002d2210]
2025/10/11 16:12:18 ==> AssignStmt [cfg]
2025/10/11 16:12:18 ==> AssignStmt [err]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [0xc0002d2540]
2025/10/11 16:12:18 ==> Format Func numLines
2025/10/11 16:12:18 ==> AssignStmt [from]
2025/10/11 16:12:18 ==> AssignStmt [to]
2025/10/11 16:12:18 ==> Format Func bodySize
2025/10/11 16:12:18 ==> AssignStmt [pos1]
2025/10/11 16:12:18 ==> AssignStmt [pos2]
2025/10/11 16:12:18 ==> AssignStmt [bodySize]
2025/10/11 16:12:18 ==> AssignStmt [bodySize]
2025/10/11 16:12:18 ==> AssignStmt [bodySize]
2025/10/11 16:12:18 ==> Format Func funcBody
2025/10/11 16:12:18 ==> AssignStmt [0xc0002c2e70]
2025/10/11 16:12:18 ==> AssignStmt [0xc0002c2ea0]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> Format Func funcBodyUnnamed
2025/10/11 16:12:18 ==> AssignStmt [_ _]
2025/10/11 16:12:18 ==> AssignStmt [0xc0002c3188]
2025/10/11 16:12:18 ==> AssignStmt [0xc0002c31b8]
2025/10/11 16:12:18 ==> AssignStmt [i]
2025/10/11 16:12:18 ==> AssignStmt [_ isEmpty]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> AssignStmt [lt _]
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> Format Func distanceFrom
2025/10/11 16:12:18 ==> Format Func funcDecl
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p funcBodyUnnamed}
2025/10/11 16:12:18 ==> AssignStmt [pos]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [startCol]
2025/10/11 16:12:18 ==> AssignStmt [list]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p funcBody}
2025/10/11 16:12:18 ==> Format Func overloadFuncDecl
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> AssignStmt [pos]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func decl
2025/10/11 16:12:18 ==> AssignStmt [d]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p genDecl}
2025/10/11 16:12:18 ==> ExprStmt &{p funcDecl}
2025/10/11 16:12:18 ==> ExprStmt &{p overloadFuncDecl}
2025/10/11 16:12:18 ==> ExprStmt panic
2025/10/11 16:12:18 ==> Format Func declToken
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [d]
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> Format Func declList
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [decl ok]
2025/10/11 16:12:18 ==> AssignStmt [prev]
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [min]
2025/10/11 16:12:18 ==> AssignStmt [min]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p decl}
2025/10/11 16:12:18 ==> Format Func file
2025/10/11 16:12:18 ==> AssignStmt [0xc0002e8570]
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p declList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
=== RUN   TestFromGopPrinter/format.Node_nodes.go
2025/10/11 16:12:18 ==> Format Func SetDebug
2025/10/11 16:12:18 ==> AssignStmt [debugFormat]
2025/10/11 16:12:18 ==> Format Func linebreak
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [nbreaks]
2025/10/11 16:12:18 ==> AssignStmt [nbreaks]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func setComment
2025/10/11 16:12:18 ==> AssignStmt [0xc00042e540]
2025/10/11 16:12:18 ==> ExprStmt &{p flush}
2025/10/11 16:12:18 ==> AssignStmt [0xc00042e690]
2025/10/11 16:12:18 ==> ExprStmt &{p internalError}
2025/10/11 16:12:18 ==> AssignStmt [0xc00041efc0]
2025/10/11 16:12:18 ==> AssignStmt [0xc00042e720]
2025/10/11 16:12:18 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:18 ==> Format Func identList
2025/10/11 16:12:18 ==> AssignStmt [xlist]
2025/10/11 16:12:18 ==> AssignStmt [0xc00041f350]
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> Format Func exprList
2025/10/11 16:12:18 ==> AssignStmt [prev]
2025/10/11 16:12:18 ==> AssignStmt [next]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [prev]
2025/10/11 16:12:18 ==> AssignStmt [next]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> AssignStmt [endLine]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [prevBreak]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [prevBreak]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [lnsum]
2025/10/11 16:12:18 ==> AssignStmt [count]
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> AssignStmt [useFF]
2025/10/11 16:12:18 ==> AssignStmt [prevSize]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [pair isPair]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [useFF]
2025/10/11 16:12:18 ==> AssignStmt [geomean]
2025/10/11 16:12:18 ==> AssignStmt [ratio]
2025/10/11 16:12:18 ==> AssignStmt [useFF]
2025/10/11 16:12:18 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> AssignStmt [nbreaks]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [prevBreak]
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> AssignStmt [lnsum]
2025/10/11 16:12:18 ==> AssignStmt [count]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> AssignStmt [lnsum]
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func parameters
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [parLineBeg]
2025/10/11 16:12:18 ==> AssignStmt [parLineBeg]
2025/10/11 16:12:18 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> AssignStmt [closing]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func signature
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> Format Func identListSize
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> Format Func isOneLineFieldList
2025/10/11 16:12:18 ==> AssignStmt [f]
2025/10/11 16:12:18 ==> AssignStmt [namesSize]
2025/10/11 16:12:18 ==> AssignStmt [namesSize]
2025/10/11 16:12:18 ==> AssignStmt [typeSize]
2025/10/11 16:12:18 ==> Format Func setLineComment
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> Format Func fieldList
2025/10/11 16:12:18 ==> AssignStmt [lbrace]
2025/10/11 16:12:18 ==> AssignStmt [list]
2025/10/11 16:12:18 ==> AssignStmt [rbrace]
2025/10/11 16:12:18 ==> AssignStmt [hasComments]
2025/10/11 16:12:18 ==> AssignStmt [srcIsOneLine]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [f]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [ftyp isFtyp]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [sep]
2025/10/11 16:12:18 ==> AssignStmt [sep]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p flush}
2025/10/11 16:12:18 ==> ExprStmt &{p setLineComment}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> AssignStmt [ftyp isFtyp]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p flush}
2025/10/11 16:12:18 ==> ExprStmt &{p setLineComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func walkBinary
2025/10/11 16:12:18 ==> AssignStmt [has4]
2025/10/11 16:12:18 ==> AssignStmt [has5]
2025/10/11 16:12:18 ==> AssignStmt [l]
2025/10/11 16:12:18 ==> AssignStmt [h4 h5 mp]
2025/10/11 16:12:18 ==> AssignStmt [has4]
2025/10/11 16:12:18 ==> AssignStmt [has5]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [r]
2025/10/11 16:12:18 ==> AssignStmt [h4 h5 mp]
2025/10/11 16:12:18 ==> AssignStmt [has4]
2025/10/11 16:12:18 ==> AssignStmt [has5]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> Format Func cutoff
2025/10/11 16:12:18 ==> AssignStmt [has4 has5 maxProblem]
2025/10/11 16:12:18 ==> Format Func diffPrec
2025/10/11 16:12:18 ==> AssignStmt [x ok]
2025/10/11 16:12:18 ==> Format Func reduceDepth
2025/10/11 16:12:18 ==> AssignStmt [depth]
2025/10/11 16:12:18 ==> Format Func binaryExpr
2025/10/11 16:12:18 ==> AssignStmt [prec]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [printBlank]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [xline]
2025/10/11 16:12:18 ==> AssignStmt [yline]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [printBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func isBinary
2025/10/11 16:12:18 ==> AssignStmt [_ ok]
2025/10/11 16:12:18 ==> Format Func expr1
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [x]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p internalError}
2025/10/11 16:12:18 ==> AssignStmt [depth]
2025/10/11 16:12:18 ==> AssignStmt [v ok]
2025/10/11 16:12:18 ==> ExprStmt &{p binaryExpr}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [startCol]
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p funcBody}
2025/10/11 16:12:18 ==> AssignStmt [_ hasParens]
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p selectorExpr}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [indices]
2025/10/11 16:12:18 ==> AssignStmt [indices]
2025/10/11 16:12:18 ==> AssignStmt [hasBinaries]
2025/10/11 16:12:18 ==> AssignStmt [needsBlanks]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [_ ok]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [wasIndented]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [wasIndented]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [incomplete]
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p fieldList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p fieldList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p listForPhrase}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [elt ok]
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p listForPhrase}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{log Fatalf}
2025/10/11 16:12:18 ==> Format Func listForPhrase
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> Format Func possibleSelectorExpr
2025/10/11 16:12:18 ==> AssignStmt [x ok]
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> Format Func selectorExpr
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func expr0
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> Format Func expr
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> Format Func stmtList
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [i]
2025/10/11 16:12:18 ==> AssignStmt [_ isEmpty]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> AssignStmt [lt _]
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func block
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func isTypeName
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> Format Func stripParens
2025/10/11 16:12:18 ==> AssignStmt [px strip]
2025/10/11 16:12:18 ==> ExprStmt &{ast Inspect}
2025/10/11 16:12:18 ==> AssignStmt [x]
2025/10/11 16:12:18 ==> AssignStmt [strip]
2025/10/11 16:12:18 ==> AssignStmt [x]
2025/10/11 16:12:18 ==> AssignStmt [strip]
2025/10/11 16:12:18 ==> Format Func stripParensAlways
2025/10/11 16:12:18 ==> AssignStmt [x ok]
2025/10/11 16:12:18 ==> Format Func controlClause
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func indentList
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> AssignStmt [xb]
2025/10/11 16:12:18 ==> AssignStmt [xe]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> Format Func stmt
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [s]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p decl}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [e isEmpty]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [e ok]
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p controlClause}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p controlClause}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [body]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p controlClause}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{log Printf}
2025/10/11 16:12:18 ==> Format Func keepTypeColumn
2025/10/11 16:12:18 ==> AssignStmt [m]
2025/10/11 16:12:18 ==> AssignStmt [populate]
2025/10/11 16:12:18 ==> AssignStmt [0xc0000f8e10]
2025/10/11 16:12:18 ==> AssignStmt [0xc0000f8e10]
2025/10/11 16:12:18 ==> AssignStmt [i0]
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> AssignStmt [i0]
2025/10/11 16:12:18 ==> AssignStmt [keepType]
2025/10/11 16:12:18 ==> ExprStmt populate
2025/10/11 16:12:18 ==> AssignStmt [i0]
2025/10/11 16:12:18 ==> AssignStmt [keepType]
2025/10/11 16:12:18 ==> ExprStmt populate
2025/10/11 16:12:18 ==> Format Func valueSpec
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> Format Func sanitizeImportPath
2025/10/11 16:12:18 ==> AssignStmt [s err]
2025/10/11 16:12:18 ==> AssignStmt [s]
2025/10/11 16:12:18 ==> Format Func spec
2025/10/11 16:12:18 ==> AssignStmt [s]
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p internalError}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt panic
2025/10/11 16:12:18 ==> Format Func genDecl
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p setPos}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setPos}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [keepType]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p valueSpec}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p spec}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setPos}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p spec}
2025/10/11 16:12:18 ==> Format Func nodeSize
2025/10/11 16:12:18 ==> AssignStmt [size found]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [0xc000155b90]
2025/10/11 16:12:18 ==> AssignStmt [cfg]
2025/10/11 16:12:18 ==> AssignStmt [err]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [0xc000155ec0]
2025/10/11 16:12:18 ==> Format Func numLines
2025/10/11 16:12:18 ==> AssignStmt [from]
2025/10/11 16:12:18 ==> AssignStmt [to]
2025/10/11 16:12:18 ==> Format Func bodySize
2025/10/11 16:12:18 ==> AssignStmt [pos1]
2025/10/11 16:12:18 ==> AssignStmt [pos2]
2025/10/11 16:12:18 ==> AssignStmt [bodySize]
2025/10/11 16:12:18 ==> AssignStmt [bodySize]
2025/10/11 16:12:18 ==> AssignStmt [bodySize]
2025/10/11 16:12:18 ==> Format Func funcBody
2025/10/11 16:12:18 ==> AssignStmt [0xc0000fff50]
2025/10/11 16:12:18 ==> AssignStmt [0xc000194000]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> Format Func funcBodyUnnamed
2025/10/11 16:12:18 ==> AssignStmt [_ _]
2025/10/11 16:12:18 ==> AssignStmt [0xc0001942e8]
2025/10/11 16:12:18 ==> AssignStmt [0xc000194318]
2025/10/11 16:12:18 ==> AssignStmt [i]
2025/10/11 16:12:18 ==> AssignStmt [_ isEmpty]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> AssignStmt [lt _]
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> Format Func distanceFrom
2025/10/11 16:12:18 ==> Format Func funcDecl
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p funcBodyUnnamed}
2025/10/11 16:12:18 ==> AssignStmt [pos]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [startCol]
2025/10/11 16:12:18 ==> AssignStmt [list]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p funcBody}
2025/10/11 16:12:18 ==> Format Func overloadFuncDecl
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> AssignStmt [pos]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func decl
2025/10/11 16:12:18 ==> AssignStmt [d]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p genDecl}
2025/10/11 16:12:18 ==> ExprStmt &{p funcDecl}
2025/10/11 16:12:18 ==> ExprStmt &{p overloadFuncDecl}
2025/10/11 16:12:18 ==> ExprStmt panic
2025/10/11 16:12:18 ==> Format Func declToken
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [d]
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> Format Func declList
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [decl ok]
2025/10/11 16:12:18 ==> AssignStmt [prev]
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [min]
2025/10/11 16:12:18 ==> AssignStmt [min]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p decl}
2025/10/11 16:12:18 ==> Format Func file
2025/10/11 16:12:18 ==> AssignStmt [0xc000195650]
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p declList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func SetDebug
2025/10/11 16:12:18 ==> AssignStmt [debugFormat]
2025/10/11 16:12:18 ==> Format Func linebreak
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [nbreaks]
2025/10/11 16:12:18 ==> AssignStmt [nbreaks]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func setComment
2025/10/11 16:12:18 ==> AssignStmt [0xc000289c08]
2025/10/11 16:12:18 ==> ExprStmt &{p flush}
2025/10/11 16:12:18 ==> AssignStmt [0xc000289d58]
2025/10/11 16:12:18 ==> ExprStmt &{p internalError}
2025/10/11 16:12:18 ==> AssignStmt [0xc0002da4e0]
2025/10/11 16:12:18 ==> AssignStmt [0xc000289de8]
2025/10/11 16:12:18 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:18 ==> Format Func identList
2025/10/11 16:12:18 ==> AssignStmt [xlist]
2025/10/11 16:12:18 ==> AssignStmt [0xc0002da870]
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> Format Func exprList
2025/10/11 16:12:18 ==> AssignStmt [prev]
2025/10/11 16:12:18 ==> AssignStmt [next]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [prev]
2025/10/11 16:12:18 ==> AssignStmt [next]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> AssignStmt [endLine]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [prevBreak]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [prevBreak]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [lnsum]
2025/10/11 16:12:18 ==> AssignStmt [count]
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> AssignStmt [useFF]
2025/10/11 16:12:18 ==> AssignStmt [prevSize]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [pair isPair]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [useFF]
2025/10/11 16:12:18 ==> AssignStmt [geomean]
2025/10/11 16:12:18 ==> AssignStmt [ratio]
2025/10/11 16:12:18 ==> AssignStmt [useFF]
2025/10/11 16:12:18 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> AssignStmt [nbreaks]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [prevBreak]
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> AssignStmt [lnsum]
2025/10/11 16:12:18 ==> AssignStmt [count]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> AssignStmt [lnsum]
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func parameters
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [parLineBeg]
2025/10/11 16:12:18 ==> AssignStmt [parLineBeg]
2025/10/11 16:12:18 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [prevLine]
2025/10/11 16:12:18 ==> AssignStmt [closing]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func signature
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> Format Func identListSize
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> Format Func isOneLineFieldList
2025/10/11 16:12:18 ==> AssignStmt [f]
2025/10/11 16:12:18 ==> AssignStmt [namesSize]
2025/10/11 16:12:18 ==> AssignStmt [namesSize]
2025/10/11 16:12:18 ==> AssignStmt [typeSize]
2025/10/11 16:12:18 ==> Format Func setLineComment
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> Format Func fieldList
2025/10/11 16:12:18 ==> AssignStmt [lbrace]
2025/10/11 16:12:18 ==> AssignStmt [list]
2025/10/11 16:12:18 ==> AssignStmt [rbrace]
2025/10/11 16:12:18 ==> AssignStmt [hasComments]
2025/10/11 16:12:18 ==> AssignStmt [srcIsOneLine]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [f]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [ftyp isFtyp]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [sep]
2025/10/11 16:12:18 ==> AssignStmt [sep]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p flush}
2025/10/11 16:12:18 ==> ExprStmt &{p setLineComment}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> AssignStmt [ftyp isFtyp]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p flush}
2025/10/11 16:12:18 ==> ExprStmt &{p setLineComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func walkBinary
2025/10/11 16:12:18 ==> AssignStmt [has4]
2025/10/11 16:12:18 ==> AssignStmt [has5]
2025/10/11 16:12:18 ==> AssignStmt [l]
2025/10/11 16:12:18 ==> AssignStmt [h4 h5 mp]
2025/10/11 16:12:18 ==> AssignStmt [has4]
2025/10/11 16:12:18 ==> AssignStmt [has5]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [r]
2025/10/11 16:12:18 ==> AssignStmt [h4 h5 mp]
2025/10/11 16:12:18 ==> AssignStmt [has4]
2025/10/11 16:12:18 ==> AssignStmt [has5]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> AssignStmt [maxProblem]
2025/10/11 16:12:18 ==> Format Func cutoff
2025/10/11 16:12:18 ==> AssignStmt [has4 has5 maxProblem]
2025/10/11 16:12:18 ==> Format Func diffPrec
2025/10/11 16:12:18 ==> AssignStmt [x ok]
2025/10/11 16:12:18 ==> Format Func reduceDepth
2025/10/11 16:12:18 ==> AssignStmt [depth]
2025/10/11 16:12:18 ==> Format Func binaryExpr
2025/10/11 16:12:18 ==> AssignStmt [prec]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [printBlank]
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [xline]
2025/10/11 16:12:18 ==> AssignStmt [yline]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [ws]
2025/10/11 16:12:18 ==> AssignStmt [printBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func isBinary
2025/10/11 16:12:18 ==> AssignStmt [_ ok]
2025/10/11 16:12:18 ==> Format Func expr1
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [x]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p internalError}
2025/10/11 16:12:18 ==> AssignStmt [depth]
2025/10/11 16:12:18 ==> AssignStmt [v ok]
2025/10/11 16:12:18 ==> ExprStmt &{p binaryExpr}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [startCol]
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p funcBody}
2025/10/11 16:12:18 ==> AssignStmt [_ hasParens]
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p selectorExpr}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [indices]
2025/10/11 16:12:18 ==> AssignStmt [indices]
2025/10/11 16:12:18 ==> AssignStmt [hasBinaries]
2025/10/11 16:12:18 ==> AssignStmt [needsBlanks]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [_ ok]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [wasIndented]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [wasIndented]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [incomplete]
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p fieldList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p fieldList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> AssignStmt [mode]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p listForPhrase}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [elt ok]
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p listForPhrase}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{log Fatalf}
2025/10/11 16:12:18 ==> Format Func listForPhrase
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> Format Func possibleSelectorExpr
2025/10/11 16:12:18 ==> AssignStmt [x ok]
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> Format Func selectorExpr
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func expr0
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> Format Func expr
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> Format Func stmtList
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [i]
2025/10/11 16:12:18 ==> AssignStmt [_ isEmpty]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> AssignStmt [lt _]
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func block
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func isTypeName
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> Format Func stripParens
2025/10/11 16:12:18 ==> AssignStmt [px strip]
2025/10/11 16:12:18 ==> ExprStmt &{ast Inspect}
2025/10/11 16:12:18 ==> AssignStmt [x]
2025/10/11 16:12:18 ==> AssignStmt [strip]
2025/10/11 16:12:18 ==> AssignStmt [x]
2025/10/11 16:12:18 ==> AssignStmt [strip]
2025/10/11 16:12:18 ==> Format Func stripParensAlways
2025/10/11 16:12:18 ==> AssignStmt [x ok]
2025/10/11 16:12:18 ==> Format Func controlClause
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [needsBlank]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func indentList
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> AssignStmt [xb]
2025/10/11 16:12:18 ==> AssignStmt [xe]
2025/10/11 16:12:18 ==> AssignStmt [line]
2025/10/11 16:12:18 ==> Format Func stmt
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [s]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p decl}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [e isEmpty]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [e ok]
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr0}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p controlClause}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p controlClause}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [body]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p controlClause}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{log Printf}
2025/10/11 16:12:18 ==> Format Func keepTypeColumn
2025/10/11 16:12:18 ==> AssignStmt [m]
2025/10/11 16:12:18 ==> AssignStmt [populate]
2025/10/11 16:12:18 ==> AssignStmt [0xc000357d70]
2025/10/11 16:12:18 ==> AssignStmt [0xc000357d70]
2025/10/11 16:12:18 ==> AssignStmt [i0]
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> AssignStmt [i0]
2025/10/11 16:12:18 ==> AssignStmt [keepType]
2025/10/11 16:12:18 ==> ExprStmt populate
2025/10/11 16:12:18 ==> AssignStmt [i0]
2025/10/11 16:12:18 ==> AssignStmt [keepType]
2025/10/11 16:12:18 ==> ExprStmt populate
2025/10/11 16:12:18 ==> Format Func valueSpec
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> AssignStmt [extraTabs]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> Format Func sanitizeImportPath
2025/10/11 16:12:18 ==> AssignStmt [s err]
2025/10/11 16:12:18 ==> AssignStmt [s]
2025/10/11 16:12:18 ==> Format Func spec
2025/10/11 16:12:18 ==> AssignStmt [s]
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p internalError}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p identList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p exprList}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt panic
2025/10/11 16:12:18 ==> Format Func genDecl
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p setPos}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setPos}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [n]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [keepType]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p valueSpec}
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p spec}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p setPos}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p spec}
2025/10/11 16:12:18 ==> Format Func nodeSize
2025/10/11 16:12:18 ==> AssignStmt [size found]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [0xc000378b70]
2025/10/11 16:12:18 ==> AssignStmt [cfg]
2025/10/11 16:12:18 ==> AssignStmt [err]
2025/10/11 16:12:18 ==> AssignStmt [size]
2025/10/11 16:12:18 ==> AssignStmt [0xc000378ea0]
2025/10/11 16:12:18 ==> Format Func numLines
2025/10/11 16:12:18 ==> AssignStmt [from]
2025/10/11 16:12:18 ==> AssignStmt [to]
2025/10/11 16:12:18 ==> Format Func bodySize
2025/10/11 16:12:18 ==> AssignStmt [pos1]
2025/10/11 16:12:18 ==> AssignStmt [pos2]
2025/10/11 16:12:18 ==> AssignStmt [bodySize]
2025/10/11 16:12:18 ==> AssignStmt [bodySize]
2025/10/11 16:12:18 ==> AssignStmt [bodySize]
2025/10/11 16:12:18 ==> Format Func funcBody
2025/10/11 16:12:18 ==> AssignStmt [0xc000373428]
2025/10/11 16:12:18 ==> AssignStmt [0xc000373458]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p block}
2025/10/11 16:12:18 ==> Format Func funcBodyUnnamed
2025/10/11 16:12:18 ==> AssignStmt [_ _]
2025/10/11 16:12:18 ==> AssignStmt [0xc000373740]
2025/10/11 16:12:18 ==> AssignStmt [0xc000373770]
2025/10/11 16:12:18 ==> AssignStmt [i]
2025/10/11 16:12:18 ==> AssignStmt [_ isEmpty]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p recordLine}
2025/10/11 16:12:18 ==> ExprStmt &{p stmt}
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> AssignStmt [lt _]
2025/10/11 16:12:18 ==> AssignStmt [t]
2025/10/11 16:12:18 ==> Format Func distanceFrom
2025/10/11 16:12:18 ==> Format Func funcDecl
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p funcBodyUnnamed}
2025/10/11 16:12:18 ==> AssignStmt [pos]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> AssignStmt [startCol]
2025/10/11 16:12:18 ==> AssignStmt [list]
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p signature}
2025/10/11 16:12:18 ==> ExprStmt &{p funcBody}
2025/10/11 16:12:18 ==> Format Func overloadFuncDecl
2025/10/11 16:12:18 ==> ExprStmt &{log Println}
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> AssignStmt [pos]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p parameters}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr1}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> Format Func decl
2025/10/11 16:12:18 ==> AssignStmt [d]
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p genDecl}
2025/10/11 16:12:18 ==> ExprStmt &{p funcDecl}
2025/10/11 16:12:18 ==> ExprStmt &{p overloadFuncDecl}
2025/10/11 16:12:18 ==> ExprStmt panic
2025/10/11 16:12:18 ==> Format Func declToken
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [d]
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> Format Func declList
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [decl ok]
2025/10/11 16:12:18 ==> AssignStmt [prev]
2025/10/11 16:12:18 ==> AssignStmt [tok]
2025/10/11 16:12:18 ==> AssignStmt [min]
2025/10/11 16:12:18 ==> AssignStmt [min]
2025/10/11 16:12:18 ==> ExprStmt &{p linebreak}
2025/10/11 16:12:18 ==> ExprStmt &{p decl}
2025/10/11 16:12:18 ==> Format Func file
2025/10/11 16:12:18 ==> AssignStmt [0xc00038ab28]
2025/10/11 16:12:18 ==> ExprStmt &{p setComment}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
2025/10/11 16:12:18 ==> ExprStmt &{p expr}
2025/10/11 16:12:18 ==> ExprStmt &{p declList}
2025/10/11 16:12:18 ==> ExprStmt &{p print}
=== RUN   TestFromGopPrinter/format.Source_printer.go
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc000124c18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000124c48]
2025/10/11 16:12:19 ==> AssignStmt [0xc000124c60]
2025/10/11 16:12:19 ==> AssignStmt [0xc000124c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000124cc0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000124d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000124d20]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125020]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125098]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125140]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc0001252f0]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000125440]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000125638]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125650]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000125800]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125878]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001258f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125980]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001259c8]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125b00]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125b78]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125ba8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125bd8]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125ce0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125d70]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125de8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125e18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125e48]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125e78]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125ea8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125ed8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000125f08]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e210]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e318]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e360]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e408]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e558]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e588]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e5b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e5e8]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e618]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e648]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e678]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e6a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e708]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001a9020]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001a94a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001a9890]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc00041ef30]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc00041fe60]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc00019e1e0 0xc00019e240]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc00019e600]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc00019e8a0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000fbc0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000fbc0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000fbf0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00019f0b0]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00019f680]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00019f8c0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00042e7f8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001b11a0 0xc0001b1230]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042ea68]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00042ed20]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00042efd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f038]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f098]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f1e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001c8360]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f2a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f2c0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f350]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f3c8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f518]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001c87b0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f668]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f6b0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f758]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042f9f8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00042fa40]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00042fa70]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e63c0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6438]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6498]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6600]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6720]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e69f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6a08]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6bb8]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6cc0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6d50]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6e10]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6f00]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e72f0]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
=== RUN   TestFromGopPrinter/format.Node_printer.go
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc000259e00]
2025/10/11 16:12:19 ==> AssignStmt [0xc000259e30]
2025/10/11 16:12:19 ==> AssignStmt [0xc000259e48]
2025/10/11 16:12:19 ==> AssignStmt [0xc000259e78]
2025/10/11 16:12:19 ==> AssignStmt [0xc000259ea8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000259ef0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000259f08]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cc270]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cc288]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cc2e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cc390]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cc540]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cc690]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cc888]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cc8a0]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cca50]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002ccac8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002ccb40]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002ccbd0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002ccc18]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002ccd50]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002ccdc8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002ccdf8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cce28]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002ccf30]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002ccfc0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd038]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd068]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd098]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd0c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd0f8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd128]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd158]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd3c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd458]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd4d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd518]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd548]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd5c0]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd710]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd740]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd770]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd7a0]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd7d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd800]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd830]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd860]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd878]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002cd8c0]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002d7bc0]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002de0c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002de4b0]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002dfaa0]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e8a50]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e8d50 0xc0002e8db0]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e9170]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e9410]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e0df8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e0df8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e0e28]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e9c20]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc0002f4270]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002f4480]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e1998]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002f5ce0 0xc0002f5d70]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e1c08]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e1ec0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc1f8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc258]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc2b8]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc408]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002faea0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc4c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc4e0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc570]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc5e8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc738]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fb2f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc888]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc8d0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fc978]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fcc18]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fcc60]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fcc90]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fd560]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fd5d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fd638]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fd7a0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fd8c0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fdb90]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fdba8]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fdd58]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fde60]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002fdef0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc000318030]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc000318120]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc000318510]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc000344fa8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000344fd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000344ff0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345020]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345050]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345098]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003450b0]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345398]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003453b0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345410]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003454b8]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000345668]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc0003457b8]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc0003459b0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003459c8]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000345b78]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345bf0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345c68]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345cf8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345d40]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345e78]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345ef0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345f20]
2025/10/11 16:12:19 ==> AssignStmt [0xc000345f50]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003920d8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392168]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003921e0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392210]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392240]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392270]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003922a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003922d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392300]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000392570]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392600]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392678]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003926c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003926f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392768]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003928b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003928e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392918]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392948]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392978]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003929a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003929d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392a08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392a20]
2025/10/11 16:12:19 ==> AssignStmt [0xc000392a68]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00039a6f0]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00039ab70]
2025/10/11 16:12:19 ==> AssignStmt [0xc00039af60]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003a45d0]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003a5500]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003a5800 0xc0003a5860]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003a5c20]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003a5ec0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc000393f20]
2025/10/11 16:12:19 ==> AssignStmt [0xc000393f20]
2025/10/11 16:12:19 ==> AssignStmt [0xc000393f50]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003ac750]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc0003acd20]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003acf30]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b0b40]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b8810 0xc0003b88a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b0db0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1068]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1320]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1380]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b13e0]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1530]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b9950]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b15f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1608]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1698]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1710]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1860]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b9da0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b19b0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b19f8]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1aa0]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1d40]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1d88]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc0003b1db8]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c8708]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c8780]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c87e0]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c8948]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c8a68]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c8d38]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c8d50]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c8f00]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c9008]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c9098]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c9158]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c9248]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003c9638]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
=== RUN   TestFromGopPrinter/format.Source_printer_test.go
2025/10/11 16:12:19 ==> Format Func format
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{ast FileExports}
2025/10/11 16:12:19 ==> AssignStmt [0xc000488cd8]
2025/10/11 16:12:19 ==> AssignStmt [cfg]
2025/10/11 16:12:19 ==> AssignStmt [0xc000488d50]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [res]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func TestLineComments
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> ExprStmt Fprint
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func testComment
2025/10/11 16:12:19 ==> AssignStmt [0xc0001a82a0]
2025/10/11 16:12:19 ==> AssignStmt [offs]
2025/10/11 16:12:19 ==> ExprStmt &{buf Reset}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> Format Func TestBadComments
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> AssignStmt [comment]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> Format Func Visit
2025/10/11 16:12:19 ==> AssignStmt [ident ok]
2025/10/11 16:12:19 ==> Format Func idents
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> ExprStmt &{ast Walk}
2025/10/11 16:12:19 ==> ExprStmt close
2025/10/11 16:12:19 ==> Format Func identCount
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func TestSourcePos
2025/10/11 16:12:19 ==> AssignStmt [f1 err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [f2 err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> AssignStmt [n1]
2025/10/11 16:12:19 ==> AssignStmt [n2]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> AssignStmt [i2range]
2025/10/11 16:12:19 ==> AssignStmt [i2]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> AssignStmt [l1]
2025/10/11 16:12:19 ==> AssignStmt [l2]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{t Logf}
2025/10/11 16:12:19 ==> Format Func TestIssue5945
2025/10/11 16:12:19 ==> AssignStmt [f1 err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestDeclLists
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestStmtLists
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestBaseIndent
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> AssignStmt [src err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [indent]
2025/10/11 16:12:19 ==> AssignStmt [indent]
2025/10/11 16:12:19 ==> ExprStmt &{t Run}
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> ExprStmt &{0xc0003c66a0 Fprint}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> ExprStmt &{0xc0003c66a0 Fprint}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestFuncType
2025/10/11 16:12:19 ==> AssignStmt [src]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00041a660]
2025/10/11 16:12:19 ==> Format Func TestWriteErrors
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> AssignStmt [src err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [lw]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> Format Func TestX
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> Format Func TestCommentedNode
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{buf Reset}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestIssue11151
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt Fprint
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestParenthesizedDecl
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [original]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00041ae70]
2025/10/11 16:12:19 ==> ExprStmt &{buf Reset}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [noparen]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestIssue32854
2025/10/11 16:12:19 ==> AssignStmt [src]
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [fd]
2025/10/11 16:12:19 ==> AssignStmt [ret]
2025/10/11 16:12:19 ==> AssignStmt [0xc000317e60]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [want]
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> Format Func TestStripParens
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [y ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
=== RUN   TestFromGopPrinter/format.Node_printer_test.go
2025/10/11 16:12:19 ==> Format Func format
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{ast FileExports}
2025/10/11 16:12:19 ==> AssignStmt [0xc000702798]
2025/10/11 16:12:19 ==> AssignStmt [cfg]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [res]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func TestLineComments
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> ExprStmt Fprint
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func testComment
2025/10/11 16:12:19 ==> AssignStmt [0xc000254930]
2025/10/11 16:12:19 ==> AssignStmt [offs]
2025/10/11 16:12:19 ==> ExprStmt &{buf Reset}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> Format Func TestBadComments
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> AssignStmt [comment]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> Format Func Visit
2025/10/11 16:12:19 ==> AssignStmt [ident ok]
2025/10/11 16:12:19 ==> Format Func idents
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> ExprStmt &{ast Walk}
2025/10/11 16:12:19 ==> ExprStmt close
2025/10/11 16:12:19 ==> Format Func identCount
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func TestSourcePos
2025/10/11 16:12:19 ==> AssignStmt [f1 err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [f2 err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> AssignStmt [n1]
2025/10/11 16:12:19 ==> AssignStmt [n2]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> AssignStmt [i2range]
2025/10/11 16:12:19 ==> AssignStmt [i2]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> AssignStmt [l1]
2025/10/11 16:12:19 ==> AssignStmt [l2]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{t Logf}
2025/10/11 16:12:19 ==> Format Func TestIssue5945
2025/10/11 16:12:19 ==> AssignStmt [f1 err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestDeclLists
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestStmtLists
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestBaseIndent
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> AssignStmt [src err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [indent]
2025/10/11 16:12:19 ==> AssignStmt [indent]
2025/10/11 16:12:19 ==> ExprStmt &{t Run}
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> ExprStmt &{0xc00027fa20 Fprint}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> ExprStmt &{0xc00027fa20 Fprint}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestFuncType
2025/10/11 16:12:19 ==> AssignStmt [src]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc000124378]
2025/10/11 16:12:19 ==> Format Func TestWriteErrors
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> AssignStmt [src err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [lw]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> Format Func TestX
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> Format Func TestCommentedNode
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{buf Reset}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestIssue11151
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt Fprint
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestParenthesizedDecl
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [original]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000124b10]
2025/10/11 16:12:19 ==> ExprStmt &{buf Reset}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [noparen]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestIssue32854
2025/10/11 16:12:19 ==> AssignStmt [src]
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [fd]
2025/10/11 16:12:19 ==> AssignStmt [ret]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002864e0]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [want]
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> Format Func TestStripParens
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [y ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> Format Func format
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{ast FileExports}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e3f0]
2025/10/11 16:12:19 ==> AssignStmt [cfg]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e468]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [res]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func TestLineComments
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> ExprStmt Fprint
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func testComment
2025/10/11 16:12:19 ==> AssignStmt [0xc0002c46f0]
2025/10/11 16:12:19 ==> AssignStmt [offs]
2025/10/11 16:12:19 ==> ExprStmt &{buf Reset}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> Format Func TestBadComments
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> AssignStmt [comment]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> ExprStmt testComment
2025/10/11 16:12:19 ==> Format Func Visit
2025/10/11 16:12:19 ==> AssignStmt [ident ok]
2025/10/11 16:12:19 ==> Format Func idents
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> ExprStmt &{ast Walk}
2025/10/11 16:12:19 ==> ExprStmt close
2025/10/11 16:12:19 ==> Format Func identCount
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func TestSourcePos
2025/10/11 16:12:19 ==> AssignStmt [f1 err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [f2 err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> AssignStmt [n1]
2025/10/11 16:12:19 ==> AssignStmt [n2]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> AssignStmt [i2range]
2025/10/11 16:12:19 ==> AssignStmt [i2]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> AssignStmt [l1]
2025/10/11 16:12:19 ==> AssignStmt [l2]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{t Logf}
2025/10/11 16:12:19 ==> Format Func TestIssue5945
2025/10/11 16:12:19 ==> AssignStmt [f1 err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestDeclLists
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestStmtLists
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestBaseIndent
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> AssignStmt [src err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [indent]
2025/10/11 16:12:19 ==> AssignStmt [indent]
2025/10/11 16:12:19 ==> ExprStmt &{t Run}
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> ExprStmt &{0xc0002d1a60 Fprint}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> ExprStmt &{0xc0002d1a60 Fprint}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestFuncType
2025/10/11 16:12:19 ==> AssignStmt [src]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000fcf8]
2025/10/11 16:12:19 ==> Format Func TestWriteErrors
2025/10/11 16:12:19 ==> ExprStmt &{t Parallel}
2025/10/11 16:12:19 ==> AssignStmt [src err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [lw]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> Format Func TestX
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{t Error}
2025/10/11 16:12:19 ==> Format Func TestCommentedNode
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> ExprStmt &{buf Reset}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestIssue11151
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> ExprStmt Fprint
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestParenthesizedDecl
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [original]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6510]
2025/10/11 16:12:19 ==> ExprStmt &{buf Reset}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [noparen]
2025/10/11 16:12:19 ==> ExprStmt &{t Errorf}
2025/10/11 16:12:19 ==> Format Func TestIssue32854
2025/10/11 16:12:19 ==> AssignStmt [src]
2025/10/11 16:12:19 ==> AssignStmt [fset]
2025/10/11 16:12:19 ==> AssignStmt [file err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [fd]
2025/10/11 16:12:19 ==> AssignStmt [ret]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e42a0]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [want]
2025/10/11 16:12:19 ==> AssignStmt [got]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatalf}
2025/10/11 16:12:19 ==> Format Func TestStripParens
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [y ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
--- PASS: TestFromGopPrinter (0.23s)
    --- PASS: TestFromGopPrinter/format.Source_nodes.go (0.04s)
    --- PASS: TestFromGopPrinter/format.Node_nodes.go (0.08s)
    --- PASS: TestFromGopPrinter/format.Source_printer.go (0.02s)
    --- PASS: TestFromGopPrinter/format.Node_printer.go (0.05s)
    --- PASS: TestFromGopPrinter/format.Source_printer_test.go (0.01s)
    --- PASS: TestFromGopPrinter/format.Node_printer_test.go (0.02s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/02-Var-and-operator/var_and_op.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [y z]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/02-Var-and-operator/var_and_op.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [y z]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/03-Import-go-package/import.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/03-Import-go-package/import.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/04-Func/func.xgo
2025/10/11 16:12:19 ==> Format Func foo
2025/10/11 16:12:19 ==> Format Func printf
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> Format Func bar
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt bar
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/04-Func/func.xgo
2025/10/11 16:12:19 ==> Format Func foo
2025/10/11 16:12:19 ==> Format Func printf
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> Format Func bar
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt bar
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> Format Func foo
2025/10/11 16:12:19 ==> Format Func printf
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> Format Func bar
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt bar
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/05-Closure/closure.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [foo]
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> AssignStmt [printf]
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> AssignStmt [bar]
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt bar
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/05-Closure/closure.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [foo]
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> AssignStmt [printf]
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> AssignStmt [n err]
2025/10/11 16:12:19 ==> AssignStmt [bar]
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt bar
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/06-String-Map-Array-Slice/datastruct.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003525a0 0xc000352600]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000352900 0xc000352930]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [arr]
2025/10/11 16:12:19 ==> AssignStmt [title]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/06-String-Map-Array-Slice/datastruct.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc0003534d0 0xc000353530]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000353830 0xc000353860]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [arr]
2025/10/11 16:12:19 ==> AssignStmt [title]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/07-MapLit/maplit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/07-MapLit/maplit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/08-SliceLit/slicelit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/08-SliceLit/slicelit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/09-IfElse-SwitchCase/flow.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/09-IfElse-SwitchCase/flow.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/10-List-comprehension/list_comprehens.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [arr]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/10-List-comprehension/list_comprehens.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [arr]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/11-Map-comprehension/map_comprehens.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/11-Map-comprehension/map_comprehens.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/12-Select-comprehension/select.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [where]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [at ok]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/12-Select-comprehension/select.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [where]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [at ok]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/12-Select-comprehension2/findscore.xgo
2025/10/11 16:12:19 ==> Format Func findScore
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/12-Select-comprehension2/findscore.xgo
2025/10/11 16:12:19 ==> Format Func findScore
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/13-Exists-comprehension/exists.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [hasFullMark]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [hasFailed]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/13-Exists-comprehension/exists.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [hasFullMark]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [hasFailed]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo.xgo
2025/10/11 16:12:19 ==> Format Func ReverseMap
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo.xgo
2025/10/11 16:12:19 ==> Format Func ReverseMap
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo_test.xgo
2025/10/11 16:12:19 ==> Format Func TestReverseMap
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo_test.xgo
2025/10/11 16:12:19 ==> Format Func TestReverseMap
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> Format Func TestReverseMap
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/footest_test.xgo
2025/10/11 16:12:19 ==> Format Func TestReverseMap
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/footest_test.xgo
2025/10/11 16:12:19 ==> Format Func TestReverseMap
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
2025/10/11 16:12:19 ==> Format Func TestReverseMap
2025/10/11 16:12:19 ==> AssignStmt [out]
2025/10/11 16:12:19 ==> ExprStmt &{t Fatal}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/15-ErrWrap/err_wrap.xgo
2025/10/11 16:12:19 ==> Format Func add
2025/10/11 16:12:19 ==> Format Func addSafe
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum err]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/15-ErrWrap/err_wrap.xgo
2025/10/11 16:12:19 ==> Format Func add
2025/10/11 16:12:19 ==> Format Func addSafe
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum err]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func add
2025/10/11 16:12:19 ==> Format Func addSafe
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum err]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/16-Fib/fib.xgo
2025/10/11 16:12:19 ==> Format Func fib
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/16-Fib/fib.xgo
2025/10/11 16:12:19 ==> Format Func fib
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/17-Fibtc/fibtc.xgo
2025/10/11 16:12:19 ==> Format Func fibtc
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/17-Fibtc/fibtc.xgo
2025/10/11 16:12:19 ==> Format Func fibtc
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/18-Rational/rational.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/18-Rational/rational.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/21-Break-continue-goto/flow.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [arr]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/21-Break-continue-goto/flow.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [arr]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/22-For-loop/for.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [fns]
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> AssignStmt [0xc000000c90]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> AssignStmt [0xc000001410]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [arr]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/22-For-loop/for.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [fns]
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> AssignStmt [0xc0000ea870]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> AssignStmt [0xc0000eaff0]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [arr]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/23-Defer/defer.xgo
2025/10/11 16:12:19 ==> Format Func f
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> Format Func g
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> Format Func h
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/23-Defer/defer.xgo
2025/10/11 16:12:19 ==> Format Func f
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> Format Func g
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> Format Func h
2025/10/11 16:12:19 ==> AssignStmt [v]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/24-Goroutine/goroutine.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt &{time Sleep}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/24-Goroutine/goroutine.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt &{time Sleep}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/25-Struct/struct.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [0xc0003f9920 0xc0003f9938]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [0xc0003f9950 0xc0003f9968]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [0xc0003f9980 0xc0003f9998]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/25-Struct/struct.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [0xc000702168 0xc000702180]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [0xc000702198 0xc0007021b0]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [0xc0007021c8 0xc0007021e0]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/26-Method/method.xgo
2025/10/11 16:12:19 ==> Format Func SetName
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func SetAge
2025/10/11 16:12:19 ==> AssignStmt [age]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007023a8]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func AddFriends
2025/10/11 16:12:19 ==> AssignStmt [0xc000702408]
2025/10/11 16:12:19 ==> Format Func Foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [p]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702438 0xc000702450]
2025/10/11 16:12:19 ==> ExprStmt &{p SetName}
2025/10/11 16:12:19 ==> ExprStmt &{p SetAge}
2025/10/11 16:12:19 ==> ExprStmt &{p AddFriends}
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt &{m Foo}
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/26-Method/method.xgo
2025/10/11 16:12:19 ==> Format Func SetName
2025/10/11 16:12:19 ==> AssignStmt [0xc0007026f0]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func SetAge
2025/10/11 16:12:19 ==> AssignStmt [age]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func AddFriends
2025/10/11 16:12:19 ==> AssignStmt [0xc000702798]
2025/10/11 16:12:19 ==> Format Func Foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [p]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007027c8 0xc0007027e0]
2025/10/11 16:12:19 ==> ExprStmt &{p SetName}
2025/10/11 16:12:19 ==> ExprStmt &{p SetAge}
2025/10/11 16:12:19 ==> ExprStmt &{p AddFriends}
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt &{m Foo}
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/27-Func-Set/func.xgo
2025/10/11 16:12:19 ==> Format Func A
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b10]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b40]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b70]
2025/10/11 16:12:19 ==> Format Func Index
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a1]
2025/10/11 16:12:19 ==> AssignStmt [a2]
2025/10/11 16:12:19 ==> AssignStmt [a3]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt A
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c30]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c60]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/27-Func-Set/func.xgo
2025/10/11 16:12:19 ==> Format Func A
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f60]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702fc0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ff0]
2025/10/11 16:12:19 ==> Format Func Index
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a1]
2025/10/11 16:12:19 ==> AssignStmt [a2]
2025/10/11 16:12:19 ==> AssignStmt [a3]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt A
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030b0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030e0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/28-Chan/chan.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt close
2025/10/11 16:12:19 ==> AssignStmt [d]
2025/10/11 16:12:19 ==> AssignStmt [e ok]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/28-Chan/chan.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt close
2025/10/11 16:12:19 ==> AssignStmt [d]
2025/10/11 16:12:19 ==> AssignStmt [e ok]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/29-CompareToNil/ref.xgo
2025/10/11 16:12:19 ==> Format Func foo
2025/10/11 16:12:19 ==> Format Func foo1
2025/10/11 16:12:19 ==> Format Func foo2
2025/10/11 16:12:19 ==> Format Func foo3
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/29-CompareToNil/ref.xgo
2025/10/11 16:12:19 ==> Format Func foo
2025/10/11 16:12:19 ==> Format Func foo1
2025/10/11 16:12:19 ==> Format Func foo2
2025/10/11 16:12:19 ==> Format Func foo3
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/30-Recover/recover.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt panic
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/30-Recover/recover.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt panic
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/31-Builtin-Typecast/builtin_and_typecast.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/31-Builtin-Typecast/builtin_and_typecast.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/32-Import-gop-package/import_gop_pkg.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [rmap]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/32-Import-gop-package/import_gop_pkg.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [rmap]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/33-Interface/shape.xgo
2025/10/11 16:12:19 ==> Format Func Area
2025/10/11 16:12:19 ==> Format Func Area
2025/10/11 16:12:19 ==> Format Func Area
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [rect]
2025/10/11 16:12:19 ==> AssignStmt [circle]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/33-Interface/shape.xgo
2025/10/11 16:12:19 ==> Format Func Area
2025/10/11 16:12:19 ==> Format Func Area
2025/10/11 16:12:19 ==> Format Func Area
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [rect]
2025/10/11 16:12:19 ==> AssignStmt [circle]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/34-Type-assert/type_assert.xgo
2025/10/11 16:12:19 ==> Format Func foo
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> Format Func add
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/34-Type-assert/type_assert.xgo
2025/10/11 16:12:19 ==> Format Func foo
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> Format Func add
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/35-Chan-select/select.xgo
2025/10/11 16:12:19 ==> Format Func consume
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func product
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [from]
2025/10/11 16:12:19 ==> AssignStmt [xchg]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt close
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/35-Chan-select/select.xgo
2025/10/11 16:12:19 ==> Format Func consume
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func product
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [from]
2025/10/11 16:12:19 ==> AssignStmt [xchg]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt close
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/36-Auto-Property/autoprop.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [script]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/36-Auto-Property/autoprop.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [script]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [script]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/37-Cmdline/cmdline.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/37-Cmdline/cmdline.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/38-Overload-operator/overload_op.xgo
2025/10/11 16:12:19 ==> Format Func Int
2025/10/11 16:12:19 ==> Format Func +
2025/10/11 16:12:19 ==> Format Func +=
2025/10/11 16:12:19 ==> ExprStmt &{0xc000124ca8 Add}
2025/10/11 16:12:19 ==> Format Func -
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/38-Overload-operator/overload_op.xgo
2025/10/11 16:12:19 ==> Format Func Int
2025/10/11 16:12:19 ==> Format Func +
2025/10/11 16:12:19 ==> Format Func +=
2025/10/11 16:12:19 ==> ExprStmt &{0xc00000e168 Add}
2025/10/11 16:12:19 ==> Format Func -
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/39-Lambda-expression/lambda.xgo
2025/10/11 16:12:19 ==> Format Func Map
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/39-Lambda-expression/lambda.xgo
2025/10/11 16:12:19 ==> Format Func Map
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/40-Deduce-struct-type/deduce.xgo
2025/10/11 16:12:19 ==> Format Func foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [ret]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/40-Deduce-struct-type/deduce.xgo
2025/10/11 16:12:19 ==> Format Func foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [ret]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/41-UDT-RangeForEach/udt_range.xgo
2025/10/11 16:12:19 ==> Format Func Gop_Enum
2025/10/11 16:12:19 ==> ExprStmt proc
2025/10/11 16:12:19 ==> ExprStmt proc
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/41-UDT-RangeForEach/udt_range.xgo
2025/10/11 16:12:19 ==> Format Func Gop_Enum
2025/10/11 16:12:19 ==> ExprStmt proc
2025/10/11 16:12:19 ==> ExprStmt proc
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/42-UDT-RangeIterator/udt_range_iter.xgo
2025/10/11 16:12:19 ==> Format Func Next
2025/10/11 16:12:19 ==> AssignStmt [key val ok]
2025/10/11 16:12:19 ==> Format Func newFoo
2025/10/11 16:12:19 ==> Format Func Gop_Enum
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [obj]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/42-UDT-RangeIterator/udt_range_iter.xgo
2025/10/11 16:12:19 ==> Format Func Next
2025/10/11 16:12:19 ==> AssignStmt [key val ok]
2025/10/11 16:12:19 ==> Format Func newFoo
2025/10/11 16:12:19 ==> Format Func Gop_Enum
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [obj]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/43-RangeExpr/rangeexpr.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/43-RangeExpr/rangeexpr.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
--- PASS: TestFromTestdata (0.05s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/02-Var-and-operator/var_and_op.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/02-Var-and-operator/var_and_op.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/03-Import-go-package/import.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/03-Import-go-package/import.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/04-Func/func.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/04-Func/func.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/05-Closure/closure.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/05-Closure/closure.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/06-String-Map-Array-Slice/datastruct.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/06-String-Map-Array-Slice/datastruct.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/07-MapLit/maplit.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/07-MapLit/maplit.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/08-SliceLit/slicelit.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/08-SliceLit/slicelit.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/09-IfElse-SwitchCase/flow.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/09-IfElse-SwitchCase/flow.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/10-List-comprehension/list_comprehens.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/10-List-comprehension/list_comprehens.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/11-Map-comprehension/map_comprehens.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/11-Map-comprehension/map_comprehens.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/12-Select-comprehension/select.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/12-Select-comprehension/select.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/12-Select-comprehension2/findscore.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/12-Select-comprehension2/findscore.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/13-Exists-comprehension/exists.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/13-Exists-comprehension/exists.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo_test.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo_test.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/footest_test.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/footest_test.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/15-ErrWrap/err_wrap.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/15-ErrWrap/err_wrap.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/16-Fib/fib.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/16-Fib/fib.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/17-Fibtc/fibtc.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/17-Fibtc/fibtc.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/18-Rational/rational.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/18-Rational/rational.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/21-Break-continue-goto/flow.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/21-Break-continue-goto/flow.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/22-For-loop/for.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/22-For-loop/for.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/23-Defer/defer.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/23-Defer/defer.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/24-Goroutine/goroutine.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/24-Goroutine/goroutine.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/25-Struct/struct.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/25-Struct/struct.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/26-Method/method.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/26-Method/method.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/27-Func-Set/func.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/27-Func-Set/func.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/28-Chan/chan.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/28-Chan/chan.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/29-CompareToNil/ref.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/29-CompareToNil/ref.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/30-Recover/recover.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/30-Recover/recover.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/31-Builtin-Typecast/builtin_and_typecast.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/31-Builtin-Typecast/builtin_and_typecast.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/32-Import-gop-package/import_gop_pkg.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/32-Import-gop-package/import_gop_pkg.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/33-Interface/shape.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/33-Interface/shape.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/34-Type-assert/type_assert.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/34-Type-assert/type_assert.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/35-Chan-select/select.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/35-Chan-select/select.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/36-Auto-Property/autoprop.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/36-Auto-Property/autoprop.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/37-Cmdline/cmdline.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/37-Cmdline/cmdline.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/38-Overload-operator/overload_op.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/38-Overload-operator/overload_op.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/39-Lambda-expression/lambda.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/39-Lambda-expression/lambda.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/40-Deduce-struct-type/deduce.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/40-Deduce-struct-type/deduce.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/41-UDT-RangeForEach/udt_range.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/41-UDT-RangeForEach/udt_range.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/42-UDT-RangeIterator/udt_range_iter.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/42-UDT-RangeIterator/udt_range_iter.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/43-RangeExpr/rangeexpr.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/43-RangeExpr/rangeexpr.xgo (0.00s)
=== RUN   TestFromParse
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/append1/append.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/append1/append.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/append2/append.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/append2/append.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/arrowop/arrowop.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
2025/10/11 16:12:19 ==> ExprStmt echo
2025/10/11 16:12:19 ==> ExprStmt echo
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/arrowop/arrowop.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
2025/10/11 16:12:19 ==> ExprStmt echo
2025/10/11 16:12:19 ==> ExprStmt echo
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/autoprop/goto.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/autoprop/goto.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/build/build.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [title]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/build/build.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [title]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/c2gohello/hello.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{C printf}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/c2gohello/hello.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{C printf}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle1/cmd.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle1/cmd.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle2/cmd2.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt x
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle2/cmd2.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt x
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle3/cmd3.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle3/cmd3.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle4/cmd4.xgo
2025/10/11 16:12:19 ==> Format Func call
2025/10/11 16:12:19 ==> ExprStmt fn
2025/10/11 16:12:19 ==> ExprStmt fn
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt call
2025/10/11 16:12:19 ==> ExprStmt call
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt call
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle4/cmd4.xgo
2025/10/11 16:12:19 ==> Format Func call
2025/10/11 16:12:19 ==> ExprStmt fn
2025/10/11 16:12:19 ==> ExprStmt fn
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt call
2025/10/11 16:12:19 ==> ExprStmt call
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt call
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/collection/collection.xgo
2025/10/11 16:12:19 ==> Format Func Index
2025/10/11 16:12:19 ==> Format Func Include
2025/10/11 16:12:19 ==> Format Func Any
2025/10/11 16:12:19 ==> Format Func All
2025/10/11 16:12:19 ==> Format Func Filter
2025/10/11 16:12:19 ==> AssignStmt [vsf]
2025/10/11 16:12:19 ==> AssignStmt [vsf]
2025/10/11 16:12:19 ==> Format Func Map
2025/10/11 16:12:19 ==> AssignStmt [vsm]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002aef90]
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/collection/collection.xgo
2025/10/11 16:12:19 ==> Format Func Index
2025/10/11 16:12:19 ==> Format Func Include
2025/10/11 16:12:19 ==> Format Func Any
2025/10/11 16:12:19 ==> Format Func All
2025/10/11 16:12:19 ==> Format Func Filter
2025/10/11 16:12:19 ==> AssignStmt [vsf]
2025/10/11 16:12:19 ==> AssignStmt [vsf]
2025/10/11 16:12:19 ==> Format Func Map
2025/10/11 16:12:19 ==> AssignStmt [vsm]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002c5800]
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> Format Func Index
2025/10/11 16:12:19 ==> Format Func Include
2025/10/11 16:12:19 ==> Format Func Any
2025/10/11 16:12:19 ==> Format Func All
2025/10/11 16:12:19 ==> Format Func Filter
2025/10/11 16:12:19 ==> AssignStmt [vsf]
2025/10/11 16:12:19 ==> AssignStmt [vsf]
2025/10/11 16:12:19 ==> Format Func Map
2025/10/11 16:12:19 ==> AssignStmt [vsm]
2025/10/11 16:12:19 ==> AssignStmt [0xc0002e4090]
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/complit/complit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/complit/complit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/domainhuh/huh.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [form]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/domainhuh/huh.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [form]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/domaintext/tpl.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [cl]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/domaintext/tpl.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [cl]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/domaintpl/tpl.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [cl]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/domaintpl/tpl.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [cl]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/embedded1/embtype.xgo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/embedded1/embtype.xgo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/envop1/envop.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/envop1/envop.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/envop2/envop.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/envop2/envop.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/errwrap1/errwrap.xgo
2025/10/11 16:12:19 ==> Format Func add
2025/10/11 16:12:19 ==> Format Func addSafe
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum err]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/errwrap1/errwrap.xgo
2025/10/11 16:12:19 ==> Format Func add
2025/10/11 16:12:19 ==> Format Func addSafe
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum err]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func add
2025/10/11 16:12:19 ==> Format Func addSafe
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum err]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/errwrap2/errwrap2.xgo
2025/10/11 16:12:19 ==> Format Func neg
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/errwrap2/errwrap2.xgo
2025/10/11 16:12:19 ==> Format Func neg
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/errwrap3/errwrap3.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{mkdir ! 6 <nil>}
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/errwrap3/errwrap3.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{mkdir ! 6 <nil>}
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/exists/exists.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [hasEven]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/exists/exists.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [hasEven]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/fnbody/fnbody.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/fnbody/fnbody.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/fncall/fncall.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{fn 3 [0xc000332c00] 0 [] 5 0}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/fncall/fncall.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{fn 3 [0xc000332e70] 0 [] 5 0}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/forloop/forloop.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/forloop/forloop.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [sum]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/funcdecl1/fndecl.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{0xc00034c180 0xc000348ae0}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/funcdecl1/fndecl.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{0xc00034c2a0 0xc000348f30}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/funcdecl2/fndecl.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{0xc00034c360 0xc0003492f0}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/funcdecl2/fndecl.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{0xc00034c3e0 0xc0003495f0}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/funcdecl3/fndecl.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{0xc00034c4e0 0xc000349950}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/funcdecl3/fndecl.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{0xc00034c5a0 0xc000349d10}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/funcdoc/funcdoc.xgo
2025/10/11 16:12:19 ==> Format Func test
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/funcdoc/funcdoc.xgo
2025/10/11 16:12:19 ==> Format Func test
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/funclit/funclit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{0xc00034cb60 0xc000350900}
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/funclit/funclit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt &{0xc00034cd60 0xc000350e40}
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/goto1/goto.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt goto
2025/10/11 16:12:19 ==> ExprStmt goto
2025/10/11 16:12:19 ==> ExprStmt goto
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/goto1/goto.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt goto
2025/10/11 16:12:19 ==> ExprStmt goto
2025/10/11 16:12:19 ==> ExprStmt goto
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/goto2/goto.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt goto
2025/10/11 16:12:19 ==> ExprStmt goto
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/goto2/goto.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt goto
2025/10/11 16:12:19 ==> ExprStmt goto
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/goxtest1/bar.gox
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/goxtest1/bar.gox
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/goxtest2/bar.gox
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/goxtest2/bar.gox
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/kwargs1/kwargs.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt playSound
2025/10/11 16:12:19 ==> ExprStmt listDir
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/kwargs1/kwargs.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt playSound
2025/10/11 16:12:19 ==> ExprStmt listDir
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/lambda1/lambda.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt foo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/lambda1/lambda.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt foo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/lambda2/lambda2.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/lambda2/lambda2.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/lambda3/lambda3.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/lambda3/lambda3.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt foo
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/lambda4/lambda4.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/lambda4/lambda4.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/listcompr/listcompr.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [arr]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/listcompr/listcompr.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [z]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [arr]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/mapfunc/map.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt map
2025/10/11 16:12:19 ==> ExprStmt map
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/mapfunc/map.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt map
2025/10/11 16:12:19 ==> ExprStmt map
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/matrix1/matrix.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/matrix1/matrix.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/matrix2/matrix.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/matrix2/matrix.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/mytest/mytest.xgo
2025/10/11 16:12:19 ==> Format Func bar
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [foo ok]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/mytest/mytest.xgo
2025/10/11 16:12:19 ==> Format Func bar
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [foo ok]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func bar
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [f err]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [foo ok]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/optparam/optparam.xgo
2025/10/11 16:12:19 ==> Format Func single
2025/10/11 16:12:19 ==> Format Func multiple
2025/10/11 16:12:19 ==> Format Func mixed
2025/10/11 16:12:19 ==> Format Func pointer
2025/10/11 16:12:19 ==> Format Func complex
2025/10/11 16:12:19 ==> Format Func arrays
2025/10/11 16:12:19 ==> Format Func interfaces
2025/10/11 16:12:19 ==> Format Func structs
2025/10/11 16:12:19 ==> Format Func funcs
2025/10/11 16:12:19 ==> Format Func qualified
2025/10/11 16:12:19 ==> Format Func unnamed
2025/10/11 16:12:19 ==> Format Func allOptional
2025/10/11 16:12:19 ==> Format Func withVariadic
2025/10/11 16:12:19 ==> Format Func Handle
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/optparam/optparam.xgo
2025/10/11 16:12:19 ==> Format Func single
2025/10/11 16:12:19 ==> Format Func multiple
2025/10/11 16:12:19 ==> Format Func mixed
2025/10/11 16:12:19 ==> Format Func pointer
2025/10/11 16:12:19 ==> Format Func complex
2025/10/11 16:12:19 ==> Format Func arrays
2025/10/11 16:12:19 ==> Format Func interfaces
2025/10/11 16:12:19 ==> Format Func structs
2025/10/11 16:12:19 ==> Format Func funcs
2025/10/11 16:12:19 ==> Format Func qualified
2025/10/11 16:12:19 ==> Format Func unnamed
2025/10/11 16:12:19 ==> Format Func allOptional
2025/10/11 16:12:19 ==> Format Func withVariadic
2025/10/11 16:12:19 ==> Format Func Handle
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/overload1/overload.xgo
2025/10/11 16:12:19 ==> Format OverloadFunc foo
2025/10/11 16:12:19 ==> Format OverloadFunc bar
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/overload1/overload.xgo
2025/10/11 16:12:19 ==> Format OverloadFunc foo
2025/10/11 16:12:19 ==> Format OverloadFunc bar
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/overload2/overload2.xgo
2025/10/11 16:12:19 ==> Format OverloadFunc *
2025/10/11 16:12:19 ==> Format OverloadFunc add
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/overload2/overload2.xgo
2025/10/11 16:12:19 ==> Format OverloadFunc *
2025/10/11 16:12:19 ==> Format OverloadFunc add
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/overloadop/op_overload.xgo
2025/10/11 16:12:19 ==> Format Func *
2025/10/11 16:12:19 ==> Format Func +
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func /
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func -
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func ++
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/overloadop/op_overload.xgo
2025/10/11 16:12:19 ==> Format Func *
2025/10/11 16:12:19 ==> Format Func +
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func /
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func -
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> Format Func ++
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/printvariadic/printv.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/printvariadic/printv.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/pystr/pystr.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt print
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/pystr/pystr.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt print
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/rangeexpr1/rangeexpr.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/rangeexpr1/rangeexpr.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/rangeexpr2/rangeexpr.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/rangeexpr2/rangeexpr.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/rangeexpr3/rangeexpr.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/rangeexpr3/rangeexpr.xgo
2025/10/11 16:12:19 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/rational/rational.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/rational/rational.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/selectdata/select.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [y]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/selectdata/select.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [y]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/slice1/slice.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/slice1/slice.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/slice2/slice2.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/slice2/slice2.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/staticmthd1/static_method.xgo
2025/10/11 16:12:19 ==> Format Func foo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/staticmthd1/static_method.xgo
2025/10/11 16:12:19 ==> Format Func foo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/staticmthd2/a.gox
2025/10/11 16:12:19 ==> Format Func New
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/staticmthd2/a.gox
2025/10/11 16:12:19 ==> Format Func New
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/stdtype/stdtype.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/stdtype/stdtype.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [y]
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> AssignStmt [a]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/stringex1/string_lit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/stringex1/string_lit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/stringex2/string_lit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/stringex2/string_lit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/stringex3/string_lit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/stringex3/string_lit.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/typeof/typeof.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/typeof/typeof.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/typeswitch/typeswitch.xgo
2025/10/11 16:12:19 ==> Format Func add
2025/10/11 16:12:19 ==> AssignStmt [a]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/typeswitch/typeswitch.xgo
2025/10/11 16:12:19 ==> Format Func add
2025/10/11 16:12:19 ==> AssignStmt [a]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/unit/step.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt wait
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/unit/step.xgo
2025/10/11 16:12:19 ==> Format Func main
2025/10/11 16:12:19 ==> ExprStmt wait
--- PASS: TestFromParse (0.04s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/append1/append.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/append1/append.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/append2/append.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/append2/append.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/arrowop/arrowop.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/arrowop/arrowop.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/autoprop/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/autoprop/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/build/build.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/build/build.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/c2gohello/hello.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/c2gohello/hello.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle1/cmd.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle1/cmd.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle2/cmd2.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle2/cmd2.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle3/cmd3.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle3/cmd3.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle4/cmd4.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle4/cmd4.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/collection/collection.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/collection/collection.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/complit/complit.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/complit/complit.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/domainhuh/huh.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/domainhuh/huh.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/domaintext/tpl.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/domaintext/tpl.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/domaintpl/tpl.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/domaintpl/tpl.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/embedded1/embtype.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/embedded1/embtype.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/envop1/envop.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/envop1/envop.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/envop2/envop.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/envop2/envop.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/errwrap1/errwrap.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/errwrap1/errwrap.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/errwrap2/errwrap2.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/errwrap2/errwrap2.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/errwrap3/errwrap3.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/errwrap3/errwrap3.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/exists/exists.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/exists/exists.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/fnbody/fnbody.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/fnbody/fnbody.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/fncall/fncall.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/fncall/fncall.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/forloop/forloop.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/forloop/forloop.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/funcdecl1/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/funcdecl1/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/funcdecl2/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/funcdecl2/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/funcdecl3/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/funcdecl3/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/funcdoc/funcdoc.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/funcdoc/funcdoc.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/funclit/funclit.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/funclit/funclit.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/goto1/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/goto1/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/goto2/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/goto2/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/goxtest1/bar.gox (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/goxtest1/bar.gox (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/goxtest2/bar.gox (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/goxtest2/bar.gox (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/kwargs1/kwargs.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/kwargs1/kwargs.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/lambda1/lambda.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/lambda1/lambda.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/lambda2/lambda2.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/lambda2/lambda2.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/lambda3/lambda3.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/lambda3/lambda3.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/lambda4/lambda4.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/lambda4/lambda4.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/listcompr/listcompr.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/listcompr/listcompr.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/mapfunc/map.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/mapfunc/map.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/matrix1/matrix.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/matrix1/matrix.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/matrix2/matrix.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/matrix2/matrix.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/mytest/mytest.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/mytest/mytest.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/optparam/optparam.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/optparam/optparam.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/overload1/overload.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/overload1/overload.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/overload2/overload2.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/overload2/overload2.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/overloadop/op_overload.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/overloadop/op_overload.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/printvariadic/printv.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/printvariadic/printv.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/pystr/pystr.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/pystr/pystr.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/rangeexpr1/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/rangeexpr1/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/rangeexpr2/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/rangeexpr2/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/rangeexpr3/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/rangeexpr3/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/rational/rational.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/rational/rational.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/selectdata/select.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/selectdata/select.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/slice1/slice.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/slice1/slice.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/slice2/slice2.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/slice2/slice2.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/staticmthd1/static_method.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/staticmthd1/static_method.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/staticmthd2/a.gox (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/staticmthd2/a.gox (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/stdtype/stdtype.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/stdtype/stdtype.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/stringex1/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/stringex1/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/stringex2/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/stringex2/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/stringex3/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/stringex3/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/typeof/typeof.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/typeof/typeof.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/typeswitch/typeswitch.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/typeswitch/typeswitch.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/unit/step.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/unit/step.xgo (0.00s)
=== CONT  TestBadComments
=== CONT  TestWriteErrors
=== CONT  TestBaseIndent
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
=== RUN   TestBaseIndent/0
=== PAUSE TestBaseIndent/0
=== RUN   TestBaseIndent/1
=== PAUSE TestBaseIndent/1
=== RUN   TestBaseIndent/2
=== PAUSE TestBaseIndent/2
=== RUN   TestBaseIndent/3
=== PAUSE TestBaseIndent/3
=== CONT  TestBaseIndent/0
=== CONT  TestBaseIndent/2
=== CONT  TestBaseIndent/3
=== CONT  TestBaseIndent/1
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e2d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e300]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e318]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e2d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e300]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e348]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e318]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e378]
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e3a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e348]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e378]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e2d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e390]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e300]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e3a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e318]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e348]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e378]
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e390]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e3a8]
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e2d0]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e300]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e318]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e348]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e378]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e5d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e5e8]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e390]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e648]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e3a8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e678]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e5d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e5e8]
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e648]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e678]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e750]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e5d0]
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e5e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e828]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e648]
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e750]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e678]
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e948]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e960]
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e750]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e828]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e5d0]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e5e8]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e648]
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e678]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e828]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eab0]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eaf8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eb70]
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e948]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ebd0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e960]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ec18]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e750]
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e948]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e960]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eca8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eab0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e828]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ecf0]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eaf8]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ed20]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ed50]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eb70]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eab0]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ebd0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eaf8]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ec18]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000edb0]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eb70]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ebd0]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e948]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ec18]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000e960]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee10]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee58]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eeb8]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eca8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef18]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eab0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef48]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ecf0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eaf8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef78]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eca8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ed20]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ed50]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ecf0]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ed20]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eb70]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ed50]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ebd0]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ec18]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000edb0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f068]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000edb0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f080]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eca8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee10]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ecf0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f0f8]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ed20]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee58]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ed50]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee10]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee88]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee58]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eeb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f170]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef18]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee88]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eeb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef48]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f1b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eee8]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef78]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef18]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000edb0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef48]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef78]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f1e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee10]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f218]
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee58]
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f248]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f278]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f068]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ee88]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f068]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eeb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f080]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f2a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000eee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f2d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef18]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f080]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f0f8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f308]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef48]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ef78]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f338]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f140]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f0f8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f350]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f170]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f398]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f1b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f170]
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f068]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f1b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f080]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f1e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f0f8]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f218]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f140]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f248]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f1e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f278]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f218]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f170]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f2a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f248]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f2d8]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f278]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f308]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f1b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f0120]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f338]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f2a8]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f2d8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f350]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f308]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f338]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f398]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f350]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f1e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f398]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f218]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f248]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f278]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f05a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f2a8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f2d8]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f308]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f338]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f0120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f350]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f0990]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f398]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f0120]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f05a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f05a0]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f0120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f0990]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f0990]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f05a0]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001f0990]
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fa000]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fa000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fa000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001faf30]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb230 0xc0001fb290]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fa000]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001faf30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [0xc000255920]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001faf30]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb230 0xc0001fb290]
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb230 0xc0001fb290]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703968]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703968]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703998]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb650]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001faf30]
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb650]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255920]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb230 0xc0001fb290]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [0xc0002641b0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255920]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb650]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703968]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703968]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255920]
2025/10/11 16:12:19 ==> AssignStmt [0xc000264780]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703968]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703968]
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703998]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0002641b0]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc000264990]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703968]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703968]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703998]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc0002641b0]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [0xc0002641b0]
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> AssignStmt [0xc000264780]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc000264990]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [0xc000264780]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [0xc000264780]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc000264990]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> AssignStmt [0xc000264990]
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703f38]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [0xc00027e270 0xc00027e300]
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703f38]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6090]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [0xc00027e270 0xc00027e300]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6090]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703f38]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00027e270 0xc00027e300]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e61b0]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6090]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6270]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e61b0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703f38]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e62a0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e62d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00027e270 0xc00027e300]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6270]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6360]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e62a0]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [0xc00027f3b0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6090]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e62d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e63a8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e61b0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e63c0]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6450]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6360]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00027f3b0]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6270]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e63a8]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e63c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e62a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e64c8]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e62d0]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6450]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6570]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e64c8]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00027f800]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6360]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00027f3b0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e63a8]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e61b0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6570]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e63c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00027f800]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6450]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6690]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e66d8]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e64c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6270]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e62a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6690]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6720]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e66d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e62d0]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6570]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00027f800]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6720]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6360]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00027f3b0]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e63a8]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6690]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e63c0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e66d8]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6450]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6870]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e68b8]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6720]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e68e8]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e64c8]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6870]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e68b8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e68e8]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6570]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc00027f800]
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6870]
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e68b8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e68e8]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6690]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e66d8]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6720]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6870]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e68b8]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e68e8]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6f90]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6fd8]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6f90]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7008]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6fd8]
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7008]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6f90]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e70c8]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6fd8]
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7008]
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e70c8]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e70c8]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e71a0]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e71a0]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e71a0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6f90]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e72c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e6fd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e72d8]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e72c0]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e72d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e72c0]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e72d8]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e70c8]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7338]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7338]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e71a0]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7338]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7410]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7470]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7410]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7470]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7410]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e72c0]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e72d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7470]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7530]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7530]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7620]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7530]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7338]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7620]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7410]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7470]
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7620]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7530]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7620]
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7758]
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7758]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7758]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001e7758]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
--- PASS: TestBaseIndent (0.03s)
    --- PASS: TestBaseIndent/0 (0.08s)
    --- PASS: TestBaseIndent/1 (0.08s)
    --- PASS: TestBaseIndent/3 (0.08s)
    --- PASS: TestBaseIndent/2 (0.08s)
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func init
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007022e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702300]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702330]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702360]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702378]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702390]
2025/10/11 16:12:19 ==> Format Func internalError
2025/10/11 16:12:19 ==> ExprStmt &{fmt Print}
2025/10/11 16:12:19 ==> ExprStmt &{fmt Println}
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> Format Func commentsHaveNewline
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [t]
2025/10/11 16:12:19 ==> AssignStmt [_]
2025/10/11 16:12:19 ==> Format Func nextComment
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [list]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007025d0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702630]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702660]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func commentBefore
2025/10/11 16:12:19 ==> Format Func commentSizeBefore
2025/10/11 16:12:19 ==> AssignStmt [0xc000702738]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> AssignStmt [size]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> Format Func recordLine
2025/10/11 16:12:19 ==> AssignStmt [0xc000702810]
2025/10/11 16:12:19 ==> Format Func linesFrom
2025/10/11 16:12:19 ==> Format Func posFor
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func lineFor
2025/10/11 16:12:19 ==> AssignStmt [0xc000702930]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702948]
2025/10/11 16:12:19 ==> Format Func writeLineDirective
2025/10/11 16:12:19 ==> AssignStmt [0xc000702a98]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ae0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702b58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702bb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c00]
2025/10/11 16:12:19 ==> Format Func writeIndent
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702c90]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702cd8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d08]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d38]
2025/10/11 16:12:19 ==> Format Func writeByte
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702d80]
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702de0]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e28]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e58]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702e88]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc000702eb8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702ee8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f18]
2025/10/11 16:12:19 ==> AssignStmt [0xc000702f48]
2025/10/11 16:12:19 ==> Format Func writeString
2025/10/11 16:12:19 ==> ExprStmt &{p writeLineDirective}
2025/10/11 16:12:19 ==> ExprStmt &{p writeIndent}
2025/10/11 16:12:19 ==> AssignStmt [0xc000703038]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703050]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007030c8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703110]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703140]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703188]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [nlines]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [li]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031b8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007031e8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703218]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703248]
2025/10/11 16:12:19 ==> AssignStmt [c]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703278]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032a8]
2025/10/11 16:12:19 ==> AssignStmt [0xc0007032d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703308]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703320]
2025/10/11 16:12:19 ==> AssignStmt [0xc000703368]
2025/10/11 16:12:19 ==> Format Func writeCommentPrefix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a120]
2025/10/11 16:12:19 ==> AssignStmt [hasSep]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> AssignStmt [sep]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00022a990]
2025/10/11 16:12:19 ==> AssignStmt [droppedLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> Format Func isBlank
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func commonPrefix
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func trimRight
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func stripCommonPrefix
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254000]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [prefixSet]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [line]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [lineOfStars]
2025/10/11 16:12:19 ==> AssignStmt [first]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [0xc000254f30]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255230 0xc000255290]
2025/10/11 16:12:19 ==> AssignStmt [suffix]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [closing]
2025/10/11 16:12:19 ==> AssignStmt [0xc000255650]
2025/10/11 16:12:19 ==> AssignStmt [prefix]
2025/10/11 16:12:19 ==> AssignStmt [0xc0001fb8c0]
2025/10/11 16:12:19 ==> Format Func writeComment
2025/10/11 16:12:19 ==> AssignStmt [text]
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f998]
2025/10/11 16:12:19 ==> AssignStmt [0xc00000f9c8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [lines]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e150]
2025/10/11 16:12:19 ==> ExprStmt stripCommonPrefix
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [pos]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> Format Func writeCommentSuffix
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e720]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> AssignStmt [droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [0xc00030e930]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline]
2025/10/11 16:12:19 ==> Format Func containsLinebreak
2025/10/11 16:12:19 ==> Format Func intersperseComments
2025/10/11 16:12:19 ==> ExprStmt &{p writeCommentPrefix}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeComment}
2025/10/11 16:12:19 ==> AssignStmt [last]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [needsLinebreak]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> Format Func writeWhitespace
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00000ff68]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031a210 0xc00031a2a0]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [l]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e0c0]
2025/10/11 16:12:19 ==> Format Func nlimit
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func mayCombine
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> Format Func setPos
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e1e0]
2025/10/11 16:12:19 ==> Format Func print
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e2d0]
2025/10/11 16:12:19 ==> AssignStmt [x]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e300]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e390]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b350]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3d8]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e3f0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e480]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e4f8]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [s]
2025/10/11 16:12:19 ==> ExprStmt &{p internalError}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e5a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031b7a0]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e6c0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e708]
2025/10/11 16:12:19 ==> AssignStmt [data]
2025/10/11 16:12:19 ==> AssignStmt [isLit]
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e750]
2025/10/11 16:12:19 ==> ExprStmt &{fmt Fprintf}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [next]
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> AssignStmt [ch]
2025/10/11 16:12:19 ==> ExprStmt &{p writeByte}
2025/10/11 16:12:19 ==> AssignStmt [impliedSemi]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8a0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e8e8]
2025/10/11 16:12:19 ==> ExprStmt &{p writeString}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031e918]
2025/10/11 16:12:19 ==> Format Func flush
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [wroteNewline droppedFF]
2025/10/11 16:12:19 ==> ExprStmt &{p writeWhitespace}
2025/10/11 16:12:19 ==> Format Func getDoc
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func getLastComment
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func printNode
2025/10/11 16:12:19 ==> AssignStmt [cnode ok]
2025/10/11 16:12:19 ==> AssignStmt [node]
2025/10/11 16:12:19 ==> AssignStmt [comments]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [doc]
2025/10/11 16:12:19 ==> AssignStmt [beg]
2025/10/11 16:12:19 ==> AssignStmt [com]
2025/10/11 16:12:19 ==> AssignStmt [e]
2025/10/11 16:12:19 ==> AssignStmt [end]
2025/10/11 16:12:19 ==> AssignStmt [i]
2025/10/11 16:12:19 ==> AssignStmt [j]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031efc0]
2025/10/11 16:12:19 ==> AssignStmt [n ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f008]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f038]
2025/10/11 16:12:19 ==> ExprStmt &{p nextComment}
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> ExprStmt &{p expr}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f0f8]
2025/10/11 16:12:19 ==> ExprStmt &{p stmt}
2025/10/11 16:12:19 ==> ExprStmt &{p decl}
2025/10/11 16:12:19 ==> ExprStmt &{p spec}
2025/10/11 16:12:19 ==> AssignStmt [_ ok]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f1d0]
2025/10/11 16:12:19 ==> ExprStmt &{p stmtList}
2025/10/11 16:12:19 ==> ExprStmt &{p declList}
2025/10/11 16:12:19 ==> ExprStmt &{p file}
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func resetSpace
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f2f0]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f308]
2025/10/11 16:12:19 ==> Format Func Write
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [b]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f368]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f440]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f4a0]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f560]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f650]
2025/10/11 16:12:19 ==> AssignStmt [m]
2025/10/11 16:12:19 ==> ExprStmt panic
2025/10/11 16:12:19 ==> AssignStmt [n]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> ExprStmt &{p resetSpace}
2025/10/11 16:12:19 ==> Format Func fprint
2025/10/11 16:12:19 ==> ExprStmt &{p init}
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> AssignStmt [0xc00031f788]
2025/10/11 16:12:19 ==> ExprStmt &{p flush}
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> AssignStmt [padchar]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [minwidth]
2025/10/11 16:12:19 ==> AssignStmt [twmode]
2025/10/11 16:12:19 ==> AssignStmt [output]
2025/10/11 16:12:19 ==> AssignStmt [_ err]
2025/10/11 16:12:19 ==> AssignStmt [tw _]
2025/10/11 16:12:19 ==> AssignStmt [err]
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func Fprint
2025/10/11 16:12:19 ==> Format Func fibo
--- PASS: TestWriteErrors (0.46s)
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
2025/10/11 16:12:19 ==> Format Func fibo
--- PASS: TestBadComments (0.49s)
PASS
coverage: 88.5% of statements
ok  	github.com/goplus/xgo/printer	0.841s	coverage: 88.5% of statements
	github.com/goplus/xgo/scanner		coverage: 0.0% of statements
	github.com/goplus/xgo/test		coverage: 0.0% of statements
=== RUN   TestArrowOp
--- PASS: TestArrowOp (0.00s)
=== RUN   TestPrecedence
--- PASS: TestPrecedence (0.00s)
=== RUN   TestLookup
--- PASS: TestLookup (0.00s)
=== RUN   TestBasic
--- PASS: TestBasic (0.00s)
=== RUN   TestLines
--- PASS: TestLines (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/token	0.012s	coverage: 100.0% of statements
=== RUN   TestLines
--- PASS: TestLines (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/token/internal/tokenutil	0.010s	coverage: 100.0% of statements
	github.com/goplus/xgo/tool		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/ast		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/cl		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/encoding/csv		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/encoding/json		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/encoding/regexp		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/encoding/regexposix		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/encoding/xml		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/matcher		coverage: 0.0% of statements
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/adjoin
2025/10/11 16:12:18 Parsing /app/tpl/parser/_testdata/adjoin
=== RUN   TestFromTestdata/pseudo
2025/10/11 16:12:18 Parsing /app/tpl/parser/_testdata/pseudo
=== RUN   TestFromTestdata/simple1
2025/10/11 16:12:18 Parsing /app/tpl/parser/_testdata/simple1
=== RUN   TestFromTestdata/simple2
2025/10/11 16:12:18 Parsing /app/tpl/parser/_testdata/simple2
--- PASS: TestFromTestdata (0.00s)
    --- PASS: TestFromTestdata/adjoin (0.00s)
    --- PASS: TestFromTestdata/pseudo (0.00s)
    --- PASS: TestFromTestdata/simple1 (0.00s)
    --- PASS: TestFromTestdata/simple2 (0.00s)
PASS
coverage: 80.5% of statements
ok  	github.com/goplus/xgo/tpl/parser	0.019s	coverage: 80.5% of statements
	github.com/goplus/xgo/tpl/parser/parsertest		coverage: 0.0% of statements
=== RUN   TestScanner
--- PASS: TestScanner (0.00s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/cstr
2025/10/11 16:12:18 Scanning /app/tpl/scanner/_testdata/cstr
=== RUN   TestFromTestdata/num
2025/10/11 16:12:18 Scanning /app/tpl/scanner/_testdata/num
=== RUN   TestFromTestdata/pow
2025/10/11 16:12:18 Scanning /app/tpl/scanner/_testdata/pow
=== RUN   TestFromTestdata/rat
2025/10/11 16:12:18 Scanning /app/tpl/scanner/_testdata/rat
=== RUN   TestFromTestdata/unit
2025/10/11 16:12:18 Scanning /app/tpl/scanner/_testdata/unit
--- PASS: TestFromTestdata (0.00s)
    --- PASS: TestFromTestdata/cstr (0.00s)
    --- PASS: TestFromTestdata/num (0.00s)
    --- PASS: TestFromTestdata/pow (0.00s)
    --- PASS: TestFromTestdata/rat (0.00s)
    --- PASS: TestFromTestdata/unit (0.00s)
PASS
coverage: 58.9% of statements
ok  	github.com/goplus/xgo/tpl/scanner	0.019s	coverage: 58.9% of statements
	github.com/goplus/xgo/tpl/scanner/scannertest		coverage: 0.0% of statements
=== RUN   TestToken
--- PASS: TestToken (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/tpl/token	0.011s	coverage: 100.0% of statements
	github.com/goplus/xgo/tpl/types		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/variant		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/variant/builtin		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/variant/delay		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/variant/math		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/variant/time		coverage: 0.0% of statements
=== RUN   TestKind
--- PASS: TestKind (0.00s)
=== RUN   TestGop
--- PASS: TestGop (1.16s)
=== RUN   TestGox
--- PASS: TestGox (0.13s)
=== RUN   TestBig
--- PASS: TestBig (0.20s)
=== RUN   TestIoxLines
--- PASS: TestIoxLines (0.15s)
=== RUN   TestErrorWrap
--- PASS: TestErrorWrap (0.18s)
=== RUN   TestSpx
--- PASS: TestSpx (0.05s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/hello
=== RUN   TestFromTestdata/multi
=== RUN   TestFromTestdata/pkg
--- PASS: TestFromTestdata (0.00s)
    --- PASS: TestFromTestdata/hello (0.00s)
    --- PASS: TestFromTestdata/multi (0.00s)
    --- PASS: TestFromTestdata/pkg (0.00s)
=== RUN   TestFS
--- PASS: TestFS (0.00s)
=== RUN   TestAst
--- PASS: TestAst (0.00s)
=== RUN   TestError
--- PASS: TestError (0.00s)
=== RUN   TestContext
--- PASS: TestContext (0.00s)
PASS
coverage: 96.3% of statements
ok  	github.com/goplus/xgo/x/build	1.895s	coverage: 96.3% of statements
	github.com/goplus/xgo/x/fakenet		coverage: 0.0% of statements
=== RUN   TestMain
=== RUN   TestMain/hello_world_1
=== RUN   TestMain/hello_world_2
=== RUN   TestMain/hello_world_3
--- PASS: TestMain (0.00s)
    --- PASS: TestMain/hello_world_1 (0.00s)
    --- PASS: TestMain/hello_world_2 (0.00s)
    --- PASS: TestMain/hello_world_3 (0.00s)
=== RUN   TestPrint
=== RUN   TestPrint/print
--- PASS: TestPrint (0.00s)
    --- PASS: TestPrint/print (0.00s)
=== RUN   TestPrintf
=== RUN   TestPrintf/print
--- PASS: TestPrintf (0.00s)
    --- PASS: TestPrintf/print (0.00s)
=== RUN   TestPrintln
=== RUN   TestPrintln/print
--- PASS: TestPrintln (0.00s)
    --- PASS: TestPrintln/print (0.00s)
=== RUN   TestPrintlnGroup
=== RUN   TestPrintlnGroup/print
--- PASS: TestPrintlnGroup (0.00s)
    --- PASS: TestPrintlnGroup/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtCalls
=== RUN   TestPrintlnWithOtherFmtCalls/print
--- PASS: TestPrintlnWithOtherFmtCalls (0.00s)
    --- PASS: TestPrintlnWithOtherFmtCalls/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtCallsGroup
=== RUN   TestPrintlnWithOtherFmtCallsGroup/print
--- PASS: TestPrintlnWithOtherFmtCallsGroup (0.00s)
    --- PASS: TestPrintlnWithOtherFmtCallsGroup/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtCallsWithAssign
=== RUN   TestPrintlnWithOtherFmtCallsWithAssign/print
--- PASS: TestPrintlnWithOtherFmtCallsWithAssign (0.00s)
    --- PASS: TestPrintlnWithOtherFmtCallsWithAssign/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtCallsWithGroupWithAssign
=== RUN   TestPrintlnWithOtherFmtCallsWithGroupWithAssign/print
--- PASS: TestPrintlnWithOtherFmtCallsWithGroupWithAssign (0.00s)
    --- PASS: TestPrintlnWithOtherFmtCallsWithGroupWithAssign/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtDecls
=== RUN   TestPrintlnWithOtherFmtDecls/print
--- PASS: TestPrintlnWithOtherFmtDecls (0.00s)
    --- PASS: TestPrintlnWithOtherFmtDecls/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtVars
=== RUN   TestPrintlnWithOtherFmtVars/print
--- PASS: TestPrintlnWithOtherFmtVars (0.00s)
    --- PASS: TestPrintlnWithOtherFmtVars/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtType
=== RUN   TestPrintlnWithOtherFmtType/print
--- PASS: TestPrintlnWithOtherFmtType (0.00s)
    --- PASS: TestPrintlnWithOtherFmtType/print (0.00s)
=== RUN   TestPrintlnImportAlias
=== RUN   TestPrintlnImportAlias/print
--- PASS: TestPrintlnImportAlias (0.00s)
    --- PASS: TestPrintlnImportAlias/print (0.00s)
=== RUN   TestPrintlnImportMultiAliases
=== RUN   TestPrintlnImportMultiAliases/print
--- PASS: TestPrintlnImportMultiAliases (0.00s)
    --- PASS: TestPrintlnImportMultiAliases/print (0.00s)
=== RUN   TestPrintlnImportMultiAliasesDifferentGroups
=== RUN   TestPrintlnImportMultiAliasesDifferentGroups/print
--- PASS: TestPrintlnImportMultiAliasesDifferentGroups (0.00s)
    --- PASS: TestPrintlnImportMultiAliasesDifferentGroups/print (0.00s)
=== RUN   TestErrorfWithPackageLevelVar
=== RUN   TestErrorfWithPackageLevelVar/print
--- PASS: TestErrorfWithPackageLevelVar (0.00s)
    --- PASS: TestErrorfWithPackageLevelVar/print (0.00s)
=== RUN   TestPrintlnWithFmtVarNoImport
=== RUN   TestPrintlnWithFmtVarNoImport/print
--- PASS: TestPrintlnWithFmtVarNoImport (0.00s)
    --- PASS: TestPrintlnWithFmtVarNoImport/print (0.00s)
=== RUN   TestPrintlnWithFmtVar
=== RUN   TestPrintlnWithFmtVar/print
--- PASS: TestPrintlnWithFmtVar (0.00s)
    --- PASS: TestPrintlnWithFmtVar/print (0.00s)
=== RUN   TestPrintlnWithFmtVarAfter
=== RUN   TestPrintlnWithFmtVarAfter/print
--- PASS: TestPrintlnWithFmtVarAfter (0.00s)
    --- PASS: TestPrintlnWithFmtVarAfter/print (0.00s)
=== RUN   TestPrintlnWithPackageLevelFmtVar
=== RUN   TestPrintlnWithPackageLevelFmtVar/print
--- PASS: TestPrintlnWithPackageLevelFmtVar (0.00s)
    --- PASS: TestPrintlnWithPackageLevelFmtVar/print (0.00s)
=== RUN   TestPrintlnWithPackageLevelFmtVarAfter
=== RUN   TestPrintlnWithPackageLevelFmtVarAfter/print
--- PASS: TestPrintlnWithPackageLevelFmtVarAfter (0.00s)
    --- PASS: TestPrintlnWithPackageLevelFmtVarAfter/print (0.00s)
=== RUN   TestPrintlnWithVarFromCall
=== RUN   TestPrintlnWithVarFromCall/print
--- PASS: TestPrintlnWithVarFromCall (0.00s)
    --- PASS: TestPrintlnWithVarFromCall/print (0.00s)
=== RUN   TestLambdaFromFuncLit
=== RUN   TestLambdaFromFuncLit/funclit_to_lambda
--- PASS: TestLambdaFromFuncLit (0.00s)
    --- PASS: TestLambdaFromFuncLit/funclit_to_lambda (0.00s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/collection
2025/10/11 16:12:18 Formatting /app/x/format/_testdata/collection
=== RUN   TestFromTestdata/gopsyntax
2025/10/11 16:12:18 Formatting /app/x/format/_testdata/gopsyntax
=== RUN   TestFromTestdata/syntax
2025/10/11 16:12:18 Formatting /app/x/format/_testdata/syntax
--- PASS: TestFromTestdata (0.00s)
    --- PASS: TestFromTestdata/collection (0.00s)
    --- PASS: TestFromTestdata/gopsyntax (0.00s)
    --- PASS: TestFromTestdata/syntax (0.00s)
PASS
coverage: 97.0% of statements
ok  	github.com/goplus/xgo/x/format	0.023s	coverage: 97.0% of statements
	github.com/goplus/xgo/x/fsnotify		coverage: 0.0% of statements
	github.com/goplus/xgo/x/gocmd		coverage: 0.0% of statements
	github.com/goplus/xgo/x/jsonrpc2		coverage: 0.0% of statements
	github.com/goplus/xgo/x/jsonrpc2/internal/stack		coverage: 0.0% of statements
	github.com/goplus/xgo/x/jsonrpc2/internal/stack/stacktest		coverage: 0.0% of statements
=== RUN   TestNetPipeDone
--- PASS: TestNetPipeDone (0.00s)
=== RUN   TestNetPipe
=== RUN   TestNetPipe/no_args
2025/10/11 16:12:18 Call no_args params: <nil>
2025/10/11 16:12:18 handleAsync {1} no_args
2025/10/11 16:12:18 processResult {1} true <nil>
2025/10/11 16:12:18 Connection.write {1} no_args <nil>
=== RUN   TestNetPipe/one_string
2025/10/11 16:12:18 Call one_string params: fish
2025/10/11 16:12:18 handleAsync {1} one_string "fish"
2025/10/11 16:12:18 processResult {1} "got:fish" <nil>
2025/10/11 16:12:18 Connection.write {1} one_string <nil>
=== RUN   TestNetPipe/one_number
2025/10/11 16:12:18 Call one_number params: 10
2025/10/11 16:12:18 handleAsync {1} one_number 10
2025/10/11 16:12:18 processResult {1} "got:10" <nil>
2025/10/11 16:12:18 Connection.write {1} one_number <nil>
=== RUN   TestNetPipe/join
2025/10/11 16:12:18 Call join params: [a b c]
2025/10/11 16:12:18 handleAsync {1} join ["a","b","c"]
2025/10/11 16:12:18 processResult {1} "a/b/c" <nil>
2025/10/11 16:12:18 Connection.write {1} join <nil>
=== RUN   TestNetPipe/notify
2025/10/11 16:12:18 Notify set params: 3
2025/10/11 16:12:18 handleAsync {} set 3
2025/10/11 16:12:18 Connection.write set <nil>
2025/10/11 16:12:18 Notify add params: 5
2025/10/11 16:12:18 handleAsync {} add 5
2025/10/11 16:12:18 Connection.write add <nil>
2025/10/11 16:12:18 Call get params: <nil>
2025/10/11 16:12:18 handleAsync {1} get
2025/10/11 16:12:18 processResult {1} 8 <nil>
2025/10/11 16:12:18 Connection.write {1} get <nil>
=== RUN   TestNetPipe/preempt
2025/10/11 16:12:18 Call wait params: a
2025/10/11 16:12:18 handleAsync {1} wait "a"
2025/10/11 16:12:18 waiter: a
2025/10/11 16:12:18 Connection.write {1} wait <nil>
2025/10/11 16:12:18 Notify unblock params: a
2025/10/11 16:12:18 closeWaiter: a
2025/10/11 16:12:18 processResult {1} true <nil>
2025/10/11 16:12:18 Connection.write unblock <nil>
=== RUN   TestNetPipe/basic_cancel
2025/10/11 16:12:18 Call wait params: b
2025/10/11 16:12:18 handleAsync {1} wait "b"
2025/10/11 16:12:18 waiter: b
2025/10/11 16:12:18 Connection.write {1} wait <nil>
2025/10/11 16:12:18 Notify cancel params: &{1}
2025/10/11 16:12:18 processResult {1}  context canceled
2025/10/11 16:12:18 Connection.write cancel <nil>
=== RUN   TestNetPipe/queue
2025/10/11 16:12:18 Call wait params: a
2025/10/11 16:12:18 handleAsync {1} wait "a"
2025/10/11 16:12:18 waiter: a
2025/10/11 16:12:18 Connection.write {1} wait <nil>
2025/10/11 16:12:18 Notify set params: 1
2025/10/11 16:12:18 Connection.write set <nil>
2025/10/11 16:12:18 Notify add params: 2
2025/10/11 16:12:18 Connection.write add <nil>
2025/10/11 16:12:18 Notify add params: 3
2025/10/11 16:12:18 Connection.write add <nil>
2025/10/11 16:12:18 Notify add params: 4
2025/10/11 16:12:18 Connection.write add <nil>
2025/10/11 16:12:18 Notify unblock params: a
2025/10/11 16:12:18 closeWaiter: a
2025/10/11 16:12:18 processResult {1} true <nil>
2025/10/11 16:12:18 handleAsync {} set 1
2025/10/11 16:12:18 handleAsync {} add 2
2025/10/11 16:12:18 handleAsync {} add 3
2025/10/11 16:12:18 handleAsync {} add 4
2025/10/11 16:12:18 Connection.write unblock <nil>
2025/10/11 16:12:18 Call get params: <nil>
2025/10/11 16:12:18 handleAsync {2} get
2025/10/11 16:12:18 processResult {2} 10 <nil>
2025/10/11 16:12:18 Connection.write {2} get <nil>
=== RUN   TestNetPipe/fork
2025/10/11 16:12:18 Call fork params: a
2025/10/11 16:12:18 handleAsync {1} fork "a"
2025/10/11 16:12:18 waiter: a
2025/10/11 16:12:18 Connection.write {1} fork <nil>
2025/10/11 16:12:18 Notify set params: 1
2025/10/11 16:12:18 handleAsync {} set 1
2025/10/11 16:12:18 Connection.write set <nil>
2025/10/11 16:12:18 Notify add params: 2
2025/10/11 16:12:18 handleAsync {} add 2
2025/10/11 16:12:18 Connection.write add <nil>
2025/10/11 16:12:18 Notify add params: 3
2025/10/11 16:12:18 handleAsync {} add 3
2025/10/11 16:12:18 Connection.write add <nil>
2025/10/11 16:12:18 Notify add params: 4
2025/10/11 16:12:18 handleAsync {} add 4
2025/10/11 16:12:18 Connection.write add <nil>
2025/10/11 16:12:18 Call get params: <nil>
2025/10/11 16:12:18 handleAsync {2} get
2025/10/11 16:12:18 processResult {2} 10 <nil>
2025/10/11 16:12:18 Connection.write {2} get <nil>
2025/10/11 16:12:18 Notify unblock params: a
2025/10/11 16:12:18 closeWaiter: a
2025/10/11 16:12:18 processResult {1} true <nil>
2025/10/11 16:12:18 Connection.write unblock <nil>
=== RUN   TestNetPipe/concurrent
2025/10/11 16:12:18 Call fork params: a
2025/10/11 16:12:18 handleAsync {1} fork "a"
2025/10/11 16:12:18 waiter: a
2025/10/11 16:12:18 Connection.write {1} fork <nil>
2025/10/11 16:12:18 Notify unblock params: a
2025/10/11 16:12:18 closeWaiter: a
2025/10/11 16:12:18 processResult {1} true <nil>
2025/10/11 16:12:18 Connection.write unblock <nil>
2025/10/11 16:12:18 Call fork params: b
2025/10/11 16:12:18 handleAsync {2} fork "b"
2025/10/11 16:12:18 waiter: b
2025/10/11 16:12:18 Connection.write {2} fork <nil>
2025/10/11 16:12:18 Notify unblock params: b
2025/10/11 16:12:18 closeWaiter: b
2025/10/11 16:12:18 Connection.write unblock <nil>
2025/10/11 16:12:18 processResult {2} true <nil>
--- PASS: TestNetPipe (0.00s)
    --- PASS: TestNetPipe/no_args (0.00s)
    --- PASS: TestNetPipe/one_string (0.00s)
    --- PASS: TestNetPipe/one_number (0.00s)
    --- PASS: TestNetPipe/join (0.00s)
    --- PASS: TestNetPipe/notify (0.00s)
    --- PASS: TestNetPipe/preempt (0.00s)
    --- PASS: TestNetPipe/basic_cancel (0.00s)
    --- PASS: TestNetPipe/queue (0.00s)
    --- PASS: TestNetPipe/fork (0.00s)
    --- PASS: TestNetPipe/concurrent (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/x/jsonrpc2/jsonrpc2test	0.018s	coverage: 100.0% of statements
	github.com/goplus/xgo/x/jsonrpc2/jsonrpc2test/cases		coverage: 0.0% of statements
	github.com/goplus/xgo/x/jsonrpc2/stdio		coverage: 0.0% of statements
	github.com/goplus/xgo/x/langserver		coverage: 0.0% of statements
2025/10/11 16:12:18 SetDebug: import=true, match=true, instr=true
=== RUN   TestConvErr
--- PASS: TestConvErr (0.00s)
=== RUN   TestCheckFiles
2025/10/11 16:12:18.891296 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 2 goFiles = 1
2025/10/11 16:12:19.870396 [INFO] typesutil/gopinfo.go:332: ==> Scope: Rect.gox scope 0xc000333d40 {
}

2025/10/11 16:12:19 ==> Preload var [x]
2025/10/11 16:12:19 ==> Preload var [y]
2025/10/11 16:12:19.870529 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000333da0 {
}

2025/10/11 16:12:19.870659 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package fmt
2025/10/11 16:12:19 ==> Preload type Point
2025/10/11 16:12:19 ==> Preload func main
2025/10/11 16:12:19 ==> Preload var [GoValue]
2025/10/11 16:12:19 ==> Preload type GoPoint
2025/10/11 16:12:19 ==> Preload method GoPoint.Test
2025/10/11 16:12:19 ==> Preload func gotest
2025/10/11 16:12:19 ==> Load > NewType GoPoint
2025/10/11 16:12:19 ==> Load > InitType GoPoint
2025/10/11 16:12:19 ==> LookupParent GoPoint => type main.GoPoint struct{x int; y int}
2025/10/11 16:12:19 ==> Load method *main.GoPoint.Test
2025/10/11 16:12:19.870841 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:19.870860 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.870879 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19 ==> Load var int [x]
2025/10/11 16:12:19 NewVarDefs
2025/10/11 16:12:19 NewVar [x]
2025/10/11 16:12:19.870922 [INFO] typesutil/gopinfo.go:251: ==> Def: x var main.x int
2025/10/11 16:12:19.870933 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:19.870943 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.870951 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19 ==> Load var int [y]
2025/10/11 16:12:19 NewVarDefs
2025/10/11 16:12:19 NewVar [y]
2025/10/11 16:12:19.870972 [INFO] typesutil/gopinfo.go:251: ==> Def: y var main.y int
2025/10/11 16:12:19 ==> Load > NewType Point
2025/10/11 16:12:19 NewType Point
2025/10/11 16:12:19 ==> Load > InitType Point
2025/10/11 16:12:19.870995 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:19.871001 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.871013 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.871028 [INFO] typesutil/gopinfo.go:251: ==> Def: x field x int
2025/10/11 16:12:19.871034 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:19.871048 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.871054 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.871060 [INFO] typesutil/gopinfo.go:251: ==> Def: y field y int
2025/10/11 16:12:19.871085 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 0xc0002267e0 false} struct{x int; y int}
2025/10/11 16:12:19 InitType Point struct{x int; y int}
2025/10/11 16:12:19.871101 [INFO] typesutil/gopinfo.go:251: ==> Def: Point type main.Point struct{x int; y int}
2025/10/11 16:12:19 ==> Load func main
2025/10/11 16:12:19.871115 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:19 NewFunc main func()
2025/10/11 16:12:19 DefineVarStart [pt]
2025/10/11 16:12:19 ==> LookupParent Point => type main.Point struct{x int; y int}
2025/10/11 16:12:19.871152 [INFO] typesutil/gopinfo.go:265: ==> Use: Point type main.Point struct{x int; y int}
2025/10/11 16:12:19.871165 [INFO] typesutil/gopinfo.go:215: ==> Type: Point main.Point
2025/10/11 16:12:19.871174 [INFO] typesutil/gopinfo.go:215: ==> Type: Point main.Point
2025/10/11 16:12:19 StructLit main.Point 0 false
2025/10/11 16:12:19.871191 [INFO] typesutil/gopinfo.go:215: ==> Type: Point main.Point
2025/10/11 16:12:19.871208 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Point 64 [] 65 false} main.Point
2025/10/11 16:12:19 UnaryOp & flags: 0
2025/10/11 16:12:19 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:19.871246 [INFO] typesutil/gopinfo.go:215: ==> Type: &{58 & 0xc0001af440} *main.Point
2025/10/11 16:12:19 EndInit 1
2025/10/11 16:12:19.871258 [INFO] typesutil/gopinfo.go:251: ==> Def: pt var pt *main.Point
2025/10/11 16:12:19 Val pt *main.Point
2025/10/11 16:12:19.871273 [INFO] typesutil/gopinfo.go:265: ==> Use: pt var pt *main.Point
2025/10/11 16:12:19.871281 [INFO] typesutil/gopinfo.go:215: ==> Type: pt *main.Point
2025/10/11 16:12:19 Member x -1 // *main.Point
2025/10/11 16:12:19.871303 [INFO] typesutil/gopinfo.go:265: ==> Use: x field x int
2025/10/11 16:12:19.871315 [INFO] typesutil/gopinfo.go:215: ==> Type: &{pt x} int
2025/10/11 16:12:19 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:19.871353 [INFO] typesutil/gopinfo.go:215: ==> Type: &{74 INT 100 <nil>} untyped int
2025/10/11 16:12:19 Assign 1 1
2025/10/11 16:12:19 ==> MatchType untyped int (100), int
2025/10/11 16:12:19 Val pt *main.Point
2025/10/11 16:12:19.871415 [INFO] typesutil/gopinfo.go:265: ==> Use: pt var pt *main.Point
2025/10/11 16:12:19.871423 [INFO] typesutil/gopinfo.go:215: ==> Type: pt *main.Point
2025/10/11 16:12:19 Member y -1 // *main.Point
2025/10/11 16:12:19.871438 [INFO] typesutil/gopinfo.go:265: ==> Use: y field y int
2025/10/11 16:12:19.871450 [INFO] typesutil/gopinfo.go:215: ==> Type: &{pt y} int
2025/10/11 16:12:19 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:19.871472 [INFO] typesutil/gopinfo.go:215: ==> Type: &{85 INT 200 <nil>} untyped int
2025/10/11 16:12:19 Assign 1 1
2025/10/11 16:12:19 ==> MatchType untyped int (200), int
2025/10/11 16:12:19.871496 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/10/11 16:12:19.871511 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:19 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:19 Val pt *main.Point
2025/10/11 16:12:19.871549 [INFO] typesutil/gopinfo.go:265: ==> Use: pt var pt *main.Point
2025/10/11 16:12:19.871569 [INFO] typesutil/gopinfo.go:215: ==> Type: pt *main.Point
2025/10/11 16:12:19 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:19 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:19 ==> MatchType *main.Point, any
2025/10/11 16:12:19 ==> EnsureLoaded main.Point
2025/10/11 16:12:19.871646 [INFO] typesutil/gopinfo.go:215: ==> Type: &{fmt Println} func(a ...any) (n int, err error)
2025/10/11 16:12:19.871806 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a24c8 100 [pt] 0 [] 103 0} (n int, err error)
2025/10/11 16:12:19 DefineVarStart [gopt]
2025/10/11 16:12:19 ==> LookupParent GoPoint => type main.GoPoint struct{x int; y int}
2025/10/11 16:12:19.871839 [INFO] typesutil/gopinfo.go:265: ==> Use: GoPoint type main.GoPoint struct{x int; y int}
2025/10/11 16:12:19.871848 [INFO] typesutil/gopinfo.go:215: ==> Type: GoPoint main.GoPoint
2025/10/11 16:12:19.871857 [INFO] typesutil/gopinfo.go:215: ==> Type: GoPoint main.GoPoint
2025/10/11 16:12:19 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:19.871876 [INFO] typesutil/gopinfo.go:215: ==> Type: &{122 INT 100 <nil>} untyped int
2025/10/11 16:12:19 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:19.871894 [INFO] typesutil/gopinfo.go:215: ==> Type: &{126 INT 200 <nil>} untyped int
2025/10/11 16:12:19 StructLit main.GoPoint 2 false
2025/10/11 16:12:19.871912 [INFO] typesutil/gopinfo.go:215: ==> Type: GoPoint main.GoPoint
2025/10/11 16:12:19.871925 [INFO] typesutil/gopinfo.go:215: ==> Type: &{GoPoint 121 [0xc0002268d0 0xc000226900] 129 false} main.GoPoint
2025/10/11 16:12:19 EndInit 1
2025/10/11 16:12:19.871947 [INFO] typesutil/gopinfo.go:251: ==> Def: gopt var gopt main.GoPoint
2025/10/11 16:12:19 Val gopt main.GoPoint
2025/10/11 16:12:19.871976 [INFO] typesutil/gopinfo.go:265: ==> Use: gopt var gopt main.GoPoint
2025/10/11 16:12:19.871985 [INFO] typesutil/gopinfo.go:215: ==> Type: gopt main.GoPoint
2025/10/11 16:12:19 Member Test 1 // main.GoPoint
2025/10/11 16:12:19.872004 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func (*main.GoPoint).Test()
2025/10/11 16:12:19.872016 [INFO] typesutil/gopinfo.go:215: ==> Type: &{gopt Test} func()
2025/10/11 16:12:19 Call 0 0 // func()
2025/10/11 16:12:19 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:19.872056 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a24e0 140 [] 0 [] 141 0} ()
2025/10/11 16:12:19 ==> Load func gotest
2025/10/11 16:12:19 Val gotest func()
2025/10/11 16:12:19.872088 [INFO] typesutil/gopinfo.go:265: ==> Use: gotest func main.gotest()
2025/10/11 16:12:19.872097 [INFO] typesutil/gopinfo.go:215: ==> Type: gotest func()
2025/10/11 16:12:19 Call 0 0 // func()
2025/10/11 16:12:19 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:19.872120 [INFO] typesutil/gopinfo.go:215: ==> Type: &{gotest 149 [] 0 [] 150 0} ()
2025/10/11 16:12:19.872131 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/10/11 16:12:19.872143 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:19 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:19 ==> Load var string [GoValue]
2025/10/11 16:12:19 NewVarDefs
2025/10/11 16:12:19 NewVar [GoValue]
2025/10/11 16:12:19 Val GoValue string
2025/10/11 16:12:19.872202 [INFO] typesutil/gopinfo.go:265: ==> Use: GoValue var main.GoValue string
2025/10/11 16:12:19.872211 [INFO] typesutil/gopinfo.go:215: ==> Type: GoValue string
2025/10/11 16:12:19 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:19 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:19 ==> MatchType string, any
2025/10/11 16:12:19.872245 [INFO] typesutil/gopinfo.go:215: ==> Type: &{fmt Println} func(a ...any) (n int, err error)
2025/10/11 16:12:19.872265 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a24f8 163 [GoValue] 0 [] 171 0} (n int, err error)
2025/10/11 16:12:19.872298 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/10/11 16:12:19.872313 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:19 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:19.872335 [INFO] typesutil/gopinfo.go:215: ==> Type: Rect invalid type
2025/10/11 16:12:19 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:19.872355 [INFO] typesutil/gopinfo.go:215: ==> Type: &{191 INT 100 <nil>} untyped int
2025/10/11 16:12:19 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:19.872369 [INFO] typesutil/gopinfo.go:215: ==> Type: &{195 INT 200 <nil>} untyped int
2025/10/11 16:12:19 ResetStmt
2025/10/11 16:12:19.872395 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0003422a0 {
.  var gopt main.GoPoint
.  var pt *main.Point
}

2025/10/11 16:12:19 End // Func
2025/10/11 16:12:19 main.xgo:17:14: Rect is not a type
2025/10/11 16:12:19 main.xgo:17:14: invalid composite literal type invalid type
2025/10/11 16:12:19.872451 [INFO] typesutil/check.go:179: typesutil.Check err: main.xgo:17:14: Rect is not a type
main.xgo:17:14: invalid composite literal type invalid type
2025/10/11 16:12:19.873433 [ERROR] log/logext.go:606:
goroutine 22 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xd15000, {0x0?, 0xc000362990?, 0xc0003d5c08?})
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc0003d5d48, {0xc0001962d0, 0x1, 0x4?}, {0xc0001a6c00, 0x2, 0x0?})
	/app/x/typesutil/check.go:180 +0xd19
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc0001af340, {0xc0001a6c00, 0x2, 0x2}, {0xc0001962d0, 0x1, 0x1}, 0x0)
	/app/x/typesutil/check_test.go:104 +0x416
github.com/goplus/xgo/x/typesutil_test.checkFiles(0xc0001af340, {0x9502e1?, 0xa654fa?}, {0x8b11c0?, 0xa118b0?}, {0x9502e9?, 0x66b?}, {0x8b11c0?, 0xa118c0?}, {0x94fa2a, ...}, ...)
	/app/x/typesutil/check_test.go:61 +0xb7
github.com/goplus/xgo/x/typesutil_test.TestCheckFiles(0xc0001b0c40)
	/app/x/typesutil/check_test.go:110 +0x93
testing.tRunner(0xc0001b0c40, 0x98d578)
	/usr/local/go/src/testing/testing.go:1792 +0xf4
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1851 +0x413

--- PASS: TestCheckFiles (0.98s)
=== RUN   TestCheckGoFiles
--- PASS: TestCheckGoFiles (0.00s)
=== RUN   TestCheckError
2025/10/11 16:12:19.874764 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:19.880798 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003dc900 {
}

2025/10/11 16:12:19 ==> Preload type Point
2025/10/11 16:12:19 ==> Preload func main
2025/10/11 16:12:19 ==> Load > NewType Point
2025/10/11 16:12:19 NewType Point
2025/10/11 16:12:19 ==> Load > InitType Point
2025/10/11 16:12:19.880869 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:19.880878 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.880891 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.880905 [INFO] typesutil/gopinfo.go:251: ==> Def: x field x int
2025/10/11 16:12:19.880911 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:19.880916 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.880921 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.880927 [INFO] typesutil/gopinfo.go:251: ==> Def: y field y int
2025/10/11 16:12:19.880939 [INFO] typesutil/gopinfo.go:215: ==> Type: &{13 0xc000475110 false} struct{x int; y int}
2025/10/11 16:12:19 InitType Point struct{x int; y int}
2025/10/11 16:12:19.880951 [INFO] typesutil/gopinfo.go:251: ==> Def: Point type main.Point struct{x int; y int}
2025/10/11 16:12:19 ==> Load func main
2025/10/11 16:12:19.880962 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:19 NewFunc main func()
2025/10/11 16:12:19 DefineVarStart [pt]
2025/10/11 16:12:19.880981 [INFO] typesutil/gopinfo.go:215: ==> Type: Point1 invalid type
2025/10/11 16:12:19 MapLit <nil> 0
2025/10/11 16:12:19.880991 [INFO] typesutil/gopinfo.go:215: ==> Type: Point1 invalid type
2025/10/11 16:12:19.881000 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Point1 51 [] 52 false} invalid type
2025/10/11 16:12:19 UnaryOp & flags: 0
2025/10/11 16:12:19 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:19.881063 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 & 0xc00033e3c0} *map[string]interface{}
2025/10/11 16:12:19 EndInit 1
2025/10/11 16:12:19.881077 [INFO] typesutil/gopinfo.go:251: ==> Def: pt var pt *map[string]interface{}
2025/10/11 16:12:19 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:19.881094 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/10/11 16:12:19.881099 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/10/11 16:12:19 Val pt *map[string]interface{}
2025/10/11 16:12:19.881111 [INFO] typesutil/gopinfo.go:265: ==> Use: pt var pt *map[string]interface{}
2025/10/11 16:12:19.881116 [INFO] typesutil/gopinfo.go:215: ==> Type: pt *map[string]interface{}
2025/10/11 16:12:19 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:19 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:19 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:19 ==> MatchType *map[string]interface{}, any
2025/10/11 16:12:19.881148 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:19.881155 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/10/11 16:12:19.881167 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 61 [pt] 0 [] 64 0} (n int, err error)
2025/10/11 16:12:19.881180 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0003dcae0 {
.  var pt *map[string]interface{}
}

2025/10/11 16:12:19 End // Func
2025/10/11 16:12:19 main.xgo:6:8: Point1 is not a type
2025/10/11 16:12:19.881201 [INFO] typesutil/check.go:179: typesutil.Check err: main.xgo:6:8: Point1 is not a type
2025/10/11 16:12:19.881485 [ERROR] log/logext.go:606:
goroutine 100 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xd15000, {0x0?, 0xc000344360?, 0xc000151cf8?})
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc000151e38, {0x0, 0x0, 0x4?}, {0xc000196b38, 0x1, 0x0?})
	/app/x/typesutil/check.go:180 +0xd19
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc00033e300, {0xc000196b38, 0x1, 0x1}, {0x0, 0x0, 0x0}, 0x0)
	/app/x/typesutil/check_test.go:104 +0x416
github.com/goplus/xgo/x/typesutil_test.checkFiles(0xc00033e300, {0x9502e1?, 0x564ea0?}, {0x8b11c0?, 0xa11910?}, {0x0?, 0x0?}, {0x8b11c0?, 0xa11500?}, {0x0, ...}, ...)
	/app/x/typesutil/check_test.go:61 +0xb7
github.com/goplus/xgo/x/typesutil_test.TestCheckError(0xc000282c40)
	/app/x/typesutil/check_test.go:183 +0x7f
testing.tRunner(0xc000282c40, 0x98d560)
	/usr/local/go/src/testing/testing.go:1792 +0xf4
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1851 +0x413

2025/10/11 16:12:19.881544 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:19.888866 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003e1b00 {
}

2025/10/11 16:12:19 ==> Preload var [i]
2025/10/11 16:12:19.888921 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:19.888933 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.888941 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19 ==> Load var int [i]
2025/10/11 16:12:19 NewVarDefs
2025/10/11 16:12:19 NewVar [i]
2025/10/11 16:12:19 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:19.888979 [INFO] typesutil/gopinfo.go:215: ==> Type: &{80 STRING "hello" <nil>} untyped string
2025/10/11 16:12:19 EndInit 1
2025/10/11 16:12:19 ==> MatchType untyped string ("hello"), int
2025/10/11 16:12:19 ResetInit
2025/10/11 16:12:19 main.xgo:2:13: cannot use "hello" (type untyped string) as type int in assignment
2025/10/11 16:12:19.889049 [INFO] typesutil/check.go:179: typesutil.Check err: main.xgo:2:13: cannot use "hello" (type untyped string) as type int in assignment
2025/10/11 16:12:19.889879 [ERROR] log/logext.go:606:
goroutine 100 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xd15000, {0x0?, 0xc000142850?, 0xc000559cf8?})
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc000559e38, {0x0, 0x0, 0x4?}, {0xc00069d6a8, 0x1, 0x0?})
	/app/x/typesutil/check.go:180 +0xd19
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc00033e300, {0xc00069d6a8, 0x1, 0x1}, {0x0, 0x0, 0x0}, 0x0)
	/app/x/typesutil/check_test.go:104 +0x416
github.com/goplus/xgo/x/typesutil_test.checkFiles(0xc00033e300, {0x9502e1?, 0x564ea0?}, {0x8b11c0?, 0xa11930?}, {0x0?, 0x0?}, {0x8b11c0?, 0xa11500?}, {0x0, ...}, ...)
	/app/x/typesutil/check_test.go:61 +0xb7
github.com/goplus/xgo/x/typesutil_test.TestCheckError(0xc000282c40)
	/app/x/typesutil/check_test.go:194 +0x105
testing.tRunner(0xc000282c40, 0x98d560)
	/usr/local/go/src/testing/testing.go:1792 +0xf4
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1851 +0x413

2025/10/11 16:12:19.889929 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:19.897508 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000340de0 {
}

2025/10/11 16:12:19 ==> Preload var [nums]
2025/10/11 16:12:19 ==> Preload func main
2025/10/11 16:12:19.897558 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:19.897568 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.897575 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:19.897591 [INFO] typesutil/gopinfo.go:215: ==> Type: &{99 <nil> int} []int
2025/10/11 16:12:19 ==> Load var []int [nums]
2025/10/11 16:12:19 NewVarDefs
2025/10/11 16:12:19 NewVar [nums]
2025/10/11 16:12:19.897615 [INFO] typesutil/gopinfo.go:251: ==> Def: nums var main.nums []int
2025/10/11 16:12:19 ==> Load func main
2025/10/11 16:12:19.897630 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:19 NewFunc main func()
2025/10/11 16:12:19 VarRef nums []int
2025/10/11 16:12:19.897651 [INFO] typesutil/gopinfo.go:265: ==> Use: nums var main.nums []int
2025/10/11 16:12:19.897658 [INFO] typesutil/gopinfo.go:215: ==> Type: nums []int
2025/10/11 16:12:19 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:19.897675 [INFO] typesutil/gopinfo.go:265: ==> Use: append builtin append
2025/10/11 16:12:19.897681 [INFO] typesutil/gopinfo.go:215: ==> Type: append invalid type
2025/10/11 16:12:19 Val nums []int
2025/10/11 16:12:19.897695 [INFO] typesutil/gopinfo.go:265: ==> Use: nums var main.nums []int
2025/10/11 16:12:19.897701 [INFO] typesutil/gopinfo.go:215: ==> Type: nums []int
2025/10/11 16:12:19 Val &{0 STRING "NaN"} *ast.BasicLit
2025/10/11 16:12:19.897719 [INFO] typesutil/gopinfo.go:215: ==> Type: &{125 STRING "NaN" <nil>} untyped string
2025/10/11 16:12:19 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:19 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:19 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:12:19 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:12:19 ==> MatchType []int, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:19 ==> MatchType untyped string ("NaN"), unboundFuncParam{typ: int}
2025/10/11 16:12:19 ResetStmt
2025/10/11 16:12:19.897795 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000340f00 {
}

2025/10/11 16:12:19 End // Func
2025/10/11 16:12:19 main.xgo:3:21: boundType untyped string => int failed
2025/10/11 16:12:19.897822 [INFO] typesutil/check.go:179: typesutil.Check err: boundType untyped string => int failed
2025/10/11 16:12:19.899548 [ERROR] log/logext.go:606:
goroutine 100 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xd15000, {0x0?, 0xc000337bc0?, 0xc000559cf8?})
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc00065de38, {0x0, 0x0, 0x4?}, {0xc000196178, 0x1, 0x0?})
	/app/x/typesutil/check.go:180 +0xd19
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc00033e300, {0xc000196178, 0x1, 0x1}, {0x0, 0x0, 0x0}, 0x0)
	/app/x/typesutil/check_test.go:104 +0x416
github.com/goplus/xgo/x/typesutil_test.checkFiles(0xc00033e300, {0x9502e1?, 0x564ea0?}, {0x8b11c0?, 0xa11940?}, {0x0?, 0x0?}, {0x8b11c0?, 0xa11500?}, {0x0, ...}, ...)
	/app/x/typesutil/check_test.go:61 +0xb7
github.com/goplus/xgo/x/typesutil_test.TestCheckError(0xc000282c40)
	/app/x/typesutil/check_test.go:200 +0x188
testing.tRunner(0xc000282c40, 0x98d560)
	/usr/local/go/src/testing/testing.go:1792 +0xf4
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1851 +0x413

--- PASS: TestCheckError (0.02s)
=== RUN   TestBadFile
2025/10/11 16:12:19.899747 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 0 goFiles = 0
2025/10/11 16:12:20 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:20 ==> NewOverloadFunc NewRange
2025/10/11 16:12:20 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:20 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:20 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:20 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:20 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:20 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:20 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:20 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:20 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:20 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:20 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:20 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:20 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:20 ==> NewOverloadMethod Uint128 Gop_Sub
--- PASS: TestBadFile (1.35s)
=== RUN   TestCheckOverload
2025/10/11 16:12:21.247492 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:21.260611 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0005a8600 {
}

2025/10/11 16:12:21 ==> Preload type foo
2025/10/11 16:12:21 ==> Preload method foo.mulInt
2025/10/11 16:12:21 ==> Preload method foo.mulFoo
2025/10/11 16:12:21 NewConstDefs
2025/10/11 16:12:21 ==> Preload const [Gopo_foo_mul]
2025/10/11 16:12:21 ==> Preload func addInt0
2025/10/11 16:12:21 ==> Preload func addInt1
2025/10/11 16:12:21 ==> Preload func addInt2
2025/10/11 16:12:21 ==> Preload var [addInt3]
2025/10/11 16:12:21 ==> Preload func add__4
2025/10/11 16:12:21 NewConstDefs
2025/10/11 16:12:21 ==> Preload const [Gopo_add]
2025/10/11 16:12:21 ==> Preload var [a b]
2025/10/11 16:12:21 ==> Preload var [c]
2025/10/11 16:12:21 ==> Preload var [d]
2025/10/11 16:12:21 ==> Preload func init
2025/10/11 16:12:21 ==> Load > NewType foo
2025/10/11 16:12:21 NewType foo
2025/10/11 16:12:21 ==> Load > InitType foo
2025/10/11 16:12:21.260839 [INFO] typesutil/gopinfo.go:215: ==> Type: &{11 0xc00041ba10 false} struct{}
2025/10/11 16:12:21 InitType foo struct{}
2025/10/11 16:12:21.260882 [INFO] typesutil/gopinfo.go:251: ==> Def: foo type main.foo struct{}
2025/10/11 16:12:21 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:12:21.260908 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:12:21.260922 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:12:21.260938 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a *main.foo
2025/10/11 16:12:21 ==> Load method *main.foo.mulInt
2025/10/11 16:12:21.260961 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:21.260972 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:21.260987 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:21.260998 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/10/11 16:12:21 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:12:21.261018 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:12:21.261029 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:12:21.261040 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:12:21.261060 [INFO] typesutil/gopinfo.go:215: ==> Type: &{51 foo} *main.foo
2025/10/11 16:12:21.261081 [INFO] typesutil/gopinfo.go:251: ==> Def: mulInt func (*main.foo).mulInt(b int) *main.foo
2025/10/11 16:12:21 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:12:21.261103 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:12:21.261114 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:12:21.261128 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a *main.foo
2025/10/11 16:12:21 ==> Load method *main.foo.mulFoo
2025/10/11 16:12:21 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:12:21.261154 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:12:21.261164 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:12:21.261175 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:12:21.261188 [INFO] typesutil/gopinfo.go:215: ==> Type: &{94 foo} *main.foo
2025/10/11 16:12:21.261198 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b *main.foo
2025/10/11 16:12:21 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:12:21.261216 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:12:21.261229 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:12:21.261241 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:12:21.261254 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 foo} *main.foo
2025/10/11 16:12:21.261271 [INFO] typesutil/gopinfo.go:251: ==> Def: mulFoo func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/10/11 16:12:21 ==> Load const [Gopo_foo_mul] <nil>
2025/10/11 16:12:21 NewConst [Gopo_foo_mul] 0
2025/10/11 16:12:21 Val &{0 STRING ".mulInt,.mulFoo"} *ast.BasicLit
2025/10/11 16:12:21.261323 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING ".mulInt,.mulFoo" <nil>} untyped string
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.261349 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_foo_mul const main.Gopo_foo_mul untyped string
2025/10/11 16:12:21 ==> Load func addInt0
2025/10/11 16:12:21.261370 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt0 func main.addInt0()
2025/10/11 16:12:21 NewFunc addInt0 func()
2025/10/11 16:12:21.261398 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt0 scope 0xc0005a8b40 {
}

2025/10/11 16:12:21 End // Func
2025/10/11 16:12:21 ==> Load func addInt1
2025/10/11 16:12:21.261427 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:21.261437 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:21.261452 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:21.261463 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:12:21.261476 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt1 func main.addInt1(i int)
2025/10/11 16:12:21 NewFunc addInt1 func(i int)
2025/10/11 16:12:21.261503 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt1 scope 0xc0005a8c60 {
.  var i int
}

2025/10/11 16:12:21 End // Func
2025/10/11 16:12:21 ==> Load func addInt2
2025/10/11 16:12:21.261528 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:21.261539 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:21.261549 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:21.261562 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:12:21.261573 [INFO] typesutil/gopinfo.go:251: ==> Def: j var j int
2025/10/11 16:12:21.261588 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt2 func main.addInt2(i int, j int)
2025/10/11 16:12:21 NewFunc addInt2 func(i int, j int)
2025/10/11 16:12:21.261616 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt2 scope 0xc0005a8de0 {
.  var i int
.  var j int
}

2025/10/11 16:12:21 End // Func
2025/10/11 16:12:21 ==> Load var <nil> [addInt3]
2025/10/11 16:12:21 NewVarDefs
2025/10/11 16:12:21 NewVar [addInt3]
2025/10/11 16:12:21.261653 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:21.261664 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:21.261674 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:21.261685 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:12:21.261699 [INFO] typesutil/gopinfo.go:251: ==> Def: j var j int
2025/10/11 16:12:21.261709 [INFO] typesutil/gopinfo.go:251: ==> Def: k var k int
2025/10/11 16:12:21.261733 [INFO] typesutil/gopinfo.go:215: ==> Type: &{256 <nil> 0xc00033c480 <nil>} func(i int, j int, k int)
2025/10/11 16:12:21.261755 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0006a5080 0xc00033c5d0} func(i int, j int, k int)
2025/10/11 16:12:21 NewClosure func(i int, j int, k int)
2025/10/11 16:12:21.261787 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0005a9020 {
.  var i int
.  var j int
.  var k int
}

2025/10/11 16:12:21 End // Func
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.261817 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt3 var main.addInt3 func(i int, j int, k int)
2025/10/11 16:12:21 ==> Load func add__4
2025/10/11 16:12:21.261835 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:21.261846 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:21.261857 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:21.261868 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a string
2025/10/11 16:12:21.261879 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b string
2025/10/11 16:12:21.261890 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:21.261901 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:21.261911 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:21.261927 [INFO] typesutil/gopinfo.go:251: ==> Def: add__4 func main.add__4(a string, b string) string
2025/10/11 16:12:21 NewFunc add__4 func(a string, b string) string
2025/10/11 16:12:21 Val a string
2025/10/11 16:12:21.261961 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a string
2025/10/11 16:12:21.261973 [INFO] typesutil/gopinfo.go:215: ==> Type: a string
2025/10/11 16:12:21 Val b string
2025/10/11 16:12:21.261993 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b string
2025/10/11 16:12:21.262009 [INFO] typesutil/gopinfo.go:215: ==> Type: b string
2025/10/11 16:12:21 BinaryOp +
2025/10/11 16:12:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:21 ==> MatchType string, unboundFuncParam{typ: string}
2025/10/11 16:12:21.262088 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 367 + b} string
2025/10/11 16:12:21 Return 1
2025/10/11 16:12:21 ==> MatchType string, string
2025/10/11 16:12:21.262124 [INFO] typesutil/gopinfo.go:332: ==> Scope: func add__4 scope 0xc0005a94a0 {
.  var a string
.  var b string
}

2025/10/11 16:12:21 End // Func
2025/10/11 16:12:21 ==> Load const [Gopo_add] <nil>
2025/10/11 16:12:21 NewConst [Gopo_add] 0
2025/10/11 16:12:21 Val &{0 STRING "addInt0,addInt1,addInt2,addInt3,"} *ast.BasicLit
2025/10/11 16:12:21.262172 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING "addInt0,addInt1,addInt2,addInt3," <nil>} untyped string
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.262190 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_add const main.Gopo_add untyped string
2025/10/11 16:12:21 ==> NewOverloadFunc add
2025/10/11 16:12:21 ==> NewOverloadMethod foo mul
2025/10/11 16:12:21 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:12:21.262254 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:12:21.262265 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:12:21.262277 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:12:21.262291 [INFO] typesutil/gopinfo.go:215: ==> Type: &{386 foo} *main.foo
2025/10/11 16:12:21 ==> Load var *main.foo [a b]
2025/10/11 16:12:21 NewVarDefs
2025/10/11 16:12:21 NewVar [a b]
2025/10/11 16:12:21.262398 [INFO] typesutil/gopinfo.go:251: ==> Def: a var main.a *main.foo
2025/10/11 16:12:21.262412 [INFO] typesutil/gopinfo.go:251: ==> Def: b var main.b *main.foo
2025/10/11 16:12:21 ==> Load var <nil> [c]
2025/10/11 16:12:21 NewVarDefs
2025/10/11 16:12:21 NewVar [c]
2025/10/11 16:12:21 Val a *main.foo
2025/10/11 16:12:21.262449 [INFO] typesutil/gopinfo.go:265: ==> Use: a var main.a *main.foo
2025/10/11 16:12:21.262463 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/10/11 16:12:21 Member mul 1 // *main.foo
2025/10/11 16:12:21.262492 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.262505 [INFO] typesutil/gopinfo.go:274: ==> Overloads: mul TyOverloadMethod
2025/10/11 16:12:21.262521 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:21.262549 [INFO] typesutil/gopinfo.go:215: ==> Type: &{405 INT 100 <nil>} untyped int
2025/10/11 16:12:21 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(b int) *main.foo args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped int (100), int
2025/10/11 16:12:21.262605 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (*main.foo).mulInt(b int) *main.foo
2025/10/11 16:12:21.262620 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(b int) *main.foo
2025/10/11 16:12:21.262642 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003f3aa0 404 [0xc00033c960] 0 [] 408 0} *main.foo
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.262663 [INFO] typesutil/gopinfo.go:251: ==> Def: c var main.c *main.foo
2025/10/11 16:12:21 ==> Load var <nil> [d]
2025/10/11 16:12:21 NewVarDefs
2025/10/11 16:12:21 NewVar [d]
2025/10/11 16:12:21 Val a *main.foo
2025/10/11 16:12:21.262700 [INFO] typesutil/gopinfo.go:265: ==> Use: a var main.a *main.foo
2025/10/11 16:12:21.262719 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/10/11 16:12:21 Member mul 1 // *main.foo
2025/10/11 16:12:21.262750 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.262760 [INFO] typesutil/gopinfo.go:274: ==> Overloads: mul TyOverloadMethod
2025/10/11 16:12:21.262776 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 Val c *main.foo
2025/10/11 16:12:21.262797 [INFO] typesutil/gopinfo.go:265: ==> Use: c var main.c *main.foo
2025/10/11 16:12:21.262808 [INFO] typesutil/gopinfo.go:215: ==> Type: c *main.foo
2025/10/11 16:12:21 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(b int) *main.foo args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchType *main.foo, int
2025/10/11 16:12:21 ==> MatchFuncCall func(b *main.foo) *main.foo args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchType *main.foo, *main.foo
2025/10/11 16:12:21.262878 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/10/11 16:12:21.262893 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(b *main.foo) *main.foo
2025/10/11 16:12:21.262910 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003f3ab8 423 [c] 0 [] 425 0} *main.foo
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.262928 [INFO] typesutil/gopinfo.go:251: ==> Def: d var main.d *main.foo
2025/10/11 16:12:21 ==> Load func init
2025/10/11 16:12:21.262946 [INFO] typesutil/gopinfo.go:251: ==> Def: init func main.init()
2025/10/11 16:12:21 NewFunc init func()
2025/10/11 16:12:21 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.262978 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.262987 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/10/11 16:12:21.262998 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:21.263022 [INFO] typesutil/gopinfo.go:215: ==> Type: &{447 INT 100 <nil>} untyped int
2025/10/11 16:12:21 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:21.263044 [INFO] typesutil/gopinfo.go:215: ==> Type: &{452 INT 200 <nil>} untyped int
2025/10/11 16:12:21 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func() args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(i int) args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(i int, j int) args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped int (100), int
2025/10/11 16:12:21 ==> MatchType untyped int (200), int
2025/10/11 16:12:21.263134 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.addInt2(i int, j int)
2025/10/11 16:12:21.263146 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(i int, j int)
2025/10/11 16:12:21.263167 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc00033cb10 0xc00033cb40] 0 [] 0 455} ()
2025/10/11 16:12:21 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.263190 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.263199 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/10/11 16:12:21.263210 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:21.263234 [INFO] typesutil/gopinfo.go:215: ==> Type: &{461 INT 100 <nil>} untyped int
2025/10/11 16:12:21 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:21.263256 [INFO] typesutil/gopinfo.go:215: ==> Type: &{466 INT 200 <nil>} untyped int
2025/10/11 16:12:21 Val &{0 INT 300} *ast.BasicLit
2025/10/11 16:12:21.263276 [INFO] typesutil/gopinfo.go:215: ==> Type: &{471 INT 300 <nil>} untyped int
2025/10/11 16:12:21 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func() args: 3 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(i int) args: 3 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(i int, j int) args: 3 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(i int, j int, k int) args: 3 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped int (100), int
2025/10/11 16:12:21 ==> MatchType untyped int (200), int
2025/10/11 16:12:21 ==> MatchType untyped int (300), int
2025/10/11 16:12:21.263392 [INFO] typesutil/gopinfo.go:265: ==> Use: add var main.addInt3 func(i int, j int, k int)
2025/10/11 16:12:21.263405 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(i int, j int, k int)
2025/10/11 16:12:21.263424 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc00033cbd0 0xc00033cc30 0xc00033cc90] 0 [] 0 474} ()
2025/10/11 16:12:21 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.263445 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.263453 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/10/11 16:12:21.263464 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:21.263486 [INFO] typesutil/gopinfo.go:215: ==> Type: &{480 STRING "hello" <nil>} untyped string
2025/10/11 16:12:21 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:12:21.263506 [INFO] typesutil/gopinfo.go:215: ==> Type: &{489 STRING "world" <nil>} untyped string
2025/10/11 16:12:21 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func() args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(i int) args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(i int, j int) args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped string ("hello"), int
2025/10/11 16:12:21 ==> MatchFuncCall func(i int, j int, k int) args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:21 ==> MatchType untyped string ("world"), string
2025/10/11 16:12:21.263629 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add__4(a string, b string) string
2025/10/11 16:12:21.263642 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(a string, b string) string
2025/10/11 16:12:21.263659 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 479 [0xc00033ccf0 0xc00033cd50] 0 [] 496 0} string
2025/10/11 16:12:21.263673 [INFO] typesutil/gopinfo.go:332: ==> Scope: func init scope 0xc0005a9ec0 {
}

2025/10/11 16:12:21 End // Func
2025/10/11 16:12:21 NewFunc mulInt (*main.foo) func(b int) *main.foo
2025/10/11 16:12:21 Val a *main.foo
2025/10/11 16:12:21.263716 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a *main.foo
2025/10/11 16:12:21.263727 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/10/11 16:12:21 Return 1
2025/10/11 16:12:21 ==> MatchType *main.foo, *main.foo
2025/10/11 16:12:21.263761 [INFO] typesutil/gopinfo.go:332: ==> Scope: func mulInt scope 0xc0005aa120 {
.  var a *main.foo
.  var b int
}

2025/10/11 16:12:21 End // Func
2025/10/11 16:12:21 NewFunc mulFoo (*main.foo) func(b *main.foo) *main.foo
2025/10/11 16:12:21 Val a *main.foo
2025/10/11 16:12:21.263815 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a *main.foo
2025/10/11 16:12:21.263826 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/10/11 16:12:21 Return 1
2025/10/11 16:12:21 ==> MatchType *main.foo, *main.foo
2025/10/11 16:12:21.263861 [INFO] typesutil/gopinfo.go:332: ==> Scope: func mulFoo scope 0xc0005aa180 {
.  var a *main.foo
.  var b *main.foo
}

2025/10/11 16:12:21 End // Func
2025/10/11 16:12:21.263887 [INFO] typesutil/gopinfo.go:251: ==> Def: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.263907 [INFO] typesutil/gopinfo.go:215: ==> Type: &{329 <nil> 0xc00033c720 0xc00033c780} func(a string, b string) string
2025/10/11 16:12:21.263922 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0006a51e0 0xc00033c8d0} func(a string, b string) string
2025/10/11 16:12:21.263933 [INFO] typesutil/gopinfo.go:292: ==> Implicit: func main.add__4(a string, b string) string
2025/10/11 16:12:21.263945 [INFO] typesutil/gopinfo.go:251: ==> Def: add func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.263963 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt1 func main.addInt1(i int)
2025/10/11 16:12:21.263975 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt2 func main.addInt2(i int, j int)
2025/10/11 16:12:21.263987 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt3 var main.addInt3 func(i int, j int, k int)
2025/10/11 16:12:21.263999 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:12:21.264011 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:12:21.264026 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:12:21.264053 [INFO] typesutil/gopinfo.go:265: ==> Use: mulInt func (*main.foo).mulInt(b int) *main.foo
2025/10/11 16:12:21.264067 [INFO] typesutil/gopinfo.go:265: ==> Use: mulFoo func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/10/11 16:12:21.264076 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt0 func main.addInt0()
--- PASS: TestCheckOverload (0.02s)
=== RUN   TestCheckError2
2025/10/11 16:12:21.264558 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:21.277480 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0002d6ae0 {
}

2025/10/11 16:12:21 ==> Preload type Foo
2025/10/11 16:12:21 ==> Preload func main
2025/10/11 16:12:21 ==> Load > NewType Foo
2025/10/11 16:12:21 NewType Foo
2025/10/11 16:12:21 ==> Load > InitType Foo
2025/10/11 16:12:21.277532 [INFO] typesutil/gopinfo.go:265: ==> Use: bool type bool
2025/10/11 16:12:21.277541 [INFO] typesutil/gopinfo.go:215: ==> Type: bool bool
2025/10/11 16:12:21.277546 [INFO] typesutil/gopinfo.go:215: ==> Type: bool bool
2025/10/11 16:12:21.277553 [INFO] typesutil/gopinfo.go:251: ==> Def: B field B bool
2025/10/11 16:12:21.277565 [INFO] typesutil/gopinfo.go:215: ==> Type: &{11 0xc0002bb140 false} struct{B bool}
2025/10/11 16:12:21 InitType Foo struct{B bool}
2025/10/11 16:12:21.277576 [INFO] typesutil/gopinfo.go:251: ==> Def: Foo type main.Foo struct{B bool}
2025/10/11 16:12:21 ==> Load func main
2025/10/11 16:12:21.277586 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:21 NewFunc main func()
2025/10/11 16:12:21 DefineVarStart [bar]
2025/10/11 16:12:21 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:21.277613 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 INT 2 <nil>} untyped int
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.277624 [INFO] typesutil/gopinfo.go:251: ==> Def: bar var bar int
2025/10/11 16:12:21 DefineVarStart [gotbar]
2025/10/11 16:12:21 Val false untyped bool
2025/10/11 16:12:21.277637 [INFO] typesutil/gopinfo.go:265: ==> Use: false const false untyped bool
2025/10/11 16:12:21.277642 [INFO] typesutil/gopinfo.go:215: ==> Type: false untyped bool
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.277650 [INFO] typesutil/gopinfo.go:251: ==> Def: gotbar var gotbar bool
2025/10/11 16:12:21 DefineVarStart [boolBar]
2025/10/11 16:12:21 Val false untyped bool
2025/10/11 16:12:21.277662 [INFO] typesutil/gopinfo.go:265: ==> Use: false const false untyped bool
2025/10/11 16:12:21.277667 [INFO] typesutil/gopinfo.go:215: ==> Type: false untyped bool
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.277674 [INFO] typesutil/gopinfo.go:251: ==> Def: boolBar var boolBar bool
2025/10/11 16:12:21 DefineVarStart [gg]
2025/10/11 16:12:21 ==> LookupParent Foo => type main.Foo struct{B bool}
2025/10/11 16:12:21.277687 [INFO] typesutil/gopinfo.go:265: ==> Use: Foo type main.Foo struct{B bool}
2025/10/11 16:12:21.277693 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/10/11 16:12:21.277700 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/10/11 16:12:21 Val 0 int
2025/10/11 16:12:21.277716 [INFO] typesutil/gopinfo.go:265: ==> Use: B field B bool
2025/10/11 16:12:21 Val true untyped bool
2025/10/11 16:12:21.277727 [INFO] typesutil/gopinfo.go:265: ==> Use: true const true untyped bool
2025/10/11 16:12:21.277733 [INFO] typesutil/gopinfo.go:215: ==> Type: true untyped bool
2025/10/11 16:12:21 StructLit main.Foo 2 true
2025/10/11 16:12:21.277746 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/10/11 16:12:21.277758 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Foo 83 [0xc0002bb200] 91 false} main.Foo
2025/10/11 16:12:21 UnaryOp & flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:21.277779 [INFO] typesutil/gopinfo.go:215: ==> Type: &{79 & 0xc0002b6900} *main.Foo
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.277788 [INFO] typesutil/gopinfo.go:251: ==> Def: gg var gg *main.Foo
2025/10/11 16:12:21 If
2025/10/11 16:12:21 Val bar int
2025/10/11 16:12:21.277800 [INFO] typesutil/gopinfo.go:265: ==> Use: bar var bar int
2025/10/11 16:12:21.277805 [INFO] typesutil/gopinfo.go:215: ==> Type: bar int
2025/10/11 16:12:21 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:21.277816 [INFO] typesutil/gopinfo.go:215: ==> Type: &{103 INT 2 <nil>} untyped int
2025/10/11 16:12:21 BinaryOp ==
2025/10/11 16:12:21.277827 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar 100 == 0xc0002bb260} untyped bool
2025/10/11 16:12:21 Val gotbar bool
2025/10/11 16:12:21.277835 [INFO] typesutil/gopinfo.go:265: ==> Use: gotbar var gotbar bool
2025/10/11 16:12:21.277839 [INFO] typesutil/gopinfo.go:215: ==> Type: gotbar bool
2025/10/11 16:12:21 UnaryOp ! flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:21.277867 [INFO] typesutil/gopinfo.go:215: ==> Type: &{108 ! gotbar} bool
2025/10/11 16:12:21 BinaryOp &&
2025/10/11 16:12:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:21 ==> MatchType bool, unboundFuncParam{typ: untyped bool}
2025/10/11 16:12:21.277897 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002bb290 105 && 0xc000199420} bool
2025/10/11 16:12:21.277911 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc0002d6e40 {
}

2025/10/11 16:12:21 Then
2025/10/11 16:12:21 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.277938 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/10/11 16:12:21.277945 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/10/11 16:12:21 Val &{0 STRING "wow!"} *ast.BasicLit
2025/10/11 16:12:21.277958 [INFO] typesutil/gopinfo.go:215: ==> Type: &{127 STRING "wow!" <nil>} untyped string
2025/10/11 16:12:21 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped string ("wow!"), any
2025/10/11 16:12:21.277986 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:21.277992 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/10/11 16:12:21.278003 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 126 [0xc0002bb320] 0 [] 133 0} (n int, err error)
2025/10/11 16:12:21 Else
2025/10/11 16:12:21 If
2025/10/11 16:12:21 Val bar int
2025/10/11 16:12:21.278017 [INFO] typesutil/gopinfo.go:265: ==> Use: bar var bar int
2025/10/11 16:12:21.278022 [INFO] typesutil/gopinfo.go:215: ==> Type: bar int
2025/10/11 16:12:21 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:21.278033 [INFO] typesutil/gopinfo.go:215: ==> Type: &{152 INT 1 <nil>} untyped int
2025/10/11 16:12:21 BinaryOp ==
2025/10/11 16:12:21.278041 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar 149 == 0xc0002bb3b0} untyped bool
2025/10/11 16:12:21 Val gotbar bool
2025/10/11 16:12:21.278049 [INFO] typesutil/gopinfo.go:265: ==> Use: gotbar var gotbar bool
2025/10/11 16:12:21.278055 [INFO] typesutil/gopinfo.go:215: ==> Type: gotbar bool
2025/10/11 16:12:21 BinaryOp &&
2025/10/11 16:12:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:21 ==> MatchType bool, unboundFuncParam{typ: untyped bool}
2025/10/11 16:12:21.278078 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002bb3e0 154 && gotbar} bool
2025/10/11 16:12:21.278083 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc0002d71a0 {
}

2025/10/11 16:12:21 Then
2025/10/11 16:12:21 If
2025/10/11 16:12:21 Val boolBar bool
2025/10/11 16:12:21.278097 [INFO] typesutil/gopinfo.go:265: ==> Use: boolBar var boolBar bool
2025/10/11 16:12:21.278102 [INFO] typesutil/gopinfo.go:215: ==> Type: boolBar bool
2025/10/11 16:12:21 UnaryOp ! flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:21.278119 [INFO] typesutil/gopinfo.go:215: ==> Type: &{170 ! boolBar} bool
2025/10/11 16:12:21.278124 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc0002d7380 {
}

2025/10/11 16:12:21 Then
2025/10/11 16:12:21 VarRef boolBar bool
2025/10/11 16:12:21.278134 [INFO] typesutil/gopinfo.go:265: ==> Use: boolBar var boolBar bool
2025/10/11 16:12:21.278139 [INFO] typesutil/gopinfo.go:215: ==> Type: boolBar bool
2025/10/11 16:12:21 Val true untyped bool
2025/10/11 16:12:21.278149 [INFO] typesutil/gopinfo.go:265: ==> Use: true const true untyped bool
2025/10/11 16:12:21.278154 [INFO] typesutil/gopinfo.go:215: ==> Type: true untyped bool
2025/10/11 16:12:21 Assign 1 1
2025/10/11 16:12:21 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:21 For
2025/10/11 16:12:21.278171 [INFO] typesutil/gopinfo.go:332: ==> Scope: for statement scope 0xc0002d7500 {
}

2025/10/11 16:12:21 DefineVarStart [i]
2025/10/11 16:12:21 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:21.278185 [INFO] typesutil/gopinfo.go:215: ==> Type: &{209 INT 0 <nil>} untyped int
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.278193 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:12:21 Val i int
2025/10/11 16:12:21.278200 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:12:21.278211 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:12:21 Val &{0 INT 20} *ast.BasicLit
2025/10/11 16:12:21.278225 [INFO] typesutil/gopinfo.go:215: ==> Type: &{216 INT 20 <nil>} untyped int
2025/10/11 16:12:21 BinaryOp <
2025/10/11 16:12:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:21 ==> MatchType untyped int (20), unboundFuncParam{typ: int}
2025/10/11 16:12:21.278251 [INFO] typesutil/gopinfo.go:215: ==> Type: &{i 214 < 0xc0002bb530} untyped bool
2025/10/11 16:12:21 Then
2025/10/11 16:12:21.278265 [INFO] typesutil/gopinfo.go:332: ==> Scope: for body scope 0xc0002d7680 {
}

2025/10/11 16:12:21 If
2025/10/11 16:12:21 Val gg *main.Foo
2025/10/11 16:12:21.278278 [INFO] typesutil/gopinfo.go:265: ==> Use: gg var gg *main.Foo
2025/10/11 16:12:21.278282 [INFO] typesutil/gopinfo.go:215: ==> Type: gg *main.Foo
2025/10/11 16:12:21 Member P 2 // *main.Foo
2025/10/11 16:12:21 ResetStmt
2025/10/11 16:12:21 End // If
2025/10/11 16:12:21 Post
2025/10/11 16:12:21 VarRef i int
2025/10/11 16:12:21.278314 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:12:21.278320 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:12:21 IncDec ++
2025/10/11 16:12:21 End // For
2025/10/11 16:12:21.278334 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc0002d74a0 {
}

2025/10/11 16:12:21 End // If
2025/10/11 16:12:21.278341 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc0002d7320 {
}

2025/10/11 16:12:21 End // If
2025/10/11 16:12:21.278348 [INFO] typesutil/gopinfo.go:332: ==> Scope: else body scope 0xc0002d7140 {
}

2025/10/11 16:12:21 End // If
2025/10/11 16:12:21.278364 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0002d6c60 {
.  var bar int
.  var boolBar bool
.  var gg *main.Foo
.  var gotbar bool
}

2025/10/11 16:12:21 End // Func
2025/10/11 16:12:21.278376 [INFO] typesutil/check.go:179: typesutil.Check err: main.xgo:16:7: gg.P undefined (type *main.Foo has no field or method P)
2025/10/11 16:12:21.280603 [ERROR] log/logext.go:606:
goroutine 105 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xd15000, {0x0?, 0xc000474c00?, 0xc000387ce8?})
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc000561e28, {0x0, 0x0, 0x4?}, {0xc000a8a9b8, 0x1, 0x0?})
	/app/x/typesutil/check.go:180 +0xd19
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc0002b6740, {0xc000a8a9b8, 0x1, 0x1}, {0x0, 0x0, 0x0}, 0xc0001a74b0)
	/app/x/typesutil/check_test.go:104 +0x416
github.com/goplus/xgo/x/typesutil_test.checkFilesWithErrorHandler(0xc0002b6740, {0x9502e1?, 0x66a?}, {0x8b11c0?, 0xa11970?}, {0x0?, 0xc0002cdf60?}, {0x8b11c0?, 0xa11500?}, {0x0, ...}, ...)
	/app/x/typesutil/check_test.go:69 +0xbc
github.com/goplus/xgo/x/typesutil_test.TestCheckError2(0xc000282fc0)
	/app/x/typesutil/check_test.go:302 +0xe5
testing.tRunner(0xc000282fc0, 0x98d568)
	/usr/local/go/src/testing/testing.go:1792 +0xf4
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1851 +0x413

--- PASS: TestCheckError2 (0.02s)
=== RUN   TestCheckError3
2025/10/11 16:12:21.281172 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:21.293482 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00052a180 {
}

2025/10/11 16:12:21 ==> Preload type Foo
2025/10/11 16:12:21 ==> Preload func main
2025/10/11 16:12:21 ==> Load > NewType Foo
2025/10/11 16:12:21 NewType Foo
2025/10/11 16:12:21 ==> Load > InitType Foo
2025/10/11 16:12:21.293527 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:21.293535 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:21.293546 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:21.293556 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 <nil> string} []string
2025/10/11 16:12:21.293562 [INFO] typesutil/gopinfo.go:251: ==> Def: B field B []string
2025/10/11 16:12:21.293573 [INFO] typesutil/gopinfo.go:215: ==> Type: &{11 0xc000474090 false} struct{B []string}
2025/10/11 16:12:21 InitType Foo struct{B []string}
2025/10/11 16:12:21.293585 [INFO] typesutil/gopinfo.go:251: ==> Def: Foo type main.Foo struct{B []string}
2025/10/11 16:12:21 ==> Load func main
2025/10/11 16:12:21.293596 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:21 NewFunc main func()
2025/10/11 16:12:21 DefineVarStart [bar]
2025/10/11 16:12:21 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:21.293621 [INFO] typesutil/gopinfo.go:215: ==> Type: &{42 INT 2 <nil>} untyped int
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.293631 [INFO] typesutil/gopinfo.go:251: ==> Def: bar var bar int
2025/10/11 16:12:21 DefineVarStart [gotbar]
2025/10/11 16:12:21 Val false untyped bool
2025/10/11 16:12:21.293645 [INFO] typesutil/gopinfo.go:265: ==> Use: false const false untyped bool
2025/10/11 16:12:21.293650 [INFO] typesutil/gopinfo.go:215: ==> Type: false untyped bool
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.293658 [INFO] typesutil/gopinfo.go:251: ==> Def: gotbar var gotbar bool
2025/10/11 16:12:21 DefineVarStart [boolBar]
2025/10/11 16:12:21 Val false untyped bool
2025/10/11 16:12:21.293670 [INFO] typesutil/gopinfo.go:265: ==> Use: false const false untyped bool
2025/10/11 16:12:21.293675 [INFO] typesutil/gopinfo.go:215: ==> Type: false untyped bool
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.293683 [INFO] typesutil/gopinfo.go:251: ==> Def: boolBar var boolBar bool
2025/10/11 16:12:21 DefineVarStart [gg]
2025/10/11 16:12:21 ==> LookupParent Foo => type main.Foo struct{B []string}
2025/10/11 16:12:21.293698 [INFO] typesutil/gopinfo.go:265: ==> Use: Foo type main.Foo struct{B []string}
2025/10/11 16:12:21.293703 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/10/11 16:12:21.293708 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/10/11 16:12:21 Val 0 int
2025/10/11 16:12:21.293716 [INFO] typesutil/gopinfo.go:265: ==> Use: B field B []string
2025/10/11 16:12:21.293722 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:21.293727 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:21.293733 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:21.293741 [INFO] typesutil/gopinfo.go:215: ==> Type: &{91 <nil> string} []string
2025/10/11 16:12:21 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:21.293752 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 STRING "hello" <nil>} untyped string
2025/10/11 16:12:21 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:12:21.293762 [INFO] typesutil/gopinfo.go:215: ==> Type: &{109 STRING "world" <nil>} untyped string
2025/10/11 16:12:21 SliceLit []string 2 false
2025/10/11 16:12:21.293775 [INFO] typesutil/gopinfo.go:215: ==> Type: &{91 <nil> string} []string
2025/10/11 16:12:21.293790 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000474180 99 [0xc0004741b0 0xc0004741e0] 116 false} []string
2025/10/11 16:12:21 StructLit main.Foo 2 true
2025/10/11 16:12:21.293801 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/10/11 16:12:21.293808 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Foo 87 [0xc000474210] 117 false} main.Foo
2025/10/11 16:12:21 UnaryOp & flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:21.293835 [INFO] typesutil/gopinfo.go:215: ==> Type: &{83 & 0xc0002dc200} *main.Foo
2025/10/11 16:12:21 EndInit 1
2025/10/11 16:12:21.293842 [INFO] typesutil/gopinfo.go:251: ==> Def: gg var gg *main.Foo
2025/10/11 16:12:21 If
2025/10/11 16:12:21 Val bar int
2025/10/11 16:12:21.293853 [INFO] typesutil/gopinfo.go:265: ==> Use: bar var bar int
2025/10/11 16:12:21.293866 [INFO] typesutil/gopinfo.go:215: ==> Type: bar int
2025/10/11 16:12:21 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:21.293877 [INFO] typesutil/gopinfo.go:215: ==> Type: &{129 INT 2 <nil>} untyped int
2025/10/11 16:12:21 BinaryOp ==
2025/10/11 16:12:21.293888 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar 126 == 0xc000474270} untyped bool
2025/10/11 16:12:21 Val gotbar bool
2025/10/11 16:12:21.293896 [INFO] typesutil/gopinfo.go:265: ==> Use: gotbar var gotbar bool
2025/10/11 16:12:21.293901 [INFO] typesutil/gopinfo.go:215: ==> Type: gotbar bool
2025/10/11 16:12:21 UnaryOp ! flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:21.293924 [INFO] typesutil/gopinfo.go:215: ==> Type: &{134 ! gotbar} bool
2025/10/11 16:12:21 BinaryOp &&
2025/10/11 16:12:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:21 ==> MatchType bool, unboundFuncParam{typ: untyped bool}
2025/10/11 16:12:21.293951 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004742a0 131 && 0xc0001985c0} bool
2025/10/11 16:12:21.293957 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc00052a4e0 {
}

2025/10/11 16:12:21 Then
2025/10/11 16:12:21 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21.293972 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/10/11 16:12:21.293977 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/10/11 16:12:21 Val &{0 STRING "Double jump activated!"} *ast.BasicLit
2025/10/11 16:12:21.293989 [INFO] typesutil/gopinfo.go:215: ==> Type: &{153 STRING "Double jump activated!" <nil>} untyped string
2025/10/11 16:12:21 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:21 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped string ("Double jump activated!"), any
2025/10/11 16:12:21.294018 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:21.294023 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/10/11 16:12:21.294034 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 152 [0xc000474330] 0 [] 177 0} (n int, err error)
2025/10/11 16:12:21 Else
2025/10/11 16:12:21 If
2025/10/11 16:12:21 Val bar int
2025/10/11 16:12:21.294048 [INFO] typesutil/gopinfo.go:265: ==> Use: bar var bar int
2025/10/11 16:12:21.294053 [INFO] typesutil/gopinfo.go:215: ==> Type: bar int
2025/10/11 16:12:21 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:21.294063 [INFO] typesutil/gopinfo.go:215: ==> Type: &{196 INT 1 <nil>} untyped int
2025/10/11 16:12:21 BinaryOp ==
2025/10/11 16:12:21.294073 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar 193 == 0xc0004743c0} untyped bool
2025/10/11 16:12:21 Val gotbar bool
2025/10/11 16:12:21.294081 [INFO] typesutil/gopinfo.go:265: ==> Use: gotbar var gotbar bool
2025/10/11 16:12:21.294085 [INFO] typesutil/gopinfo.go:215: ==> Type: gotbar bool
2025/10/11 16:12:21 BinaryOp &&
2025/10/11 16:12:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:21 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:21 ==> MatchType bool, unboundFuncParam{typ: untyped bool}
2025/10/11 16:12:21.294108 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004743f0 198 && gotbar} bool
2025/10/11 16:12:21.294114 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc00052a840 {
}

2025/10/11 16:12:21 Then
2025/10/11 16:12:21 If
2025/10/11 16:12:21 Val boolBar bool
2025/10/11 16:12:21.294132 [INFO] typesutil/gopinfo.go:265: ==> Use: boolBar var boolBar bool
2025/10/11 16:12:21.294143 [INFO] typesutil/gopinfo.go:215: ==> Type: boolBar bool
2025/10/11 16:12:21 UnaryOp ! flags: 0
2025/10/11 16:12:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/10/11 16:12:21 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:21.294166 [INFO] typesutil/gopinfo.go:215: ==> Type: &{214 ! boolBar} bool
2025/10/11 16:12:21.294171 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc00052aa20 {
}

2025/10/11 16:12:21 Then
2025/10/11 16:12:21 VarRef boolBar bool
2025/10/11 16:12:21.294183 [INFO] typesutil/gopinfo.go:265: ==> Use: boolBar var boolBar bool
2025/10/11 16:12:21.294188 [INFO] typesutil/gopinfo.go:215: ==> Type: boolBar bool
2025/10/11 16:12:21 Val true untyped bool
2025/10/11 16:12:21.294196 [INFO] typesutil/gopinfo.go:265: ==> Use: true const true untyped bool
2025/10/11 16:12:21.294201 [INFO] typesutil/gopinfo.go:215: ==> Type: true untyped bool
2025/10/11 16:12:21 Assign 1 1
2025/10/11 16:12:21 ==> MatchType untyped bool (true), bool
2025/10/11 16:12:21 ForRange [item]
2025/10/11 16:12:21 Val gg *main.Foo
2025/10/11 16:12:21.294231 [INFO] typesutil/gopinfo.go:265: ==> Use: gg var gg *main.Foo
2025/10/11 16:12:21.294237 [INFO] typesutil/gopinfo.go:215: ==> Type: gg *main.Foo
2025/10/11 16:12:21 Member P 2 // *main.Foo
2025/10/11 16:12:21 ResetStmt
2025/10/11 16:12:21 End // ForRange
2025/10/11 16:12:21.294259 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc00052ab40 {
}

2025/10/11 16:12:21 End // If
2025/10/11 16:12:21.294267 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc00052a9c0 {
}

2025/10/11 16:12:21 End // If
2025/10/11 16:12:21.294274 [INFO] typesutil/gopinfo.go:332: ==> Scope: else body scope 0xc00052a7e0 {
}

2025/10/11 16:12:21 End // If
2025/10/11 16:12:21.294288 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc00052a300 {
.  var bar int
.  var boolBar bool
.  var gg *main.Foo
.  var gotbar bool
}

2025/10/11 16:12:21 End // Func
2025/10/11 16:12:21.294301 [INFO] typesutil/check.go:179: typesutil.Check err: main.xgo:15:21: gg.P undefined (type *main.Foo has no field or method P)
2025/10/11 16:12:21.296144 [ERROR] log/logext.go:606:
goroutine 14 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xd15000, {0x0?, 0xc000227ad0?, 0xc000309ce8?})
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/root/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc00065de28, {0x0, 0x0, 0x4?}, {0xc000a8a1d8, 0x1, 0x0?})
	/app/x/typesutil/check.go:180 +0xd19
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc0002dc000, {0xc000a8a1d8, 0x1, 0x1}, {0x0, 0x0, 0x0}, 0xc0005e6060)
	/app/x/typesutil/check_test.go:104 +0x416
github.com/goplus/xgo/x/typesutil_test.checkFilesWithErrorHandler(0xc0002dc000, {0x9502e1?, 0x66a?}, {0x8b11c0?, 0xa11990?}, {0x0?, 0xc0002cdf60?}, {0x8b11c0?, 0xa11500?}, {0x0, ...}, ...)
	/app/x/typesutil/check_test.go:69 +0xbc
github.com/goplus/xgo/x/typesutil_test.TestCheckError3(0xc000283180)
	/app/x/typesutil/check_test.go:335 +0xe5
testing.tRunner(0xc000283180, 0x98d570)
	/usr/local/go/src/testing/testing.go:1792 +0xf4
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1851 +0x413

--- PASS: TestCheckError3 (0.02s)
=== RUN   TestExprString
--- PASS: TestExprString (0.00s)
=== RUN   TestVarTypes
2025/10/11 16:12:21.297927 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:22 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:22 ==> NewOverloadFunc NewRange
2025/10/11 16:12:22 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:22 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:22 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:22 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:22 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:22 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:22 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:22 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:22 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:22 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:22 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:22 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:22 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:22 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:22.649939 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003aa120 {
}

2025/10/11 16:12:22 ==> Preload type T
2025/10/11 16:12:22 ==> Preload var [v]
2025/10/11 16:12:22 ==> Preload var [v1]
2025/10/11 16:12:22 ==> Preload var [v2]
2025/10/11 16:12:22 ==> Preload var [v3]
2025/10/11 16:12:22 ==> Preload var [v4]
2025/10/11 16:12:22 ==> Preload var [v5]
2025/10/11 16:12:22 ==> Preload var [v6]
2025/10/11 16:12:22 ==> Preload var [v7]
2025/10/11 16:12:22 ==> Preload var [m]
2025/10/11 16:12:22 ==> Preload func init
2025/10/11 16:12:22 ==> Load > NewType T
2025/10/11 16:12:22 NewType T
2025/10/11 16:12:22 ==> Load > InitType T
2025/10/11 16:12:22.650081 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:22.650104 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.650118 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.650130 [INFO] typesutil/gopinfo.go:251: ==> Def: x field x int
2025/10/11 16:12:22.650141 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:22.650149 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.650157 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.650166 [INFO] typesutil/gopinfo.go:251: ==> Def: y field y int
2025/10/11 16:12:22.650193 [INFO] typesutil/gopinfo.go:215: ==> Type: &{21 0xc000475620 false} struct{x int; y int}
2025/10/11 16:12:22 InitType T struct{x int; y int}
2025/10/11 16:12:22.650217 [INFO] typesutil/gopinfo.go:251: ==> Def: T type T struct{x int; y int}
2025/10/11 16:12:22.650232 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:22.650240 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.650248 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.650261 [INFO] typesutil/gopinfo.go:215: ==> Type: &{52 int} *int
2025/10/11 16:12:22 ==> Load var *int [v]
2025/10/11 16:12:22 NewVarDefs
2025/10/11 16:12:22 NewVar [v]
2025/10/11 16:12:22 Val nil untyped nil
2025/10/11 16:12:22.650311 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:22.650323 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:22 EndInit 1
2025/10/11 16:12:22 ==> MatchType untyped nil, *int
2025/10/11 16:12:22.650360 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v *int
2025/10/11 16:12:22.650375 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:22.650383 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.650390 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.650403 [INFO] typesutil/gopinfo.go:215: ==> Type: &{70 <nil> int} []int
2025/10/11 16:12:22 ==> Load var []int [v1]
2025/10/11 16:12:22 NewVarDefs
2025/10/11 16:12:22 NewVar [v1]
2025/10/11 16:12:22.650433 [INFO] typesutil/gopinfo.go:251: ==> Def: v1 var v1 []int
2025/10/11 16:12:22.650443 [INFO] typesutil/gopinfo.go:265: ==> Use: int8 type int8
2025/10/11 16:12:22.650455 [INFO] typesutil/gopinfo.go:215: ==> Type: int8 int8
2025/10/11 16:12:22.650469 [INFO] typesutil/gopinfo.go:215: ==> Type: int8 int8
2025/10/11 16:12:22.650478 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:22.650485 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:22.650493 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:22.650513 [INFO] typesutil/gopinfo.go:215: ==> Type: &{83 int8 string} map[int8]string
2025/10/11 16:12:22 ==> Load var map[int8]string [v2]
2025/10/11 16:12:22 NewVarDefs
2025/10/11 16:12:22 NewVar [v2]
2025/10/11 16:12:22.650541 [INFO] typesutil/gopinfo.go:251: ==> Def: v2 var v2 map[int8]string
2025/10/11 16:12:22.650557 [INFO] typesutil/gopinfo.go:215: ==> Type: &{106 0xc000475800 false} struct{}
2025/10/11 16:12:22 ==> Load var struct{} [v3]
2025/10/11 16:12:22 NewVarDefs
2025/10/11 16:12:22 NewVar [v3]
2025/10/11 16:12:22.650585 [INFO] typesutil/gopinfo.go:251: ==> Def: v3 var v3 struct{}
2025/10/11 16:12:22 ==> LookupParent T => type T struct{x int; y int}
2025/10/11 16:12:22.650605 [INFO] typesutil/gopinfo.go:265: ==> Use: T type T struct{x int; y int}
2025/10/11 16:12:22.650616 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/10/11 16:12:22.650625 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/10/11 16:12:22.650636 [INFO] typesutil/gopinfo.go:215: ==> Type: &{122 T} *T
2025/10/11 16:12:22 ==> Load var *T [v4]
2025/10/11 16:12:22 NewVarDefs
2025/10/11 16:12:22 NewVar [v4]
2025/10/11 16:12:22 ==> LookupParent T => type T struct{x int; y int}
2025/10/11 16:12:22.650672 [INFO] typesutil/gopinfo.go:265: ==> Use: T type T struct{x int; y int}
2025/10/11 16:12:22.650686 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/10/11 16:12:22.650700 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/10/11 16:12:22 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:22.650727 [INFO] typesutil/gopinfo.go:215: ==> Type: &{130 INT 100 <nil>} untyped int
2025/10/11 16:12:22 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:22.650749 [INFO] typesutil/gopinfo.go:215: ==> Type: &{134 INT 200 <nil>} untyped int
2025/10/11 16:12:22 StructLit T 2 false
2025/10/11 16:12:22.650767 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/10/11 16:12:22.650781 [INFO] typesutil/gopinfo.go:215: ==> Type: &{T 129 [0xc000475830 0xc000475860] 137 false} T
2025/10/11 16:12:22 UnaryOp & flags: 0
2025/10/11 16:12:22 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:22.650810 [INFO] typesutil/gopinfo.go:215: ==> Type: &{127 & 0xc000541400} *T
2025/10/11 16:12:22 EndInit 1
2025/10/11 16:12:22 ==> MatchType *T, *T
2025/10/11 16:12:22 ==> EnsureLoaded T
2025/10/11 16:12:22 ==> EnsureLoaded T
2025/10/11 16:12:22.650843 [INFO] typesutil/gopinfo.go:251: ==> Def: v4 var v4 *T
2025/10/11 16:12:22 ==> Load var <nil> [v5]
2025/10/11 16:12:22 NewVarDefs
2025/10/11 16:12:22 NewVar [v5]
2025/10/11 16:12:22.650866 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:22.650875 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.650883 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:22.650901 [INFO] typesutil/gopinfo.go:215: ==> Type: &{149 INT 6 <nil>} untyped int
2025/10/11 16:12:22.650917 [INFO] typesutil/gopinfo.go:215: ==> Type: &{148 0xc000475890 int} [6]int
2025/10/11 16:12:22 ArrayLit [6]int 0 false
2025/10/11 16:12:22.650941 [INFO] typesutil/gopinfo.go:215: ==> Type: &{148 0xc000475890 int} [6]int
2025/10/11 16:12:22.650954 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000475920 154 [] 155 false} [6]int
2025/10/11 16:12:22 EndInit 1
2025/10/11 16:12:22.650973 [INFO] typesutil/gopinfo.go:251: ==> Def: v5 var v5 [6]int
2025/10/11 16:12:22 ==> Load var <nil> [v6]
2025/10/11 16:12:22 NewVarDefs
2025/10/11 16:12:22 NewVar [v6]
2025/10/11 16:12:22 Val v5 [6]int
2025/10/11 16:12:22.651009 [INFO] typesutil/gopinfo.go:265: ==> Use: v5 var v5 [6]int
2025/10/11 16:12:22.651019 [INFO] typesutil/gopinfo.go:215: ==> Type: v5 [6]int
2025/10/11 16:12:22 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:22.651037 [INFO] typesutil/gopinfo.go:215: ==> Type: &{169 INT 0 <nil>} untyped int
2025/10/11 16:12:22 Index 1 false
2025/10/11 16:12:22.651062 [INFO] typesutil/gopinfo.go:215: ==> Type: &{v5 168 0xc000475950 170} int
2025/10/11 16:12:22 EndInit 1
2025/10/11 16:12:22.651078 [INFO] typesutil/gopinfo.go:251: ==> Def: v6 var v6 int
2025/10/11 16:12:22 ==> Load var <nil> [v7]
2025/10/11 16:12:22 NewVarDefs
2025/10/11 16:12:22 NewVar [v7]
2025/10/11 16:12:22.651102 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:22.651111 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.651119 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:22.651138 [INFO] typesutil/gopinfo.go:215: ==> Type: &{182 INT 6 <nil>} untyped int
2025/10/11 16:12:22.651160 [INFO] typesutil/gopinfo.go:215: ==> Type: &{181 0xc0004759b0 int} [6]int
2025/10/11 16:12:22 ArrayLit [6]int 0 false
2025/10/11 16:12:22.651187 [INFO] typesutil/gopinfo.go:215: ==> Type: &{181 0xc0004759b0 int} [6]int
2025/10/11 16:12:22.651199 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000475a40 187 [] 188 false} [6]int
2025/10/11 16:12:22 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:22.651216 [INFO] typesutil/gopinfo.go:215: ==> Type: &{190 INT 0 <nil>} untyped int
2025/10/11 16:12:22 Index 1 false
2025/10/11 16:12:22.651237 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000541540 189 0xc000475a70 191} int
2025/10/11 16:12:22 EndInit 1
2025/10/11 16:12:22.651255 [INFO] typesutil/gopinfo.go:251: ==> Def: v7 var v7 int
2025/10/11 16:12:22.651269 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:22.651276 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.651284 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.651293 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:22.651301 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:22.651309 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:22.651321 [INFO] typesutil/gopinfo.go:215: ==> Type: &{199 int string} map[int]string
2025/10/11 16:12:22 ==> Load var map[int]string [m]
2025/10/11 16:12:22 NewVarDefs
2025/10/11 16:12:22 NewVar [m]
2025/10/11 16:12:22.651349 [INFO] typesutil/gopinfo.go:251: ==> Def: m var m map[int]string
2025/10/11 16:12:22 ==> Load func init
2025/10/11 16:12:22.651370 [INFO] typesutil/gopinfo.go:251: ==> Def: init func init()
2025/10/11 16:12:22 NewFunc init func()
2025/10/11 16:12:22 Val v5 [6]int
2025/10/11 16:12:22.651408 [INFO] typesutil/gopinfo.go:265: ==> Use: v5 var v5 [6]int
2025/10/11 16:12:22.651419 [INFO] typesutil/gopinfo.go:215: ==> Type: v5 [6]int
2025/10/11 16:12:22 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:22.651436 [INFO] typesutil/gopinfo.go:215: ==> Type: &{232 INT 0 <nil>} untyped int
2025/10/11 16:12:22 IndexRef 1
2025/10/11 16:12:22.651452 [INFO] typesutil/gopinfo.go:215: ==> Type: &{v5 231 0xc000475bc0 233} int
2025/10/11 16:12:22 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:22.651475 [INFO] typesutil/gopinfo.go:215: ==> Type: &{237 INT 100 <nil>} untyped int
2025/10/11 16:12:22 Assign 1 1
2025/10/11 16:12:22 ==> MatchType untyped int (100), int
2025/10/11 16:12:22 VarRef _
2025/10/11 16:12:22 Val v5 [6]int
2025/10/11 16:12:22.651518 [INFO] typesutil/gopinfo.go:265: ==> Use: v5 var v5 [6]int
2025/10/11 16:12:22.651526 [INFO] typesutil/gopinfo.go:215: ==> Type: v5 [6]int
2025/10/11 16:12:22 None
2025/10/11 16:12:22 None
2025/10/11 16:12:22 Slice false
2025/10/11 16:12:22.651554 [INFO] typesutil/gopinfo.go:215: ==> Type: &{v5 248 <nil> <nil> <nil> false 250} []int
2025/10/11 16:12:22 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:22.651574 [INFO] typesutil/gopinfo.go:215: ==> Type: &{252 INT 0 <nil>} untyped int
2025/10/11 16:12:22 Index 1 false
2025/10/11 16:12:22.651592 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0008006c0 251 0xc000475ce0 253} int
2025/10/11 16:12:22 Assign 1 1
2025/10/11 16:12:22 Val m map[int]string
2025/10/11 16:12:22.651625 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]string
2025/10/11 16:12:22.651634 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]string
2025/10/11 16:12:22 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:22.651650 [INFO] typesutil/gopinfo.go:215: ==> Type: &{258 INT 0 <nil>} untyped int
2025/10/11 16:12:22 IndexRef 1
2025/10/11 16:12:22.651669 [INFO] typesutil/gopinfo.go:215: ==> Type: &{m 257 0xc000475da0 259} string
2025/10/11 16:12:22 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:22.651692 [INFO] typesutil/gopinfo.go:215: ==> Type: &{263 STRING "hello" <nil>} untyped string
2025/10/11 16:12:22 Assign 1 1
2025/10/11 16:12:22 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:22 VarRef _
2025/10/11 16:12:22 Val m map[int]string
2025/10/11 16:12:22.651729 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]string
2025/10/11 16:12:22.651742 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]string
2025/10/11 16:12:22 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:22.651759 [INFO] typesutil/gopinfo.go:215: ==> Type: &{278 INT 0 <nil>} untyped int
2025/10/11 16:12:22 Index 1 false
2025/10/11 16:12:22.651778 [INFO] typesutil/gopinfo.go:215: ==> Type: &{m 277 0xc000475e60 279} string
2025/10/11 16:12:22 Assign 1 1
2025/10/11 16:12:22 VarRef _
2025/10/11 16:12:22.651806 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:22.651818 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.651826 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.651835 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:22.651844 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:22.651851 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:22.651861 [INFO] typesutil/gopinfo.go:215: ==> Type: &{286 int string} map[int]string
2025/10/11 16:12:22 MapLit map[int]string 0
2025/10/11 16:12:22.651880 [INFO] typesutil/gopinfo.go:215: ==> Type: &{286 int string} map[int]string
2025/10/11 16:12:22.651893 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000475ec0 300 [] 301 false} map[int]string
2025/10/11 16:12:22 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:22.651917 [INFO] typesutil/gopinfo.go:215: ==> Type: &{303 INT 0 <nil>} untyped int
2025/10/11 16:12:22 Index 1 false
2025/10/11 16:12:22.651931 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000541740 302 0xc000475ef0 304} string
2025/10/11 16:12:22 Assign 1 1
2025/10/11 16:12:22 VarRef _
2025/10/11 16:12:22 Val v3 struct{}
2025/10/11 16:12:22.651960 [INFO] typesutil/gopinfo.go:265: ==> Use: v3 var v3 struct{}
2025/10/11 16:12:22.651980 [INFO] typesutil/gopinfo.go:215: ==> Type: v3 struct{}
2025/10/11 16:12:22 UnaryOp & flags: 0
2025/10/11 16:12:22 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:22.652022 [INFO] typesutil/gopinfo.go:215: ==> Type: &{311 & v3} *struct{}
2025/10/11 16:12:22 Assign 1 1
2025/10/11 16:12:22 VarRef _
2025/10/11 16:12:22 Val v3 struct{}
2025/10/11 16:12:22.652084 [INFO] typesutil/gopinfo.go:265: ==> Use: v3 var v3 struct{}
2025/10/11 16:12:22.652092 [INFO] typesutil/gopinfo.go:215: ==> Type: v3 struct{}
2025/10/11 16:12:22 UnaryOp & flags: 0
2025/10/11 16:12:22 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:22.652114 [INFO] typesutil/gopinfo.go:215: ==> Type: &{322 & v3} *struct{}
2025/10/11 16:12:22.652152 [INFO] typesutil/gopinfo.go:215: ==> Type: &{321 0xc000198bc0 325} *struct{}
2025/10/11 16:12:22 Star
2025/10/11 16:12:22.652170 [INFO] typesutil/gopinfo.go:215: ==> Type: &{320 0xc000198c00} struct{}
2025/10/11 16:12:22 Assign 1 1
2025/10/11 16:12:22 DefineVarStart [a]
2025/10/11 16:12:22.652190 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:22.652199 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.652207 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:22.652218 [INFO] typesutil/gopinfo.go:215: ==> Type: &{333 <nil> int} []int
2025/10/11 16:12:22 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:22.652241 [INFO] typesutil/gopinfo.go:215: ==> Type: &{339 INT 1 <nil>} untyped int
2025/10/11 16:12:22 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:22.652258 [INFO] typesutil/gopinfo.go:215: ==> Type: &{341 INT 2 <nil>} untyped int
2025/10/11 16:12:22 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:22.652281 [INFO] typesutil/gopinfo.go:215: ==> Type: &{343 INT 3 <nil>} untyped int
2025/10/11 16:12:22 Val &{0 INT 4} *ast.BasicLit
2025/10/11 16:12:22.652302 [INFO] typesutil/gopinfo.go:215: ==> Type: &{345 INT 4 <nil>} untyped int
2025/10/11 16:12:22 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:22.652321 [INFO] typesutil/gopinfo.go:215: ==> Type: &{347 INT 5 <nil>} untyped int
2025/10/11 16:12:22 SliceLit []int 5 false
2025/10/11 16:12:22.652348 [INFO] typesutil/gopinfo.go:215: ==> Type: &{333 <nil> int} []int
2025/10/11 16:12:22.652366 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000812090 338 [0xc0008120f0 0xc000812120 0xc000812150 0xc000812180 0xc0008121b0] 348 false} []int
2025/10/11 16:12:22 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:22.652390 [INFO] typesutil/gopinfo.go:215: ==> Type: &{350 INT 0 <nil>} untyped int
2025/10/11 16:12:22 Index 1 false
2025/10/11 16:12:22.652409 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000541880 349 0xc000812210 351} int
2025/10/11 16:12:22 EndInit 1
2025/10/11 16:12:22.652428 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/10/11 16:12:22 VarRef _
2025/10/11 16:12:22 Val a int
2025/10/11 16:12:22.652447 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/10/11 16:12:22.652455 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/10/11 16:12:22 Assign 1 1
2025/10/11 16:12:22.652474 [INFO] typesutil/gopinfo.go:332: ==> Scope: func init scope 0xc0003aa720 {
.  var a int
}

2025/10/11 16:12:22 End // Func
    info_test.go:226: ====== check types pass (count: 73) ======
        000:  2: 8 | struct {
        	x int
        	y int
        } *ast.StructType                | type    : struct{x int; y int} | type
        001:  3: 4 | int                 *ast.Ident                     | type    : int | type
        002:  4: 4 | int                 *ast.Ident                     | type    : int | type
        003:  6: 7 | *int                *ast.StarExpr                  | type    : *int | type
        004:  6: 8 | int                 *ast.Ident                     | type    : int | type
        005:  6:14 | nil                 *ast.Ident                     | nil     : untyped nil | value
        006:  7: 8 | []int               *ast.ArrayType                 | type    : []int | type
        007:  7:10 | int                 *ast.Ident                     | type    : int | type
        008:  8: 8 | map[int8]string     *ast.MapType                   | type    : map[int8]string | type
        009:  8:12 | int8                *ast.Ident                     | type    : int8 | type
        010:  8:17 | string              *ast.Ident                     | type    : string | type
        011:  9: 8 | struct{}            *ast.StructType                | type    : struct{} | type
        012: 10: 8 | *T                  *ast.StarExpr                  | type    : *T | type
        013: 10: 9 | T                   *ast.Ident                     | type    : T | type
        014: 10:13 | &T{100, 200}        *ast.UnaryExpr                 | value   : *T | value
        015: 10:14 | T                   *ast.Ident                     | type    : T | type
        016: 10:14 | T{100, 200}         *ast.CompositeLit              | value   : T | value
        017: 10:16 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
        018: 10:20 | 200                 *ast.BasicLit                  | value   : INT = 200 | constant
        019: 11:10 | [6]int              *ast.ArrayType                 | type    : [6]int | type
        020: 11:10 | [6]int{}            *ast.CompositeLit              | value   : [6]int | value
        021: 11:11 | 6                   *ast.BasicLit                  | value   : INT = 6 | constant
        022: 11:13 | int                 *ast.Ident                     | type    : int | type
        023: 12:10 | v5                  *ast.Ident                     | var     : [6]int | variable
        024: 12:10 | v5[0]               *ast.IndexExpr                 | var     : int | variable
        025: 12:13 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        026: 13:10 | [6]int              *ast.ArrayType                 | type    : [6]int | type
        027: 13:10 | [6]int{}            *ast.CompositeLit              | value   : [6]int | value
        028: 13:10 | [6]int{}[0]         *ast.IndexExpr                 | value   : int | value
        029: 13:11 | 6                   *ast.BasicLit                  | value   : INT = 6 | constant
        030: 13:13 | int                 *ast.Ident                     | type    : int | type
        031: 13:19 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        032: 14: 7 | map[int]string      *ast.MapType                   | type    : map[int]string | type
        033: 14:11 | int                 *ast.Ident                     | type    : int | type
        034: 14:15 | string              *ast.Ident                     | type    : string | type
        035: 16: 2 | v5                  *ast.Ident                     | var     : [6]int | variable
        036: 16: 2 | v5[0]               *ast.IndexExpr                 | var     : int | variable
        037: 16: 5 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        038: 16:10 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
        039: 17: 6 | v5                  *ast.Ident                     | var     : [6]int | variable
        040: 17: 6 | v5[:]               *ast.SliceExpr                 | value   : []int | value
        041: 17: 6 | v5[:][0]            *ast.IndexExpr                 | var     : int | variable
        042: 17:12 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        043: 18: 2 | m                   *ast.Ident                     | var     : map[int]string | variable
        044: 18: 2 | m[0]                *ast.IndexExpr                 | mapindex : string | map index expression
        045: 18: 4 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        046: 18: 9 | "hello"             *ast.BasicLit                  | value   : STRING = "hello" | constant
        047: 19: 6 | m                   *ast.Ident                     | var     : map[int]string | variable
        048: 19: 6 | m[0]                *ast.IndexExpr                 | mapindex : string | map index expression
        049: 19: 8 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        050: 20: 6 | map[int]string      *ast.MapType                   | type    : map[int]string | type
        051: 20: 6 | map[int]string{}    *ast.CompositeLit              | value   : map[int]string | value
        052: 20: 6 | map[int]string{}[0] *ast.IndexExpr                 | mapindex : string | map index expression
        053: 20:10 | int                 *ast.Ident                     | type    : int | type
        054: 20:14 | string              *ast.Ident                     | type    : string | type
        055: 20:23 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        056: 21: 6 | &v3                 *ast.UnaryExpr                 | value   : *struct{} | value
        057: 21: 7 | v3                  *ast.Ident                     | var     : struct{} | variable
        058: 22: 6 | *(&v3)              *ast.StarExpr                  | var     : struct{} | variable
        059: 22: 7 | (&v3)               *ast.ParenExpr                 | value   : *struct{} | value
        060: 22: 8 | &v3                 *ast.UnaryExpr                 | value   : *struct{} | value
        061: 22: 9 | v3                  *ast.Ident                     | var     : struct{} | variable
        062: 23: 7 | []int               *ast.ArrayType                 | type    : []int | type
        063: 23: 7 | []int{1, 2, 3, 4, 5} *ast.CompositeLit              | value   : []int | value
        064: 23: 7 | []int{1, 2, 3, 4, 5}[0] *ast.IndexExpr                 | var     : int | variable
        065: 23: 9 | int                 *ast.Ident                     | type    : int | type
        066: 23:13 | 1                   *ast.BasicLit                  | value   : INT = 1 | constant
        067: 23:15 | 2                   *ast.BasicLit                  | value   : INT = 2 | constant
        068: 23:17 | 3                   *ast.BasicLit                  | value   : INT = 3 | constant
        069: 23:19 | 4                   *ast.BasicLit                  | value   : INT = 4 | constant
        070: 23:21 | 5                   *ast.BasicLit                  | value   : INT = 5 | constant
        071: 23:24 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        072: 24: 6 | a                   *ast.Ident                     | var     : int | variable
    info_test.go:226: ====== check defs pass (count: 14) ======
        000:  2: 6 | T                   | type T struct{x int; y int}
        001:  3: 2 | x                   | field x int
        002:  4: 2 | y                   | field y int
        003:  6: 5 | v                   | var v *int
        004:  7: 5 | v1                  | var v1 []int
        005:  8: 5 | v2                  | var v2 map[int8]string
        006:  9: 5 | v3                  | var v3 struct{}
        007: 10: 5 | v4                  | var v4 *T
        008: 11: 5 | v5                  | var v5 [6]int
        009: 12: 5 | v6                  | var v6 int
        010: 13: 5 | v7                  | var v7 int
        011: 14: 5 | m                   | var m map[int]string
        012: 15: 6 | init                | func init()
        013: 23: 2 | a                   | var a int
    info_test.go:226: ====== check uses pass (count: 24) ======
        000:  3: 4 | int                 | type int
        001:  4: 4 | int                 | type int
        002:  6: 8 | int                 | type int
        003:  6:14 | nil                 | nil
        004:  7:10 | int                 | type int
        005:  8:12 | int8                | type int8
        006:  8:17 | string              | type string
        007: 10: 9 | T                   | type T struct{x int; y int}
        008: 10:14 | T                   | type T struct{x int; y int}
        009: 11:13 | int                 | type int
        010: 12:10 | v5                  | var v5 [6]int
        011: 13:13 | int                 | type int
        012: 14:11 | int                 | type int
        013: 14:15 | string              | type string
        014: 16: 2 | v5                  | var v5 [6]int
        015: 17: 6 | v5                  | var v5 [6]int
        016: 18: 2 | m                   | var m map[int]string
        017: 19: 6 | m                   | var m map[int]string
        018: 20:10 | int                 | type int
        019: 20:14 | string              | type string
        020: 21: 7 | v3                  | var v3 struct{}
        021: 22: 9 | v3                  | var v3 struct{}
        022: 23: 9 | int                 | type int
        023: 24: 6 | a                   | var a int
--- PASS: TestVarTypes (1.36s)
=== RUN   TestStruct
2025/10/11 16:12:22.656300 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:23 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:23 ==> NewOverloadFunc NewRange
2025/10/11 16:12:23 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:23 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:23 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:23 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:23 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:23 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:23 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:23 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:23 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:23 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:23 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:23 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:23 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:23 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:23.976934 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000248240 {
}

2025/10/11 16:12:23.976996 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package fmt
2025/10/11 16:12:23 ==> Preload type Person
2025/10/11 16:12:23 ==> Preload func test
2025/10/11 16:12:23 ==> Load > NewType Person
2025/10/11 16:12:23 NewType Person
2025/10/11 16:12:23 ==> Load > InitType Person
2025/10/11 16:12:23.977099 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:23.977130 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:23.977143 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:23.977158 [INFO] typesutil/gopinfo.go:251: ==> Def: name field name string
2025/10/11 16:12:23.977171 [INFO] typesutil/gopinfo.go:265: ==> Use: int8 type int8
2025/10/11 16:12:23.977183 [INFO] typesutil/gopinfo.go:215: ==> Type: int8 int8
2025/10/11 16:12:23.977194 [INFO] typesutil/gopinfo.go:215: ==> Type: int8 int8
2025/10/11 16:12:23.977208 [INFO] typesutil/gopinfo.go:251: ==> Def: age field age int8
2025/10/11 16:12:23.977244 [INFO] typesutil/gopinfo.go:215: ==> Type: &{40 0xc0003ae2a0 false} struct{name string; age int8}
2025/10/11 16:12:23 InitType Person struct{name string; age int8}
2025/10/11 16:12:23.977281 [INFO] typesutil/gopinfo.go:251: ==> Def: Person type Person struct{name string; age int8}
2025/10/11 16:12:23 ==> Load func test
2025/10/11 16:12:23.977313 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test()
2025/10/11 16:12:23 NewFunc test func()
2025/10/11 16:12:23 DefineVarStart [p]
2025/10/11 16:12:23 ==> LookupParent Person => type Person struct{name string; age int8}
2025/10/11 16:12:23.977372 [INFO] typesutil/gopinfo.go:265: ==> Use: Person type Person struct{name string; age int8}
2025/10/11 16:12:23.977385 [INFO] typesutil/gopinfo.go:215: ==> Type: Person Person
2025/10/11 16:12:23.977399 [INFO] typesutil/gopinfo.go:215: ==> Type: Person Person
2025/10/11 16:12:23 Val 0 int
2025/10/11 16:12:23.977422 [INFO] typesutil/gopinfo.go:265: ==> Use: name field name string
2025/10/11 16:12:23 Val &{0 STRING "jack"} *ast.BasicLit
2025/10/11 16:12:23.977458 [INFO] typesutil/gopinfo.go:215: ==> Type: &{112 STRING "jack" <nil>} untyped string
2025/10/11 16:12:23 StructLit Person 2 true
2025/10/11 16:12:23.977494 [INFO] typesutil/gopinfo.go:215: ==> Type: Person Person
2025/10/11 16:12:23.977521 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Person 102 [0xc0003ae390] 121 false} Person
2025/10/11 16:12:23 EndInit 1
2025/10/11 16:12:23.977548 [INFO] typesutil/gopinfo.go:251: ==> Def: p var p Person
2025/10/11 16:12:23 VarRef _
2025/10/11 16:12:23 Val p Person
2025/10/11 16:12:23.977585 [INFO] typesutil/gopinfo.go:265: ==> Use: p var p Person
2025/10/11 16:12:23.977597 [INFO] typesutil/gopinfo.go:215: ==> Type: p Person
2025/10/11 16:12:23 Member name 2 // Person
2025/10/11 16:12:23.977627 [INFO] typesutil/gopinfo.go:265: ==> Use: name field name string
2025/10/11 16:12:23.977648 [INFO] typesutil/gopinfo.go:215: ==> Type: &{p name} string
2025/10/11 16:12:23 Assign 1 1
2025/10/11 16:12:23 Val p Person
2025/10/11 16:12:23.977677 [INFO] typesutil/gopinfo.go:265: ==> Use: p var p Person
2025/10/11 16:12:23.977691 [INFO] typesutil/gopinfo.go:215: ==> Type: p Person
2025/10/11 16:12:23 Member name -1 // Person
2025/10/11 16:12:23.977730 [INFO] typesutil/gopinfo.go:265: ==> Use: name field name string
2025/10/11 16:12:23.977744 [INFO] typesutil/gopinfo.go:215: ==> Type: &{p name} string
2025/10/11 16:12:23 Val &{0 STRING "name"} *ast.BasicLit
2025/10/11 16:12:23.977771 [INFO] typesutil/gopinfo.go:215: ==> Type: &{145 STRING "name" <nil>} untyped string
2025/10/11 16:12:23 Assign 1 1
2025/10/11 16:12:23 ==> MatchType untyped string ("name"), string
2025/10/11 16:12:23.977810 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/10/11 16:12:23.977838 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:23 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:23 Val p Person
2025/10/11 16:12:23.977882 [INFO] typesutil/gopinfo.go:265: ==> Use: p var p Person
2025/10/11 16:12:23.977895 [INFO] typesutil/gopinfo.go:215: ==> Type: p Person
2025/10/11 16:12:23 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:12:23 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:23 ==> MatchType Person, any
2025/10/11 16:12:23 ==> EnsureLoaded Person
2025/10/11 16:12:23.977975 [INFO] typesutil/gopinfo.go:215: ==> Type: &{fmt Println} func(a ...any) (n int, err error)
2025/10/11 16:12:23.978002 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0000dc0a8 164 [p] 0 [] 166 0} (n int, err error)
2025/10/11 16:12:23.978029 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc000248420 {
.  var p Person
}

2025/10/11 16:12:23 End // Func
    info_test.go:226: ====== check types pass (count: 14) ======
        000:  4:13 | struct {
        	name string
        	age  int8
        } *ast.StructType                | type    : struct{name string; age int8} | type
        001:  5: 7 | string              *ast.Ident                     | type    : string | type
        002:  6: 7 | int8                *ast.Ident                     | type    : int8 | type
        003: 10: 7 | Person              *ast.Ident                     | type    : Person | type
        004: 10: 7 | Person{
        	name: "jack",
        } *ast.CompositeLit              | value   : Person | value
        005: 11: 9 | "jack"              *ast.BasicLit                  | value   : STRING = "jack" | constant
        006: 13: 6 | p                   *ast.Ident                     | var     : Person | variable
        007: 13: 6 | p.name              *ast.SelectorExpr              | var     : string | variable
        008: 14: 2 | p                   *ast.Ident                     | var     : Person | variable
        009: 14: 2 | p.name              *ast.SelectorExpr              | var     : string | variable
        010: 14:11 | "name"              *ast.BasicLit                  | value   : STRING = "name" | constant
        011: 15: 2 | fmt.Println         *ast.SelectorExpr              | value   : func(a ...any) (n int, err error) | value
        012: 15: 2 | fmt.Println(p)      *ast.CallExpr                  | value   : (n int, err error) | value
        013: 15:14 | p                   *ast.Ident                     | var     : Person | variable
    info_test.go:226: ====== check defs pass (count: 5) ======
        000:  4: 6 | Person              | type Person struct{name string; age int8}
        001:  5: 2 | name                | field name string
        002:  6: 2 | age                 | field age int8
        003:  9: 6 | test                | func test()
        004: 10: 2 | p                   | var p Person
    info_test.go:226: ====== check uses pass (count: 11) ======
        000:  5: 7 | string              | type string
        001:  6: 7 | int8                | type int8
        002: 10: 7 | Person              | type Person struct{name string; age int8}
        003: 11: 3 | name                | field name string
        004: 13: 6 | p                   | var p Person
        005: 13: 8 | name                | field name string
        006: 14: 2 | p                   | var p Person
        007: 14: 4 | name                | field name string
        008: 15: 2 | fmt                 | package fmt
        009: 15: 6 | Println             | func fmt.Println(a ...any) (n int, err error)
        010: 15:14 | p                   | var p Person
--- PASS: TestStruct (1.33s)
=== RUN   TestTypeAssert
2025/10/11 16:12:23.982865 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:24 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:24 ==> NewOverloadFunc NewRange
2025/10/11 16:12:24 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:24 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:24 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:24 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:24 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:24 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:24 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:24 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:24 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:24 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:24 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:24 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:24 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:24 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:25.190034 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003a0420 {
}

2025/10/11 16:12:25 ==> Preload func test
2025/10/11 16:12:25 ==> Load func test
2025/10/11 16:12:25.190098 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test()
2025/10/11 16:12:25 NewFunc test func()
2025/10/11 16:12:25.190141 [INFO] typesutil/gopinfo.go:215: ==> Type: &{36 0xc000474c30 false} interface{}
2025/10/11 16:12:25 ==> Load var interface{} [a]
2025/10/11 16:12:25 NewVarDefs
2025/10/11 16:12:25 NewVar [a]
2025/10/11 16:12:25 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:25.190199 [INFO] typesutil/gopinfo.go:215: ==> Type: &{50 INT 100 <nil>} untyped int
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25 ==> MatchType untyped int (100), interface{}
2025/10/11 16:12:25.190240 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a interface{}
2025/10/11 16:12:25 If
2025/10/11 16:12:25 DefineVarStart [n ok]
2025/10/11 16:12:25 Val a interface{}
2025/10/11 16:12:25.190280 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a interface{}
2025/10/11 16:12:25.190291 [INFO] typesutil/gopinfo.go:215: ==> Type: a interface{}
2025/10/11 16:12:25.190302 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:25.190312 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:25.190321 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:25 TypeAssert int true
2025/10/11 16:12:25.190345 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 69 int 73} (int, bool)
2025/10/11 16:12:25 EndInit 1
2025/10/11 16:12:25.190366 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n int
2025/10/11 16:12:25.190378 [INFO] typesutil/gopinfo.go:251: ==> Def: ok var ok bool
2025/10/11 16:12:25 Val ok bool
2025/10/11 16:12:25.190392 [INFO] typesutil/gopinfo.go:265: ==> Use: ok var ok bool
2025/10/11 16:12:25.190401 [INFO] typesutil/gopinfo.go:215: ==> Type: ok bool
2025/10/11 16:12:25.190417 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc0003a05a0 {
.  var n int
.  var ok bool
}

2025/10/11 16:12:25 Then
2025/10/11 16:12:25 VarRef _
2025/10/11 16:12:25 Val n int
2025/10/11 16:12:25.190445 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n int
2025/10/11 16:12:25.190454 [INFO] typesutil/gopinfo.go:215: ==> Type: n int
2025/10/11 16:12:25 Assign 1 1
2025/10/11 16:12:25.190469 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc0003a0780 {
}

2025/10/11 16:12:25 End // If
2025/10/11 16:12:25.190492 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc0003a04e0 {
.  var a interface{}
}

2025/10/11 16:12:25 End // Func
    info_test.go:226: ====== check types pass (count: 7) ======
        000:  4: 8 | interface{}         *ast.InterfaceType             | type    : interface{} | type
        001:  4:22 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
        002:  5:14 | a                   *ast.Ident                     | var     : interface{} | variable
        003:  5:14 | a.(int)             *ast.TypeAssertExpr            | value   : (int, bool) | comma, error expression
        004:  5:17 | int                 *ast.Ident                     | type    : int | type
        005:  5:23 | ok                  *ast.Ident                     | var     : bool | variable
        006:  6: 7 | n                   *ast.Ident                     | var     : int | variable
    info_test.go:226: ====== check defs pass (count: 4) ======
        000:  3: 6 | test                | func test()
        001:  4: 6 | a                   | var a interface{}
        002:  5: 5 | n                   | var n int
        003:  5: 8 | ok                  | var ok bool
    info_test.go:226: ====== check uses pass (count: 4) ======
        000:  5:14 | a                   | var a interface{}
        001:  5:17 | int                 | type int
        002:  5:23 | ok                  | var ok bool
        003:  6: 7 | n                   | var n int
--- PASS: TestTypeAssert (1.21s)
=== RUN   TestChan
2025/10/11 16:12:25.191174 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:25 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:25 ==> NewOverloadFunc NewRange
2025/10/11 16:12:26 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:26 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:26 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:26 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:26 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:26 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:26 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:26 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:26 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:26 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:26 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:26 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:26 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:26 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:26.521390 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0002e5aa0 {
}

2025/10/11 16:12:26 ==> Preload func test
2025/10/11 16:12:26 ==> Load func test
2025/10/11 16:12:26.521462 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test()
2025/10/11 16:12:26 NewFunc test func()
2025/10/11 16:12:26.521496 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:26.521511 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:26.521522 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:26.521555 [INFO] typesutil/gopinfo.go:215: ==> Type: &{37 0 3 int} chan int
2025/10/11 16:12:26 ==> Load var chan int [ch]
2025/10/11 16:12:26 NewVarDefs
2025/10/11 16:12:26 NewVar [ch]
2025/10/11 16:12:26.521602 [INFO] typesutil/gopinfo.go:251: ==> Def: ch var ch chan int
2025/10/11 16:12:26 Select
2025/10/11 16:12:26 CommCase
2025/10/11 16:12:26 DefineVarStart [n ok]
2025/10/11 16:12:26 Val ch chan int
2025/10/11 16:12:26.521648 [INFO] typesutil/gopinfo.go:265: ==> Use: ch var ch chan int
2025/10/11 16:12:26.521658 [INFO] typesutil/gopinfo.go:215: ==> Type: ch chan int
2025/10/11 16:12:26 UnaryOp <- flags: 2
2025/10/11 16:12:26 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 2
2025/10/11 16:12:26.521701 [INFO] typesutil/gopinfo.go:215: ==> Type: &{71 <- ch} (int, bool)
2025/10/11 16:12:26 EndInit 1
2025/10/11 16:12:26.521721 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n int
2025/10/11 16:12:26.521732 [INFO] typesutil/gopinfo.go:251: ==> Def: ok var ok bool
2025/10/11 16:12:26 Then
2025/10/11 16:12:26 VarRef _
2025/10/11 16:12:26 Val n int
2025/10/11 16:12:26.521764 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n int
2025/10/11 16:12:26.521774 [INFO] typesutil/gopinfo.go:215: ==> Type: n int
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 VarRef _
2025/10/11 16:12:26 Val ok bool
2025/10/11 16:12:26.521801 [INFO] typesutil/gopinfo.go:265: ==> Use: ok var ok bool
2025/10/11 16:12:26.521809 [INFO] typesutil/gopinfo.go:215: ==> Type: ok bool
2025/10/11 16:12:26 Assign 1 1
2025/10/11 16:12:26 Break
2025/10/11 16:12:26.521843 [INFO] typesutil/gopinfo.go:332: ==> Scope: comm case statement scope 0xc0002e5ce0 {
.  var n int
.  var ok bool
}

2025/10/11 16:12:26 End // CommCase
2025/10/11 16:12:26 End // Select
2025/10/11 16:12:26.521890 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc0002e5b60 {
.  var ch chan int
}

2025/10/11 16:12:26 End // Func
    info_test.go:226: ====== check types pass (count: 6) ======
        000:  4: 9 | chan int            *ast.ChanType                  | type    : chan int | type
        001:  4:14 | int                 *ast.Ident                     | type    : int | type
        002:  6:16 | <-ch                *ast.UnaryExpr                 | value   : (int, bool) | comma, error expression
        003:  6:18 | ch                  *ast.Ident                     | var     : chan int | variable
        004:  7: 7 | n                   *ast.Ident                     | var     : int | variable
        005:  8: 7 | ok                  *ast.Ident                     | var     : bool | variable
    info_test.go:226: ====== check defs pass (count: 4) ======
        000:  3: 6 | test                | func test()
        001:  4: 6 | ch                  | var ch chan int
        002:  6: 7 | n                   | var n int
        003:  6:10 | ok                  | var ok bool
    info_test.go:226: ====== check uses pass (count: 4) ======
        000:  4:14 | int                 | type int
        001:  6:18 | ch                  | var ch chan int
        002:  7: 7 | n                   | var n int
        003:  8: 7 | ok                  | var ok bool
--- PASS: TestChan (1.33s)
=== RUN   TestRange
2025/10/11 16:12:26.522723 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:27 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:27 ==> NewOverloadFunc NewRange
2025/10/11 16:12:27 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:27 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:27 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:27 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:27 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:27 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:27 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:27 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:27 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:27 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:27 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:27 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:27 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:27 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:27.772962 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00071e780 {
}

2025/10/11 16:12:27 ==> Preload func test
2025/10/11 16:12:27 ==> Load func test
2025/10/11 16:12:27.773066 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test()
2025/10/11 16:12:27 NewFunc test func()
2025/10/11 16:12:27 DefineVarStart [a]
2025/10/11 16:12:27.773697 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:27.773771 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:27.773790 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:27.773818 [INFO] typesutil/gopinfo.go:215: ==> Type: &{34 <nil> int} []int
2025/10/11 16:12:27 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:27.773879 [INFO] typesutil/gopinfo.go:215: ==> Type: &{40 INT 100 <nil>} untyped int
2025/10/11 16:12:27 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:27.773908 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 INT 200 <nil>} untyped int
2025/10/11 16:12:27 SliceLit []int 2 false
2025/10/11 16:12:27.773946 [INFO] typesutil/gopinfo.go:215: ==> Type: &{34 <nil> int} []int
2025/10/11 16:12:27.773974 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002f0bd0 39 [0xc0002f0c00 0xc0002f0c30] 47 false} []int
2025/10/11 16:12:27 EndInit 1
2025/10/11 16:12:27.774011 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []int
2025/10/11 16:12:27 ForRange [k v]
2025/10/11 16:12:27 Val a []int
2025/10/11 16:12:27.774058 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []int
2025/10/11 16:12:27.774077 [INFO] typesutil/gopinfo.go:215: ==> Type: a []int
2025/10/11 16:12:27 RangeAssignThen
2025/10/11 16:12:27.774102 [INFO] typesutil/gopinfo.go:251: ==> Def: k var k int
2025/10/11 16:12:27.774121 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v int
2025/10/11 16:12:27.774153 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00036c0c0 {
.  var k int
.  var v int
}

2025/10/11 16:12:27 VBlock
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val k int
2025/10/11 16:12:27.774194 [INFO] typesutil/gopinfo.go:265: ==> Use: k var k int
2025/10/11 16:12:27.774206 [INFO] typesutil/gopinfo.go:215: ==> Type: k int
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val v int
2025/10/11 16:12:27.774235 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v int
2025/10/11 16:12:27.774247 [INFO] typesutil/gopinfo.go:215: ==> Type: v int
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27.774265 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc00036c300 {
}

2025/10/11 16:12:27 End // Vblock
2025/10/11 16:12:27 End // ForRange
2025/10/11 16:12:27.774300 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:27.774317 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:27.774332 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:27.774346 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:27.774358 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:27.774370 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:27.774388 [INFO] typesutil/gopinfo.go:215: ==> Type: &{98 int string} map[int]string
2025/10/11 16:12:27 ==> Load var map[int]string [m]
2025/10/11 16:12:27 NewVarDefs
2025/10/11 16:12:27 NewVar [m]
2025/10/11 16:12:27.774431 [INFO] typesutil/gopinfo.go:251: ==> Def: m var m map[int]string
2025/10/11 16:12:27 ForRange [k v]
2025/10/11 16:12:27 Val m map[int]string
2025/10/11 16:12:27.774476 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]string
2025/10/11 16:12:27.774494 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]string
2025/10/11 16:12:27 RangeAssignThen
2025/10/11 16:12:27.774514 [INFO] typesutil/gopinfo.go:251: ==> Def: k var k int
2025/10/11 16:12:27.774527 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v string
2025/10/11 16:12:27.774548 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00036ca20 {
.  var k int
.  var v string
}

2025/10/11 16:12:27 VBlock
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val k int
2025/10/11 16:12:27.774591 [INFO] typesutil/gopinfo.go:265: ==> Use: k var k int
2025/10/11 16:12:27.774603 [INFO] typesutil/gopinfo.go:215: ==> Type: k int
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val v string
2025/10/11 16:12:27.774637 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v string
2025/10/11 16:12:27.774659 [INFO] typesutil/gopinfo.go:215: ==> Type: v string
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27.774678 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc00036d200 {
}

2025/10/11 16:12:27 End // Vblock
2025/10/11 16:12:27 End // ForRange
2025/10/11 16:12:27 ForRange [v]
2025/10/11 16:12:27 Val m map[int]string
2025/10/11 16:12:27.774727 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]string
2025/10/11 16:12:27.774748 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]string
2025/10/11 16:12:27 RangeAssignThen
2025/10/11 16:12:27.774772 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v int
2025/10/11 16:12:27.774789 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00036d380 {
.  var v int
}

2025/10/11 16:12:27 VBlock
2025/10/11 16:12:27 VarRef _
2025/10/11 16:12:27 Val v int
2025/10/11 16:12:27.774823 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v int
2025/10/11 16:12:27.774835 [INFO] typesutil/gopinfo.go:215: ==> Type: v int
2025/10/11 16:12:27 Assign 1 1
2025/10/11 16:12:27.774854 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc00036d4a0 {
}

2025/10/11 16:12:27 End // Vblock
2025/10/11 16:12:27 End // ForRange
2025/10/11 16:12:27.774892 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc00071e840 {
.  var a []int
.  var m map[int]string
}

2025/10/11 16:12:27 End // Func
    info_test.go:226: ====== check types pass (count: 16) ======
        000:  3: 7 | []int               *ast.ArrayType                 | type    : []int | type
        001:  3: 7 | []int{100, 200}     *ast.CompositeLit              | value   : []int | value
        002:  3: 9 | int                 *ast.Ident                     | type    : int | type
        003:  3:13 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
        004:  3:17 | 200                 *ast.BasicLit                  | value   : INT = 200 | constant
        005:  4:20 | a                   *ast.Ident                     | var     : []int | variable
        006:  5: 7 | k                   *ast.Ident                     | var     : int | variable
        007:  6: 7 | v                   *ast.Ident                     | var     : int | variable
        008:  8: 8 | map[int]string      *ast.MapType                   | type    : map[int]string | type
        009:  8:12 | int                 *ast.Ident                     | type    : int | type
        010:  8:16 | string              *ast.Ident                     | type    : string | type
        011:  9:20 | m                   *ast.Ident                     | var     : map[int]string | variable
        012: 10: 7 | k                   *ast.Ident                     | var     : int | variable
        013: 11: 7 | v                   *ast.Ident                     | var     : string | variable
        014: 13:17 | m                   *ast.Ident                     | var     : map[int]string | variable
        015: 14: 7 | v                   *ast.Ident                     | var     : int | variable
    info_test.go:226: ====== check defs pass (count: 8) ======
        000:  2: 6 | test                | func test()
        001:  3: 2 | a                   | var a []int
        002:  4: 6 | k                   | var k int
        003:  4: 9 | v                   | var v int
        004:  8: 6 | m                   | var m map[int]string
        005:  9: 6 | k                   | var k int
        006:  9: 9 | v                   | var v string
        007: 13: 6 | v                   | var v int
    info_test.go:226: ====== check uses pass (count: 11) ======
        000:  3: 9 | int                 | type int
        001:  4:20 | a                   | var a []int
        002:  5: 7 | k                   | var k int
        003:  6: 7 | v                   | var v int
        004:  8:12 | int                 | type int
        005:  8:16 | string              | type string
        006:  9:20 | m                   | var m map[int]string
        007: 10: 7 | k                   | var k int
        008: 11: 7 | v                   | var v string
        009: 13:17 | m                   | var m map[int]string
        010: 14: 7 | v                   | var v int
--- PASS: TestRange (1.25s)
=== RUN   TestFuncLit
2025/10/11 16:12:27.776408 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:28 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:28 ==> NewOverloadFunc NewRange
2025/10/11 16:12:28 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:28 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:28 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:28 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:28 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:28 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:28 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:28 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:28 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:28 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:28 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:28 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:28 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:28 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:29.033248 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0005b4c60 {
}

2025/10/11 16:12:29 ==> Preload func test
2025/10/11 16:12:29 ==> Load func test
2025/10/11 16:12:29.033332 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test()
2025/10/11 16:12:29 NewFunc test func()
2025/10/11 16:12:29 DefineVarStart [add]
2025/10/11 16:12:29.033380 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:29.033399 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:29.033413 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:29.033430 [INFO] typesutil/gopinfo.go:251: ==> Def: n1 var n1 int
2025/10/11 16:12:29.033454 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:29.033467 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:29.033478 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:29.033489 [INFO] typesutil/gopinfo.go:251: ==> Def: n2 var n2 int
2025/10/11 16:12:29.033501 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:29.033511 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:29.033522 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:29.033549 [INFO] typesutil/gopinfo.go:215: ==> Type: &{36 <nil> 0xc0003ae420 0xc0003ae4b0} func(n1 int, n2 int) int
2025/10/11 16:12:29.033569 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001f4700 0xc0003ae600} func(n1 int, n2 int) int
2025/10/11 16:12:29 NewClosure func(n1 int, n2 int) int
2025/10/11 16:12:29 Val n1 int
2025/10/11 16:12:29.033605 [INFO] typesutil/gopinfo.go:265: ==> Use: n1 var n1 int
2025/10/11 16:12:29.033616 [INFO] typesutil/gopinfo.go:215: ==> Type: n1 int
2025/10/11 16:12:29 Val n2 int
2025/10/11 16:12:29.033635 [INFO] typesutil/gopinfo.go:265: ==> Use: n2 var n2 int
2025/10/11 16:12:29.033648 [INFO] typesutil/gopinfo.go:215: ==> Type: n2 int
2025/10/11 16:12:29 BinaryOp +
2025/10/11 16:12:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:29.033735 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n1 74 + n2} int
2025/10/11 16:12:29 Return 1
2025/10/11 16:12:29 ==> MatchType int, int
2025/10/11 16:12:29.033853 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0005b4f00 {
.  var n1 int
.  var n2 int
}

2025/10/11 16:12:29 End // Func
2025/10/11 16:12:29 EndInit 1
2025/10/11 16:12:29.033896 [INFO] typesutil/gopinfo.go:251: ==> Def: add var add func(n1 int, n2 int) int
2025/10/11 16:12:29 VarRef _
2025/10/11 16:12:29 Val add func(n1 int, n2 int) int
2025/10/11 16:12:29.033937 [INFO] typesutil/gopinfo.go:265: ==> Use: add var add func(n1 int, n2 int) int
2025/10/11 16:12:29.033956 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(n1 int, n2 int) int
2025/10/11 16:12:29 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:29.033991 [INFO] typesutil/gopinfo.go:215: ==> Type: &{90 INT 1 <nil>} untyped int
2025/10/11 16:12:29 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:29.034016 [INFO] typesutil/gopinfo.go:215: ==> Type: &{92 INT 2 <nil>} untyped int
2025/10/11 16:12:29 Call 2 0 // func(n1 int, n2 int) int
2025/10/11 16:12:29 ==> MatchFuncCall func(n1 int, n2 int) int args: 2 flags: 0
2025/10/11 16:12:29 ==> MatchType untyped int (1), int
2025/10/11 16:12:29 ==> MatchType untyped int (2), int
2025/10/11 16:12:29.034090 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 89 [0xc0003ae660 0xc0003ae690] 0 [] 93 0} int
2025/10/11 16:12:29 Assign 1 1
2025/10/11 16:12:29.034114 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:29.034124 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:29.034136 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:29.034147 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n int
2025/10/11 16:12:29.034163 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 <nil> 0xc0003ae6f0 <nil>} func(n int)
2025/10/11 16:12:29.034183 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001f48a0 0xc0003ae7b0} func(n int)
2025/10/11 16:12:29 NewClosure func(n int)
2025/10/11 16:12:29 VarRef _
2025/10/11 16:12:29 Val n int
2025/10/11 16:12:29.034222 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n int
2025/10/11 16:12:29.034236 [INFO] typesutil/gopinfo.go:215: ==> Type: n int
2025/10/11 16:12:29 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:29.034258 [INFO] typesutil/gopinfo.go:215: ==> Type: &{122 INT 100 <nil>} untyped int
2025/10/11 16:12:29 BinaryOp +
2025/10/11 16:12:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:29 ==> MatchType untyped int (100), unboundFuncParam{typ: int}
2025/10/11 16:12:29.034389 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n 121 + 0xc0003ae750} int
2025/10/11 16:12:29 Assign 1 1
2025/10/11 16:12:29.034423 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0005b5200 {
.  var n int
}

2025/10/11 16:12:29 End // Func
2025/10/11 16:12:29 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:29.034457 [INFO] typesutil/gopinfo.go:215: ==> Type: &{129 INT 100 <nil>} untyped int
2025/10/11 16:12:29 Call 1 0 // func(n int)
2025/10/11 16:12:29 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/10/11 16:12:29 ==> MatchType untyped int (100), int
2025/10/11 16:12:29.034504 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a7a50 128 [0xc0003ae7e0] 0 [] 132 0} ()
2025/10/11 16:12:29 Go
2025/10/11 16:12:29.034527 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc0005b4d20 {
.  var add func(n1 int, n2 int) int
}

2025/10/11 16:12:29 End // Func
    info_test.go:226: ====== check types pass (count: 20) ======
        000:  3: 9 | func(n1 int, n2 int) int *ast.FuncType                  | type    : func(n1 int, n2 int) int | type
        001:  3: 9 | func(n1 int, n2 int) int {
        	return n1 + n2
        } *ast.FuncLit                   | value   : func(n1 int, n2 int) int | value
        002:  3:17 | int                 *ast.Ident                     | type    : int | type
        003:  3:25 | int                 *ast.Ident                     | type    : int | type
        004:  3:30 | int                 *ast.Ident                     | type    : int | type
        005:  4:10 | n1                  *ast.Ident                     | var     : int | variable
        006:  4:10 | n1 + n2             *ast.BinaryExpr                | value   : int | value
        007:  4:13 | n2                  *ast.Ident                     | var     : int | variable
        008:  6: 6 | add                 *ast.Ident                     | var     : func(n1 int, n2 int) int | variable
        009:  6: 6 | add(1, 2)           *ast.CallExpr                  | value   : int | value
        010:  6:10 | 1                   *ast.BasicLit                  | value   : INT = 1 | constant
        011:  6:12 | 2                   *ast.BasicLit                  | value   : INT = 2 | constant
        012:  8: 5 | func(n int)         *ast.FuncType                  | type    : func(n int) | type
        013:  8: 5 | func(n int) {
        	_ = n + 100
        } *ast.FuncLit                   | value   : func(n int) | value
        014:  8: 5 | func(n int) {
        	_ = n + 100
        }(100) *ast.CallExpr                  | void    : () | no value
        015:  8:12 | int                 *ast.Ident                     | type    : int | type
        016:  9: 7 | n                   *ast.Ident                     | var     : int | variable
        017:  9: 7 | n + 100             *ast.BinaryExpr                | value   : int | value
        018:  9: 9 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
        019: 10: 4 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
    info_test.go:226: ====== check defs pass (count: 5) ======
        000:  2: 6 | test                | func test()
        001:  3: 2 | add                 | var add func(n1 int, n2 int) int
        002:  3:14 | n1                  | var n1 int
        003:  3:22 | n2                  | var n2 int
        004:  8:10 | n                   | var n int
    info_test.go:226: ====== check uses pass (count: 8) ======
        000:  3:17 | int                 | type int
        001:  3:25 | int                 | type int
        002:  3:30 | int                 | type int
        003:  4:10 | n1                  | var n1 int
        004:  4:13 | n2                  | var n2 int
        005:  6: 6 | add                 | var add func(n1 int, n2 int) int
        006:  8:12 | int                 | type int
        007:  9: 7 | n                   | var n int
--- PASS: TestFuncLit (1.26s)
=== RUN   TestSliceLit
2025/10/11 16:12:29.036405 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:29 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:29 ==> NewOverloadFunc NewRange
2025/10/11 16:12:29 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:29 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:29 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:29 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:29 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:29 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:29 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:29 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:29 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:29 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:29 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:29 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:29 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:29 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:30.292459 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003fa540 {
}

2025/10/11 16:12:30 ==> Preload func main
2025/10/11 16:12:30 ==> Load func main
2025/10/11 16:12:30.292541 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:30 NewFunc main func()
2025/10/11 16:12:30 DefineVarStart [a]
2025/10/11 16:12:30 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:30.292628 [INFO] typesutil/gopinfo.go:215: ==> Type: &{8 INT 100 <nil>} untyped int
2025/10/11 16:12:30 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:30.292663 [INFO] typesutil/gopinfo.go:215: ==> Type: &{12 INT 200 <nil>} untyped int
2025/10/11 16:12:30 SliceLit <nil> 2 false
2025/10/11 16:12:30 EndInit 1
2025/10/11 16:12:30.292695 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []int
2025/10/11 16:12:30 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:30.292731 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/10/11 16:12:30.292746 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/10/11 16:12:30 Val a []int
2025/10/11 16:12:30.292770 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []int
2025/10/11 16:12:30.292782 [INFO] typesutil/gopinfo.go:215: ==> Type: a []int
2025/10/11 16:12:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:30 ==> MatchType []int, any
2025/10/11 16:12:30.292849 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:30.292867 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/10/11 16:12:30.292890 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 0 [a] 0 [] 0 26} (n int, err error)
2025/10/11 16:12:30.292915 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0003fa600 {
.  var a []int
}

2025/10/11 16:12:30 End // Func
    info_test.go:190: == types ==
        000:  2: 7 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        001:  2:11 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        002:  3: 1 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        003:  3: 1 | println a           *ast.CallExpr                  | value   : (n int, err error) | value
        004:  3: 9 | a                   *ast.Ident                     | var     : []int | variable
        == defs ==
        000:  2: 1 | a                   | var a []int
        001:  2: 1 | main                | func main.main()
        == uses ==
        000:  3: 1 | println             | func fmt.Println(a ...any) (n int, err error)
        001:  3: 9 | a                   | var a []int
--- PASS: TestSliceLit (1.26s)
=== RUN   TestForPhrase1
2025/10/11 16:12:30.293631 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:30 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:30 ==> NewOverloadFunc NewRange
2025/10/11 16:12:31 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:31 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:31 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:31 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:31 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:31 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:31 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:31 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:31 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:31 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:31 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:31 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:31 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:31 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:31.525988 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003c8540 {
}

2025/10/11 16:12:31 ==> Preload func main
2025/10/11 16:12:31 ==> Load func main
2025/10/11 16:12:31.526050 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:31 NewFunc main func()
2025/10/11 16:12:31 DefineVarStart [sum]
2025/10/11 16:12:31 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:31.526102 [INFO] typesutil/gopinfo.go:215: ==> Type: &{9 INT 0 <nil>} untyped int
2025/10/11 16:12:31 EndInit 1
2025/10/11 16:12:31.526118 [INFO] typesutil/gopinfo.go:251: ==> Def: sum var sum int
2025/10/11 16:12:31 ForRange [_ x]
2025/10/11 16:12:31 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:31.526147 [INFO] typesutil/gopinfo.go:215: ==> Type: &{21 INT 1 <nil>} untyped int
2025/10/11 16:12:31 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:31.526163 [INFO] typesutil/gopinfo.go:215: ==> Type: &{24 INT 3 <nil>} untyped int
2025/10/11 16:12:31 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:31.526176 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 INT 5 <nil>} untyped int
2025/10/11 16:12:31 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:31.526189 [INFO] typesutil/gopinfo.go:215: ==> Type: &{30 INT 7 <nil>} untyped int
2025/10/11 16:12:31 Val &{0 INT 11} *ast.BasicLit
2025/10/11 16:12:31.526205 [INFO] typesutil/gopinfo.go:215: ==> Type: &{33 INT 11 <nil>} untyped int
2025/10/11 16:12:31 Val &{0 INT 13} *ast.BasicLit
2025/10/11 16:12:31.526218 [INFO] typesutil/gopinfo.go:215: ==> Type: &{37 INT 13 <nil>} untyped int
2025/10/11 16:12:31 Val &{0 INT 17} *ast.BasicLit
2025/10/11 16:12:31.526231 [INFO] typesutil/gopinfo.go:215: ==> Type: &{41 INT 17 <nil>} untyped int
2025/10/11 16:12:31 SliceLit <nil> 7 false
2025/10/11 16:12:31 RangeAssignThen
2025/10/11 16:12:31.526249 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:12:31.526266 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0003c86c0 {
.  var x int
}

2025/10/11 16:12:31 If
2025/10/11 16:12:31 Val x int
2025/10/11 16:12:31.526287 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:12:31.526299 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:12:31 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:31.526316 [INFO] typesutil/gopinfo.go:215: ==> Type: &{50 INT 3 <nil>} untyped int
2025/10/11 16:12:31 BinaryOp >
2025/10/11 16:12:31 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:31 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:31 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:31.526383 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 48 > 0xc0003af170} untyped bool
2025/10/11 16:12:31 Then
2025/10/11 16:12:31 VarRef sum int
2025/10/11 16:12:31.526402 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:12:31.526411 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:12:31 Val sum int
2025/10/11 16:12:31.526424 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:12:31.526430 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:12:31 Val x int
2025/10/11 16:12:31.526444 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:12:31.526450 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:12:31 BinaryOp +
2025/10/11 16:12:31 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:31 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:31 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:31.526493 [INFO] typesutil/gopinfo.go:215: ==> Type: &{sum 65 + x} int
2025/10/11 16:12:31 Assign 1 1
2025/10/11 16:12:31 ==> MatchType int, int
2025/10/11 16:12:31.526518 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc0003c8900 {
}

2025/10/11 16:12:31 End // If
2025/10/11 16:12:31 End // ForRange
2025/10/11 16:12:31 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:31.526552 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/10/11 16:12:31.526562 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/10/11 16:12:31 Val sum int
2025/10/11 16:12:31.526581 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:12:31.526588 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:12:31 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:31 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:31 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:31 ==> MatchType int, any
2025/10/11 16:12:31.526632 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:31.526642 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/10/11 16:12:31.526658 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 0 [sum] 0 [] 0 82} (n int, err error)
2025/10/11 16:12:31.526671 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0003c8600 {
.  var sum int
}

2025/10/11 16:12:31 End // Func
    info_test.go:190: == types ==
        000:  2: 8 | 0                   *ast.BasicLit                  | value   : untyped int = 0 | constant
        001:  3:11 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        002:  3:14 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        003:  3:17 | 5                   *ast.BasicLit                  | value   : untyped int = 5 | constant
        004:  3:20 | 7                   *ast.BasicLit                  | value   : untyped int = 7 | constant
        005:  3:23 | 11                  *ast.BasicLit                  | value   : untyped int = 11 | constant
        006:  3:27 | 13                  *ast.BasicLit                  | value   : untyped int = 13 | constant
        007:  3:31 | 17                  *ast.BasicLit                  | value   : untyped int = 17 | constant
        008:  3:36 | x                   *ast.Ident                     | var     : int | variable
        009:  3:36 | x > 3               *ast.BinaryExpr                | value   : untyped bool | value
        010:  3:40 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        011:  4: 2 | sum                 *ast.Ident                     | var     : int | variable
        012:  4: 8 | sum                 *ast.Ident                     | var     : int | variable
        013:  4: 8 | sum + x             *ast.BinaryExpr                | value   : int | value
        014:  4:14 | x                   *ast.Ident                     | var     : int | variable
        015:  6: 1 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        016:  6: 1 | println sum         *ast.CallExpr                  | value   : (n int, err error) | value
        017:  6: 9 | sum                 *ast.Ident                     | var     : int | variable
        == defs ==
        000:  2: 1 | main                | func main.main()
        001:  2: 1 | sum                 | var sum int
        002:  3: 5 | x                   | var x int
        == uses ==
        000:  3:36 | x                   | var x int
        001:  4: 2 | sum                 | var sum int
        002:  4: 8 | sum                 | var sum int
        003:  4:14 | x                   | var x int
        004:  6: 1 | println             | func fmt.Println(a ...any) (n int, err error)
        005:  6: 9 | sum                 | var sum int
--- PASS: TestForPhrase1 (1.23s)
=== RUN   TestForPhrase2
2025/10/11 16:12:31.527470 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:32 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:32 ==> NewOverloadFunc NewRange
2025/10/11 16:12:32 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:32 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:32 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:32 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:32 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:32 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:32 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:32 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:32 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:32 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:32 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:32 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:32 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:32 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:32.878386 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00044f1a0 {
}

2025/10/11 16:12:32 ==> Preload func main
2025/10/11 16:12:32 ==> Load func main
2025/10/11 16:12:32.878476 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:32 NewFunc main func()
2025/10/11 16:12:32 DefineVarStart [sum]
2025/10/11 16:12:32 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:12:32.878553 [INFO] typesutil/gopinfo.go:215: ==> Type: &{9 INT 0 <nil>} untyped int
2025/10/11 16:12:32 EndInit 1
2025/10/11 16:12:32.878583 [INFO] typesutil/gopinfo.go:251: ==> Def: sum var sum int
2025/10/11 16:12:32 ForRange [i x]
2025/10/11 16:12:32 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:32.878623 [INFO] typesutil/gopinfo.go:215: ==> Type: &{24 INT 1 <nil>} untyped int
2025/10/11 16:12:32 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:32.878648 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 INT 3 <nil>} untyped int
2025/10/11 16:12:32 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:32.878672 [INFO] typesutil/gopinfo.go:215: ==> Type: &{30 INT 5 <nil>} untyped int
2025/10/11 16:12:32 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:12:32.878695 [INFO] typesutil/gopinfo.go:215: ==> Type: &{33 INT 7 <nil>} untyped int
2025/10/11 16:12:32 Val &{0 INT 11} *ast.BasicLit
2025/10/11 16:12:32.878718 [INFO] typesutil/gopinfo.go:215: ==> Type: &{36 INT 11 <nil>} untyped int
2025/10/11 16:12:32 Val &{0 INT 13} *ast.BasicLit
2025/10/11 16:12:32.878745 [INFO] typesutil/gopinfo.go:215: ==> Type: &{40 INT 13 <nil>} untyped int
2025/10/11 16:12:32 Val &{0 INT 17} *ast.BasicLit
2025/10/11 16:12:32.878771 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 INT 17 <nil>} untyped int
2025/10/11 16:12:32 SliceLit <nil> 7 false
2025/10/11 16:12:32 RangeAssignThen
2025/10/11 16:12:32.878804 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:12:32.878817 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:12:32.878842 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00044f320 {
.  var i int
.  var x int
}

2025/10/11 16:12:32 If
2025/10/11 16:12:32 Val i int
2025/10/11 16:12:32.878876 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:12:32.878894 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:12:32 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:32.878924 [INFO] typesutil/gopinfo.go:215: ==> Type: &{51 INT 2 <nil>} untyped int
2025/10/11 16:12:32 BinaryOp %
2025/10/11 16:12:32 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:32 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:32 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:32.879032 [INFO] typesutil/gopinfo.go:215: ==> Type: &{i 50 % 0xc0002f0030} int
2025/10/11 16:12:32 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:32.879064 [INFO] typesutil/gopinfo.go:215: ==> Type: &{56 INT 1 <nil>} untyped int
2025/10/11 16:12:32 BinaryOp ==
2025/10/11 16:12:32.879087 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002f0060 53 == 0xc0002f0090} untyped bool
2025/10/11 16:12:32 Val x int
2025/10/11 16:12:32.879110 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:12:32.879122 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:12:32 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:32.879152 [INFO] typesutil/gopinfo.go:215: ==> Type: &{65 INT 3 <nil>} untyped int
2025/10/11 16:12:32 BinaryOp >
2025/10/11 16:12:32 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:32 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:32 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:12:32.879224 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 63 > 0xc0002f00f0} untyped bool
2025/10/11 16:12:32 BinaryOp &&
2025/10/11 16:12:32 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:32 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:32 ==> MatchType untyped bool, unboundFuncParam{typ: untyped bool}
2025/10/11 16:12:32.879282 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002f00c0 58 && 0xc0002f0120} untyped bool
2025/10/11 16:12:32 Then
2025/10/11 16:12:32 VarRef sum int
2025/10/11 16:12:32.879318 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:12:32.879331 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:12:32 Val sum int
2025/10/11 16:12:32.879351 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:12:32.879363 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:12:32 Val x int
2025/10/11 16:12:32.879382 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:12:32.879393 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:12:32 BinaryOp +
2025/10/11 16:12:32 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:32 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:32 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:32.879457 [INFO] typesutil/gopinfo.go:215: ==> Type: &{sum 80 + x} int
2025/10/11 16:12:32 Assign 1 1
2025/10/11 16:12:32 ==> MatchType int, int
2025/10/11 16:12:32.879492 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc00044f800 {
}

2025/10/11 16:12:32 End // If
2025/10/11 16:12:32 End // ForRange
2025/10/11 16:12:32 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:32.879544 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/10/11 16:12:32.879560 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/10/11 16:12:32 Val sum int
2025/10/11 16:12:32.879584 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:12:32.879657 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:12:32 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:32 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:32 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:32 ==> MatchType int, any
2025/10/11 16:12:32.879728 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:32.879751 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/10/11 16:12:32.879776 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 0 [sum] 0 [] 0 97} (n int, err error)
2025/10/11 16:12:32.879801 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc00044f260 {
.  var sum int
}

2025/10/11 16:12:32 End // Func
    info_test.go:190: == types ==
        000:  2: 8 | 0                   *ast.BasicLit                  | value   : untyped int = 0 | constant
        001:  3:14 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        002:  3:17 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        003:  3:20 | 5                   *ast.BasicLit                  | value   : untyped int = 5 | constant
        004:  3:23 | 7                   *ast.BasicLit                  | value   : untyped int = 7 | constant
        005:  3:26 | 11                  *ast.BasicLit                  | value   : untyped int = 11 | constant
        006:  3:30 | 13                  *ast.BasicLit                  | value   : untyped int = 13 | constant
        007:  3:34 | 17                  *ast.BasicLit                  | value   : untyped int = 17 | constant
        008:  3:39 | i                   *ast.Ident                     | var     : int | variable
        009:  3:39 | i % 2               *ast.BinaryExpr                | value   : int | value
        010:  3:39 | i%2 == 1            *ast.BinaryExpr                | value   : untyped bool | value
        011:  3:39 | i%2 == 1 && x > 3   *ast.BinaryExpr                | value   : untyped bool | value
        012:  3:41 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        013:  3:46 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        014:  3:51 | x                   *ast.Ident                     | var     : int | variable
        015:  3:51 | x > 3               *ast.BinaryExpr                | value   : untyped bool | value
        016:  3:55 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        017:  4: 2 | sum                 *ast.Ident                     | var     : int | variable
        018:  4: 8 | sum                 *ast.Ident                     | var     : int | variable
        019:  4: 8 | sum + x             *ast.BinaryExpr                | value   : int | value
        020:  4:14 | x                   *ast.Ident                     | var     : int | variable
        021:  6: 1 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        022:  6: 1 | println sum         *ast.CallExpr                  | value   : (n int, err error) | value
        023:  6: 9 | sum                 *ast.Ident                     | var     : int | variable
        == defs ==
        000:  2: 1 | main                | func main.main()
        001:  2: 1 | sum                 | var sum int
        002:  3: 5 | i                   | var i int
        003:  3: 8 | x                   | var x int
        == uses ==
        000:  3:39 | i                   | var i int
        001:  3:51 | x                   | var x int
        002:  4: 2 | sum                 | var sum int
        003:  4: 8 | sum                 | var sum int
        004:  4:14 | x                   | var x int
        005:  6: 1 | println             | func fmt.Println(a ...any) (n int, err error)
        006:  6: 9 | sum                 | var sum int
--- PASS: TestForPhrase2 (1.35s)
=== RUN   TestMapComprehension
2025/10/11 16:12:32.882305 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:33 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:33 ==> NewOverloadFunc NewRange
2025/10/11 16:12:33 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:33 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:33 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:33 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:33 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:33 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:33 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:33 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:33 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:33 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:33 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:33 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:33 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:33 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:34.107874 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003944e0 {
}

2025/10/11 16:12:34 ==> Preload func main
2025/10/11 16:12:34 ==> Load func main
2025/10/11 16:12:34.107952 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:34 NewFunc main func()
2025/10/11 16:12:34 DefineVarStart [y]
2025/10/11 16:12:34 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:34 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:34 ZeroLit // unboundType{typ: <nil>}
2025/10/11 16:12:34 Assign 1 1
2025/10/11 16:12:34 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/10/11 16:12:34 ForRange [i x]
2025/10/11 16:12:34 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:34.108127 [INFO] typesutil/gopinfo.go:215: ==> Type: &{26 STRING "1" <nil>} untyped string
2025/10/11 16:12:34 Val &{0 STRING "3"} *ast.BasicLit
2025/10/11 16:12:34.108152 [INFO] typesutil/gopinfo.go:215: ==> Type: &{31 STRING "3" <nil>} untyped string
2025/10/11 16:12:34 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:12:34.108176 [INFO] typesutil/gopinfo.go:215: ==> Type: &{36 STRING "5" <nil>} untyped string
2025/10/11 16:12:34 Val &{0 STRING "7"} *ast.BasicLit
2025/10/11 16:12:34.108197 [INFO] typesutil/gopinfo.go:215: ==> Type: &{41 STRING "7" <nil>} untyped string
2025/10/11 16:12:34 Val &{0 STRING "11"} *ast.BasicLit
2025/10/11 16:12:34.108218 [INFO] typesutil/gopinfo.go:215: ==> Type: &{46 STRING "11" <nil>} untyped string
2025/10/11 16:12:34 SliceLit <nil> 5 false
2025/10/11 16:12:34 RangeAssignThen
2025/10/11 16:12:34.108249 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:12:34.108261 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x string
2025/10/11 16:12:34.108283 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc000394720 {
.  var i int
.  var x string
}

2025/10/11 16:12:34 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:34 Val x string
2025/10/11 16:12:34.108312 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x string
2025/10/11 16:12:34.108324 [INFO] typesutil/gopinfo.go:215: ==> Type: x string
2025/10/11 16:12:34 IndexRef 1
2025/10/11 16:12:34 Val i int
2025/10/11 16:12:34.108350 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:12:34.108361 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:12:34 Assign 1 1
2025/10/11 16:12:34 ==> MatchType int, unboundMapElemType{key: string}
2025/10/11 16:12:34 End // ForRange
2025/10/11 16:12:34 Return 0
2025/10/11 16:12:34 End // Func
2025/10/11 16:12:34 Call 0 0 // func() (_xgo_ret map[string]int)
2025/10/11 16:12:34 ==> MatchFuncCall func() (_xgo_ret map[string]int) args: 0 flags: 0
2025/10/11 16:12:34 EndInit 1
2025/10/11 16:12:34.108458 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y map[string]int
2025/10/11 16:12:34 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:34.108488 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/10/11 16:12:34.108500 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/10/11 16:12:34 Val y map[string]int
2025/10/11 16:12:34.108522 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y map[string]int
2025/10/11 16:12:34.108546 [INFO] typesutil/gopinfo.go:215: ==> Type: y map[string]int
2025/10/11 16:12:34 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:34 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:34 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:34 ==> MatchType map[string]int, any
2025/10/11 16:12:34.108583 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:34.108592 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/10/11 16:12:34.108604 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 0 [y] 0 [] 0 62} (n int, err error)
2025/10/11 16:12:34.108615 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0003945a0 {
.  var y map[string]int
}

2025/10/11 16:12:34 End // Func
    info_test.go:190: == types ==
        000:  2: 7 | x                   *ast.Ident                     | var     : string | variable
        001:  2:10 | i                   *ast.Ident                     | var     : int | variable
        002:  2:25 | "1"                 *ast.BasicLit                  | value   : untyped string = "1" | constant
        003:  2:30 | "3"                 *ast.BasicLit                  | value   : untyped string = "3" | constant
        004:  2:35 | "5"                 *ast.BasicLit                  | value   : untyped string = "5" | constant
        005:  2:40 | "7"                 *ast.BasicLit                  | value   : untyped string = "7" | constant
        006:  2:45 | "11"                *ast.BasicLit                  | value   : untyped string = "11" | constant
        007:  3: 1 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        008:  3: 1 | println y           *ast.CallExpr                  | value   : (n int, err error) | value
        009:  3: 9 | y                   *ast.Ident                     | var     : map[string]int | variable
        == defs ==
        000:  2: 1 | main                | func main.main()
        001:  2: 1 | y                   | var y map[string]int
        002:  2:16 | i                   | var i int
        003:  2:19 | x                   | var x string
        == uses ==
        000:  2: 7 | x                   | var x string
        001:  2:10 | i                   | var i int
        002:  3: 1 | println             | func fmt.Println(a ...any) (n int, err error)
        003:  3: 9 | y                   | var y map[string]int
--- PASS: TestMapComprehension (1.23s)
=== RUN   TestListComprehension
2025/10/11 16:12:34.109169 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:34 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:34 ==> NewOverloadFunc NewRange
2025/10/11 16:12:34 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:34 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:34 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:34 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:34 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:34 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:34 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:34 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:34 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:34 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:34 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:34 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:34 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:34 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:35.274566 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003651a0 {
}

2025/10/11 16:12:35 ==> Preload func main
2025/10/11 16:12:35 ==> Load func main
2025/10/11 16:12:35.274647 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:35 NewFunc main func()
2025/10/11 16:12:35 DefineVarStart [a]
2025/10/11 16:12:35 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:35.274716 [INFO] typesutil/gopinfo.go:215: ==> Type: &{8 INT 1 <nil>} untyped int
2025/10/11 16:12:35 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:12:35.274756 [INFO] typesutil/gopinfo.go:215: ==> Type: &{11 FLOAT 3.4 <nil>} untyped float
2025/10/11 16:12:35 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:35.274780 [INFO] typesutil/gopinfo.go:215: ==> Type: &{16 INT 5 <nil>} untyped int
2025/10/11 16:12:35 SliceLit <nil> 3 false
2025/10/11 16:12:35 EndInit 1
2025/10/11 16:12:35.274818 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []float64
2025/10/11 16:12:35 DefineVarStart [b]
2025/10/11 16:12:35 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:35 ForRange [_ x]
2025/10/11 16:12:35 Val a []float64
2025/10/11 16:12:35.274876 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []float64
2025/10/11 16:12:35.274892 [INFO] typesutil/gopinfo.go:215: ==> Type: a []float64
2025/10/11 16:12:35 RangeAssignThen
2025/10/11 16:12:35.274911 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/10/11 16:12:35.274932 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc000365440 {
.  var x float64
}

2025/10/11 16:12:35 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:35 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:35 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:35 Val x float64
2025/10/11 16:12:35.274983 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:35.274994 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:35 Val x float64
2025/10/11 16:12:35.275014 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:35.275025 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:35 BinaryOp *
2025/10/11 16:12:35 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:35 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:35 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:35.275118 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 26 * x} float64
2025/10/11 16:12:35 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:35 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:35 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:12:35 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:12:35 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:35 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:35 Assign 1 1
2025/10/11 16:12:35 ==> MatchType []float64, unboundType{typ: <nil>}
2025/10/11 16:12:35 End // ForRange
2025/10/11 16:12:35 Return 0
2025/10/11 16:12:35 End // Func
2025/10/11 16:12:35 Call 0 0 // func() (_xgo_ret []float64)
2025/10/11 16:12:35 ==> MatchFuncCall func() (_xgo_ret []float64) args: 0 flags: 0
2025/10/11 16:12:35 EndInit 1
2025/10/11 16:12:35.275272 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b []float64
2025/10/11 16:12:35 VarRef _
2025/10/11 16:12:35 Val b []float64
2025/10/11 16:12:35.275303 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b []float64
2025/10/11 16:12:35.275314 [INFO] typesutil/gopinfo.go:215: ==> Type: b []float64
2025/10/11 16:12:35 Assign 1 1
2025/10/11 16:12:35.275340 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000365260 {
.  var a []float64
.  var b []float64
}

2025/10/11 16:12:35 End // Func
    info_test.go:190: == types ==
        000:  2: 7 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        001:  2:10 | 3.4                 *ast.BasicLit                  | value   : untyped float = 3.4 | constant
        002:  2:15 | 5                   *ast.BasicLit                  | value   : untyped int = 5 | constant
        003:  3: 7 | x                   *ast.Ident                     | var     : float64 | variable
        004:  3: 7 | x * x               *ast.BinaryExpr                | value   : float64 | value
        005:  3: 9 | x                   *ast.Ident                     | var     : float64 | variable
        006:  3:20 | a                   *ast.Ident                     | var     : []float64 | variable
        007:  4: 5 | b                   *ast.Ident                     | var     : []float64 | variable
        == defs ==
        000:  2: 1 | a                   | var a []float64
        001:  2: 1 | main                | func main.main()
        002:  3: 1 | b                   | var b []float64
        003:  3:15 | x                   | var x float64
        == uses ==
        000:  3: 7 | x                   | var x float64
        001:  3: 9 | x                   | var x float64
        002:  3:20 | a                   | var a []float64
        003:  4: 5 | b                   | var b []float64
--- PASS: TestListComprehension (1.17s)
=== RUN   TestListComprehensionMultiLevel
2025/10/11 16:12:35.277225 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:35 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:35 ==> NewOverloadFunc NewRange
2025/10/11 16:12:36 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:36 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:36 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:36 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:36 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:36 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:36 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:36 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:36 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:36 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:36 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:36 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:36 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:36 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:36.507035 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0005b0540 {
}

2025/10/11 16:12:36 ==> Preload func main
2025/10/11 16:12:36 ==> Load func main
2025/10/11 16:12:36.507193 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:36 NewFunc main func()
2025/10/11 16:12:36 DefineVarStart [arr]
2025/10/11 16:12:36 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:36.507372 [INFO] typesutil/gopinfo.go:215: ==> Type: &{10 INT 1 <nil>} untyped int
2025/10/11 16:12:36 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:36.508278 [INFO] typesutil/gopinfo.go:215: ==> Type: &{13 INT 2 <nil>} untyped int
2025/10/11 16:12:36 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:36.508348 [INFO] typesutil/gopinfo.go:215: ==> Type: &{16 INT 3 <nil>} untyped int
2025/10/11 16:12:36 Val &{0 FLOAT 4.1} *ast.BasicLit
2025/10/11 16:12:36.508388 [INFO] typesutil/gopinfo.go:215: ==> Type: &{19 FLOAT 4.1 <nil>} untyped float
2025/10/11 16:12:36 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:12:36.508407 [INFO] typesutil/gopinfo.go:215: ==> Type: &{24 INT 5 <nil>} untyped int
2025/10/11 16:12:36 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:36.508429 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 INT 6 <nil>} untyped int
2025/10/11 16:12:36 SliceLit <nil> 6 false
2025/10/11 16:12:36 EndInit 1
2025/10/11 16:12:36.508493 [INFO] typesutil/gopinfo.go:251: ==> Def: arr var arr []float64
2025/10/11 16:12:36 DefineVarStart [x]
2025/10/11 16:12:36 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:12:36 ForRange [_ b]
2025/10/11 16:12:36 Val arr []float64
2025/10/11 16:12:36.508547 [INFO] typesutil/gopinfo.go:265: ==> Use: arr var arr []float64
2025/10/11 16:12:36.508554 [INFO] typesutil/gopinfo.go:215: ==> Type: arr []float64
2025/10/11 16:12:36 RangeAssignThen
2025/10/11 16:12:36.508568 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b float64
2025/10/11 16:12:36.508581 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00041aae0 {
.  var b float64
}

2025/10/11 16:12:36 If
2025/10/11 16:12:36 Val b float64
2025/10/11 16:12:36.508599 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/10/11 16:12:36.508604 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/10/11 16:12:36 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:36.508618 [INFO] typesutil/gopinfo.go:215: ==> Type: &{81 INT 2 <nil>} untyped int
2025/10/11 16:12:36 BinaryOp >
2025/10/11 16:12:36 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/10/11 16:12:36.508670 [INFO] typesutil/gopinfo.go:215: ==> Type: &{b 79 > 0xc00052d1a0} untyped bool
2025/10/11 16:12:36 Then
2025/10/11 16:12:36 ForRange [_ a]
2025/10/11 16:12:36 Val arr []float64
2025/10/11 16:12:36.508687 [INFO] typesutil/gopinfo.go:265: ==> Use: arr var arr []float64
2025/10/11 16:12:36.508694 [INFO] typesutil/gopinfo.go:215: ==> Type: arr []float64
2025/10/11 16:12:36 RangeAssignThen
2025/10/11 16:12:36.508706 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a float64
2025/10/11 16:12:36.508715 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00041b800 {
.  var a float64
}

2025/10/11 16:12:36 If
2025/10/11 16:12:36 Val a float64
2025/10/11 16:12:36.508726 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/10/11 16:12:36.508733 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/10/11 16:12:36 Val b float64
2025/10/11 16:12:36.508745 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/10/11 16:12:36.508753 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/10/11 16:12:36 BinaryOp <
2025/10/11 16:12:36 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:36.508786 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 59 < b} untyped bool
2025/10/11 16:12:36 Then
2025/10/11 16:12:36 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:36 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:12:36 Val a float64
2025/10/11 16:12:36.508820 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/10/11 16:12:36.508831 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/10/11 16:12:36 Val b float64
2025/10/11 16:12:36.508847 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/10/11 16:12:36.508855 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/10/11 16:12:36 SliceLit <nil> 2 false
2025/10/11 16:12:36 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 ==> MatchType []float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:36 Assign 1 1
2025/10/11 16:12:36 ==> MatchType [][]float64, unboundType{typ: <nil>}
2025/10/11 16:12:36 End // If
2025/10/11 16:12:36 End // ForRange
2025/10/11 16:12:36 End // If
2025/10/11 16:12:36 End // ForRange
2025/10/11 16:12:36 Return 0
2025/10/11 16:12:36 End // Func
2025/10/11 16:12:36 Call 0 0 // func() (_xgo_ret [][]float64)
2025/10/11 16:12:36 ==> MatchFuncCall func() (_xgo_ret [][]float64) args: 0 flags: 0
2025/10/11 16:12:36 EndInit 1
2025/10/11 16:12:36.508970 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x [][]float64
2025/10/11 16:12:36 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36.508985 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/10/11 16:12:36.508993 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/10/11 16:12:36 Val &{0 STRING "x:"} *ast.BasicLit
2025/10/11 16:12:36.509008 [INFO] typesutil/gopinfo.go:215: ==> Type: &{92 STRING "x:" <nil>} untyped string
2025/10/11 16:12:36 Val x [][]float64
2025/10/11 16:12:36.509024 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x [][]float64
2025/10/11 16:12:36.509032 [INFO] typesutil/gopinfo.go:215: ==> Type: x [][]float64
2025/10/11 16:12:36 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:36 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/10/11 16:12:36 ==> MatchType untyped string ("x:"), any
2025/10/11 16:12:36 ==> MatchType [][]float64, any
2025/10/11 16:12:36.509072 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:36.509082 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/10/11 16:12:36.509095 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 91 [0xc00052d200 x] 0 [] 99 0} (n int, err error)
2025/10/11 16:12:36.509108 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0005b0600 {
.  var arr []float64
.  var x [][]float64
}

2025/10/11 16:12:36 End // Func
    info_test.go:190: == types ==
        000:  2: 9 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        001:  2:12 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        002:  2:15 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        003:  2:18 | 4.1                 *ast.BasicLit                  | value   : untyped float = 4.1 | constant
        004:  2:23 | 5                   *ast.BasicLit                  | value   : untyped int = 5 | constant
        005:  2:26 | 6                   *ast.BasicLit                  | value   : untyped int = 6 | constant
        006:  3: 8 | a                   *ast.Ident                     | var     : float64 | variable
        007:  3:11 | b                   *ast.Ident                     | var     : float64 | variable
        008:  3:23 | arr                 *ast.Ident                     | var     : []float64 | variable
        009:  3:28 | a                   *ast.Ident                     | var     : float64 | variable
        010:  3:28 | a < b               *ast.BinaryExpr                | value   : untyped bool | value
        011:  3:32 | b                   *ast.Ident                     | var     : float64 | variable
        012:  3:43 | arr                 *ast.Ident                     | var     : []float64 | variable
        013:  3:48 | b                   *ast.Ident                     | var     : float64 | variable
        014:  3:48 | b > 2               *ast.BinaryExpr                | value   : untyped bool | value
        015:  3:52 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        016:  4: 1 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        017:  4: 1 | println("x:", x)    *ast.CallExpr                  | value   : (n int, err error) | value
        018:  4: 9 | "x:"                *ast.BasicLit                  | value   : untyped string = "x:" | constant
        019:  4:15 | x                   *ast.Ident                     | var     : [][]float64 | variable
        == defs ==
        000:  2: 1 | arr                 | var arr []float64
        001:  2: 1 | main                | func main.main()
        002:  3: 1 | x                   | var x [][]float64
        003:  3:18 | a                   | var a float64
        004:  3:38 | b                   | var b float64
        == uses ==
        000:  3: 8 | a                   | var a float64
        001:  3:11 | b                   | var b float64
        002:  3:23 | arr                 | var arr []float64
        003:  3:28 | a                   | var a float64
        004:  3:32 | b                   | var b float64
        005:  3:43 | arr                 | var arr []float64
        006:  3:48 | b                   | var b float64
        007:  4: 1 | println             | func fmt.Println(a ...any) (n int, err error)
        008:  4:15 | x                   | var x [][]float64
--- PASS: TestListComprehensionMultiLevel (1.23s)
=== RUN   TestFileEnumLines
2025/10/11 16:12:36.509734 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:37 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:37 ==> NewOverloadFunc NewRange
2025/10/11 16:12:37 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:37 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:37 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:37 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:37 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:37 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:37 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:37 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:37 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:37 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:37 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:37 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:37 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:37 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:37.718391 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0006f98c0 {
}

2025/10/11 16:12:37.718455 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package os
2025/10/11 16:12:37 ==> Preload func main
2025/10/11 16:12:37 ==> Load func main
2025/10/11 16:12:37.718520 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:37 NewFunc main func()
2025/10/11 16:12:37 ForRange [_ line]
2025/10/11 16:12:37.718570 [INFO] typesutil/gopinfo.go:265: ==> Use: os package os
2025/10/11 16:12:37.718592 [INFO] typesutil/gopinfo.go:265: ==> Use: Stdin var os.Stdin *os.File
2025/10/11 16:12:37 Val Stdin *os.File
2025/10/11 16:12:37.718628 [INFO] typesutil/gopinfo.go:215: ==> Type: &{os Stdin} *os.File
2025/10/11 16:12:37 RangeAssignThen
2025/10/11 16:12:37.718674 [INFO] typesutil/gopinfo.go:251: ==> Def: line var line string
2025/10/11 16:12:37.718698 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0006f9a40 {
.  var line string
}

2025/10/11 16:12:37 VBlock
2025/10/11 16:12:37 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37.718747 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/10/11 16:12:37.718762 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/10/11 16:12:37 Val line string
2025/10/11 16:12:37.718789 [INFO] typesutil/gopinfo.go:265: ==> Use: line var line string
2025/10/11 16:12:37.718801 [INFO] typesutil/gopinfo.go:215: ==> Type: line string
2025/10/11 16:12:37 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:37 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType string, any
2025/10/11 16:12:37.718875 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:37.718895 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/10/11 16:12:37.718923 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 0 [line] 0 [] 0 51} (n int, err error)
2025/10/11 16:12:37.718946 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc0006f9b60 {
}

2025/10/11 16:12:37 End // Vblock
2025/10/11 16:12:37 End // ForRange
2025/10/11 16:12:37 Member Gop_Enum 0 // *os.File
2025/10/11 16:12:37 Val EnumLines func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/10/11 16:12:37 Call 1 0 // func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/10/11 16:12:37 ==> MatchFuncCall func(r io.Reader) github.com/qiniu/x/osx.LineIter args: 1 flags: 0
2025/10/11 16:12:37 ==> MatchType *os.File, io.Reader
2025/10/11 16:12:37 ==> EnsureLoaded io.Reader
2025/10/11 16:12:37.719073 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0006f99e0 {
}

2025/10/11 16:12:37 End // Func
    info_test.go:190: == types ==
        000:  4:13 | os.Stdin            *ast.SelectorExpr              | var     : *os.File | variable
        001:  5: 2 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        002:  5: 2 | println line        *ast.CallExpr                  | value   : (n int, err error) | value
        003:  5:10 | line                *ast.Ident                     | var     : string | variable
        == defs ==
        000:  4: 1 | main                | func main.main()
        001:  4: 5 | line                | var line string
        == uses ==
        000:  4:13 | os                  | package os
        001:  4:16 | Stdin               | var os.Stdin *os.File
        002:  5: 2 | println             | func fmt.Println(a ...any) (n int, err error)
        003:  5:10 | line                | var line string
--- PASS: TestFileEnumLines (1.21s)
=== RUN   TestLambdaExpr
2025/10/11 16:12:37.720315 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:38 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:38 ==> NewOverloadFunc NewRange
2025/10/11 16:12:38 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:38 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:38 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:38 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:38 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:38 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:38 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:38 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:38 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:38 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:38 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:38 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:38 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:38 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:38.930735 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000412540 {
}

2025/10/11 16:12:38 ==> Preload func Map
2025/10/11 16:12:38 ==> Preload func Map2
2025/10/11 16:12:38 ==> Preload func main
2025/10/11 16:12:38 ==> Load func Map
2025/10/11 16:12:38.930818 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:38.930837 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.930851 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.930872 [INFO] typesutil/gopinfo.go:215: ==> Type: &{25 <nil> float64} []float64
2025/10/11 16:12:38.930887 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c []float64
2025/10/11 16:12:38.930900 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:38.930911 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.930921 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.930932 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:38.930942 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.930949 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.930970 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 <nil> 0xc0001efc80 0xc0001efcb0} func(float64) float64
2025/10/11 16:12:38.930988 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t func(float64) float64
2025/10/11 16:12:38.931008 [INFO] typesutil/gopinfo.go:251: ==> Def: Map func main.Map(c []float64, t func(float64) float64)
2025/10/11 16:12:38 NewFunc Map func(c []float64, t func(float64) float64)
2025/10/11 16:12:38.931047 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Map scope 0xc000412780 {
.  var c []float64
.  var t func(float64) float64
}

2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 ==> Load func Map2
2025/10/11 16:12:38.931082 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:38.931095 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.931105 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.931117 [INFO] typesutil/gopinfo.go:215: ==> Type: &{86 <nil> float64} []float64
2025/10/11 16:12:38.931129 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c []float64
2025/10/11 16:12:38.931141 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:38.931151 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.931165 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.931178 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:38.931189 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.931199 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.931209 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:38.931219 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.931227 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:38.931242 [INFO] typesutil/gopinfo.go:215: ==> Type: &{99 <nil> 0xc0001efe30 0xc0001efe60} func(float64) (float64, float64)
2025/10/11 16:12:38.931254 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t func(float64) (float64, float64)
2025/10/11 16:12:38.931269 [INFO] typesutil/gopinfo.go:251: ==> Def: Map2 func main.Map2(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:38 NewFunc Map2 func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:38.931306 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Map2 scope 0xc000412a20 {
.  var c []float64
.  var t func(float64) (float64, float64)
}

2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 ==> Load func main
2025/10/11 16:12:38.931344 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:38 NewFunc main func()
2025/10/11 16:12:38 Val Map func(c []float64, t func(float64) float64)
2025/10/11 16:12:38.931382 [INFO] typesutil/gopinfo.go:265: ==> Use: Map func main.Map(c []float64, t func(float64) float64)
2025/10/11 16:12:38.931395 [INFO] typesutil/gopinfo.go:215: ==> Type: Map func(c []float64, t func(float64) float64)
2025/10/11 16:12:38 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:38.931442 [INFO] typesutil/gopinfo.go:215: ==> Type: &{151 FLOAT 1.2 <nil>} untyped float
2025/10/11 16:12:38 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/10/11 16:12:38.931473 [INFO] typesutil/gopinfo.go:215: ==> Type: &{156 FLOAT 3.5 <nil>} untyped float
2025/10/11 16:12:38 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:38.931500 [INFO] typesutil/gopinfo.go:215: ==> Type: &{161 INT 6 <nil>} untyped int
2025/10/11 16:12:38 SliceLit []float64 3 false
2025/10/11 16:12:38.931536 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/10/11 16:12:38 NewClosure func(x float64) float64
2025/10/11 16:12:38.931566 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/10/11 16:12:38 Val x float64
2025/10/11 16:12:38.931589 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:38.931601 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:38 Val x float64
2025/10/11 16:12:38.931619 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:38.931631 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:38 BinaryOp *
2025/10/11 16:12:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:38.931711 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 172 * x} float64
2025/10/11 16:12:38.931726 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000412c60 {
.  var x float64
}

2025/10/11 16:12:38 Return 1
2025/10/11 16:12:38 ==> MatchType float64, float64
2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 Call 2 0 // func(c []float64, t func(float64) float64)
2025/10/11 16:12:38 ==> MatchFuncCall func(c []float64, t func(float64) float64) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType []float64, []float64
2025/10/11 16:12:38 ==> MatchType func(x float64) float64, func(float64) float64
2025/10/11 16:12:38.931821 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Map 149 [0xc0003ae0c0 0xc00033caf0] 0 [] 175 0} ()
2025/10/11 16:12:38 Val Map2 func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:38.931853 [INFO] typesutil/gopinfo.go:265: ==> Use: Map2 func main.Map2(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:38.931866 [INFO] typesutil/gopinfo.go:215: ==> Type: Map2 func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:38 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:38.931895 [INFO] typesutil/gopinfo.go:215: ==> Type: &{183 FLOAT 1.2 <nil>} untyped float
2025/10/11 16:12:38 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/10/11 16:12:38.931918 [INFO] typesutil/gopinfo.go:215: ==> Type: &{188 FLOAT 3.5 <nil>} untyped float
2025/10/11 16:12:38 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:38.931937 [INFO] typesutil/gopinfo.go:215: ==> Type: &{193 INT 6 <nil>} untyped int
2025/10/11 16:12:38 SliceLit []float64 3 false
2025/10/11 16:12:38.931958 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/10/11 16:12:38 NewClosure func(x float64) (float64, float64)
2025/10/11 16:12:38.931980 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/10/11 16:12:38 Val x float64
2025/10/11 16:12:38.931996 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:38.932007 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:38 Val x float64
2025/10/11 16:12:38.932023 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:38.932052 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:38 BinaryOp *
2025/10/11 16:12:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:38.932110 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 205 * x} float64
2025/10/11 16:12:38 Val x float64
2025/10/11 16:12:38.932133 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:38.932145 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:38 Val x float64
2025/10/11 16:12:38.932160 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:38.932174 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:38 BinaryOp +
2025/10/11 16:12:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:38 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:38.932230 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 212 + x} float64
2025/10/11 16:12:38.932251 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000412fc0 {
.  var x float64
}

2025/10/11 16:12:38 Return 2
2025/10/11 16:12:38 ==> MatchType float64, float64
2025/10/11 16:12:38 ==> MatchType float64, float64
2025/10/11 16:12:38 End // Func
2025/10/11 16:12:38 Call 2 0 // func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:38 ==> MatchFuncCall func(c []float64, t func(float64) (float64, float64)) args: 2 flags: 0
2025/10/11 16:12:38 ==> MatchType []float64, []float64
2025/10/11 16:12:38 ==> MatchType func(x float64) (float64, float64), func(float64) (float64, float64)
2025/10/11 16:12:38.932345 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Map2 181 [0xc0003ae1b0 0xc00033cb40] 0 [] 216 0} ()
2025/10/11 16:12:38.932380 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000412ae0 {
}

2025/10/11 16:12:38 End // Func
    info_test.go:190: == types ==
        000:  2:12 | []float64           *ast.ArrayType                 | type    : []float64 | type
        001:  2:14 | float64             *ast.Ident                     | type    : float64 | type
        002:  2:25 | func(float64) float64 *ast.FuncType                  | type    : func(float64) float64 | type
        003:  2:30 | float64             *ast.Ident                     | type    : float64 | type
        004:  2:39 | float64             *ast.Ident                     | type    : float64 | type
        005:  6:13 | []float64           *ast.ArrayType                 | type    : []float64 | type
        006:  6:15 | float64             *ast.Ident                     | type    : float64 | type
        007:  6:26 | func(float64) (float64, float64) *ast.FuncType                  | type    : func(float64) (float64, float64) | type
        008:  6:31 | float64             *ast.Ident                     | type    : float64 | type
        009:  6:41 | float64             *ast.Ident                     | type    : float64 | type
        010:  6:50 | float64             *ast.Ident                     | type    : float64 | type
        011: 10: 1 | Map                 *ast.Ident                     | value   : func(c []float64, t func(float64) float64) | value
        012: 10: 1 | Map([1.2, 3.5, 6], x => x * x) *ast.CallExpr                  | void    : () | no value
        013: 10: 6 | 1.2                 *ast.BasicLit                  | value   : untyped float = 1.2 | constant
        014: 10:11 | 3.5                 *ast.BasicLit                  | value   : untyped float = 3.5 | constant
        015: 10:16 | 6                   *ast.BasicLit                  | value   : untyped int = 6 | constant
        016: 10:25 | x                   *ast.Ident                     | var     : float64 | variable
        017: 10:25 | x * x               *ast.BinaryExpr                | value   : float64 | value
        018: 10:29 | x                   *ast.Ident                     | var     : float64 | variable
        019: 11: 1 | Map2                *ast.Ident                     | value   : func(c []float64, t func(float64) (float64, float64)) | value
        020: 11: 1 | Map2([1.2, 3.5, 6], x => (x * x, x + x)) *ast.CallExpr                  | void    : () | no value
        021: 11: 7 | 1.2                 *ast.BasicLit                  | value   : untyped float = 1.2 | constant
        022: 11:12 | 3.5                 *ast.BasicLit                  | value   : untyped float = 3.5 | constant
        023: 11:17 | 6                   *ast.BasicLit                  | value   : untyped int = 6 | constant
        024: 11:27 | x                   *ast.Ident                     | var     : float64 | variable
        025: 11:27 | x * x               *ast.BinaryExpr                | value   : float64 | value
        026: 11:31 | x                   *ast.Ident                     | var     : float64 | variable
        027: 11:34 | x                   *ast.Ident                     | var     : float64 | variable
        028: 11:34 | x + x               *ast.BinaryExpr                | value   : float64 | value
        029: 11:38 | x                   *ast.Ident                     | var     : float64 | variable
        == defs ==
        000:  2: 6 | Map                 | func main.Map(c []float64, t func(float64) float64)
        001:  2:10 | c                   | var c []float64
        002:  2:23 | t                   | var t func(float64) float64
        003:  6: 6 | Map2                | func main.Map2(c []float64, t func(float64) (float64, float64))
        004:  6:11 | c                   | var c []float64
        005:  6:24 | t                   | var t func(float64) (float64, float64)
        006: 10: 1 | main                | func main.main()
        007: 10:20 | x                   | var x float64
        008: 11:21 | x                   | var x float64
        == uses ==
        000:  2:14 | float64             | type float64
        001:  2:30 | float64             | type float64
        002:  2:39 | float64             | type float64
        003:  6:15 | float64             | type float64
        004:  6:31 | float64             | type float64
        005:  6:41 | float64             | type float64
        006:  6:50 | float64             | type float64
        007: 10: 1 | Map                 | func main.Map(c []float64, t func(float64) float64)
        008: 10:25 | x                   | var x float64
        009: 10:29 | x                   | var x float64
        010: 11: 1 | Map2                | func main.Map2(c []float64, t func(float64) (float64, float64))
        011: 11:27 | x                   | var x float64
        012: 11:31 | x                   | var x float64
        013: 11:34 | x                   | var x float64
        014: 11:38 | x                   | var x float64
--- PASS: TestLambdaExpr (1.21s)
=== RUN   TestLambdaExpr2
2025/10/11 16:12:38.933716 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:39 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:39 ==> NewOverloadFunc NewRange
2025/10/11 16:12:39 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:39 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:39 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:39 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:39 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:39 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:39 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:39 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:39 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:39 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:39 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:39 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:39 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:39 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:40.238997 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00051e000 {
}

2025/10/11 16:12:40 ==> Preload func Map
2025/10/11 16:12:40 ==> Preload func Map2
2025/10/11 16:12:40 ==> Preload func main
2025/10/11 16:12:40 ==> Load func Map
2025/10/11 16:12:40.239078 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:40.239101 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239114 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239137 [INFO] typesutil/gopinfo.go:215: ==> Type: &{25 <nil> float64} []float64
2025/10/11 16:12:40.239150 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c []float64
2025/10/11 16:12:40.239165 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:40.239178 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239191 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239203 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:40.239213 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239222 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239243 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 <nil> 0xc00044ee10 0xc00044ee40} func(float64) float64
2025/10/11 16:12:40.239269 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t func(float64) float64
2025/10/11 16:12:40.239291 [INFO] typesutil/gopinfo.go:251: ==> Def: Map func main.Map(c []float64, t func(float64) float64)
2025/10/11 16:12:40 NewFunc Map func(c []float64, t func(float64) float64)
2025/10/11 16:12:40.239338 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Map scope 0xc00051e240 {
.  var c []float64
.  var t func(float64) float64
}

2025/10/11 16:12:40 End // Func
2025/10/11 16:12:40 ==> Load func Map2
2025/10/11 16:12:40.239378 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:40.239390 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239401 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239416 [INFO] typesutil/gopinfo.go:215: ==> Type: &{86 <nil> float64} []float64
2025/10/11 16:12:40.239430 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c []float64
2025/10/11 16:12:40.239444 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:40.239454 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239468 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239481 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:40.239492 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239502 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239514 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:12:40.239524 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239533 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:12:40.239553 [INFO] typesutil/gopinfo.go:215: ==> Type: &{99 <nil> 0xc00044efc0 0xc00044eff0} func(float64) (float64, float64)
2025/10/11 16:12:40.239566 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t func(float64) (float64, float64)
2025/10/11 16:12:40.239583 [INFO] typesutil/gopinfo.go:251: ==> Def: Map2 func main.Map2(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:40 NewFunc Map2 func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:40.239620 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Map2 scope 0xc00051e4e0 {
.  var c []float64
.  var t func(float64) (float64, float64)
}

2025/10/11 16:12:40 End // Func
2025/10/11 16:12:40 ==> Load func main
2025/10/11 16:12:40.239666 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:40 NewFunc main func()
2025/10/11 16:12:40 Val Map func(c []float64, t func(float64) float64)
2025/10/11 16:12:40.239708 [INFO] typesutil/gopinfo.go:265: ==> Use: Map func main.Map(c []float64, t func(float64) float64)
2025/10/11 16:12:40.239722 [INFO] typesutil/gopinfo.go:215: ==> Type: Map func(c []float64, t func(float64) float64)
2025/10/11 16:12:40 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:40.239772 [INFO] typesutil/gopinfo.go:215: ==> Type: &{151 FLOAT 1.2 <nil>} untyped float
2025/10/11 16:12:40 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/10/11 16:12:40.239805 [INFO] typesutil/gopinfo.go:215: ==> Type: &{156 FLOAT 3.5 <nil>} untyped float
2025/10/11 16:12:40 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:40.239835 [INFO] typesutil/gopinfo.go:215: ==> Type: &{161 INT 6 <nil>} untyped int
2025/10/11 16:12:40 SliceLit []float64 3 false
2025/10/11 16:12:40.239878 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/10/11 16:12:40 NewClosure func(x float64) float64
2025/10/11 16:12:40.239904 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/10/11 16:12:40 Val x float64
2025/10/11 16:12:40.239930 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:40.239943 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:40 Val x float64
2025/10/11 16:12:40.239960 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:40.239971 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:40 BinaryOp *
2025/10/11 16:12:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:40 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:40 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:40.240096 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 182 * x} float64
2025/10/11 16:12:40 Return 1
2025/10/11 16:12:40 ==> MatchType float64, float64
2025/10/11 16:12:40.240133 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00051e720 {
.  var x float64
}

2025/10/11 16:12:40 End // Func
2025/10/11 16:12:40 Call 2 0 // func(c []float64, t func(float64) float64)
2025/10/11 16:12:40 ==> MatchFuncCall func(c []float64, t func(float64) float64) args: 2 flags: 0
2025/10/11 16:12:40 ==> MatchType []float64, []float64
2025/10/11 16:12:40 ==> MatchType func(x float64) float64, func(float64) float64
2025/10/11 16:12:40.240219 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Map 149 [0xc00044f1d0 0xc0004720c0] 0 [] 187 0} ()
2025/10/11 16:12:40 Val Map2 func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:40.240250 [INFO] typesutil/gopinfo.go:265: ==> Use: Map2 func main.Map2(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:40.240265 [INFO] typesutil/gopinfo.go:215: ==> Type: Map2 func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:40 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/10/11 16:12:40.240297 [INFO] typesutil/gopinfo.go:215: ==> Type: &{195 FLOAT 1.2 <nil>} untyped float
2025/10/11 16:12:40 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/10/11 16:12:40.240329 [INFO] typesutil/gopinfo.go:215: ==> Type: &{200 FLOAT 3.5 <nil>} untyped float
2025/10/11 16:12:40 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:12:40.240352 [INFO] typesutil/gopinfo.go:215: ==> Type: &{205 INT 6 <nil>} untyped int
2025/10/11 16:12:40 SliceLit []float64 3 false
2025/10/11 16:12:40.240374 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/10/11 16:12:40 NewClosure func(x float64) (float64, float64)
2025/10/11 16:12:40.240414 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/10/11 16:12:40 Val x float64
2025/10/11 16:12:40.240428 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:40.240434 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:40 Val x float64
2025/10/11 16:12:40.240445 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:40.240452 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:40 BinaryOp *
2025/10/11 16:12:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:40 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:40 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:40.240486 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 226 * x} float64
2025/10/11 16:12:40 Val x float64
2025/10/11 16:12:40.240495 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:40.240500 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:40 Val x float64
2025/10/11 16:12:40.240510 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:12:40.240516 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:12:40 BinaryOp +
2025/10/11 16:12:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:40 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:40 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:12:40.240547 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 233 + x} float64
2025/10/11 16:12:40 Return 2
2025/10/11 16:12:40 ==> MatchType float64, float64
2025/10/11 16:12:40 ==> MatchType float64, float64
2025/10/11 16:12:40.240574 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00051ea80 {
.  var x float64
}

2025/10/11 16:12:40 End // Func
2025/10/11 16:12:40 Call 2 0 // func(c []float64, t func(float64) (float64, float64))
2025/10/11 16:12:40 ==> MatchFuncCall func(c []float64, t func(float64) (float64, float64)) args: 2 flags: 0
2025/10/11 16:12:40 ==> MatchType []float64, []float64
2025/10/11 16:12:40 ==> MatchType func(x float64) (float64, float64), func(float64) (float64, float64)
2025/10/11 16:12:40.241047 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Map2 193 [0xc00044f320 0xc000472100] 0 [] 238 0} ()
2025/10/11 16:12:40.241063 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc00051e5a0 {
}

2025/10/11 16:12:40 End // Func
    info_test.go:190: == types ==
        000:  2:12 | []float64           *ast.ArrayType                 | type    : []float64 | type
        001:  2:14 | float64             *ast.Ident                     | type    : float64 | type
        002:  2:25 | func(float64) float64 *ast.FuncType                  | type    : func(float64) float64 | type
        003:  2:30 | float64             *ast.Ident                     | type    : float64 | type
        004:  2:39 | float64             *ast.Ident                     | type    : float64 | type
        005:  6:13 | []float64           *ast.ArrayType                 | type    : []float64 | type
        006:  6:15 | float64             *ast.Ident                     | type    : float64 | type
        007:  6:26 | func(float64) (float64, float64) *ast.FuncType                  | type    : func(float64) (float64, float64) | type
        008:  6:31 | float64             *ast.Ident                     | type    : float64 | type
        009:  6:41 | float64             *ast.Ident                     | type    : float64 | type
        010:  6:50 | float64             *ast.Ident                     | type    : float64 | type
        011: 10: 1 | Map                 *ast.Ident                     | value   : func(c []float64, t func(float64) float64) | value
        012: 10: 1 | Map([1.2, 3.5, 6], x => {
        	return x * x
        }) *ast.CallExpr                  | void    : () | no value
        013: 10: 6 | 1.2                 *ast.BasicLit                  | value   : untyped float = 1.2 | constant
        014: 10:11 | 3.5                 *ast.BasicLit                  | value   : untyped float = 3.5 | constant
        015: 10:16 | 6                   *ast.BasicLit                  | value   : untyped int = 6 | constant
        016: 11: 9 | x                   *ast.Ident                     | var     : float64 | variable
        017: 11: 9 | x * x               *ast.BinaryExpr                | value   : float64 | value
        018: 11:13 | x                   *ast.Ident                     | var     : float64 | variable
        019: 13: 1 | Map2                *ast.Ident                     | value   : func(c []float64, t func(float64) (float64, float64)) | value
        020: 13: 1 | Map2([1.2, 3.5, 6], x => {
        	return x * x, x + x
        }) *ast.CallExpr                  | void    : () | no value
        021: 13: 7 | 1.2                 *ast.BasicLit                  | value   : untyped float = 1.2 | constant
        022: 13:12 | 3.5                 *ast.BasicLit                  | value   : untyped float = 3.5 | constant
        023: 13:17 | 6                   *ast.BasicLit                  | value   : untyped int = 6 | constant
        024: 14: 9 | x                   *ast.Ident                     | var     : float64 | variable
        025: 14: 9 | x * x               *ast.BinaryExpr                | value   : float64 | value
        026: 14:13 | x                   *ast.Ident                     | var     : float64 | variable
        027: 14:16 | x                   *ast.Ident                     | var     : float64 | variable
        028: 14:16 | x + x               *ast.BinaryExpr                | value   : float64 | value
        029: 14:20 | x                   *ast.Ident                     | var     : float64 | variable
        == defs ==
        000:  2: 6 | Map                 | func main.Map(c []float64, t func(float64) float64)
        001:  2:10 | c                   | var c []float64
        002:  2:23 | t                   | var t func(float64) float64
        003:  6: 6 | Map2                | func main.Map2(c []float64, t func(float64) (float64, float64))
        004:  6:11 | c                   | var c []float64
        005:  6:24 | t                   | var t func(float64) (float64, float64)
        006: 10: 1 | main                | func main.main()
        007: 10:20 | x                   | var x float64
        008: 13:21 | x                   | var x float64
        == uses ==
        000:  2:14 | float64             | type float64
        001:  2:30 | float64             | type float64
        002:  2:39 | float64             | type float64
        003:  6:15 | float64             | type float64
        004:  6:31 | float64             | type float64
        005:  6:41 | float64             | type float64
        006:  6:50 | float64             | type float64
        007: 10: 1 | Map                 | func main.Map(c []float64, t func(float64) float64)
        008: 11: 9 | x                   | var x float64
        009: 11:13 | x                   | var x float64
        010: 13: 1 | Map2                | func main.Map2(c []float64, t func(float64) (float64, float64))
        011: 14: 9 | x                   | var x float64
        012: 14:13 | x                   | var x float64
        013: 14:16 | x                   | var x float64
        014: 14:20 | x                   | var x float64
--- PASS: TestLambdaExpr2 (1.31s)
=== RUN   TestMixedOverload1
2025/10/11 16:12:40.244183 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/10/11 16:12:40 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:40 ==> NewOverloadFunc NewRange
2025/10/11 16:12:41 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:41 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:41 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:41 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:41 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:41 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:41 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:41 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:41 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:41 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:41 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:41 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:41 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:41 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:41.468998 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00046cf00 {
}

2025/10/11 16:12:41 ==> Preload type Mesh
2025/10/11 16:12:41 ==> Preload method Mesh.Name
2025/10/11 16:12:41 ==> Preload var [m1]
2025/10/11 16:12:41 ==> Preload var [m2]
2025/10/11 16:12:41 ==> Preload func main
2025/10/11 16:12:41 ==> Preload type Mesher
2025/10/11 16:12:41 ==> Preload type N
2025/10/11 16:12:41 ==> Preload method N.OnKey__0
2025/10/11 16:12:41 ==> Preload method N.OnKey__1
2025/10/11 16:12:41 ==> Preload method N.OnKey__2
2025/10/11 16:12:41 ==> Preload method N.OnKey__3
2025/10/11 16:12:41 ==> Preload method N.OnKey__4
2025/10/11 16:12:41 ==> Preload method N.OnKey__5
2025/10/11 16:12:41 ==> Preload method N.OnKey__6
2025/10/11 16:12:41 ==> Preload method N.OnKey__7
2025/10/11 16:12:41 ==> Preload method N.OnKey__8
2025/10/11 16:12:41 ==> Preload func OnKey__0
2025/10/11 16:12:41 ==> Preload func OnKey__1
2025/10/11 16:12:41 ==> Preload func OnKey__2
2025/10/11 16:12:41 ==> Preload func OnKey__3
2025/10/11 16:12:41 ==> Preload func OnKey__4
2025/10/11 16:12:41 ==> Preload func OnKey__5
2025/10/11 16:12:41 ==> Preload func OnKey__6
2025/10/11 16:12:41 ==> Preload func OnKey__7
2025/10/11 16:12:41 ==> Preload func OnKey__8
2025/10/11 16:12:41 ==> Preload func OnKey__9
2025/10/11 16:12:41 ==> Preload func OnKey__a
2025/10/11 16:12:41 ==> Load func OnKey__1
2025/10/11 16:12:41 ==> Load func OnKey__2
2025/10/11 16:12:41 ==> Load func OnKey__3
2025/10/11 16:12:41 ==> Load func OnKey__9
2025/10/11 16:12:41 ==> Load func OnKey__a
2025/10/11 16:12:41 ==> Load > NewType Mesher
2025/10/11 16:12:41 ==> Load > InitType Mesher
2025/10/11 16:12:41 ==> Load > NewType N
2025/10/11 16:12:41 ==> Load > InitType N
2025/10/11 16:12:41 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:41 ==> Load method *main.N.OnKey__0
2025/10/11 16:12:41 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:41 ==> Load method *main.N.OnKey__1
2025/10/11 16:12:41 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:41 ==> Load method *main.N.OnKey__2
2025/10/11 16:12:41 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:41 ==> Load method *main.N.OnKey__3
2025/10/11 16:12:41 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:41 ==> Load method *main.N.OnKey__4
2025/10/11 16:12:41 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:41 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:41 ==> Load method *main.N.OnKey__5
2025/10/11 16:12:41 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:41 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:41 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:41 ==> Load method *main.N.OnKey__6
2025/10/11 16:12:41 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:41 ==> Load method *main.N.OnKey__7
2025/10/11 16:12:41 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:41 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:41 ==> Load method *main.N.OnKey__8
2025/10/11 16:12:41 ==> Load func OnKey__4
2025/10/11 16:12:41 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:41 ==> Load func OnKey__5
2025/10/11 16:12:41 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:41 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:41 ==> Load func OnKey__0
2025/10/11 16:12:41 ==> Load func OnKey__6
2025/10/11 16:12:41 ==> Load func OnKey__7
2025/10/11 16:12:41 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:41 ==> Load func OnKey__8
2025/10/11 16:12:41 ==> NewOverloadMethod N OnKey
2025/10/11 16:12:41 ==> NewOverloadFunc OnKey
2025/10/11 16:12:41 ==> Load > NewType Mesh
2025/10/11 16:12:41 NewType Mesh
2025/10/11 16:12:41 ==> Load > InitType Mesh
2025/10/11 16:12:41.469639 [INFO] typesutil/gopinfo.go:215: ==> Type: &{12 0xc0002399b0 false} struct{}
2025/10/11 16:12:41 InitType Mesh struct{}
2025/10/11 16:12:41.469659 [INFO] typesutil/gopinfo.go:251: ==> Def: Mesh type main.Mesh struct{}
2025/10/11 16:12:41 ==> LookupParent Mesh => type main.Mesh struct{}
2025/10/11 16:12:41.469677 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/10/11 16:12:41.469687 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:41.469697 [INFO] typesutil/gopinfo.go:251: ==> Def: p var p *main.Mesh
2025/10/11 16:12:41 ==> Load method *main.Mesh.Name
2025/10/11 16:12:41.469714 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:41.469723 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:41.469730 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:41.469744 [INFO] typesutil/gopinfo.go:251: ==> Def: Name func (*main.Mesh).Name() string
2025/10/11 16:12:41 ==> Load var <nil> [m1]
2025/10/11 16:12:41 NewVarDefs
2025/10/11 16:12:41 NewVar [m1]
2025/10/11 16:12:41 ==> LookupParent Mesh => type main.Mesh struct{}
2025/10/11 16:12:41.469782 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/10/11 16:12:41.469789 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:41.469798 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:41 StructLit main.Mesh 0 false
2025/10/11 16:12:41.469814 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:41.469828 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mesh 91 [] 92 false} main.Mesh
2025/10/11 16:12:41 UnaryOp & flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:41.469860 [INFO] typesutil/gopinfo.go:215: ==> Type: &{86 & 0xc000179f40} *main.Mesh
2025/10/11 16:12:41 EndInit 1
2025/10/11 16:12:41.469876 [INFO] typesutil/gopinfo.go:251: ==> Def: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41 ==> Load var <nil> [m2]
2025/10/11 16:12:41 NewVarDefs
2025/10/11 16:12:41 NewVar [m2]
2025/10/11 16:12:41 ==> LookupParent Mesh => type main.Mesh struct{}
2025/10/11 16:12:41.469904 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/10/11 16:12:41.469912 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:41.469922 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:41 StructLit main.Mesh 0 false
2025/10/11 16:12:41.469935 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:41.469944 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mesh 105 [] 106 false} main.Mesh
2025/10/11 16:12:41 UnaryOp & flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:41.469969 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 & 0xc0003fc800} *main.Mesh
2025/10/11 16:12:41 EndInit 1
2025/10/11 16:12:41.469982 [INFO] typesutil/gopinfo.go:251: ==> Def: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41 ==> Load func main
2025/10/11 16:12:41.470000 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:41 NewFunc main func()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.470031 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.470038 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.470050 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:41.470076 [INFO] typesutil/gopinfo.go:215: ==> Type: &{117 STRING "hello" <nil>} untyped string
2025/10/11 16:12:41 NewClosure func()
2025/10/11 16:12:41.470094 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000511860 {
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:41 ==> MatchType func(), func()
2025/10/11 16:12:41.470154 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__0(a string, fn func())
2025/10/11 16:12:41.470164 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a string, fn func())
2025/10/11 16:12:41.470178 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc000239bc0 0xc0003fcc80] 0 [] 0 132} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.470195 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.470204 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.470212 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:41.470232 [INFO] typesutil/gopinfo.go:215: ==> Type: &{139 STRING "hello" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:41.470252 [INFO] typesutil/gopinfo.go:215: ==> Type: &{139 STRING "hello" <nil>} untyped string
2025/10/11 16:12:41.470260 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41 NewClosure func(key string)
2025/10/11 16:12:41.470276 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41.470287 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0005119e0 {
.  var key string
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:41 ==> MatchType func(key string), func()
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:41 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:41.470349 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__1(a string, fn func(key string))
2025/10/11 16:12:41.470356 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a string, fn func(key string))
2025/10/11 16:12:41.470378 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc000239c50 0xc0003fcd40] 0 [] 0 158} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.470397 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.470403 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.470411 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:41.470426 [INFO] typesutil/gopinfo.go:215: ==> Type: &{166 STRING "1" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 NewClosure func()
2025/10/11 16:12:41.470444 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000511b00 {
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, []string
2025/10/11 16:12:41 ==> MatchType func(), func()
2025/10/11 16:12:41.470505 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__2(a []string, fn func())
2025/10/11 16:12:41.470513 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []string, fn func())
2025/10/11 16:12:41.470526 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc000239d10 0xc0003fd800] 0 [] 0 178} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.470540 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.470546 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.470554 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:41.470569 [INFO] typesutil/gopinfo.go:215: ==> Type: &{186 STRING "2" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:41.470587 [INFO] typesutil/gopinfo.go:215: ==> Type: &{186 STRING "2" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41.470597 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41 NewClosure func(key string)
2025/10/11 16:12:41.470610 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41.470625 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000511ec0 {
.  var key string
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, []string
2025/10/11 16:12:41 ==> MatchType func(key string), func()
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, []string
2025/10/11 16:12:41 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:41.470701 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__3(a []string, fn func(key string))
2025/10/11 16:12:41.470711 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []string, fn func(key string))
2025/10/11 16:12:41.470724 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc000239dd0 0xc0003fd880] 0 [] 0 202} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.470737 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.470742 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.470749 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.470764 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.470776 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.470787 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.470793 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit <nil> 2 false
2025/10/11 16:12:41 NewClosure func()
2025/10/11 16:12:41.470811 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0002bb860 {
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, []main.Mesher
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, []main.Mesher
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, int
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.470977 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.470984 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.470995 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.471001 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit <nil> 2 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.471019 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.471025 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.471036 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.471041 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit []string 2 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.471081 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.471089 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.471102 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.471108 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit []string 2 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.471134 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.471140 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.471158 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.471166 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit []main.Mesher 2 false
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 NewClosure func()
2025/10/11 16:12:41.471201 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0002bb9e0 {
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, []main.Mesher
2025/10/11 16:12:41 ==> MatchType func(), func()
2025/10/11 16:12:41.471304 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__4(a []main.Mesher, fn func())
2025/10/11 16:12:41.471313 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []main.Mesher, fn func())
2025/10/11 16:12:41.471327 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc000239e60 0xc0003fd8c0] 0 [] 0 225} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.471343 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.471348 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.471356 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.471371 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.471379 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.471391 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.471400 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit <nil> 2 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.471427 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.471435 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.471449 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.471456 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit <nil> 2 false
2025/10/11 16:12:41.471468 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41 NewClosure func(key string)
2025/10/11 16:12:41.471487 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41.471497 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0002bc6c0 {
.  var key string
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, []main.Mesher
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, []main.Mesher
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, int
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.471688 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.471744 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.471759 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.471768 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit []string 2 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.471810 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.471818 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.471832 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.471840 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit []string 2 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.471872 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.471880 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.471892 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.471898 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit []main.Mesher 2 false
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.471933 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.471953 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.472690 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.472754 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit []main.Mesher 2 false
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41.472917 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key main.Mesher
2025/10/11 16:12:41 NewClosure func(key main.Mesher)
2025/10/11 16:12:41.473006 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key main.Mesher
2025/10/11 16:12:41.473057 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0002dd0e0 {
.  var key main.Mesher
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, []main.Mesher
2025/10/11 16:12:41 ==> MatchType func(key main.Mesher), func()
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType []main.Mesher, []main.Mesher
2025/10/11 16:12:41 ==> MatchType func(key main.Mesher), func(key main.Mesher)
2025/10/11 16:12:41.474081 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__5(a []main.Mesher, fn func(key main.Mesher))
2025/10/11 16:12:41.474102 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []main.Mesher, fn func(key main.Mesher))
2025/10/11 16:12:41.474138 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc000239ef0 0xc0003fd900] 0 [] 0 252} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.474171 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.474183 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.474194 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.474224 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.474247 [INFO] typesutil/gopinfo.go:215: ==> Type: &{267 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.474275 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.474296 [INFO] typesutil/gopinfo.go:215: ==> Type: &{267 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.474318 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.474342 [INFO] typesutil/gopinfo.go:215: ==> Type: &{267 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.474365 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.474388 [INFO] typesutil/gopinfo.go:215: ==> Type: &{267 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.474408 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []main.Mesher 1 false
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.474454 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []main.Mesher 1 false
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.474496 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.474522 [INFO] typesutil/gopinfo.go:215: ==> Type: &{267 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41.474539 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41 NewClosure func(key string)
2025/10/11 16:12:41.474559 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41.474579 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00021c300 {
.  var key string
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, []string
2025/10/11 16:12:41 ==> MatchType []string, []string
2025/10/11 16:12:41 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:41.474742 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__6(a []string, b []string, fn func(key string))
2025/10/11 16:12:41.474755 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []string, b []string, fn func(key string))
2025/10/11 16:12:41.474771 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0001ee090 0xc0001ee120 0xc0003fd940] 0 [] 0 283} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.474790 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.474798 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.474807 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.474825 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.474850 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.474863 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.474878 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.474887 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit <nil> 2 false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.474914 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.474935 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.474943 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.474959 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.474968 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit <nil> 2 false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.474990 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.475016 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.475023 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.475038 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.475045 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit <nil> 2 false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475067 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.475087 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.475094 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.475108 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.475116 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit <nil> 2 false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475136 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []main.Mesher 1 false
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475179 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []main.Mesher 1 false
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475215 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.475245 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.475253 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.475271 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.475278 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit []string 2 false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475307 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41 Val m1 *main.Mesh
2025/10/11 16:12:41.475331 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:41.475339 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:41 Val m2 *main.Mesh
2025/10/11 16:12:41.475354 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:41.475361 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:41 SliceLit []main.Mesher 2 false
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41.475396 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41 NewClosure func(key string)
2025/10/11 16:12:41.475414 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41.475426 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00021c4e0 {
.  var key string
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, []string
2025/10/11 16:12:41 ==> MatchType []main.Mesher, []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, []string
2025/10/11 16:12:41 ==> MatchType []main.Mesher, []main.Mesher
2025/10/11 16:12:41 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:41.475612 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__7(a []string, b []main.Mesher, fn func(key string))
2025/10/11 16:12:41.475623 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []string, b []main.Mesher, fn func(key string))
2025/10/11 16:12:41.475639 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0001ee3c0 0xc0001ee420 0xc0003fd9c0] 0 [] 0 317} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.475659 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.475666 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.475675 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475693 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val nil untyped nil
2025/10/11 16:12:41.475716 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:41.475725 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475744 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit <nil> 1 false
2025/10/11 16:12:41 Val nil untyped nil
2025/10/11 16:12:41.475762 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:41.475770 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475787 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41 Val nil untyped nil
2025/10/11 16:12:41.475808 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:41.475815 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475833 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41 Val nil untyped nil
2025/10/11 16:12:41.475853 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:41.475861 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475877 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []main.Mesher 1 false
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475917 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []main.Mesher 1 false
2025/10/11 16:12:41 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:41 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.475960 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 SliceLit []string 1 false
2025/10/11 16:12:41 Val nil untyped nil
2025/10/11 16:12:41.475977 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:41.475985 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:41.475993 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41 NewClosure func(key string)
2025/10/11 16:12:41.476078 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:41.476097 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00021c6c0 {
.  var key string
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:41 ==> MatchType []string, []string
2025/10/11 16:12:41 ==> MatchType untyped nil, []string
2025/10/11 16:12:41 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:41.476253 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__6(a []string, b []string, fn func(key string))
2025/10/11 16:12:41.476266 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []string, b []string, fn func(key string))
2025/10/11 16:12:41.476283 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0001ee630 nil 0xc0003fda40] 0 [] 0 346} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.476302 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.476308 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.476319 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:41.476340 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 INT 100 <nil>} untyped int
2025/10/11 16:12:41 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:41.476360 [INFO] typesutil/gopinfo.go:215: ==> Type: &{358 INT 200 <nil>} untyped int
2025/10/11 16:12:41 NewClosure func() int
2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), []main.Mesher
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), []main.Mesher
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), int
2025/10/11 16:12:41 ==> MatchType func() int, int
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), string
2025/10/11 16:12:41 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:41.476576 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 INT 100 <nil>} untyped int
2025/10/11 16:12:41 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:41.476592 [INFO] typesutil/gopinfo.go:215: ==> Type: &{358 INT 200 <nil>} untyped int
2025/10/11 16:12:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), []string
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), []main.Mesher
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), []main.Mesher
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped int (100), int
2025/10/11 16:12:41 ==> MatchType untyped int (200), int
2025/10/11 16:12:41.476753 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__8(x int, y int)
2025/10/11 16:12:41.476762 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(x int, y int)
2025/10/11 16:12:41.476776 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0001ee960 0xc0001ee990] 0 [] 0 361} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.476792 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.476800 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.476808 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.476826 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.476842 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 NewClosure func() string
2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.476875 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.476892 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.476909 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.476924 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 NewClosure func() string
2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.476956 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.476971 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.476988 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.477002 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 NewClosure func() string
2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.477035 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.477052 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.477068 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.477085 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.477106 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.477121 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.477142 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.477158 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.477173 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.477188 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/10/11 16:12:41.477197 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:12:41 NewClosure func(x int) int
2025/10/11 16:12:41.477212 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:12:41 Val x int
2025/10/11 16:12:41.477228 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:12:41.477238 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:12:41 Val x int
2025/10/11 16:12:41.477252 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:12:41.477261 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:12:41 BinaryOp *
2025/10/11 16:12:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:41 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:12:41.477314 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 385 * x} int
2025/10/11 16:12:41.477327 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00021cde0 {
.  var x int
}

2025/10/11 16:12:41 Return 1
2025/10/11 16:12:41 ==> MatchType int, int
2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41.477358 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:12:41 NewClosure func(x int) int
2025/10/11 16:12:41.477383 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:12:41 Val x int
2025/10/11 16:12:41.477398 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:12:41.477406 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:12:41 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:41.477423 [INFO] typesutil/gopinfo.go:215: ==> Type: &{409 INT 2 <nil>} untyped int
2025/10/11 16:12:41 BinaryOp *
2025/10/11 16:12:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:12:41 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:12:41 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/10/11 16:12:41.477468 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 407 * 0xc0001eeb10} int
2025/10/11 16:12:41 Return 1
2025/10/11 16:12:41 ==> MatchType int, int
2025/10/11 16:12:41.477494 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00021d0e0 {
.  var x int
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Call 4 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(x int, y int) args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 4 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:41 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:41 ==> MatchType func(x int) int, func(x int) int
2025/10/11 16:12:41 ==> MatchType func(x int) int, func(x int) int
2025/10/11 16:12:41.477722 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__9(a string, b string, fn ...func(x int) int)
2025/10/11 16:12:41.477732 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a string, b string, fn ...func(x int) int)
2025/10/11 16:12:41.477748 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0001ee9c0 0xc0001ee9f0 0xc000156b40 0xc0003fdb00] 0 [] 0 412} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.477764 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.477771 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.477789 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.477832 [INFO] typesutil/gopinfo.go:215: ==> Type: &{419 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.477850 [INFO] typesutil/gopinfo.go:215: ==> Type: &{424 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 NewClosure func() string
2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:41.477880 [INFO] typesutil/gopinfo.go:215: ==> Type: &{429 INT 1 <nil>} untyped int
2025/10/11 16:12:41 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:41.477894 [INFO] typesutil/gopinfo.go:215: ==> Type: &{432 INT 2 <nil>} untyped int
2025/10/11 16:12:41 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:41.477910 [INFO] typesutil/gopinfo.go:215: ==> Type: &{435 INT 3 <nil>} untyped int
2025/10/11 16:12:41 Call 5 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(x int, y int) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:41 ==> MatchType func() string, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, v ...int) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:41 ==> MatchType func() string, string
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.478143 [INFO] typesutil/gopinfo.go:215: ==> Type: &{419 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.478159 [INFO] typesutil/gopinfo.go:215: ==> Type: &{424 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:41.478173 [INFO] typesutil/gopinfo.go:215: ==> Type: &{429 INT 1 <nil>} untyped int
2025/10/11 16:12:41 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:41.478188 [INFO] typesutil/gopinfo.go:215: ==> Type: &{432 INT 2 <nil>} untyped int
2025/10/11 16:12:41 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:41.478202 [INFO] typesutil/gopinfo.go:215: ==> Type: &{435 INT 3 <nil>} untyped int
2025/10/11 16:12:41 Call 5 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(x int, y int) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:41 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:41 ==> MatchType untyped int (1), func(x int) int
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, v ...int) args: 5 flags: 0
2025/10/11 16:12:41 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:41 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:41 ==> MatchType untyped int (1), int
2025/10/11 16:12:41 ==> MatchType untyped int (2), int
2025/10/11 16:12:41 ==> MatchType untyped int (3), int
2025/10/11 16:12:41.478439 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__a(a string, b string, v ...int)
2025/10/11 16:12:41.478450 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a string, b string, v ...int)
2025/10/11 16:12:41.478466 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0001eec30 0xc0001eec60 0xc0001eec90 0xc0001eecc0 0xc0001eecf0] 0 [] 0 436} ()
2025/10/11 16:12:41 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.478484 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41.478490 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/10/11 16:12:41.478499 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.478517 [INFO] typesutil/gopinfo.go:215: ==> Type: &{443 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.478535 [INFO] typesutil/gopinfo.go:215: ==> Type: &{448 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 NewClosure func() string
2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:41.478563 [INFO] typesutil/gopinfo.go:215: ==> Type: &{454 INT 1 <nil>} untyped int
2025/10/11 16:12:41 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:41.478580 [INFO] typesutil/gopinfo.go:215: ==> Type: &{457 INT 2 <nil>} untyped int
2025/10/11 16:12:41 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:41.478594 [INFO] typesutil/gopinfo.go:215: ==> Type: &{460 INT 3 <nil>} untyped int
2025/10/11 16:12:41 SliceLit <nil> 3 false
2025/10/11 16:12:41 Call 3 1 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(x int, y int) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:41 ==> MatchType func() string, string
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, v ...int) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:41 ==> MatchType func() string, string
2025/10/11 16:12:41 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:41.478743 [INFO] typesutil/gopinfo.go:215: ==> Type: &{443 STRING "a" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:41.478758 [INFO] typesutil/gopinfo.go:215: ==> Type: &{448 STRING "b" <nil>} untyped string
2025/10/11 16:12:41 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:41.478773 [INFO] typesutil/gopinfo.go:215: ==> Type: &{454 INT 1 <nil>} untyped int
2025/10/11 16:12:41 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:41.478789 [INFO] typesutil/gopinfo.go:215: ==> Type: &{457 INT 2 <nil>} untyped int
2025/10/11 16:12:41 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:12:41.478803 [INFO] typesutil/gopinfo.go:215: ==> Type: &{460 INT 3 <nil>} untyped int
2025/10/11 16:12:41 SliceLit <nil> 3 false
2025/10/11 16:12:41 Call 3 1 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:41 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(x int, y int) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:41 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:41 ==> MatchType []int, []func(x int) int
2025/10/11 16:12:41 ==> MatchFuncCall func(a string, b string, v ...int) args: 3 flags: 1
2025/10/11 16:12:41 ==> MatchType untyped string ("a"), string
2025/10/11 16:12:41 ==> MatchType untyped string ("b"), string
2025/10/11 16:12:41 ==> MatchType []int, []int
2025/10/11 16:12:41.478967 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__a(a string, b string, v ...int)
2025/10/11 16:12:41.478976 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a string, b string, v ...int)
2025/10/11 16:12:41.478991 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 442 [0xc0001eed20 0xc0001eed50 0xc0001eee10] 462 [] 465 0} ()
2025/10/11 16:12:41.479003 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0005117a0 {
}

2025/10/11 16:12:41 End // Func
2025/10/11 16:12:41 NewFunc Name (*main.Mesh) func() string
2025/10/11 16:12:41 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:41.479038 [INFO] typesutil/gopinfo.go:215: ==> Type: &{63 STRING "hello" <nil>} untyped string
2025/10/11 16:12:41 Return 1
2025/10/11 16:12:41 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:41.479063 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Name scope 0xc00021d680 {
.  var p *main.Mesh
}

2025/10/11 16:12:41 End // Func
    info_test.go:190: == types ==
        000:  2:11 | struct {
        }          *ast.StructType                | type    : struct{} | type
        001:  5:10 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        002:  5:23 | string              *ast.Ident                     | type    : string | type
        003:  6: 9 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        004: 10: 7 | &Mesh{}             *ast.UnaryExpr                 | value   : *main.Mesh | value
        005: 10: 8 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        006: 10: 8 | Mesh{}              *ast.CompositeLit              | value   : main.Mesh | value
        007: 11: 7 | &Mesh{}             *ast.UnaryExpr                 | value   : *main.Mesh | value
        008: 11: 8 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        009: 11: 8 | Mesh{}              *ast.CompositeLit              | value   : main.Mesh | value
        010: 14: 1 | OnKey               *ast.Ident                     | value   : func(a string, fn func()) | value
        011: 14: 1 | OnKey "hello", => {
        } *ast.CallExpr                  | void    : () | no value
        012: 14: 7 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        013: 16: 1 | OnKey               *ast.Ident                     | value   : func(a string, fn func(key string)) | value
        014: 16: 1 | OnKey "hello", key => {
        } *ast.CallExpr                  | void    : () | no value
        015: 16: 7 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        016: 18: 1 | OnKey               *ast.Ident                     | value   : func(a []string, fn func()) | value
        017: 18: 1 | OnKey ["1"], => {
        } *ast.CallExpr                  | void    : () | no value
        018: 18: 8 | "1"                 *ast.BasicLit                  | value   : untyped string = "1" | constant
        019: 20: 1 | OnKey               *ast.Ident                     | value   : func(a []string, fn func(key string)) | value
        020: 20: 1 | OnKey ["2"], key => {
        } *ast.CallExpr                  | void    : () | no value
        021: 20: 8 | "2"                 *ast.BasicLit                  | value   : untyped string = "2" | constant
        022: 22: 1 | OnKey               *ast.Ident                     | value   : func(a []main.Mesher, fn func()) | value
        023: 22: 1 | OnKey [m1, m2], => {
        } *ast.CallExpr                  | void    : () | no value
        024: 22: 8 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        025: 22:12 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        026: 24: 1 | OnKey               *ast.Ident                     | value   : func(a []main.Mesher, fn func(key main.Mesher)) | value
        027: 24: 1 | OnKey [m1, m2], key => {
        } *ast.CallExpr                  | void    : () | no value
        028: 24: 8 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        029: 24:12 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        030: 26: 1 | OnKey               *ast.Ident                     | value   : func(a []string, b []string, fn func(key string)) | value
        031: 26: 1 | OnKey ["a"], ["b"], key => {
        } *ast.CallExpr                  | void    : () | no value
        032: 26: 8 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        033: 26:15 | "b"                 *ast.BasicLit                  | value   : untyped string = "b" | constant
        034: 28: 1 | OnKey               *ast.Ident                     | value   : func(a []string, b []main.Mesher, fn func(key string)) | value
        035: 28: 1 | OnKey ["a"], [m1, m2], key => {
        } *ast.CallExpr                  | void    : () | no value
        036: 28: 8 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        037: 28:15 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        038: 28:19 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        039: 30: 1 | OnKey               *ast.Ident                     | value   : func(a []string, b []string, fn func(key string)) | value
        040: 30: 1 | OnKey ["a"], nil, key => {
        } *ast.CallExpr                  | void    : () | no value
        041: 30: 8 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        042: 30:14 | nil                 *ast.Ident                     | nil     : untyped nil | value
        043: 32: 1 | OnKey               *ast.Ident                     | value   : func(x int, y int) | value
        044: 32: 1 | OnKey 100, 200      *ast.CallExpr                  | void    : () | no value
        045: 32: 7 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        046: 32:12 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        047: 33: 1 | OnKey               *ast.Ident                     | value   : func(a string, b string, fn ...func(x int) int) | value
        048: 33: 1 | OnKey "a", "b", x => x * x, x => {
        	return x * 2
        } *ast.CallExpr                  | void    : () | no value
        049: 33: 7 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        050: 33:12 | "b"                 *ast.BasicLit                  | value   : untyped string = "b" | constant
        051: 33:22 | x                   *ast.Ident                     | var     : int | variable
        052: 33:22 | x * x               *ast.BinaryExpr                | value   : int | value
        053: 33:26 | x                   *ast.Ident                     | var     : int | variable
        054: 34: 9 | x                   *ast.Ident                     | var     : int | variable
        055: 34: 9 | x * 2               *ast.BinaryExpr                | value   : int | value
        056: 34:13 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        057: 36: 1 | OnKey               *ast.Ident                     | value   : func(a string, b string, v ...int) | value
        058: 36: 1 | OnKey "a", "b", 1, 2, 3 *ast.CallExpr                  | void    : () | no value
        059: 36: 7 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        060: 36:12 | "b"                 *ast.BasicLit                  | value   : untyped string = "b" | constant
        061: 36:17 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        062: 36:20 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        063: 36:23 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        064: 37: 1 | OnKey               *ast.Ident                     | value   : func(a string, b string, v ...int) | value
        065: 37: 1 | OnKey("a", "b", [1, 2, 3]...) *ast.CallExpr                  | void    : () | no value
        066: 37: 7 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        067: 37:12 | "b"                 *ast.BasicLit                  | value   : untyped string = "b" | constant
        068: 37:18 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        069: 37:21 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        070: 37:24 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        == defs ==
        000:  2: 6 | Mesh                | type main.Mesh struct{}
        001:  5: 7 | p                   | var p *main.Mesh
        002:  5:16 | Name                | func (*main.Mesh).Name() string
        003: 10: 2 | m1                  | var main.m1 *main.Mesh
        004: 11: 2 | m2                  | var main.m2 *main.Mesh
        005: 14: 1 | main                | func main.main()
        006: 16:16 | key                 | var key string
        007: 20:14 | key                 | var key string
        008: 24:17 | key                 | var key main.Mesher
        009: 26:21 | key                 | var key string
        010: 28:24 | key                 | var key string
        011: 30:19 | key                 | var key string
        012: 33:17 | x                   | var x int
        013: 33:29 | x                   | var x int
        == uses ==
        000:  5:10 | Mesh                | type main.Mesh struct{}
        001:  5:23 | string              | type string
        002: 10: 8 | Mesh                | type main.Mesh struct{}
        003: 11: 8 | Mesh                | type main.Mesh struct{}
        004: 14: 1 | OnKey               | func main.OnKey__0(a string, fn func())
        005: 16: 1 | OnKey               | func main.OnKey__1(a string, fn func(key string))
        006: 18: 1 | OnKey               | func main.OnKey__2(a []string, fn func())
        007: 20: 1 | OnKey               | func main.OnKey__3(a []string, fn func(key string))
        008: 22: 1 | OnKey               | func main.OnKey__4(a []main.Mesher, fn func())
        009: 22: 8 | m1                  | var main.m1 *main.Mesh
        010: 22:12 | m2                  | var main.m2 *main.Mesh
        011: 24: 1 | OnKey               | func main.OnKey__5(a []main.Mesher, fn func(key main.Mesher))
        012: 24: 8 | m1                  | var main.m1 *main.Mesh
        013: 24:12 | m2                  | var main.m2 *main.Mesh
        014: 26: 1 | OnKey               | func main.OnKey__6(a []string, b []string, fn func(key string))
        015: 28: 1 | OnKey               | func main.OnKey__7(a []string, b []main.Mesher, fn func(key string))
        016: 28:15 | m1                  | var main.m1 *main.Mesh
        017: 28:19 | m2                  | var main.m2 *main.Mesh
        018: 30: 1 | OnKey               | func main.OnKey__6(a []string, b []string, fn func(key string))
        019: 30:14 | nil                 | nil
        020: 32: 1 | OnKey               | func main.OnKey__8(x int, y int)
        021: 33: 1 | OnKey               | func main.OnKey__9(a string, b string, fn ...func(x int) int)
        022: 33:22 | x                   | var x int
        023: 33:26 | x                   | var x int
        024: 34: 9 | x                   | var x int
        025: 36: 1 | OnKey               | func main.OnKey__a(a string, b string, v ...int)
        026: 37: 1 | OnKey               | func main.OnKey__a(a string, b string, v ...int)
        == overloads ==
        000: 14: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        001: 16: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        002: 18: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        003: 20: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        004: 22: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        005: 24: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        006: 26: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        007: 28: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        008: 30: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        009: 32: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        010: 33: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        011: 36: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        012: 37: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
--- PASS: TestMixedOverload1 (1.24s)
=== RUN   TestMixedOverload2
2025/10/11 16:12:41.481169 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/10/11 16:12:42 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:42 ==> NewOverloadFunc NewRange
2025/10/11 16:12:42 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:42 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:42 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:42 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:42 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:42 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:42 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:42 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:42 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:42 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:42 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:42 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:42 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:42 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:42.723376 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00057cf00 {
}

2025/10/11 16:12:42 ==> Preload type Mesh
2025/10/11 16:12:42 ==> Preload method Mesh.Name
2025/10/11 16:12:42 ==> Preload var [m1]
2025/10/11 16:12:42 ==> Preload var [m2]
2025/10/11 16:12:42 ==> Preload func main
2025/10/11 16:12:42 ==> Preload type Mesher
2025/10/11 16:12:42 ==> Preload type N
2025/10/11 16:12:42 ==> Preload method N.OnKey__0
2025/10/11 16:12:42 ==> Preload method N.OnKey__1
2025/10/11 16:12:42 ==> Preload method N.OnKey__2
2025/10/11 16:12:42 ==> Preload method N.OnKey__3
2025/10/11 16:12:42 ==> Preload method N.OnKey__4
2025/10/11 16:12:42 ==> Preload method N.OnKey__5
2025/10/11 16:12:42 ==> Preload method N.OnKey__6
2025/10/11 16:12:42 ==> Preload method N.OnKey__7
2025/10/11 16:12:42 ==> Preload method N.OnKey__8
2025/10/11 16:12:42 ==> Preload func OnKey__0
2025/10/11 16:12:42 ==> Preload func OnKey__1
2025/10/11 16:12:42 ==> Preload func OnKey__2
2025/10/11 16:12:42 ==> Preload func OnKey__3
2025/10/11 16:12:42 ==> Preload func OnKey__4
2025/10/11 16:12:42 ==> Preload func OnKey__5
2025/10/11 16:12:42 ==> Preload func OnKey__6
2025/10/11 16:12:42 ==> Preload func OnKey__7
2025/10/11 16:12:42 ==> Preload func OnKey__8
2025/10/11 16:12:42 ==> Preload func OnKey__9
2025/10/11 16:12:42 ==> Preload func OnKey__a
2025/10/11 16:12:42 ==> Load func OnKey__4
2025/10/11 16:12:42 ==> Load > NewType Mesher
2025/10/11 16:12:42 ==> Lookup (LoadSymbol) Mesher => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:42 ==> Load > InitType Mesher
2025/10/11 16:12:42 ==> Load func OnKey__6
2025/10/11 16:12:42 ==> Load func OnKey__7
2025/10/11 16:12:42 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:42 ==> Load func OnKey__8
2025/10/11 16:12:42 ==> Load func OnKey__a
2025/10/11 16:12:42 ==> Load > NewType N
2025/10/11 16:12:42 ==> Load > InitType N
2025/10/11 16:12:42 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:42 ==> Load method *main.N.OnKey__0
2025/10/11 16:12:42 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:42 ==> Load method *main.N.OnKey__1
2025/10/11 16:12:42 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:42 ==> Load method *main.N.OnKey__2
2025/10/11 16:12:42 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:42 ==> Load method *main.N.OnKey__3
2025/10/11 16:12:42 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:42 ==> Load method *main.N.OnKey__4
2025/10/11 16:12:42 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:42 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:42 ==> Load method *main.N.OnKey__5
2025/10/11 16:12:42 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:42 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:42 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:42 ==> Load method *main.N.OnKey__6
2025/10/11 16:12:42 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:42 ==> Load method *main.N.OnKey__7
2025/10/11 16:12:42 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:42 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:42 ==> Load method *main.N.OnKey__8
2025/10/11 16:12:42 ==> Load func OnKey__0
2025/10/11 16:12:42 ==> Load func OnKey__2
2025/10/11 16:12:42 ==> Load func OnKey__1
2025/10/11 16:12:42 ==> Load func OnKey__3
2025/10/11 16:12:42 ==> Load func OnKey__5
2025/10/11 16:12:42 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:42 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/10/11 16:12:42 ==> Load func OnKey__9
2025/10/11 16:12:42 ==> NewOverloadMethod N OnKey
2025/10/11 16:12:42 ==> NewOverloadFunc OnKey
2025/10/11 16:12:42 ==> Load > NewType Mesh
2025/10/11 16:12:42 NewType Mesh
2025/10/11 16:12:42 ==> Load > InitType Mesh
2025/10/11 16:12:42.724273 [INFO] typesutil/gopinfo.go:215: ==> Type: &{12 0xc000216180 false} struct{}
2025/10/11 16:12:42 InitType Mesh struct{}
2025/10/11 16:12:42.724303 [INFO] typesutil/gopinfo.go:251: ==> Def: Mesh type main.Mesh struct{}
2025/10/11 16:12:42 ==> LookupParent Mesh => type main.Mesh struct{}
2025/10/11 16:12:42.724326 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/10/11 16:12:42.724338 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:42.724351 [INFO] typesutil/gopinfo.go:251: ==> Def: p var p *main.Mesh
2025/10/11 16:12:42 ==> Load method *main.Mesh.Name
2025/10/11 16:12:42.724369 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:42.724378 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:42.724390 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:42.724404 [INFO] typesutil/gopinfo.go:251: ==> Def: Name func (*main.Mesh).Name() string
2025/10/11 16:12:42 ==> Load var <nil> [m1]
2025/10/11 16:12:42 NewVarDefs
2025/10/11 16:12:42 NewVar [m1]
2025/10/11 16:12:42 ==> LookupParent Mesh => type main.Mesh struct{}
2025/10/11 16:12:42.724444 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/10/11 16:12:42.724453 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:42.724464 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:42 StructLit main.Mesh 0 false
2025/10/11 16:12:42.724484 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:42.724499 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mesh 91 [] 92 false} main.Mesh
2025/10/11 16:12:42 UnaryOp & flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:42.724536 [INFO] typesutil/gopinfo.go:215: ==> Type: &{86 & 0xc0002e0740} *main.Mesh
2025/10/11 16:12:42 EndInit 1
2025/10/11 16:12:42.724552 [INFO] typesutil/gopinfo.go:251: ==> Def: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42 ==> Load var <nil> [m2]
2025/10/11 16:12:42 NewVarDefs
2025/10/11 16:12:42 NewVar [m2]
2025/10/11 16:12:42 ==> LookupParent Mesh => type main.Mesh struct{}
2025/10/11 16:12:42.724586 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/10/11 16:12:42.724595 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:42.724605 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:42 StructLit main.Mesh 0 false
2025/10/11 16:12:42.724621 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/10/11 16:12:42.724634 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mesh 105 [] 106 false} main.Mesh
2025/10/11 16:12:42 UnaryOp & flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:42.724662 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 & 0xc0002e0780} *main.Mesh
2025/10/11 16:12:42 EndInit 1
2025/10/11 16:12:42.724681 [INFO] typesutil/gopinfo.go:251: ==> Def: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42 ==> Load func main
2025/10/11 16:12:42.724700 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:42 NewFunc main func()
2025/10/11 16:12:42 DefineVarStart [n]
2025/10/11 16:12:42 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:42.724737 [INFO] typesutil/gopinfo.go:265: ==> Use: N type main.N struct{}
2025/10/11 16:12:42.724746 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/10/11 16:12:42.724756 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/10/11 16:12:42 StructLit main.N 0 false
2025/10/11 16:12:42.724772 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/10/11 16:12:42.724785 [INFO] typesutil/gopinfo.go:215: ==> Type: &{N 118 [] 119 false} main.N
2025/10/11 16:12:42 UnaryOp & flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:42.724810 [INFO] typesutil/gopinfo.go:215: ==> Type: &{116 & 0xc0002e0840} *main.N
2025/10/11 16:12:42 EndInit 1
2025/10/11 16:12:42.724826 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n *main.N
2025/10/11 16:12:42 Val n *main.N
2025/10/11 16:12:42.724847 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/10/11 16:12:42.724857 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/10/11 16:12:42 Member onKey 1 // *main.N
2025/10/11 16:12:42.724888 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42.724897 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/10/11 16:12:42.724913 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:42.724948 [INFO] typesutil/gopinfo.go:215: ==> Type: &{129 STRING "hello" <nil>} untyped string
2025/10/11 16:12:42 NewClosure func()
2025/10/11 16:12:42.724975 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000446840 {
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:42 ==> MatchType func(), func()
2025/10/11 16:12:42.725050 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__0(a string, fn func())
2025/10/11 16:12:42.725062 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a string, fn func())
2025/10/11 16:12:42.725082 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a3140 0 [0xc000216390 0xc0002e08c0] 0 [] 0 144} ()
2025/10/11 16:12:42 Val n *main.N
2025/10/11 16:12:42.725101 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/10/11 16:12:42.725112 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/10/11 16:12:42 Member onKey 1 // *main.N
2025/10/11 16:12:42.725133 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42.725143 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/10/11 16:12:42.725154 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:42.725177 [INFO] typesutil/gopinfo.go:215: ==> Type: &{153 STRING "hello" <nil>} untyped string
2025/10/11 16:12:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:42.725201 [INFO] typesutil/gopinfo.go:215: ==> Type: &{153 STRING "hello" <nil>} untyped string
2025/10/11 16:12:42.725212 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42 NewClosure func(key string)
2025/10/11 16:12:42.725232 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42.725250 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000447020 {
.  var key string
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:42 ==> MatchType func(key string), func()
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:42 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:42.725340 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__1(a string, fn func(key string))
2025/10/11 16:12:42.725352 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a string, fn func(key string))
2025/10/11 16:12:42.725369 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a3158 0 [0xc000216420 0xc0002e09c0] 0 [] 0 172} ()
2025/10/11 16:12:42 Val n *main.N
2025/10/11 16:12:42.725390 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/10/11 16:12:42.725400 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/10/11 16:12:42 Member onKey 1 // *main.N
2025/10/11 16:12:42.725422 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42.725431 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/10/11 16:12:42.725442 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:12:42.725463 [INFO] typesutil/gopinfo.go:215: ==> Type: &{182 STRING "1" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 NewClosure func()
2025/10/11 16:12:42.725490 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0004471a0 {
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, []string
2025/10/11 16:12:42 ==> MatchType func(), func()
2025/10/11 16:12:42.725576 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__2(a []string, fn func())
2025/10/11 16:12:42.725588 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []string, fn func())
2025/10/11 16:12:42.725604 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a3170 0 [0xc0002164e0 0xc0002e0a80] 0 [] 0 194} ()
2025/10/11 16:12:42 Val n *main.N
2025/10/11 16:12:42.725624 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/10/11 16:12:42.725634 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/10/11 16:12:42 Member onKey 1 // *main.N
2025/10/11 16:12:42.725655 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42.725662 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/10/11 16:12:42.725673 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:42.725693 [INFO] typesutil/gopinfo.go:215: ==> Type: &{204 STRING "2" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val &{0 STRING "2"} *ast.BasicLit
2025/10/11 16:12:42.725721 [INFO] typesutil/gopinfo.go:215: ==> Type: &{204 STRING "2" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42.725736 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42 NewClosure func(key string)
2025/10/11 16:12:42.725754 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42.725768 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000447320 {
.  var key string
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, []string
2025/10/11 16:12:42 ==> MatchType func(key string), func()
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, []string
2025/10/11 16:12:42 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:42.725886 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__3(a []string, fn func(key string))
2025/10/11 16:12:42.725901 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []string, fn func(key string))
2025/10/11 16:12:42.725917 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a3188 0 [0xc0002165a0 0xc0002e0b00] 0 [] 0 220} ()
2025/10/11 16:12:42 Val n *main.N
2025/10/11 16:12:42.725936 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/10/11 16:12:42.725952 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/10/11 16:12:42 Member onKey 1 // *main.N
2025/10/11 16:12:42.725978 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42.725988 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/10/11 16:12:42.725999 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.726020 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.726029 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.726047 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.726056 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit <nil> 2 false
2025/10/11 16:12:42 NewClosure func()
2025/10/11 16:12:42.726078 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0004474a0 {
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, []main.Mesher
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, []main.Mesher
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, int
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.726285 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.726295 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.726312 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.726321 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit <nil> 2 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.726346 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.726355 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.726369 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.726381 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit []string 2 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.726420 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.726429 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.726444 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.726453 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit []string 2 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.726485 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.726495 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.726511 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.726519 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit []main.Mesher 2 false
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 NewClosure func()
2025/10/11 16:12:42.726571 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0004475c0 {
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, []main.Mesher
2025/10/11 16:12:42 ==> MatchType func(), func()
2025/10/11 16:12:42.726699 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__4(a []main.Mesher, fn func())
2025/10/11 16:12:42.726712 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []main.Mesher, fn func())
2025/10/11 16:12:42.726728 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a31a0 0 [0xc000216630 0xc0002e0b40] 0 [] 0 245} ()
2025/10/11 16:12:42 Val n *main.N
2025/10/11 16:12:42.726746 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/10/11 16:12:42.726756 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/10/11 16:12:42 Member onKey 1 // *main.N
2025/10/11 16:12:42.726777 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42.726785 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/10/11 16:12:42.726795 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.726814 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.726825 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.726840 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.726852 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit <nil> 2 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.726880 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.726888 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.726907 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.726916 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit <nil> 2 false
2025/10/11 16:12:42.726936 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42 NewClosure func(key string)
2025/10/11 16:12:42.726956 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42.726970 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000447740 {
.  var key string
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, []main.Mesher
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, []main.Mesher
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []*main.Mesh, int
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.727170 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.727179 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.727197 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.727205 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit []string 2 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.727240 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.727251 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.727266 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.727275 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit []string 2 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.727318 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.727329 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.727345 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.727353 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit []main.Mesher 2 false
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.727396 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.727407 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.727422 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.727431 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit []main.Mesher 2 false
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42.727463 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key main.Mesher
2025/10/11 16:12:42 NewClosure func(key main.Mesher)
2025/10/11 16:12:42.727482 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key main.Mesher
2025/10/11 16:12:42.727496 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000447860 {
.  var key main.Mesher
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, []main.Mesher
2025/10/11 16:12:42 ==> MatchType func(key main.Mesher), func()
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType []main.Mesher, []main.Mesher
2025/10/11 16:12:42 ==> MatchType func(key main.Mesher), func(key main.Mesher)
2025/10/11 16:12:42.727644 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__5(a []main.Mesher, fn func(key main.Mesher))
2025/10/11 16:12:42.727660 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []main.Mesher, fn func(key main.Mesher))
2025/10/11 16:12:42.727676 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a31b8 0 [0xc0002166c0 0xc0002e0bc0] 0 [] 0 274} ()
2025/10/11 16:12:42 Val n *main.N
2025/10/11 16:12:42.727696 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/10/11 16:12:42.727705 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/10/11 16:12:42 Member onKey 1 // *main.N
2025/10/11 16:12:42.727724 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42.727732 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/10/11 16:12:42.727745 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.727769 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:42.727797 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "b" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.727826 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:42.727852 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "b" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.727876 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:42.727906 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "b" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.727931 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:42.727957 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "b" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.727984 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []main.Mesher 1 false
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.728052 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []main.Mesher 1 false
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.728102 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42 Val &{0 STRING "b"} *ast.BasicLit
2025/10/11 16:12:42.728127 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "b" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42.728145 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42 NewClosure func(key string)
2025/10/11 16:12:42.728163 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42.728177 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000447a40 {
.  var key string
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, []string
2025/10/11 16:12:42 ==> MatchType []string, []string
2025/10/11 16:12:42 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:42.728362 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__6(a []string, b []string, fn func(key string))
2025/10/11 16:12:42.728376 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []string, b []string, fn func(key string))
2025/10/11 16:12:42.728394 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a31d0 0 [0xc000216780 0xc0002167e0 0xc0002e0c00] 0 [] 0 307} ()
2025/10/11 16:12:42 Val n *main.N
2025/10/11 16:12:42.728413 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/10/11 16:12:42.728423 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/10/11 16:12:42 Member onKey 1 // *main.N
2025/10/11 16:12:42.728446 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42.728454 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/10/11 16:12:42.728464 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.728485 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.728506 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.728517 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.728532 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.728542 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit <nil> 2 false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.728569 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.728591 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.728601 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.728620 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.728628 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit <nil> 2 false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.728655 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.728686 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.728694 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.728709 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.728718 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit <nil> 2 false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.728742 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.728767 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.728774 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.728792 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.728800 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit <nil> 2 false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.728824 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []main.Mesher 1 false
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.728869 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []main.Mesher 1 false
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.728910 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.728934 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.728943 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.728961 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.728970 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit []string 2 false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.729001 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42 Val m1 *main.Mesh
2025/10/11 16:12:42.729025 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/10/11 16:12:42.729034 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/10/11 16:12:42 Val m2 *main.Mesh
2025/10/11 16:12:42.729052 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/10/11 16:12:42.729062 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/10/11 16:12:42 SliceLit []main.Mesher 2 false
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42.729095 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42 NewClosure func(key string)
2025/10/11 16:12:42.729117 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42.729129 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000447c20 {
.  var key string
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, []string
2025/10/11 16:12:42 ==> MatchType []main.Mesher, []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, []string
2025/10/11 16:12:42 ==> MatchType []main.Mesher, []main.Mesher
2025/10/11 16:12:42 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:42.729337 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__7(a []string, b []main.Mesher, fn func(key string))
2025/10/11 16:12:42.729351 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []string, b []main.Mesher, fn func(key string))
2025/10/11 16:12:42.729369 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a31e8 0 [0xc0002168a0 0xc0002168d0 0xc0002e0c80] 0 [] 0 343} ()
2025/10/11 16:12:42 Val n *main.N
2025/10/11 16:12:42.729390 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/10/11 16:12:42.729400 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/10/11 16:12:42 Member onKey 1 // *main.N
2025/10/11 16:12:42.729420 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42.729434 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/10/11 16:12:42.729448 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.729470 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val nil untyped nil
2025/10/11 16:12:42.729497 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:42.729507 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.729529 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit <nil> 1 false
2025/10/11 16:12:42 Val nil untyped nil
2025/10/11 16:12:42.729549 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:42.729557 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.729579 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42 Val nil untyped nil
2025/10/11 16:12:42.729602 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:42.729609 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.729629 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42 Val nil untyped nil
2025/10/11 16:12:42.729651 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:42.729658 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.729680 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []main.Mesher 1 false
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.729725 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []main.Mesher 1 false
2025/10/11 16:12:42 ==> EnsureLoaded main.Mesher
2025/10/11 16:12:42 ==> AssignableConv untyped string main.Mesher false
2025/10/11 16:12:42 Val &{0 STRING "a"} *ast.BasicLit
2025/10/11 16:12:42.729766 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/10/11 16:12:42 SliceLit []string 1 false
2025/10/11 16:12:42 Val nil untyped nil
2025/10/11 16:12:42.729791 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/10/11 16:12:42.729802 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/10/11 16:12:42.729812 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42 NewClosure func(key string)
2025/10/11 16:12:42.729832 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/10/11 16:12:42.729846 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000447e00 {
.  var key string
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/10/11 16:12:42 ==> MatchType []string, []string
2025/10/11 16:12:42 ==> MatchType untyped nil, []string
2025/10/11 16:12:42 ==> MatchType func(key string), func(key string)
2025/10/11 16:12:42.730022 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__6(a []string, b []string, fn func(key string))
2025/10/11 16:12:42.730036 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []string, b []string, fn func(key string))
2025/10/11 16:12:42.730054 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a3200 0 [0xc000216990 nil 0xc0002e0d00] 0 [] 0 374} ()
2025/10/11 16:12:42 Val n *main.N
2025/10/11 16:12:42.730071 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/10/11 16:12:42.730082 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/10/11 16:12:42 Member onKey 1 // *main.N
2025/10/11 16:12:42.730101 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42.730108 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/10/11 16:12:42.730119 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:42.730152 [INFO] typesutil/gopinfo.go:215: ==> Type: &{383 INT 100 <nil>} untyped int
2025/10/11 16:12:42 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:42.730233 [INFO] typesutil/gopinfo.go:215: ==> Type: &{388 INT 200 <nil>} untyped int
2025/10/11 16:12:42 NewClosure func() int
2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), string
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), []main.Mesher
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), []main.Mesher
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), int
2025/10/11 16:12:42 ==> MatchType func() int, int
2025/10/11 16:12:42 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:42.730470 [INFO] typesutil/gopinfo.go:215: ==> Type: &{383 INT 100 <nil>} untyped int
2025/10/11 16:12:42 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:12:42.730489 [INFO] typesutil/gopinfo.go:215: ==> Type: &{388 INT 200 <nil>} untyped int
2025/10/11 16:12:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:42 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), string
2025/10/11 16:12:42 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), []string
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), []main.Mesher
2025/10/11 16:12:42 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), []main.Mesher
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/10/11 16:12:42 ==> MatchType untyped int (100), int
2025/10/11 16:12:42 ==> MatchType untyped int (200), int
2025/10/11 16:12:42.730684 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__8(x int, y int)
2025/10/11 16:12:42.730698 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(x int, y int)
2025/10/11 16:12:42.730716 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001a3218 0 [0xc000216a20 0xc000216a50] 0 [] 0 391} ()
2025/10/11 16:12:42.730732 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0004463c0 {
.  var n *main.N
}

2025/10/11 16:12:42 End // Func
2025/10/11 16:12:42 NewFunc Name (*main.Mesh) func() string
2025/10/11 16:12:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:12:42.730771 [INFO] typesutil/gopinfo.go:215: ==> Type: &{63 STRING "hello" <nil>} untyped string
2025/10/11 16:12:42 Return 1
2025/10/11 16:12:42 ==> MatchType untyped string ("hello"), string
2025/10/11 16:12:42.730802 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Name scope 0xc000620120 {
.  var p *main.Mesh
}

2025/10/11 16:12:42 End // Func
    info_test.go:190: == types ==
        000:  2:11 | struct {
        }          *ast.StructType                | type    : struct{} | type
        001:  5:10 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        002:  5:23 | string              *ast.Ident                     | type    : string | type
        003:  6: 9 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        004: 10: 7 | &Mesh{}             *ast.UnaryExpr                 | value   : *main.Mesh | value
        005: 10: 8 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        006: 10: 8 | Mesh{}              *ast.CompositeLit              | value   : main.Mesh | value
        007: 11: 7 | &Mesh{}             *ast.UnaryExpr                 | value   : *main.Mesh | value
        008: 11: 8 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        009: 11: 8 | Mesh{}              *ast.CompositeLit              | value   : main.Mesh | value
        010: 14: 6 | &N{}                *ast.UnaryExpr                 | value   : *main.N | value
        011: 14: 7 | N                   *ast.Ident                     | type    : main.N | type
        012: 14: 7 | N{}                 *ast.CompositeLit              | value   : main.N | value
        013: 15: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        014: 15: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a string, fn func()) | value
        015: 15: 1 | n.onKey "hello", => {
        } *ast.CallExpr                  | void    : () | no value
        016: 15: 9 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        017: 17: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        018: 17: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a string, fn func(key string)) | value
        019: 17: 1 | n.onKey "hello", key => {
        } *ast.CallExpr                  | void    : () | no value
        020: 17: 9 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        021: 19: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        022: 19: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []string, fn func()) | value
        023: 19: 1 | n.onKey ["1"], => {
        } *ast.CallExpr                  | void    : () | no value
        024: 19:10 | "1"                 *ast.BasicLit                  | value   : untyped string = "1" | constant
        025: 21: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        026: 21: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []string, fn func(key string)) | value
        027: 21: 1 | n.onKey ["2"], key => {
        } *ast.CallExpr                  | void    : () | no value
        028: 21:10 | "2"                 *ast.BasicLit                  | value   : untyped string = "2" | constant
        029: 23: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        030: 23: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []main.Mesher, fn func()) | value
        031: 23: 1 | n.onKey [m1, m2], => {
        } *ast.CallExpr                  | void    : () | no value
        032: 23:10 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        033: 23:14 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        034: 25: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        035: 25: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []main.Mesher, fn func(key main.Mesher)) | value
        036: 25: 1 | n.onKey [m1, m2], key => {
        } *ast.CallExpr                  | void    : () | no value
        037: 25:10 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        038: 25:14 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        039: 27: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        040: 27: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []string, b []string, fn func(key string)) | value
        041: 27: 1 | n.onKey ["a"], ["b"], key => {
        } *ast.CallExpr                  | void    : () | no value
        042: 27:10 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        043: 27:17 | "b"                 *ast.BasicLit                  | value   : untyped string = "b" | constant
        044: 29: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        045: 29: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []string, b []main.Mesher, fn func(key string)) | value
        046: 29: 1 | n.onKey ["a"], [m1, m2], key => {
        } *ast.CallExpr                  | void    : () | no value
        047: 29:10 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        048: 29:17 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        049: 29:21 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        050: 31: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        051: 31: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []string, b []string, fn func(key string)) | value
        052: 31: 1 | n.onKey ["a"], nil, key => {
        } *ast.CallExpr                  | void    : () | no value
        053: 31:10 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        054: 31:16 | nil                 *ast.Ident                     | nil     : untyped nil | value
        055: 33: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        056: 33: 1 | n.onKey             *ast.SelectorExpr              | value   : func(x int, y int) | value
        057: 33: 1 | n.onKey 100, 200    *ast.CallExpr                  | void    : () | no value
        058: 33: 9 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        059: 33:14 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        == defs ==
        000:  2: 6 | Mesh                | type main.Mesh struct{}
        001:  5: 7 | p                   | var p *main.Mesh
        002:  5:16 | Name                | func (*main.Mesh).Name() string
        003: 10: 2 | m1                  | var main.m1 *main.Mesh
        004: 11: 2 | m2                  | var main.m2 *main.Mesh
        005: 14: 1 | main                | func main.main()
        006: 14: 1 | n                   | var n *main.N
        007: 17:18 | key                 | var key string
        008: 21:16 | key                 | var key string
        009: 25:19 | key                 | var key main.Mesher
        010: 27:23 | key                 | var key string
        011: 29:26 | key                 | var key string
        012: 31:21 | key                 | var key string
        == uses ==
        000:  5:10 | Mesh                | type main.Mesh struct{}
        001:  5:23 | string              | type string
        002: 10: 8 | Mesh                | type main.Mesh struct{}
        003: 11: 8 | Mesh                | type main.Mesh struct{}
        004: 14: 7 | N                   | type main.N struct{}
        005: 15: 1 | n                   | var n *main.N
        006: 15: 3 | onKey               | func (*main.N).OnKey__0(a string, fn func())
        007: 17: 1 | n                   | var n *main.N
        008: 17: 3 | onKey               | func (*main.N).OnKey__1(a string, fn func(key string))
        009: 19: 1 | n                   | var n *main.N
        010: 19: 3 | onKey               | func (*main.N).OnKey__2(a []string, fn func())
        011: 21: 1 | n                   | var n *main.N
        012: 21: 3 | onKey               | func (*main.N).OnKey__3(a []string, fn func(key string))
        013: 23: 1 | n                   | var n *main.N
        014: 23: 3 | onKey               | func (*main.N).OnKey__4(a []main.Mesher, fn func())
        015: 23:10 | m1                  | var main.m1 *main.Mesh
        016: 23:14 | m2                  | var main.m2 *main.Mesh
        017: 25: 1 | n                   | var n *main.N
        018: 25: 3 | onKey               | func (*main.N).OnKey__5(a []main.Mesher, fn func(key main.Mesher))
        019: 25:10 | m1                  | var main.m1 *main.Mesh
        020: 25:14 | m2                  | var main.m2 *main.Mesh
        021: 27: 1 | n                   | var n *main.N
        022: 27: 3 | onKey               | func (*main.N).OnKey__6(a []string, b []string, fn func(key string))
        023: 29: 1 | n                   | var n *main.N
        024: 29: 3 | onKey               | func (*main.N).OnKey__7(a []string, b []main.Mesher, fn func(key string))
        025: 29:17 | m1                  | var main.m1 *main.Mesh
        026: 29:21 | m2                  | var main.m2 *main.Mesh
        027: 31: 1 | n                   | var n *main.N
        028: 31: 3 | onKey               | func (*main.N).OnKey__6(a []string, b []string, fn func(key string))
        029: 31:16 | nil                 | nil
        030: 33: 1 | n                   | var n *main.N
        031: 33: 3 | onKey               | func (*main.N).OnKey__8(x int, y int)
        == overloads ==
        000: 15: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        001: 17: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        002: 19: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        003: 21: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        004: 23: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        005: 25: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        006: 27: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        007: 29: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        008: 31: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        009: 33: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
--- PASS: TestMixedOverload2 (1.25s)
=== RUN   TestMixedOverload3
2025/10/11 16:12:42.732712 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/10/11 16:12:43 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:43 ==> NewOverloadFunc NewRange
2025/10/11 16:12:43 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:43 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:43 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:43 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:43 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:43 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:43 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:43 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:43 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:43 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:43 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:43 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:43 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:43 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:43.937507 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000306540 {
}

2025/10/11 16:12:43 ==> Preload func main
2025/10/11 16:12:43 ==> Preload func Test__0
2025/10/11 16:12:43 ==> Preload func Test__1
2025/10/11 16:12:43 ==> Preload type N
2025/10/11 16:12:43 ==> Preload method N.Test__0
2025/10/11 16:12:43 ==> Preload method N.Test__1
2025/10/11 16:12:43 ==> Load func Test__1
2025/10/11 16:12:43 ==> Load > NewType N
2025/10/11 16:12:43 ==> Load > InitType N
2025/10/11 16:12:43 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:43 ==> Load method *main.N.Test__0
2025/10/11 16:12:43 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:43 ==> Load method *main.N.Test__1
2025/10/11 16:12:43 ==> Load func Test__0
2025/10/11 16:12:43 ==> NewOverloadMethod N Test
2025/10/11 16:12:43 ==> NewOverloadFunc Test
2025/10/11 16:12:43 ==> Load func main
2025/10/11 16:12:43.937791 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:43 NewFunc main func()
2025/10/11 16:12:43 Val Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43.937850 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43.937865 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Test TyOverloadFunc
2025/10/11 16:12:43.937885 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/10/11 16:12:43 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:43.937930 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test__0()
2025/10/11 16:12:43.937944 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func()
2025/10/11 16:12:43 Val Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43.937974 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43.937985 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Test TyOverloadFunc
2025/10/11 16:12:43.937998 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:43.938042 [INFO] typesutil/gopinfo.go:215: ==> Type: &{12 INT 100 <nil>} untyped int
2025/10/11 16:12:43 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:12:43 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:12:43 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/10/11 16:12:43 ==> MatchType untyped int (100), int
2025/10/11 16:12:43.938125 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test__1(n int)
2025/10/11 16:12:43.938138 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(n int)
2025/10/11 16:12:43.938163 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Test 0 [0xc0003cc030] 0 [] 0 15} ()
2025/10/11 16:12:43 ==> LookupParent N => type main.N struct{}
2025/10/11 16:12:43.938197 [INFO] typesutil/gopinfo.go:265: ==> Use: N type main.N struct{}
2025/10/11 16:12:43.938211 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/10/11 16:12:43.938225 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/10/11 16:12:43 ==> Load var main.N [n]
2025/10/11 16:12:43 NewVarDefs
2025/10/11 16:12:43 NewVar [n]
2025/10/11 16:12:43.938274 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n main.N
2025/10/11 16:12:43 Val n main.N
2025/10/11 16:12:43.938296 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n main.N
2025/10/11 16:12:43.938310 [INFO] typesutil/gopinfo.go:215: ==> Type: n main.N
2025/10/11 16:12:43 Member test 1 // main.N
2025/10/11 16:12:43.938342 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (main.N).Test(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43.938354 [INFO] typesutil/gopinfo.go:274: ==> Overloads: test TyOverloadMethod
2025/10/11 16:12:43.938372 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43 ==> MatchFuncCall TyOverloadMethod args: 0 flags: 0
2025/10/11 16:12:43 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:43.938414 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (*main.N).Test__0()
2025/10/11 16:12:43.938429 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func()
2025/10/11 16:12:43 Val n main.N
2025/10/11 16:12:43.938452 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n main.N
2025/10/11 16:12:43.938466 [INFO] typesutil/gopinfo.go:215: ==> Type: n main.N
2025/10/11 16:12:43 Member test 1 // main.N
2025/10/11 16:12:43.938487 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (main.N).Test(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43.938497 [INFO] typesutil/gopinfo.go:274: ==> Overloads: test TyOverloadMethod
2025/10/11 16:12:43.938519 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:12:43.938561 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 INT 100 <nil>} untyped int
2025/10/11 16:12:43 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:43 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:12:43 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:12:43 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/10/11 16:12:43 ==> MatchType untyped int (100), int
2025/10/11 16:12:43.938656 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (*main.N).Test__1(n int)
2025/10/11 16:12:43.938670 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(n int)
2025/10/11 16:12:43.938691 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000614a20 0 [0xc0003cc060] 0 [] 0 41} ()
2025/10/11 16:12:43.938716 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000307080 {
.  var n main.N
}

2025/10/11 16:12:43 End // Func
    info_test.go:190: == types ==
        000:  2: 1 | Test                *ast.Ident                     | value   : func() | value
        001:  3: 1 | Test                *ast.Ident                     | value   : func(n int) | value
        002:  3: 1 | Test 100            *ast.CallExpr                  | void    : () | no value
        003:  3: 6 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        004:  4: 7 | N                   *ast.Ident                     | type    : main.N | type
        005:  5: 1 | n                   *ast.Ident                     | var     : main.N | variable
        006:  5: 1 | n.test              *ast.SelectorExpr              | value   : func() | value
        007:  6: 1 | n                   *ast.Ident                     | var     : main.N | variable
        008:  6: 1 | n.test              *ast.SelectorExpr              | value   : func(n int) | value
        009:  6: 1 | n.test 100          *ast.CallExpr                  | void    : () | no value
        010:  6: 8 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        == defs ==
        000:  2: 1 | main                | func main.main()
        001:  4: 5 | n                   | var n main.N
        == uses ==
        000:  2: 1 | Test                | func main.Test__0()
        001:  3: 1 | Test                | func main.Test__1(n int)
        002:  4: 7 | N                   | type main.N struct{}
        003:  5: 1 | n                   | var n main.N
        004:  5: 3 | test                | func (*main.N).Test__0()
        005:  6: 1 | n                   | var n main.N
        006:  6: 3 | test                | func (*main.N).Test__1(n int)
        == overloads ==
        000:  2: 1 | Test                | func main.Test(__xgo_overload_args__ interface{_()})
        001:  3: 1 | Test                | func main.Test(__xgo_overload_args__ interface{_()})
        002:  5: 3 | test                | func (main.N).Test(__xgo_overload_args__ interface{_()})
        003:  6: 3 | test                | func (main.N).Test(__xgo_overload_args__ interface{_()})
--- PASS: TestMixedOverload3 (1.21s)
=== RUN   TestOverloadNamed
2025/10/11 16:12:43.940026 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:44 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:44 ==> NewOverloadFunc NewRange
2025/10/11 16:12:44 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:44 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:44 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:44 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:44 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:44 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:44 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:44 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:44 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:44 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:44 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:44 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:44 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:44 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:45.141407 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000159260 {
}

2025/10/11 16:12:45 ==> Import github.com/goplus/xgo/cl/internal/overload/bar
2025/10/11 16:12:45 ==> NewOverloadFunc Gopt_Player_Gopx_OnCmd
2025/10/11 16:12:45 ==> NewTemplateRecvMethod Player Gopx_OnCmd
2025/10/11 16:12:45 ==> AliasMethod github.com/goplus/xgo/cl/internal/overload/bar.Player Gopx_OnCmd => OnCmd
2025/10/11 16:12:45 ==> NewOverloadFunc Gopx_Var_Cast
2025/10/11 16:12:45 ==> AliasFunc Gopx_Var_Cast => Var_Cast
2025/10/11 16:12:45 ==> NewOverloadNamed Var
2025/10/11 16:12:45.162545 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/10/11 16:12:45 ==> Preload var [a]
2025/10/11 16:12:45 ==> Preload var [b]
2025/10/11 16:12:45 ==> Preload func main
2025/10/11 16:12:45.162615 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/10/11 16:12:45.162647 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:45.162664 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{github.com/goplus/xgo/cl/internal/overload/bar.Var}
2025/10/11 16:12:45.162691 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:45.162710 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:45.162724 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:45.162736 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:45.162771 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int]
2025/10/11 16:12:45.162795 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T github.com/goplus/xgo/cl/internal/overload/bar.basetype] struct{val T}
2025/10/11 16:12:45.162816 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003ead68 72 int 76} github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int]
2025/10/11 16:12:45 ==> Load var github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int] [a]
2025/10/11 16:12:45 NewVarDefs
2025/10/11 16:12:45 NewVar [a]
2025/10/11 16:12:45.162867 [INFO] typesutil/gopinfo.go:251: ==> Def: a var main.a github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int]
2025/10/11 16:12:45.162887 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/10/11 16:12:45.162903 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:45.162915 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{github.com/goplus/xgo/cl/internal/overload/bar.Var}
2025/10/11 16:12:45.162932 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:45.162948 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/10/11 16:12:45.162967 [INFO] typesutil/gopinfo.go:265: ==> Use: M type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any
2025/10/11 16:12:45.162983 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar M} map[string]any
2025/10/11 16:12:45.163082 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
2025/10/11 16:12:45.163104 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T map[string]any] struct{val T}
2025/10/11 16:12:45.163125 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003ead80 91 0xc0003ead98 97} github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
2025/10/11 16:12:45 ==> Load var github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any] [b]
2025/10/11 16:12:45 NewVarDefs
2025/10/11 16:12:45 NewVar [b]
2025/10/11 16:12:45.163168 [INFO] typesutil/gopinfo.go:251: ==> Def: b var main.b github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
2025/10/11 16:12:45 ==> Load func main
2025/10/11 16:12:45.163195 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:45 NewFunc main func()
2025/10/11 16:12:45 DefineVarStart [c]
2025/10/11 16:12:45.163244 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/10/11 16:12:45.163262 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:45.163279 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{github.com/goplus/xgo/cl/internal/overload/bar.Var}
2025/10/11 16:12:45 Val Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:45 Val type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:45 Val string string
2025/10/11 16:12:45 Val type string => Typ string
2025/10/11 16:12:45.163339 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:45.163351 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:45 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/10/11 16:12:45 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/10/11 16:12:45 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/10/11 16:12:45 ==> MatchFuncCall func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:45 boundTypeParams: bar.Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:45.163513 [INFO] typesutil/gopinfo.go:265: ==> Use: Var func github.com/goplus/xgo/cl/internal/overload/bar.Gopx_Var_Cast__0[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T]
2025/10/11 16:12:45.163536 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T]
2025/10/11 16:12:45.163566 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003eadc8 111 [string] 0 [] 118 0} *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[string]
2025/10/11 16:12:45 EndInit 1
2025/10/11 16:12:45.163595 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[string]
2025/10/11 16:12:45 DefineVarStart [d]
2025/10/11 16:12:45.163626 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/10/11 16:12:45.163642 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:45.163654 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{github.com/goplus/xgo/cl/internal/overload/bar.Var}
2025/10/11 16:12:45 Val Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:45 Val type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:45.163694 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/10/11 16:12:45.163707 [INFO] typesutil/gopinfo.go:265: ==> Use: M type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any
2025/10/11 16:12:45 Val M map[string]any
2025/10/11 16:12:45 Val type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any => Typ map[string]any
2025/10/11 16:12:45.163743 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar M} map[string]any
2025/10/11 16:12:45 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/10/11 16:12:45 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/10/11 16:12:45 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/10/11 16:12:45 ==> MatchFuncCall func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:45 boundTypeParams: bar.Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:45 ==> MatchFuncCall func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T] args: 1 flags: 8
2025/10/11 16:12:45 boundTypeParams: bar.Gopx_Var_Cast__1 sig: func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T] args: 1 flags: 8
2025/10/11 16:12:45.163927 [INFO] typesutil/gopinfo.go:265: ==> Use: Var func github.com/goplus/xgo/cl/internal/overload/bar.Gopx_Var_Cast__1[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T]
2025/10/11 16:12:45.163950 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T]
2025/10/11 16:12:45.163974 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003eade0 132 [0xc0003eadf8] 0 [] 138 0} *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
2025/10/11 16:12:45 EndInit 1
2025/10/11 16:12:45.163997 [INFO] typesutil/gopinfo.go:251: ==> Def: d var d *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
2025/10/11 16:12:45.164028 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc00015f5c0 {
.  var c *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[string]
.  var d *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
}

2025/10/11 16:12:45 End // Func
    info_test.go:190: == types ==
        000:  4: 7 | bar.Var             *ast.SelectorExpr              | type    : github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int] | type
        001:  4: 7 | bar.Var[int]        *ast.IndexExpr                 | type    : github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int] | type
        002:  4:15 | int                 *ast.Ident                     | type    : int | type
        003:  5: 7 | bar.Var             *ast.SelectorExpr              | type    : github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any] | type
        004:  5: 7 | bar.Var[bar.M]      *ast.IndexExpr                 | type    : github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any] | type
        005:  5:15 | bar.M               *ast.SelectorExpr              | type    : map[string]any | type
        006:  6: 6 | bar.Var             *ast.SelectorExpr              | value   : func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] | value
        007:  6: 6 | bar.Var(string)     *ast.CallExpr                  | value   : *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[string] | value
        008:  6:14 | string              *ast.Ident                     | type    : string | type
        009:  7: 6 | bar.Var             *ast.SelectorExpr              | value   : func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T] | value
        010:  7: 6 | bar.Var(bar.M)      *ast.CallExpr                  | value   : *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any] | value
        011:  7:14 | bar.M               *ast.SelectorExpr              | var     : map[string]any | variable
        == defs ==
        000:  4: 5 | a                   | var main.a github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int]
        001:  5: 5 | b                   | var main.b github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
        002:  6: 1 | c                   | var c *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[string]
        003:  6: 1 | main                | func main.main()
        004:  7: 1 | d                   | var d *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
        == uses ==
        000:  4: 7 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        001:  4:11 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T github.com/goplus/xgo/cl/internal/overload/bar.basetype] struct{val T}
        002:  4:15 | int                 | type int
        003:  5: 7 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        004:  5:11 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T map[string]any] struct{val T}
        005:  5:15 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        006:  5:19 | M                   | type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any
        007:  6: 6 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        008:  6:10 | Var                 | func github.com/goplus/xgo/cl/internal/overload/bar.Gopx_Var_Cast__0[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T]
        009:  6:14 | string              | type string
        010:  7: 6 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        011:  7:10 | Var                 | func github.com/goplus/xgo/cl/internal/overload/bar.Gopx_Var_Cast__1[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T]
        012:  7:14 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        013:  7:18 | M                   | type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any
        == overloads ==
        000:  4:11 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
        001:  5:11 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
        002:  6:10 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
        003:  7:10 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
--- PASS: TestOverloadNamed (1.23s)
=== RUN   TestMixedOverloadNamed
2025/10/11 16:12:45.165058 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/10/11 16:12:45 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:45 ==> NewOverloadFunc NewRange
2025/10/11 16:12:45 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:45 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:45 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:45 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:45 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:45 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:45 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:45 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:45 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:45 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:45 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:45 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:45 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:45 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:46.385760 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0006b1020 {
}

2025/10/11 16:12:46 ==> Preload var [a]
2025/10/11 16:12:46 ==> Preload var [b]
2025/10/11 16:12:46 ==> Preload func main
2025/10/11 16:12:46 ==> Preload type M
2025/10/11 16:12:46 ==> Preload type basetype
2025/10/11 16:12:46 ==> Preload type Var__0
2025/10/11 16:12:46 ==> Preload type Var__1
2025/10/11 16:12:46 ==> Preload func Gopx_Var_Cast__0
2025/10/11 16:12:46 ==> Preload func Gopx_Var_Cast__1
2025/10/11 16:12:46 ==> Load func Gopx_Var_Cast__0
2025/10/11 16:12:46 ==> Load > NewType basetype
2025/10/11 16:12:46 ==> Lookup (LoadSymbol) basetype => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:46 ==> Load > InitType basetype
2025/10/11 16:12:46 ==> Load > NewType Var__0
2025/10/11 16:12:46 ==> Lookup (LoadSymbol) Var__0 => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:46 ==> EnsureLoaded main.Var__0
2025/10/11 16:12:46 ==> Load > InitType Var__0
2025/10/11 16:12:46 ==> LookupParent basetype => type main.basetype interface{interface{string | int | bool | float64}}
2025/10/11 16:12:46 ==> Load func Gopx_Var_Cast__1
2025/10/11 16:12:46 ==> Load > NewType Var__1
2025/10/11 16:12:46 ==> Lookup (LoadSymbol) Var__1 => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:46 ==> EnsureLoaded main.Var__1
2025/10/11 16:12:46 ==> Load > InitType Var__1
2025/10/11 16:12:46 ==> Load > AliasType M
2025/10/11 16:12:46 ==> NewOverloadFunc Gopx_Var_Cast
2025/10/11 16:12:46 ==> AliasFunc Gopx_Var_Cast => Var_Cast
2025/10/11 16:12:46 ==> NewOverloadNamed Var
2025/10/11 16:12:46 ==> LookupParent Var => type main.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.386268 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.386289 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{main.Var}
2025/10/11 16:12:46.386310 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.386326 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.386340 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:46.386359 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:46.386371 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:46.386399 [INFO] typesutil/gopinfo.go:215: ==> Type: Var main.Var__0[int]
2025/10/11 16:12:46.386421 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var__0[T main.basetype] struct{val T}
2025/10/11 16:12:46.386446 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var 11 int 15} main.Var__0[int]
2025/10/11 16:12:46 ==> Load var main.Var__0[int] [a]
2025/10/11 16:12:46 NewVarDefs
2025/10/11 16:12:46 NewVar [a]
2025/10/11 16:12:46.386502 [INFO] typesutil/gopinfo.go:251: ==> Def: a var main.a main.Var__0[int]
2025/10/11 16:12:46 ==> LookupParent Var => type main.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.386531 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.386544 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{main.Var}
2025/10/11 16:12:46.386559 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.386572 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46 ==> LookupParent M => type main.M = map[string]interface{}
2025/10/11 16:12:46.386598 [INFO] typesutil/gopinfo.go:265: ==> Use: M type main.M = map[string]interface{}
2025/10/11 16:12:46.386612 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/10/11 16:12:46.386626 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/10/11 16:12:46.386683 [INFO] typesutil/gopinfo.go:215: ==> Type: Var main.Var__1[map[string]interface{}]
2025/10/11 16:12:46.386704 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var__1[T map[string]interface{}] struct{val T}
2025/10/11 16:12:46.386726 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var 26 M 28} main.Var__1[map[string]interface{}]
2025/10/11 16:12:46 ==> Load var main.Var__1[map[string]interface{}] [b]
2025/10/11 16:12:46 NewVarDefs
2025/10/11 16:12:46 NewVar [b]
2025/10/11 16:12:46.386771 [INFO] typesutil/gopinfo.go:251: ==> Def: b var main.b main.Var__1[map[string]interface{}]
2025/10/11 16:12:46 ==> Load func main
2025/10/11 16:12:46.386797 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:46 NewFunc main func()
2025/10/11 16:12:46 DefineVarStart [c]
2025/10/11 16:12:46 Val Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46 Val type main.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.386870 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.386892 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{main.Var}
2025/10/11 16:12:46.386905 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46 Val string string
2025/10/11 16:12:46 Val type string => Typ string
2025/10/11 16:12:46.386940 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:46.386952 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:46 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/10/11 16:12:46 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/10/11 16:12:46 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/10/11 16:12:46 ==> MatchFuncCall func[T main.basetype]() *main.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:46 boundTypeParams: Gopx_Var_Cast__0 sig: func[T main.basetype]() *main.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:46.387091 [INFO] typesutil/gopinfo.go:265: ==> Use: Var func main.Gopx_Var_Cast__0[T main.basetype]() *main.Var__0[T]
2025/10/11 16:12:46.387117 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func[T main.basetype]() *main.Var__0[T]
2025/10/11 16:12:46.387145 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var 38 [string] 0 [] 45 0} *main.Var__0[string]
2025/10/11 16:12:46 EndInit 1
2025/10/11 16:12:46.387171 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c *main.Var__0[string]
2025/10/11 16:12:46 DefineVarStart [d]
2025/10/11 16:12:46 Val Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46 Val type main.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.387226 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var = func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46.387247 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{main.Var}
2025/10/11 16:12:46.387260 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:46 Val M map[string]interface{}
2025/10/11 16:12:46 Val type main.M = map[string]interface{} => Typ map[string]interface{}
2025/10/11 16:12:46.387299 [INFO] typesutil/gopinfo.go:265: ==> Use: M type main.M = map[string]interface{}
2025/10/11 16:12:46.387314 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/10/11 16:12:46 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/10/11 16:12:46 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/10/11 16:12:46 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/10/11 16:12:46 ==> MatchFuncCall func[T main.basetype]() *main.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:46 boundTypeParams: Gopx_Var_Cast__0 sig: func[T main.basetype]() *main.Var__0[T] args: 1 flags: 8
2025/10/11 16:12:46 ==> MatchFuncCall func[T map[string]interface{}]() *main.Var__1[T] args: 1 flags: 8
2025/10/11 16:12:46 boundTypeParams: Gopx_Var_Cast__1 sig: func[T map[string]interface{}]() *main.Var__1[T] args: 1 flags: 8
2025/10/11 16:12:46.387496 [INFO] typesutil/gopinfo.go:265: ==> Use: Var func main.Gopx_Var_Cast__1[T map[string]interface{}]() *main.Var__1[T]
2025/10/11 16:12:46.387521 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func[T map[string]interface{}]() *main.Var__1[T]
2025/10/11 16:12:46.387544 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var 55 [M] 0 [] 57 0} *main.Var__1[map[string]interface{}]
2025/10/11 16:12:46 EndInit 1
2025/10/11 16:12:46.387569 [INFO] typesutil/gopinfo.go:251: ==> Def: d var d *main.Var__1[map[string]interface{}]
2025/10/11 16:12:46.387599 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0006b18c0 {
.  var c *main.Var__0[string]
.  var d *main.Var__1[map[string]interface{}]
}

2025/10/11 16:12:46 End // Func
    info_test.go:190: == types ==
        000:  2: 7 | Var                 *ast.Ident                     | type    : main.Var__0[int] | type
        001:  2: 7 | Var[int]            *ast.IndexExpr                 | type    : main.Var__0[int] | type
        002:  2:11 | int                 *ast.Ident                     | type    : int | type
        003:  3: 7 | Var                 *ast.Ident                     | type    : main.Var__1[map[string]interface{}] | type
        004:  3: 7 | Var[M]              *ast.IndexExpr                 | type    : main.Var__1[map[string]interface{}] | type
        005:  3:11 | M                   *ast.Ident                     | type    : map[string]interface{} | type
        006:  4: 6 | Var                 *ast.Ident                     | value   : func[T main.basetype]() *main.Var__0[T] | value
        007:  4: 6 | Var(string)         *ast.CallExpr                  | value   : *main.Var__0[string] | value
        008:  4:10 | string              *ast.Ident                     | type    : string | type
        009:  5: 6 | Var                 *ast.Ident                     | value   : func[T map[string]interface{}]() *main.Var__1[T] | value
        010:  5: 6 | Var(M)              *ast.CallExpr                  | value   : *main.Var__1[map[string]interface{}] | value
        011:  5:10 | M                   *ast.Ident                     | type    : map[string]interface{} | type
        == defs ==
        000:  2: 5 | a                   | var main.a main.Var__0[int]
        001:  3: 5 | b                   | var main.b main.Var__1[map[string]interface{}]
        002:  4: 1 | c                   | var c *main.Var__0[string]
        003:  4: 1 | main                | func main.main()
        004:  5: 1 | d                   | var d *main.Var__1[map[string]interface{}]
        == uses ==
        000:  2: 7 | Var                 | type main.Var__0[T main.basetype] struct{val T}
        001:  2:11 | int                 | type int
        002:  3: 7 | Var                 | type main.Var__1[T map[string]any] struct{val T}
        003:  3:11 | M                   | type main.M = map[string]any
        004:  4: 6 | Var                 | func main.Gopx_Var_Cast__0[T main.basetype]() *main.Var__0[T]
        005:  4:10 | string              | type string
        006:  5: 6 | Var                 | func main.Gopx_Var_Cast__1[T map[string]any]() *main.Var__1[T]
        007:  5:10 | M                   | type main.M = map[string]any
        == overloads ==
        000:  2: 7 | Var                 | type main.Var = func(__xgo_overload_args__ interface{_()})
        001:  3: 7 | Var                 | type main.Var = func(__xgo_overload_args__ interface{_()})
        002:  4: 6 | Var                 | type main.Var = func(__xgo_overload_args__ interface{_()})
        003:  5: 6 | Var                 | type main.Var = func(__xgo_overload_args__ interface{_()})
--- PASS: TestMixedOverloadNamed (1.22s)
=== RUN   TestMixedRawNamed
2025/10/11 16:12:46.389393 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/10/11 16:12:47 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:47 ==> NewOverloadFunc NewRange
2025/10/11 16:12:47 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:47 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:47 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:47 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:47 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:47 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:47 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:47 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:47 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:47 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:47 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:47 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:47 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:47 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:47.679178 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003c5ce0 {
}

2025/10/11 16:12:47 ==> Preload var [a]
2025/10/11 16:12:47 ==> Preload var [b]
2025/10/11 16:12:47 ==> Preload func main
2025/10/11 16:12:47 ==> Preload type M
2025/10/11 16:12:47 ==> Preload type basetype
2025/10/11 16:12:47 ==> Preload type Var__0
2025/10/11 16:12:47 ==> Preload type Var__1
2025/10/11 16:12:47 ==> Preload func Gopx_Var_Cast__0
2025/10/11 16:12:47 ==> Preload func Gopx_Var_Cast__1
2025/10/11 16:12:47 ==> Load > NewType Var__1
2025/10/11 16:12:47 ==> Load > InitType Var__1
2025/10/11 16:12:47 ==> Load func Gopx_Var_Cast__0
2025/10/11 16:12:47 ==> Load > NewType basetype
2025/10/11 16:12:47 ==> Lookup (LoadSymbol) basetype => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:47 ==> Load > InitType basetype
2025/10/11 16:12:47 ==> Load > NewType Var__0
2025/10/11 16:12:47 ==> Lookup (LoadSymbol) Var__0 => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:47 ==> EnsureLoaded main.Var__0
2025/10/11 16:12:47 ==> Load > InitType Var__0
2025/10/11 16:12:47 ==> LookupParent basetype => type main.basetype interface{interface{string | int | bool | float64}}
2025/10/11 16:12:47 ==> Load func Gopx_Var_Cast__1
2025/10/11 16:12:47 ==> LookupParent Var__1 => type main.Var__1[T map[string]interface{}] struct{val T}
2025/10/11 16:12:47 ==> EnsureLoaded main.Var__1[T map[string]interface{}]
2025/10/11 16:12:47 ==> Load > AliasType M
2025/10/11 16:12:47 ==> NewOverloadFunc Gopx_Var_Cast
2025/10/11 16:12:47 ==> AliasFunc Gopx_Var_Cast => Var_Cast
2025/10/11 16:12:47 ==> NewOverloadNamed Var
2025/10/11 16:12:47 ==> LookupParent Var__0 => type main.Var__0[T main.basetype] struct{val T}
2025/10/11 16:12:47.679597 [INFO] typesutil/gopinfo.go:265: ==> Use: Var__0 type main.Var__0[T main.basetype] struct{val T}
2025/10/11 16:12:47.679617 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__0 main.Var__0[T main.basetype]
2025/10/11 16:12:47.679630 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__0 main.Var__0[T main.basetype]
2025/10/11 16:12:47.679643 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:47.679653 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:47.679661 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:47 ==> EnsureLoaded main.Var__0[T main.basetype]
2025/10/11 16:12:47.679694 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__0 main.Var__0[int]
2025/10/11 16:12:47.679712 [INFO] typesutil/gopinfo.go:265: ==> Use: Var__0 type main.Var__0[T main.basetype] struct{val T}
2025/10/11 16:12:47.679731 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var__0 14 int 18} main.Var__0[int]
2025/10/11 16:12:47 ==> Load var main.Var__0[int] [a]
2025/10/11 16:12:47 NewVarDefs
2025/10/11 16:12:47 NewVar [a]
2025/10/11 16:12:47.679770 [INFO] typesutil/gopinfo.go:251: ==> Def: a var main.a main.Var__0[int]
2025/10/11 16:12:47 ==> LookupParent Var__1 => type main.Var__1[T map[string]interface{}] struct{val T}
2025/10/11 16:12:47.679797 [INFO] typesutil/gopinfo.go:265: ==> Use: Var__1 type main.Var__1[T map[string]interface{}] struct{val T}
2025/10/11 16:12:47.679809 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__1 main.Var__1[T map[string]interface{}]
2025/10/11 16:12:47.679821 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__1 main.Var__1[T map[string]interface{}]
2025/10/11 16:12:47 ==> LookupParent M => type main.M = map[string]interface{}
2025/10/11 16:12:47.679843 [INFO] typesutil/gopinfo.go:265: ==> Use: M type main.M = map[string]interface{}
2025/10/11 16:12:47.679855 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/10/11 16:12:47.679867 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/10/11 16:12:47 ==> EnsureLoaded main.Var__1[T map[string]interface{}]
2025/10/11 16:12:47.679898 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__1 main.Var__1[map[string]interface{}]
2025/10/11 16:12:47.679912 [INFO] typesutil/gopinfo.go:265: ==> Use: Var__1 type main.Var__1[T map[string]interface{}] struct{val T}
2025/10/11 16:12:47.679926 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var__1 32 M 34} main.Var__1[map[string]interface{}]
2025/10/11 16:12:47 ==> Load var main.Var__1[map[string]interface{}] [b]
2025/10/11 16:12:47 NewVarDefs
2025/10/11 16:12:47 NewVar [b]
2025/10/11 16:12:47.679959 [INFO] typesutil/gopinfo.go:251: ==> Def: b var main.b main.Var__1[map[string]interface{}]
2025/10/11 16:12:47 ==> Load func main
2025/10/11 16:12:47.679977 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:12:47 NewFunc main func()
2025/10/11 16:12:47 DefineVarStart [c]
2025/10/11 16:12:47 Val Gopx_Var_Cast__0 func[T main.basetype]() *main.Var__0[T]
2025/10/11 16:12:47.680023 [INFO] typesutil/gopinfo.go:265: ==> Use: Gopx_Var_Cast__0 func main.Gopx_Var_Cast__0[T main.basetype]() *main.Var__0[T]
2025/10/11 16:12:47.680057 [INFO] typesutil/gopinfo.go:215: ==> Type: Gopx_Var_Cast__0 func[T main.basetype]() *main.Var__0[T]
2025/10/11 16:12:47 Val string string
2025/10/11 16:12:47 Val type string => Typ string
2025/10/11 16:12:47.680088 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:12:47.680099 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:12:47 Index 1 false
2025/10/11 16:12:47 ==> InferType func() *main.Var__0[string]
2025/10/11 16:12:47.680162 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Gopx_Var_Cast__0 57 string 64} func() *main.Var__0[string]
2025/10/11 16:12:47 EndInit 1
2025/10/11 16:12:47.680185 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c func() *main.Var__0[string]
2025/10/11 16:12:47 DefineVarStart [d]
2025/10/11 16:12:47 Val Gopx_Var_Cast__1 func[T map[string]interface{}]() *main.Var__1[T]
2025/10/11 16:12:47.680221 [INFO] typesutil/gopinfo.go:265: ==> Use: Gopx_Var_Cast__1 func main.Gopx_Var_Cast__1[T map[string]interface{}]() *main.Var__1[T]
2025/10/11 16:12:47.680237 [INFO] typesutil/gopinfo.go:215: ==> Type: Gopx_Var_Cast__1 func[T map[string]interface{}]() *main.Var__1[T]
2025/10/11 16:12:47 Val M map[string]interface{}
2025/10/11 16:12:47 Val type main.M = map[string]interface{} => Typ map[string]interface{}
2025/10/11 16:12:47.680269 [INFO] typesutil/gopinfo.go:265: ==> Use: M type main.M = map[string]interface{}
2025/10/11 16:12:47.680281 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/10/11 16:12:47 Index 1 false
2025/10/11 16:12:47 ==> InferType func() *main.Var__1[map[string]interface{}]
2025/10/11 16:12:47.680336 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Gopx_Var_Cast__1 87 M 89} func() *main.Var__1[map[string]interface{}]
2025/10/11 16:12:47 EndInit 1
2025/10/11 16:12:47.680356 [INFO] typesutil/gopinfo.go:251: ==> Def: d var d func() *main.Var__1[map[string]interface{}]
2025/10/11 16:12:47.680387 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0003d8600 {
.  var c func() *main.Var__0[string]
.  var d func() *main.Var__1[map[string]interface{}]
}

2025/10/11 16:12:47 End // Func
    info_test.go:190: == types ==
        000:  2: 7 | Var__0              *ast.Ident                     | type    : main.Var__0[int] | type
        001:  2: 7 | Var__0[int]         *ast.IndexExpr                 | type    : main.Var__0[int] | type
        002:  2:14 | int                 *ast.Ident                     | type    : int | type
        003:  3: 7 | Var__1              *ast.Ident                     | type    : main.Var__1[map[string]interface{}] | type
        004:  3: 7 | Var__1[M]           *ast.IndexExpr                 | type    : main.Var__1[map[string]interface{}] | type
        005:  3:14 | M                   *ast.Ident                     | type    : map[string]interface{} | type
        006:  4: 6 | Gopx_Var_Cast__0    *ast.Ident                     | value   : func[T main.basetype]() *main.Var__0[T] | value
        007:  4: 6 | Gopx_Var_Cast__0[string] *ast.IndexExpr                 | var     : func() *main.Var__0[string] | variable
        008:  4:23 | string              *ast.Ident                     | type    : string | type
        009:  5: 6 | Gopx_Var_Cast__1    *ast.Ident                     | value   : func[T map[string]interface{}]() *main.Var__1[T] | value
        010:  5: 6 | Gopx_Var_Cast__1[M] *ast.IndexExpr                 | var     : func() *main.Var__1[map[string]interface{}] | variable
        011:  5:23 | M                   *ast.Ident                     | type    : map[string]interface{} | type
        == defs ==
        000:  2: 5 | a                   | var main.a main.Var__0[int]
        001:  3: 5 | b                   | var main.b main.Var__1[map[string]interface{}]
        002:  4: 1 | c                   | var c func() *main.Var__0[string]
        003:  4: 1 | main                | func main.main()
        004:  5: 1 | d                   | var d func() *main.Var__1[map[string]interface{}]
        == uses ==
        000:  2: 7 | Var__0              | type main.Var__0[T main.basetype] struct{val T}
        001:  2:14 | int                 | type int
        002:  3: 7 | Var__1              | type main.Var__1[T map[string]any] struct{val T}
        003:  3:14 | M                   | type main.M = map[string]any
        004:  4: 6 | Gopx_Var_Cast__0    | func main.Gopx_Var_Cast__0[T main.basetype]() *main.Var__0[T]
        005:  4:23 | string              | type string
        006:  5: 6 | Gopx_Var_Cast__1    | func main.Gopx_Var_Cast__1[T map[string]any]() *main.Var__1[T]
        007:  5:23 | M                   | type main.M = map[string]any
--- PASS: TestMixedRawNamed (1.29s)
=== RUN   TestSpxInfo
2025/10/11 16:12:47.681697 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:12:48 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:48 ==> NewOverloadFunc NewRange
2025/10/11 16:12:48 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:48 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:48 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:48 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:48 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:48 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:48 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:48 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:48 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:48 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:48 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:48 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:48 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:48 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:48 ==> ClassFile Kai.tspx
2025/10/11 16:12:48 ==> Import github.com/goplus/xgo/cl/internal/spx
2025/10/11 16:12:48 ==> NewTemplateRecvMethod MyGame Main
2025/10/11 16:12:48 ==> NewTemplateRecvMethod MyGame Run
2025/10/11 16:12:48 ==> NewTemplateRecvMethod Sprite OnKey2
2025/10/11 16:12:48 ==> NewOverloadFunc Gopt_Sprite_Clone
2025/10/11 16:12:48 ==> NewTemplateRecvMethod Sprite Clone
2025/10/11 16:12:48 ==> NewOverloadFunc Gopt_Sprite_OnKey
2025/10/11 16:12:48 ==> NewTemplateRecvMethod Sprite OnKey
2025/10/11 16:12:48 ==> NewOverloadMethod MyGame Broadcast
2025/10/11 16:12:48 ==> NewOverloadFunc Rand
2025/10/11 16:12:48 ==> Import github.com/goplus/xgo/cl/internal/spx/pkg
2025/10/11 16:12:48 ==> NewOverloadMethod Vector Add
2025/10/11 16:12:49 ==> InitClass Kai isProj: false
2025/10/11 16:12:49.004682 [INFO] typesutil/gopinfo.go:332: ==> Scope: Kai.tspx scope 0xc0002c0fc0 {
}

2025/10/11 16:12:49 ==> Preload type Kai
2025/10/11 16:12:49 ==> Preload type info
2025/10/11 16:12:49 ==> Preload method Kai.onInit
2025/10/11 16:12:49 ==> Preload method Kai.onCloned
2025/10/11 16:12:49 ==> Preload method Kai.Main
2025/10/11 16:12:49 ==> Load > NewType Kai
2025/10/11 16:12:49 NewType Kai
2025/10/11 16:12:49 ==> Load > NewType info
2025/10/11 16:12:49 NewType info
2025/10/11 16:12:49 ==> Load > InitType info
2025/10/11 16:12:49.004875 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:49.004902 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:49.004924 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:49.004940 [INFO] typesutil/gopinfo.go:251: ==> Def: x field x int
2025/10/11 16:12:49.004954 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:49.004967 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:49.004979 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:49.004993 [INFO] typesutil/gopinfo.go:251: ==> Def: y field y int
2025/10/11 16:12:49.005022 [INFO] typesutil/gopinfo.go:215: ==> Type: &{28 0xc0005b61e0 false} struct{x int; y int}
2025/10/11 16:12:49 InitType info struct{x int; y int}
2025/10/11 16:12:49.005058 [INFO] typesutil/gopinfo.go:251: ==> Def: info type main.info struct{x int; y int}
2025/10/11 16:12:49 ==> Load > InitType Kai
2025/10/11 16:12:49 ==> Load > NewType MyGame
2025/10/11 16:12:49 NewType MyGame
2025/10/11 16:12:49 ==> Lookup (LoadSymbol) MyGame => %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:49.005131 [INFO] typesutil/gopinfo.go:265: ==> Use: MyGame %!v(PANIC=String method: nil underlying)
2025/10/11 16:12:49.005146 [INFO] typesutil/gopinfo.go:215: ==> Type: MyGame main.MyGame
2025/10/11 16:12:49.005160 [INFO] typesutil/gopinfo.go:215: ==> Type: MyGame main.MyGame
2025/10/11 16:12:49 ==> Load > InitType MyGame
2025/10/11 16:12:49 InitType MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:49.005207 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:49.005224 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:49.005236 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:49.005251 [INFO] typesutil/gopinfo.go:251: ==> Def: a field a int
2025/10/11 16:12:49 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/10/11 16:12:49 ==> LookupParent Kai => type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/10/11 16:12:49.005306 [INFO] typesutil/gopinfo.go:265: ==> Use: Kai type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/10/11 16:12:49.005319 [INFO] typesutil/gopinfo.go:215: ==> Type: Kai main.Kai
2025/10/11 16:12:49.005334 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Kai
2025/10/11 16:12:49 ==> Load method *main.Kai.onInit
2025/10/11 16:12:49.005364 [INFO] typesutil/gopinfo.go:251: ==> Def: onInit func (*main.Kai).onInit()
2025/10/11 16:12:49 ==> LookupParent Kai => type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/10/11 16:12:49.005396 [INFO] typesutil/gopinfo.go:265: ==> Use: Kai type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/10/11 16:12:49.005409 [INFO] typesutil/gopinfo.go:215: ==> Type: Kai main.Kai
2025/10/11 16:12:49.005425 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Kai
2025/10/11 16:12:49 ==> Load method *main.Kai.onCloned
2025/10/11 16:12:49.005450 [INFO] typesutil/gopinfo.go:251: ==> Def: onCloned func (*main.Kai).onCloned()
2025/10/11 16:12:49 ==> LookupParent Kai => type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/10/11 16:12:49.005479 [INFO] typesutil/gopinfo.go:265: ==> Use: Kai type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/10/11 16:12:49.005492 [INFO] typesutil/gopinfo.go:215: ==> Type: Kai main.Kai
2025/10/11 16:12:49.005507 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Kai
2025/10/11 16:12:49 ==> Load method *main.Kai.Main
2025/10/11 16:12:49.005535 [INFO] typesutil/gopinfo.go:251: ==> Def: Main func (*main.Kai).Main()
2025/10/11 16:12:49 NewFunc Main (*main.MyGame) func()
2025/10/11 16:12:49 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/10/11 16:12:49 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/10/11 16:12:49 Val this *main.MyGame
2025/10/11 16:12:49 Call 1 0 // func(game any)
2025/10/11 16:12:49 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/10/11 16:12:49 ==> MatchType *main.MyGame, any
2025/10/11 16:12:49 End // Func
2025/10/11 16:12:49 NewFunc onInit (*main.Kai) func()
2025/10/11 16:12:49 Val this *main.Kai
2025/10/11 16:12:49 Member a -1 // *main.Kai
2025/10/11 16:12:49.005713 [INFO] typesutil/gopinfo.go:265: ==> Use: a field a int
2025/10/11 16:12:49.005729 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/10/11 16:12:49 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:49.005767 [INFO] typesutil/gopinfo.go:215: ==> Type: &{75 INT 1 <nil>} untyped int
2025/10/11 16:12:49 Assign 1 1
2025/10/11 16:12:49 ==> MatchType untyped int (1), int
2025/10/11 16:12:49 Val this *main.Kai
2025/10/11 16:12:49 Member clone 1 // *main.Kai
2025/10/11 16:12:49.005840 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:49.005863 [INFO] typesutil/gopinfo.go:274: ==> Overloads: clone TyTemplateRecvMethod
2025/10/11 16:12:49.005883 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:49 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:49 ==> MatchFuncCall TyTemplateRecvMethod args: 0 flags: 0
2025/10/11 16:12:49 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 16
2025/10/11 16:12:49 ==> MatchFuncCall func(sprite any) args: 1 flags: 16
2025/10/11 16:12:49 ==> MatchType *main.Kai, any
2025/10/11 16:12:49.005952 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__0(sprite any)
2025/10/11 16:12:49.005967 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(sprite any)
2025/10/11 16:12:49 Val this *main.Kai
2025/10/11 16:12:49 Member clone 1 // *main.Kai
2025/10/11 16:12:49.006010 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:49.006021 [INFO] typesutil/gopinfo.go:274: ==> Overloads: clone TyTemplateRecvMethod
2025/10/11 16:12:49.006035 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:49 ==> LookupParent info => type main.info struct{x int; y int}
2025/10/11 16:12:49.006070 [INFO] typesutil/gopinfo.go:265: ==> Use: info type main.info struct{x int; y int}
2025/10/11 16:12:49.006086 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/10/11 16:12:49.006098 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/10/11 16:12:49 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:49.006127 [INFO] typesutil/gopinfo.go:215: ==> Type: &{96 INT 1 <nil>} untyped int
2025/10/11 16:12:49 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:49.006153 [INFO] typesutil/gopinfo.go:215: ==> Type: &{98 INT 2 <nil>} untyped int
2025/10/11 16:12:49 StructLit main.info 2 false
2025/10/11 16:12:49.006179 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/10/11 16:12:49.006201 [INFO] typesutil/gopinfo.go:215: ==> Type: &{info 95 [0xc0005b62d0 0xc0005b64e0] 99 false} main.info
2025/10/11 16:12:49 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:49 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/10/11 16:12:49 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 16
2025/10/11 16:12:49 ==> MatchFuncCall func(sprite any) args: 2 flags: 16
2025/10/11 16:12:49 ==> MatchFuncCall func(sprite any, data any) args: 2 flags: 16
2025/10/11 16:12:49 ==> MatchType *main.Kai, any
2025/10/11 16:12:49 ==> MatchType main.info, any
2025/10/11 16:12:49 ==> EnsureLoaded main.info
2025/10/11 16:12:49.006321 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__1(sprite any, data any)
2025/10/11 16:12:49.006337 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(sprite any, data any)
2025/10/11 16:12:49.006365 [INFO] typesutil/gopinfo.go:215: ==> Type: &{clone 0 [0xc0003ec8c0] 0 [] 0 100} ()
2025/10/11 16:12:49 Val this *main.Kai
2025/10/11 16:12:49 Member clone 1 // *main.Kai
2025/10/11 16:12:49.006408 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:49.006419 [INFO] typesutil/gopinfo.go:274: ==> Overloads: clone TyTemplateRecvMethod
2025/10/11 16:12:49.006433 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:49 ==> LookupParent info => type main.info struct{x int; y int}
2025/10/11 16:12:49.006462 [INFO] typesutil/gopinfo.go:265: ==> Use: info type main.info struct{x int; y int}
2025/10/11 16:12:49.006475 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/10/11 16:12:49.006491 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/10/11 16:12:49 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:49.006519 [INFO] typesutil/gopinfo.go:215: ==> Type: &{114 INT 1 <nil>} untyped int
2025/10/11 16:12:49 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:49.006546 [INFO] typesutil/gopinfo.go:215: ==> Type: &{116 INT 2 <nil>} untyped int
2025/10/11 16:12:49 StructLit main.info 2 false
2025/10/11 16:12:49.006571 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/10/11 16:12:49.006589 [INFO] typesutil/gopinfo.go:215: ==> Type: &{info 113 [0xc0005b6570 0xc0005b65a0] 117 false} main.info
2025/10/11 16:12:49 UnaryOp & flags: 0
2025/10/11 16:12:49 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:12:49.006627 [INFO] typesutil/gopinfo.go:215: ==> Type: &{108 & 0xc0003ec940} *main.info
2025/10/11 16:12:49 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:12:49 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/10/11 16:12:49 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 16
2025/10/11 16:12:49 ==> MatchFuncCall func(sprite any) args: 2 flags: 16
2025/10/11 16:12:49 ==> MatchFuncCall func(sprite any, data any) args: 2 flags: 16
2025/10/11 16:12:49 ==> MatchType *main.Kai, any
2025/10/11 16:12:49 ==> MatchType *main.info, any
2025/10/11 16:12:49 ==> EnsureLoaded main.info
2025/10/11 16:12:49.006739 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__1(sprite any, data any)
2025/10/11 16:12:49.006753 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(sprite any, data any)
2025/10/11 16:12:49.006774 [INFO] typesutil/gopinfo.go:215: ==> Type: &{clone 0 [0xc0001f3dc0] 0 [] 0 118} ()
2025/10/11 16:12:49.006803 [INFO] typesutil/gopinfo.go:332: ==> Scope: func onInit scope 0xc0002c1680 {
.  var this *main.Kai
}

2025/10/11 16:12:49 End // Func
2025/10/11 16:12:49 NewFunc onCloned (*main.Kai) func()
2025/10/11 16:12:49 Val this *main.Kai
2025/10/11 16:12:49 Member say 1 // *main.Kai
2025/10/11 16:12:49.006872 [INFO] typesutil/gopinfo.go:265: ==> Use: say func (*github.com/goplus/xgo/cl/internal/spx.Sprite).Say(msg string, secs ...float64)
2025/10/11 16:12:49.006904 [INFO] typesutil/gopinfo.go:215: ==> Type: say func(msg string, secs ...float64)
2025/10/11 16:12:49 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:12:49.006935 [INFO] typesutil/gopinfo.go:215: ==> Type: &{145 STRING "Hi" <nil>} untyped string
2025/10/11 16:12:49 Call 1 0 // func(msg string, secs ...float64)
2025/10/11 16:12:49 ==> MatchFuncCall func(msg string, secs ...float64) args: 1 flags: 0
2025/10/11 16:12:49 ==> MatchType untyped string ("Hi"), string
2025/10/11 16:12:49.006987 [INFO] typesutil/gopinfo.go:215: ==> Type: &{say 144 [0xc0005b66c0] 0 [] 149 0} ()
2025/10/11 16:12:49.007008 [INFO] typesutil/gopinfo.go:332: ==> Scope: func onCloned scope 0xc0002c17a0 {
.  var this *main.Kai
}

2025/10/11 16:12:49 End // Func
2025/10/11 16:12:49 NewFunc Main (*main.Kai) func()
2025/10/11 16:12:49.007050 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Main scope 0xc0002c1860 {
.  var this *main.Kai
}

2025/10/11 16:12:49 End // Func
2025/10/11 16:12:49 NewFunc main func()
2025/10/11 16:12:49 Val new TyInstruction{gogen.newInstr}
2025/10/11 16:12:49 Val MyGame main.MyGame
2025/10/11 16:12:49 Val type main.MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ main.MyGame
2025/10/11 16:12:49 Call 1 0 // TyInstruction{gogen.newInstr}
2025/10/11 16:12:49 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/10/11 16:12:49 Member Main 0 // *main.MyGame
2025/10/11 16:12:49 Call 0 0 // func()
2025/10/11 16:12:49 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:12:49 End // Func
    info_test.go:190: == types ==
        000:  0: 0 | Kai                 *ast.Ident                     | type    : main.Kai | type
        001:  0: 0 | MyGame              *ast.Ident                     | type    : main.MyGame | type
        002:  3: 4 | int                 *ast.Ident                     | type    : int | type
        003:  6:11 | struct {
        	x int
        	y int
        } *ast.StructType                | type    : struct{x int; y int} | type
        004:  7: 4 | int                 *ast.Ident                     | type    : int | type
        005:  8: 4 | int                 *ast.Ident                     | type    : int | type
        006: 12: 2 | a                   *ast.Ident                     | var     : int | variable
        007: 12: 6 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        008: 13: 2 | clone               *ast.Ident                     | value   : func(sprite any) | value
        009: 14: 2 | clone               *ast.Ident                     | value   : func(sprite any, data any) | value
        010: 14: 2 | clone info{1, 2}    *ast.CallExpr                  | void    : () | no value
        011: 14: 8 | info                *ast.Ident                     | type    : main.info | type
        012: 14: 8 | info{1, 2}          *ast.CompositeLit              | value   : main.info | value
        013: 14:13 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        014: 14:15 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        015: 15: 2 | clone               *ast.Ident                     | value   : func(sprite any, data any) | value
        016: 15: 2 | clone &info{1, 2}   *ast.CallExpr                  | void    : () | no value
        017: 15: 8 | &info{1, 2}         *ast.UnaryExpr                 | value   : *main.info | value
        018: 15: 9 | info                *ast.Ident                     | type    : main.info | type
        019: 15: 9 | info{1, 2}          *ast.CompositeLit              | value   : main.info | value
        020: 15:14 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        021: 15:16 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        022: 19: 2 | say                 *ast.Ident                     | value   : func(msg string, secs ...float64) | value
        023: 19: 2 | say("Hi")           *ast.CallExpr                  | void    : () | no value
        024: 19: 6 | "Hi"                *ast.BasicLit                  | value   : untyped string = "Hi" | constant
        == defs ==
        000:  0: 0 | Main                | func (*main.Kai).Main()
        001:  0: 0 | this                | var this *main.Kai
        002:  3: 2 | a                   | field a int
        003:  6: 6 | info                | type main.info struct{x int; y int}
        004:  7: 2 | x                   | field x int
        005:  8: 2 | y                   | field y int
        006: 11: 6 | onInit              | func (*main.Kai).onInit()
        007: 18: 6 | onCloned            | func (*main.Kai).onCloned()
        == uses ==
        000:  0: 0 | Kai                 | type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
        001:  0: 0 | MyGame              | type main.MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
        002:  3: 4 | int                 | type int
        003:  7: 4 | int                 | type int
        004:  8: 4 | int                 | type int
        005: 12: 2 | a                   | field a int
        006: 13: 2 | clone               | func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__0(sprite any)
        007: 14: 2 | clone               | func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__1(sprite any, data any)
        008: 14: 8 | info                | type main.info struct{x int; y int}
        009: 15: 2 | clone               | func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__1(sprite any, data any)
        010: 15: 9 | info                | type main.info struct{x int; y int}
        011: 19: 2 | say                 | func (*github.com/goplus/xgo/cl/internal/spx.Sprite).Say(msg string, secs ...float64)
        == overloads ==
        000: 13: 2 | clone               | func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
        001: 14: 2 | clone               | func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
        002: 15: 2 | clone               | func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
--- PASS: TestSpxInfo (1.33s)
=== RUN   TestScopesInfo
2025/10/11 16:12:49.008057 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:49 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:49 ==> NewOverloadFunc NewRange
2025/10/11 16:12:49 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:49 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:49 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:49 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:49 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:49 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:49 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:49 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:49 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:49 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:49 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:49 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:49 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:49 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:50.204229 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003a3b00 {
}

2025/10/11 16:12:50.204404 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:50 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:50 ==> NewOverloadFunc NewRange
2025/10/11 16:12:51 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:51 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:51 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:51 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:51 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:51 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:51 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:51 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:51 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:51 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:51 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:51 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:51 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:51 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:51.518438 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00061e960 {
}

2025/10/11 16:12:51.518526 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package fmt
2025/10/11 16:12:51.557804 [INFO] typesutil/gopinfo.go:251: ==> Def: m package m ("math")
2025/10/11 16:12:51.557845 [INFO] typesutil/gopinfo.go:251: ==> Def: _ package _ ("os")
2025/10/11 16:12:51 ==> Preload var [_]
2025/10/11 16:12:51 ==> Preload var [_]
2025/10/11 16:12:51 ==> Load var <nil> [_]
2025/10/11 16:12:51 NewVarDefs
2025/10/11 16:12:51 NewVar [_]
2025/10/11 16:12:51.557905 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/10/11 16:12:51.557928 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:12:51 Val Println func(a ...any) (n int, err error)
2025/10/11 16:12:51.557960 [INFO] typesutil/gopinfo.go:215: ==> Type: &{fmt Println} func(a ...any) (n int, err error)
2025/10/11 16:12:51 EndInit 1
2025/10/11 16:12:51 ==> Load var <nil> [_]
2025/10/11 16:12:51 NewVarDefs
2025/10/11 16:12:51 NewVar [_]
2025/10/11 16:12:51.557995 [INFO] typesutil/gopinfo.go:265: ==> Use: m package m ("math")
2025/10/11 16:12:51.558009 [INFO] typesutil/gopinfo.go:265: ==> Use: Pi const math.Pi untyped float
2025/10/11 16:12:51 Val Pi untyped float
2025/10/11 16:12:51.558028 [INFO] typesutil/gopinfo.go:215: ==> Type: &{m Pi} untyped float
2025/10/11 16:12:51 EndInit 1
2025/10/11 16:12:51.558108 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:52 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:52 ==> NewOverloadFunc NewRange
2025/10/11 16:12:52 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:52 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:52 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:52 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:52 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:52 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:52 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:52 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:52 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:52 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:52 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:52 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:52 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:52 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:52.774935 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000447e60 {
}

2025/10/11 16:12:52 ==> Preload func _
2025/10/11 16:12:52 ==> Load func _
2025/10/11 16:12:52.775006 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:12:52 NewFunc _ func()
2025/10/11 16:12:52.775036 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000447f20 {
}

2025/10/11 16:12:52 End // Func
2025/10/11 16:12:52.775160 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:53 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:53 ==> NewOverloadFunc NewRange
2025/10/11 16:12:53 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:53 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:53 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:53 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:53 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:53 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:53 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:53 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:53 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:53 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:53 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:53 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:53 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:53 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:54.036065 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00047f740 {
}

2025/10/11 16:12:54 ==> Preload func _
2025/10/11 16:12:54 ==> Load func _
2025/10/11 16:12:54.036155 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:54.036179 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:54.036195 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:54.036211 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:12:54.036226 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/10/11 16:12:54.036247 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(x int, y int)
2025/10/11 16:12:54 NewFunc _ func(x int, y int)
2025/10/11 16:12:54.036290 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00047fec0 {
.  var x int
.  var y int
}

2025/10/11 16:12:54 End // Func
2025/10/11 16:12:54.036473 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:54 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:54 ==> NewOverloadFunc NewRange
2025/10/11 16:12:54 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:54 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:54 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:54 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:54 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:54 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:54 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:54 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:54 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:54 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:54 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:54 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:54 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:54 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:55.298877 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002b3740 {
}

2025/10/11 16:12:55 ==> Preload func _
2025/10/11 16:12:55 ==> Load func _
2025/10/11 16:12:55.298962 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:55.298984 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:55.298999 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:55.299014 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:12:55.299028 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/10/11 16:12:55.299049 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(x int, y int)
2025/10/11 16:12:55 NewFunc _ func(x int, y int)
2025/10/11 16:12:55 DefineVarStart [x z]
2025/10/11 16:12:55 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:12:55.299124 [INFO] typesutil/gopinfo.go:215: ==> Type: &{40 INT 1 <nil>} untyped int
2025/10/11 16:12:55 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:12:55.299151 [INFO] typesutil/gopinfo.go:215: ==> Type: &{43 INT 2 <nil>} untyped int
2025/10/11 16:12:55 EndInit 2
2025/10/11 16:12:55 ==> MatchType untyped int (1), int
2025/10/11 16:12:55.299193 [INFO] typesutil/gopinfo.go:251: ==> Def: z var z int
2025/10/11 16:12:55 VarRef _
2025/10/11 16:12:55 Val z int
2025/10/11 16:12:55.299229 [INFO] typesutil/gopinfo.go:265: ==> Use: z var z int
2025/10/11 16:12:55.299242 [INFO] typesutil/gopinfo.go:215: ==> Type: z int
2025/10/11 16:12:55 Assign 1 1
2025/10/11 16:12:55.299278 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002b38c0 {
.  var x int
.  var y int
.  var z int
}

2025/10/11 16:12:55 End // Func
2025/10/11 16:12:55.299440 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:55 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:55 ==> NewOverloadFunc NewRange
2025/10/11 16:12:56 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:56 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:56 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:56 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:56 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:56 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:56 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:56 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:56 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:56 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:56 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:56 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:56 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:56 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:56.540315 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000473320 {
}

2025/10/11 16:12:56 ==> Preload func _
2025/10/11 16:12:56 ==> Load func _
2025/10/11 16:12:56.540400 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:56.540432 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:56.540446 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:56.540463 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:12:56.540479 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/10/11 16:12:56.540493 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:56.540505 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:56.540518 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:56.540531 [INFO] typesutil/gopinfo.go:251: ==> Def: u var u int
2025/10/11 16:12:56.540544 [INFO] typesutil/gopinfo.go:251: ==> Def: _ var _ int
2025/10/11 16:12:56.540565 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(x int, y int) (u int, _ int)
2025/10/11 16:12:56 NewFunc _ func(x int, y int) (u int, _ int)
2025/10/11 16:12:56 Return 0
2025/10/11 16:12:56.540623 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000473560 {
.  var u int
.  var x int
.  var y int
}

2025/10/11 16:12:56 End // Func
2025/10/11 16:12:56.540809 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:57 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:57 ==> NewOverloadFunc NewRange
2025/10/11 16:12:57 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:57 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:57 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:57 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:57 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:57 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:57 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:57 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:57 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:57 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:57 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:57 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:57 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:57 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:57.853006 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00042c420 {
}

2025/10/11 16:12:57 ==> Preload func _
2025/10/11 16:12:57 ==> Load func _
2025/10/11 16:12:57.853091 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:12:57 NewFunc _ func()
2025/10/11 16:12:57 Block
2025/10/11 16:12:57.853133 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:12:57.853151 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:57.853169 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:12:57 ==> Load var int [x]
2025/10/11 16:12:57 NewVarDefs
2025/10/11 16:12:57 NewVar [x]
2025/10/11 16:12:57.853218 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:12:57 VarRef _
2025/10/11 16:12:57 Val x int
2025/10/11 16:12:57.853252 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:12:57.853265 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:12:57 Assign 1 1
2025/10/11 16:12:57.853295 [INFO] typesutil/gopinfo.go:332: ==> Scope: block statement scope 0xc00042c540 {
.  var x int
}

2025/10/11 16:12:57 End // Block
2025/10/11 16:12:57.853320 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00042c4e0 {
}

2025/10/11 16:12:57 End // Func
2025/10/11 16:12:57.853453 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:58 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:58 ==> NewOverloadFunc NewRange
2025/10/11 16:12:58 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:58 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:58 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:58 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:58 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:58 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:58 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:58 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:58 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:58 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:58 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:58 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:58 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:58 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:59.136717 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00047d920 {
}

2025/10/11 16:12:59 ==> Preload func _
2025/10/11 16:12:59 ==> Load func _
2025/10/11 16:12:59.136793 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:12:59 NewFunc _ func()
2025/10/11 16:12:59 If
2025/10/11 16:12:59 Val true untyped bool
2025/10/11 16:12:59.136848 [INFO] typesutil/gopinfo.go:265: ==> Use: true const true untyped bool
2025/10/11 16:12:59.136866 [INFO] typesutil/gopinfo.go:215: ==> Type: true untyped bool
2025/10/11 16:12:59.136883 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc00047da40 {
}

2025/10/11 16:12:59 Then
2025/10/11 16:12:59.136908 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc00047daa0 {
}

2025/10/11 16:12:59 End // If
2025/10/11 16:12:59.136935 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00047d9e0 {
}

2025/10/11 16:12:59 End // Func
2025/10/11 16:12:59.137105 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:12:59 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:12:59 ==> NewOverloadFunc NewRange
2025/10/11 16:12:59 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:12:59 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:12:59 ==> NewOverloadFunc Int128_Init
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:12:59 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:12:59 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:12:59 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:12:59 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:12:59 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:12:59 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:12:59 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:12:59 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:12:59 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:12:59 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:12:59 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:00.344197 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000594180 {
}

2025/10/11 16:13:00 ==> Preload func _
2025/10/11 16:13:00 ==> Load func _
2025/10/11 16:13:00.344248 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:00 NewFunc _ func()
2025/10/11 16:13:00 If
2025/10/11 16:13:00 DefineVarStart [x]
2025/10/11 16:13:00 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:00.344301 [INFO] typesutil/gopinfo.go:215: ==> Type: &{32 INT 0 <nil>} untyped int
2025/10/11 16:13:00 EndInit 1
2025/10/11 16:13:00.344316 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:00 Val x int
2025/10/11 16:13:00.344329 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:00.344335 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:00 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:00.344350 [INFO] typesutil/gopinfo.go:215: ==> Type: &{39 INT 0 <nil>} untyped int
2025/10/11 16:13:00 BinaryOp <
2025/10/11 16:13:00 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:13:00 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:00 ==> MatchType untyped int (0), unboundFuncParam{typ: int}
2025/10/11 16:13:00.344401 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 37 < 0xc0005b75c0} untyped bool
2025/10/11 16:13:00.344411 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc000594600 {
.  var x int
}

2025/10/11 16:13:00 Then
2025/10/11 16:13:00 DefineVarStart [y]
2025/10/11 16:13:00 Val x int
2025/10/11 16:13:00.344432 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:00.344438 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:00 EndInit 1
2025/10/11 16:13:00.344446 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/10/11 16:13:00 VarRef _
2025/10/11 16:13:00 Val y int
2025/10/11 16:13:00.344462 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y int
2025/10/11 16:13:00.344469 [INFO] typesutil/gopinfo.go:215: ==> Type: y int
2025/10/11 16:13:00 Assign 1 1
2025/10/11 16:13:00.344481 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc000594f60 {
.  var y int
}

2025/10/11 16:13:00 End // If
2025/10/11 16:13:00.344492 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000594480 {
}

2025/10/11 16:13:00 End // Func
2025/10/11 16:13:00.344573 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:00 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:00 ==> NewOverloadFunc NewRange
2025/10/11 16:13:01 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:01 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:01 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:01 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:01 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:01 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:01 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:01 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:01 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:01 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:01 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:01 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:01 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:01 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:01.601114 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000548300 {
}

2025/10/11 16:13:01 ==> Preload func _
2025/10/11 16:13:01 ==> Load func _
2025/10/11 16:13:01.601183 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:01 NewFunc _ func()
2025/10/11 16:13:01 Switch
2025/10/11 16:13:01 DefineVarStart [x]
2025/10/11 16:13:01 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:01.601253 [INFO] typesutil/gopinfo.go:215: ==> Type: &{36 INT 0 <nil>} untyped int
2025/10/11 16:13:01 EndInit 1
2025/10/11 16:13:01.601278 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:01 Val x int
2025/10/11 16:13:01.601299 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:01.601312 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:01.601330 [INFO] typesutil/gopinfo.go:332: ==> Scope: switch statement scope 0xc0005484e0 {
.  var x int
}

2025/10/11 16:13:01 Then
2025/10/11 16:13:01 End // Switch
2025/10/11 16:13:01.601365 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000548420 {
}

2025/10/11 16:13:01 End // Func
2025/10/11 16:13:01.601513 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:02 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:02 ==> NewOverloadFunc NewRange
2025/10/11 16:13:02 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:02 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:02 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:02 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:02 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:02 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:02 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:02 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:02 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:02 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:02 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:02 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:02 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:02 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:02.876373 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0005a5020 {
}

2025/10/11 16:13:02 ==> Preload func _
2025/10/11 16:13:02 ==> Load func _
2025/10/11 16:13:02.876454 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:02 NewFunc _ func()
2025/10/11 16:13:02 Switch
2025/10/11 16:13:02 DefineVarStart [x]
2025/10/11 16:13:02 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:02.876548 [INFO] typesutil/gopinfo.go:215: ==> Type: &{37 INT 0 <nil>} untyped int
2025/10/11 16:13:02 EndInit 1
2025/10/11 16:13:02.876581 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:02 Val x int
2025/10/11 16:13:02.876604 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:02.876617 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:02.876636 [INFO] typesutil/gopinfo.go:332: ==> Scope: switch statement scope 0xc0005a51a0 {
.  var x int
}

2025/10/11 16:13:02 Then
2025/10/11 16:13:02 Case
2025/10/11 16:13:02 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:13:02.876680 [INFO] typesutil/gopinfo.go:215: ==> Type: &{49 INT 1 <nil>} untyped int
2025/10/11 16:13:02 Then
2025/10/11 16:13:02 DefineVarStart [y]
2025/10/11 16:13:02 Val x int
2025/10/11 16:13:02.876718 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:02.876730 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:02 EndInit 1
2025/10/11 16:13:02.876747 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/10/11 16:13:02 VarRef _
2025/10/11 16:13:02 Val y int
2025/10/11 16:13:02.876775 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y int
2025/10/11 16:13:02.876785 [INFO] typesutil/gopinfo.go:215: ==> Type: y int
2025/10/11 16:13:02 Assign 1 1
2025/10/11 16:13:02.876820 [INFO] typesutil/gopinfo.go:332: ==> Scope: case statement scope 0xc0005a5260 {
.  var y int
}

2025/10/11 16:13:02 End // Case
2025/10/11 16:13:02 Case
2025/10/11 16:13:02 Then
2025/10/11 16:13:02.876855 [INFO] typesutil/gopinfo.go:332: ==> Scope: case statement scope 0xc0005a5320 {
}

2025/10/11 16:13:02 End // Case
2025/10/11 16:13:02 End // Switch
2025/10/11 16:13:02.876878 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0005a50e0 {
}

2025/10/11 16:13:02 End // Func
2025/10/11 16:13:02.877036 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:03 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:03 ==> NewOverloadFunc NewRange
2025/10/11 16:13:03 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:03 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:03 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:03 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:03 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:03 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:03 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:03 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:03 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:03 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:03 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:03 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:03 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:03 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:04.089665 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0001f0480 {
}

2025/10/11 16:13:04 ==> Preload func _
2025/10/11 16:13:04 ==> Load func _
2025/10/11 16:13:04.089782 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 0xc0003af6e0 false} interface{}
2025/10/11 16:13:04.089802 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t interface{}
2025/10/11 16:13:04.089822 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(t interface{})
2025/10/11 16:13:04 NewFunc _ func(t interface{})
2025/10/11 16:13:04 TypeSwitch
2025/10/11 16:13:04.089859 [INFO] typesutil/gopinfo.go:332: ==> Scope: type switch statement scope 0xc0001f0600 {
}

2025/10/11 16:13:04 Val t interface{}
2025/10/11 16:13:04.089884 [INFO] typesutil/gopinfo.go:265: ==> Use: t var t interface{}
2025/10/11 16:13:04.089898 [INFO] typesutil/gopinfo.go:215: ==> Type: t interface{}
2025/10/11 16:13:04 TypeAssertThen
2025/10/11 16:13:04 End // TypeSwitch
2025/10/11 16:13:04.089934 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0001f05a0 {
.  var t interface{}
}

2025/10/11 16:13:04 End // Func
2025/10/11 16:13:04.090087 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:04 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:04 ==> NewOverloadFunc NewRange
2025/10/11 16:13:05 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:05 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:05 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:05 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:05 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:05 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:05 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:05 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:05 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:05 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:05 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:05 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:05 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:05 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:05.406095 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00038ccc0 {
}

2025/10/11 16:13:05 ==> Preload func _
2025/10/11 16:13:05 ==> Load func _
2025/10/11 16:13:05.406171 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 0xc0002269c0 false} interface{}
2025/10/11 16:13:05.406188 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t interface{}
2025/10/11 16:13:05.406206 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(t interface{})
2025/10/11 16:13:05 NewFunc _ func(t interface{})
2025/10/11 16:13:05 TypeSwitch
2025/10/11 16:13:05.406238 [INFO] typesutil/gopinfo.go:332: ==> Scope: type switch statement scope 0xc00038ce40 {
}

2025/10/11 16:13:05 DefineVarStart [t]
2025/10/11 16:13:05 Val t interface{}
2025/10/11 16:13:05.406276 [INFO] typesutil/gopinfo.go:265: ==> Use: t var t interface{}
2025/10/11 16:13:05.406286 [INFO] typesutil/gopinfo.go:215: ==> Type: t interface{}
2025/10/11 16:13:05 EndInit 1
2025/10/11 16:13:05.406306 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t interface{}
2025/10/11 16:13:05 Val t interface{}
2025/10/11 16:13:05.406323 [INFO] typesutil/gopinfo.go:265: ==> Use: t var t interface{}
2025/10/11 16:13:05.406335 [INFO] typesutil/gopinfo.go:215: ==> Type: t interface{}
2025/10/11 16:13:05 TypeAssertThen
2025/10/11 16:13:05 End // TypeSwitch
2025/10/11 16:13:05.406368 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00038cde0 {
.  var t interface{}
}

2025/10/11 16:13:05 End // Func
2025/10/11 16:13:05.406523 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:06 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:06 ==> NewOverloadFunc NewRange
2025/10/11 16:13:06 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:06 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:06 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:06 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:06 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:06 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:06 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:06 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:06 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:06 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:06 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:06 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:06 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:06 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:06.757958 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000309b60 {
}

2025/10/11 16:13:06 ==> Preload func _
2025/10/11 16:13:06 ==> Load func _
2025/10/11 16:13:06.758065 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 0xc000611bc0 false} interface{}
2025/10/11 16:13:06.758089 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t interface{}
2025/10/11 16:13:06.758112 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(t interface{})
2025/10/11 16:13:06 NewFunc _ func(t interface{})
2025/10/11 16:13:06 TypeSwitch
2025/10/11 16:13:06.758155 [INFO] typesutil/gopinfo.go:332: ==> Scope: type switch statement scope 0xc000309ce0 {
}

2025/10/11 16:13:06 Val t interface{}
2025/10/11 16:13:06.758182 [INFO] typesutil/gopinfo.go:265: ==> Use: t var t interface{}
2025/10/11 16:13:06.758196 [INFO] typesutil/gopinfo.go:215: ==> Type: t interface{}
2025/10/11 16:13:06 TypeAssertThen
2025/10/11 16:13:06 TypeCase
2025/10/11 16:13:06 Val int int
2025/10/11 16:13:06 Val type int => Typ int
2025/10/11 16:13:06.758252 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:06.758265 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:06 Then
2025/10/11 16:13:06 VarRef _
2025/10/11 16:13:06 Val x int
2025/10/11 16:13:06.758307 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:06.758319 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:06 Assign 1 1
2025/10/11 16:13:06.758348 [INFO] typesutil/gopinfo.go:332: ==> Scope: type case statement scope 0xc000309d40 {
.  var x int
}

2025/10/11 16:13:06 End // TypeCase
2025/10/11 16:13:06 End // TypeSwitch
2025/10/11 16:13:06.758390 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000309c80 {
.  var t interface{}
}

2025/10/11 16:13:06 End // Func
2025/10/11 16:13:06.758542 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:07 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:07 ==> NewOverloadFunc NewRange
2025/10/11 16:13:07 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:07 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:07 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:07 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:07 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:07 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:07 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:07 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:07 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:07 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:07 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:07 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:07 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:07 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:08.074637 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0004420c0 {
}

2025/10/11 16:13:08 ==> Preload func _
2025/10/11 16:13:08 ==> Load func _
2025/10/11 16:13:08.074809 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:08 NewFunc _ func()
2025/10/11 16:13:08 Select
2025/10/11 16:13:08 End // Select
2025/10/11 16:13:08.075397 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00050e060 {
}

2025/10/11 16:13:08 End // Func
2025/10/11 16:13:08.075569 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:08 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:08 ==> NewOverloadFunc NewRange
2025/10/11 16:13:08 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:08 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:08 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:08 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:08 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:08 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:08 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:08 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:08 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:08 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:08 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:08 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:08 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:08 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:09.248860 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000697080 {
}

2025/10/11 16:13:09 ==> Preload func _
2025/10/11 16:13:09 ==> Load func _
2025/10/11 16:13:09.248932 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:09.248954 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:09.248967 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:09.248994 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 0 3 int} chan int
2025/10/11 16:13:09.249010 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c chan int
2025/10/11 16:13:09.249032 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(c chan int)
2025/10/11 16:13:09 NewFunc _ func(c chan int)
2025/10/11 16:13:09 Select
2025/10/11 16:13:09 CommCase
2025/10/11 16:13:09 Val c chan int
2025/10/11 16:13:09.249094 [INFO] typesutil/gopinfo.go:265: ==> Use: c var c chan int
2025/10/11 16:13:09.249107 [INFO] typesutil/gopinfo.go:215: ==> Type: c chan int
2025/10/11 16:13:09 UnaryOp <- flags: 0
2025/10/11 16:13:09 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/10/11 16:13:09.249153 [INFO] typesutil/gopinfo.go:215: ==> Type: &{48 <- c} int
2025/10/11 16:13:09 Then
2025/10/11 16:13:09.249189 [INFO] typesutil/gopinfo.go:332: ==> Scope: comm case statement scope 0xc000697380 {
}

2025/10/11 16:13:09 End // CommCase
2025/10/11 16:13:09 End // Select
2025/10/11 16:13:09.249231 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000697200 {
.  var c chan int
}

2025/10/11 16:13:09 End // Func
2025/10/11 16:13:09.249411 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:09 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:09 ==> NewOverloadFunc NewRange
2025/10/11 16:13:10 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:10 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:10 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:10 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:10 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:10 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:10 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:10 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:10 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:10 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:10 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:10 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:10 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:10 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:10.552015 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002ef980 {
}

2025/10/11 16:13:10 ==> Preload func _
2025/10/11 16:13:10 ==> Load func _
2025/10/11 16:13:10.552127 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:10.552150 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:10.552163 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:10.552187 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 0 3 int} chan int
2025/10/11 16:13:10.552203 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c chan int
2025/10/11 16:13:10.552221 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(c chan int)
2025/10/11 16:13:10 NewFunc _ func(c chan int)
2025/10/11 16:13:10 Select
2025/10/11 16:13:10 CommCase
2025/10/11 16:13:10 DefineVarStart [i]
2025/10/11 16:13:10 Val c chan int
2025/10/11 16:13:10.552287 [INFO] typesutil/gopinfo.go:265: ==> Use: c var c chan int
2025/10/11 16:13:10.552300 [INFO] typesutil/gopinfo.go:215: ==> Type: c chan int
2025/10/11 16:13:10 UnaryOp <- flags: 0
2025/10/11 16:13:10 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/10/11 16:13:10.552343 [INFO] typesutil/gopinfo.go:215: ==> Type: &{53 <- c} int
2025/10/11 16:13:10 EndInit 1
2025/10/11 16:13:10.552363 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:13:10 Then
2025/10/11 16:13:10 DefineVarStart [x]
2025/10/11 16:13:10 Val i int
2025/10/11 16:13:10.552396 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:13:10.552408 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:13:10 EndInit 1
2025/10/11 16:13:10.552426 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:10 VarRef _
2025/10/11 16:13:10 Val x int
2025/10/11 16:13:10.552451 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:10.552461 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:10 Assign 1 1
2025/10/11 16:13:10.552491 [INFO] typesutil/gopinfo.go:332: ==> Scope: comm case statement scope 0xc0002efbc0 {
.  var i int
.  var x int
}

2025/10/11 16:13:10 End // CommCase
2025/10/11 16:13:10 End // Select
2025/10/11 16:13:10.552535 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002efaa0 {
.  var c chan int
}

2025/10/11 16:13:10 End // Func
2025/10/11 16:13:10.552713 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:11 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:11 ==> NewOverloadFunc NewRange
2025/10/11 16:13:11 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:11 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:11 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:11 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:11 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:11 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:11 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:11 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:11 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:11 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:11 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:11 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:11 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:11 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:11.785141 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000324c00 {
}

2025/10/11 16:13:11 ==> Preload func _
2025/10/11 16:13:11 ==> Load func _
2025/10/11 16:13:11.785214 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:11 NewFunc _ func()
2025/10/11 16:13:11 For
2025/10/11 16:13:11.785247 [INFO] typesutil/gopinfo.go:332: ==> Scope: for statement scope 0xc000324d20 {
}

2025/10/11 16:13:11 None
2025/10/11 16:13:11 Then
2025/10/11 16:13:11.785267 [INFO] typesutil/gopinfo.go:332: ==> Scope: for body scope 0xc000324d80 {
}

2025/10/11 16:13:11 End // For
2025/10/11 16:13:11.785292 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000324cc0 {
}

2025/10/11 16:13:11 End // Func
2025/10/11 16:13:11.785442 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:12 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:12 ==> NewOverloadFunc NewRange
2025/10/11 16:13:12 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:12 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:12 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:12 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:12 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:12 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:12 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:12 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:12 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:12 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:12 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:12 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:12 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:12 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:13.119312 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00018d080 {
}

2025/10/11 16:13:13 ==> Preload func _
2025/10/11 16:13:13 ==> Load func _
2025/10/11 16:13:13.119395 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:13.119414 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:13.119426 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:13.119440 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n int
2025/10/11 16:13:13.119458 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(n int)
2025/10/11 16:13:13 NewFunc _ func(n int)
2025/10/11 16:13:13 For
2025/10/11 16:13:13.119495 [INFO] typesutil/gopinfo.go:332: ==> Scope: for statement scope 0xc00018d200 {
}

2025/10/11 16:13:13 DefineVarStart [i]
2025/10/11 16:13:13 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:13.119547 [INFO] typesutil/gopinfo.go:215: ==> Type: &{39 INT 0 <nil>} untyped int
2025/10/11 16:13:13 EndInit 1
2025/10/11 16:13:13.119569 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:13:13 Val i int
2025/10/11 16:13:13.119592 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:13:13.119605 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:13:13 Val n int
2025/10/11 16:13:13.119623 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n int
2025/10/11 16:13:13.119632 [INFO] typesutil/gopinfo.go:215: ==> Type: n int
2025/10/11 16:13:13 BinaryOp <
2025/10/11 16:13:13 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:13:13 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:13 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:13.119730 [INFO] typesutil/gopinfo.go:215: ==> Type: &{i 44 < n} untyped bool
2025/10/11 16:13:13 Then
2025/10/11 16:13:13.119757 [INFO] typesutil/gopinfo.go:332: ==> Scope: for body scope 0xc00018d380 {
}

2025/10/11 16:13:13 VarRef _
2025/10/11 16:13:13 Val i int
2025/10/11 16:13:13.119784 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:13:13.119795 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:13:13 Assign 1 1
2025/10/11 16:13:13 Post
2025/10/11 16:13:13 VarRef i int
2025/10/11 16:13:13.119830 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:13:13.119841 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:13:13 IncDec ++
2025/10/11 16:13:13 End // For
2025/10/11 16:13:13.119877 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00018d1a0 {
.  var n int
}

2025/10/11 16:13:13 End // Func
2025/10/11 16:13:13.120054 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:13 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:13 ==> NewOverloadFunc NewRange
2025/10/11 16:13:13 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:13 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:13 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:13 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:13 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:13 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:13 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:13 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:13 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:13 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:13 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:13 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:13 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:13 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:14.327565 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002a90e0 {
}

2025/10/11 16:13:14 ==> Preload func _
2025/10/11 16:13:14 ==> Load func _
2025/10/11 16:13:14.327618 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:14.327630 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:14.327637 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:14.327673 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 <nil> int} []int
2025/10/11 16:13:14.327682 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []int
2025/10/11 16:13:14.327692 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(a []int)
2025/10/11 16:13:14 NewFunc _ func(a []int)
2025/10/11 16:13:14 ForRange [i]
2025/10/11 16:13:14 Val a []int
2025/10/11 16:13:14.327723 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []int
2025/10/11 16:13:14.327730 [INFO] typesutil/gopinfo.go:215: ==> Type: a []int
2025/10/11 16:13:14 RangeAssignThen
2025/10/11 16:13:14.327743 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:13:14.327753 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0002a9260 {
.  var i int
}

2025/10/11 16:13:14 VBlock
2025/10/11 16:13:14 VarRef _
2025/10/11 16:13:14 Val i int
2025/10/11 16:13:14.327773 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:13:14.327779 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:13:14 Assign 1 1
2025/10/11 16:13:14.327789 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc0002a9380 {
}

2025/10/11 16:13:14 End // Vblock
2025/10/11 16:13:14 End // ForRange
2025/10/11 16:13:14.327812 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002a9200 {
.  var a []int
}

2025/10/11 16:13:14 End // Func
2025/10/11 16:13:14.327919 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:15 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:15 ==> NewOverloadFunc NewRange
2025/10/11 16:13:15 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:15 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:15 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:15 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:15 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:15 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:15 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:15 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:15 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:15 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:15 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:15 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:15 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:15 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:15.579717 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002b0a20 {
}

2025/10/11 16:13:15 ==> Preload var [s]
2025/10/11 16:13:15 ==> Preload func _
2025/10/11 16:13:15.579808 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:15.579830 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:15.579845 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:15 ==> Load var int [s]
2025/10/11 16:13:15 NewVarDefs
2025/10/11 16:13:15 NewVar [s]
2025/10/11 16:13:15.579889 [INFO] typesutil/gopinfo.go:251: ==> Def: s var s int
2025/10/11 16:13:15 ==> Load func _
2025/10/11 16:13:15.579911 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:15.579925 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:15.579937 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:15.579959 [INFO] typesutil/gopinfo.go:215: ==> Type: &{34 <nil> int} []int
2025/10/11 16:13:15.579986 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []int
2025/10/11 16:13:15.580007 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(a []int)
2025/10/11 16:13:15 NewFunc _ func(a []int)
2025/10/11 16:13:15 ForRange [i x]
2025/10/11 16:13:15 Val a []int
2025/10/11 16:13:15.580104 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []int
2025/10/11 16:13:15.580118 [INFO] typesutil/gopinfo.go:215: ==> Type: a []int
2025/10/11 16:13:15 RangeAssignThen
2025/10/11 16:13:15.580139 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:13:15.580151 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:15.580178 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0002b0c00 {
.  var i int
.  var x int
}

2025/10/11 16:13:15 VBlock
2025/10/11 16:13:15 VarRef s int
2025/10/11 16:13:15.580212 [INFO] typesutil/gopinfo.go:265: ==> Use: s var s int
2025/10/11 16:13:15.580226 [INFO] typesutil/gopinfo.go:215: ==> Type: s int
2025/10/11 16:13:15 Val x int
2025/10/11 16:13:15.580246 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:15.580257 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:15 AssignOp += Gop_AddAssign
2025/10/11 16:13:15 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/10/11 16:13:15 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/10/11 16:13:15 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:15 VarRef _
2025/10/11 16:13:15 Val i int
2025/10/11 16:13:15.580393 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:13:15.580405 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:13:15 Assign 1 1
2025/10/11 16:13:15.580428 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc0002b0d80 {
}

2025/10/11 16:13:15 End // Vblock
2025/10/11 16:13:15 End // ForRange
2025/10/11 16:13:15.580467 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002b0ba0 {
.  var a []int
}

2025/10/11 16:13:15 End // Func
2025/10/11 16:13:15.580675 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:16 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:16 ==> NewOverloadFunc NewRange
2025/10/11 16:13:16 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:16 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:16 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:16 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:16 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:16 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:16 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:16 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:16 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:16 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:16 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:16 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:16 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:16 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:16.857671 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00018fe60 {
}

2025/10/11 16:13:16 ==> Preload var [s]
2025/10/11 16:13:16 ==> Preload func _
2025/10/11 16:13:16.857761 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:16.857782 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:16.857799 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:16 ==> Load var int [s]
2025/10/11 16:13:16 NewVarDefs
2025/10/11 16:13:16 NewVar [s]
2025/10/11 16:13:16.857835 [INFO] typesutil/gopinfo.go:251: ==> Def: s var s int
2025/10/11 16:13:16 ==> Load func _
2025/10/11 16:13:16.857855 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:16.857873 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:16.857886 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:16.857905 [INFO] typesutil/gopinfo.go:215: ==> Type: &{34 <nil> int} []int
2025/10/11 16:13:16.857917 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []int
2025/10/11 16:13:16.857936 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(a []int)
2025/10/11 16:13:16 NewFunc _ func(a []int)
2025/10/11 16:13:16 ForRange [i x]
2025/10/11 16:13:16 Val a []int
2025/10/11 16:13:16.857996 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []int
2025/10/11 16:13:16.858007 [INFO] typesutil/gopinfo.go:215: ==> Type: a []int
2025/10/11 16:13:16 RangeAssignThen
2025/10/11 16:13:16.858031 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:13:16.858057 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:16.858080 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0002180c0 {
.  var i int
.  var x int
}

2025/10/11 16:13:16 VBlock
2025/10/11 16:13:16 DefineVarStart [c]
2025/10/11 16:13:16 Val i int
2025/10/11 16:13:16.858123 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:13:16.858137 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:13:16 EndInit 1
2025/10/11 16:13:16.858154 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c int
2025/10/11 16:13:16 Val println func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:16.858184 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/10/11 16:13:16.858200 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/10/11 16:13:16 Val c int
2025/10/11 16:13:16.858224 [INFO] typesutil/gopinfo.go:265: ==> Use: c var c int
2025/10/11 16:13:16.858235 [INFO] typesutil/gopinfo.go:215: ==> Type: c int
2025/10/11 16:13:16 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:16 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:13:16 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:13:16 ==> MatchType int, any
2025/10/11 16:13:16.858304 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:13:16.858318 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/10/11 16:13:16.858340 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 80 [c] 0 [] 82 0} (n int, err error)
2025/10/11 16:13:16.858371 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc000218240 {
.  var c int
}

2025/10/11 16:13:16 End // Vblock
2025/10/11 16:13:16 End // ForRange
2025/10/11 16:13:16.858404 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000218060 {
.  var a []int
}

2025/10/11 16:13:16 End // Func
2025/10/11 16:13:16.858612 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:17 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:17 ==> NewOverloadFunc NewRange
2025/10/11 16:13:17 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:17 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:17 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:17 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:17 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:17 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:17 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:17 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:17 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:17 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:17 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:17 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:17 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:17 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:18.157202 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00023d4a0 {
}

2025/10/11 16:13:18 ==> Preload func _
2025/10/11 16:13:18 ==> Load func _
2025/10/11 16:13:18.157282 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:18 NewFunc _ func()
2025/10/11 16:13:18 DefineVarStart [sum]
2025/10/11 16:13:18 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:18.157359 [INFO] typesutil/gopinfo.go:215: ==> Type: &{31 INT 0 <nil>} untyped int
2025/10/11 16:13:18 EndInit 1
2025/10/11 16:13:18.157388 [INFO] typesutil/gopinfo.go:251: ==> Def: sum var sum int
2025/10/11 16:13:18 ForRange [_ x]
2025/10/11 16:13:18 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:13:18.157426 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 INT 1 <nil>} untyped int
2025/10/11 16:13:18 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:13:18.157453 [INFO] typesutil/gopinfo.go:215: ==> Type: &{47 INT 3 <nil>} untyped int
2025/10/11 16:13:18 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:13:18.157479 [INFO] typesutil/gopinfo.go:215: ==> Type: &{50 INT 5 <nil>} untyped int
2025/10/11 16:13:18 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:13:18.157505 [INFO] typesutil/gopinfo.go:215: ==> Type: &{53 INT 7 <nil>} untyped int
2025/10/11 16:13:18 Val &{0 INT 11} *ast.BasicLit
2025/10/11 16:13:18.157529 [INFO] typesutil/gopinfo.go:215: ==> Type: &{56 INT 11 <nil>} untyped int
2025/10/11 16:13:18 Val &{0 INT 13} *ast.BasicLit
2025/10/11 16:13:18.157553 [INFO] typesutil/gopinfo.go:215: ==> Type: &{60 INT 13 <nil>} untyped int
2025/10/11 16:13:18 Val &{0 INT 17} *ast.BasicLit
2025/10/11 16:13:18.157576 [INFO] typesutil/gopinfo.go:215: ==> Type: &{64 INT 17 <nil>} untyped int
2025/10/11 16:13:18 SliceLit <nil> 7 false
2025/10/11 16:13:18 RangeAssignThen
2025/10/11 16:13:18.157608 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:18.157629 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00023d620 {
.  var x int
}

2025/10/11 16:13:18 If
2025/10/11 16:13:18 Val x int
2025/10/11 16:13:18.157661 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:18.157680 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:18 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:13:18.157709 [INFO] typesutil/gopinfo.go:215: ==> Type: &{73 INT 3 <nil>} untyped int
2025/10/11 16:13:18 BinaryOp >
2025/10/11 16:13:18 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:13:18 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:18 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:13:18.157809 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 71 > 0xc0003afb60} untyped bool
2025/10/11 16:13:18 Then
2025/10/11 16:13:18 VarRef sum int
2025/10/11 16:13:18.157854 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:13:18.157866 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:13:18 Val sum int
2025/10/11 16:13:18.157889 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:13:18.157901 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:13:18 Val x int
2025/10/11 16:13:18.158190 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:18.158212 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:18 BinaryOp +
2025/10/11 16:13:18 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:18 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:18 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:18.159552 [INFO] typesutil/gopinfo.go:215: ==> Type: &{sum 87 + x} int
2025/10/11 16:13:18 Assign 1 1
2025/10/11 16:13:18 ==> MatchType int, int
2025/10/11 16:13:18 DefineVarStart [c]
2025/10/11 16:13:18 Val sum int
2025/10/11 16:13:18.160302 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:13:18.160332 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:13:18 EndInit 1
2025/10/11 16:13:18.160358 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c int
2025/10/11 16:13:18 VarRef _
2025/10/11 16:13:18 Val c int
2025/10/11 16:13:18.160389 [INFO] typesutil/gopinfo.go:265: ==> Use: c var c int
2025/10/11 16:13:18.160405 [INFO] typesutil/gopinfo.go:215: ==> Type: c int
2025/10/11 16:13:18 Assign 1 1
2025/10/11 16:13:18.160440 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc00023d860 {
.  var c int
}

2025/10/11 16:13:18 End // If
2025/10/11 16:13:18 End // ForRange
2025/10/11 16:13:18.160485 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00023d560 {
.  var sum int
}

2025/10/11 16:13:18 End // Func
2025/10/11 16:13:18.160716 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:18 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:18 ==> NewOverloadFunc NewRange
2025/10/11 16:13:18 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:18 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:18 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:18 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:18 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:18 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:18 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:18 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:18 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:18 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:18 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:18 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:18 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:18 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:19.354838 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00044aa80 {
}

2025/10/11 16:13:19 ==> Preload func _
2025/10/11 16:13:19 ==> Load func _
2025/10/11 16:13:19.354909 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:19 NewFunc _ func()
2025/10/11 16:13:19 DefineVarStart [sum]
2025/10/11 16:13:19 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:19.354975 [INFO] typesutil/gopinfo.go:215: ==> Type: &{31 INT 0 <nil>} untyped int
2025/10/11 16:13:19 EndInit 1
2025/10/11 16:13:19.354999 [INFO] typesutil/gopinfo.go:251: ==> Def: sum var sum int
2025/10/11 16:13:19 ForRange [_ x]
2025/10/11 16:13:19 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:13:19.355031 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 INT 1 <nil>} untyped int
2025/10/11 16:13:19 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:13:19.355051 [INFO] typesutil/gopinfo.go:215: ==> Type: &{47 INT 3 <nil>} untyped int
2025/10/11 16:13:19 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:13:19.355069 [INFO] typesutil/gopinfo.go:215: ==> Type: &{50 INT 5 <nil>} untyped int
2025/10/11 16:13:19 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:13:19.355088 [INFO] typesutil/gopinfo.go:215: ==> Type: &{53 INT 7 <nil>} untyped int
2025/10/11 16:13:19 Val &{0 INT 11} *ast.BasicLit
2025/10/11 16:13:19.355107 [INFO] typesutil/gopinfo.go:215: ==> Type: &{56 INT 11 <nil>} untyped int
2025/10/11 16:13:19 Val &{0 INT 13} *ast.BasicLit
2025/10/11 16:13:19.355123 [INFO] typesutil/gopinfo.go:215: ==> Type: &{60 INT 13 <nil>} untyped int
2025/10/11 16:13:19 Val &{0 INT 17} *ast.BasicLit
2025/10/11 16:13:19.355143 [INFO] typesutil/gopinfo.go:215: ==> Type: &{64 INT 17 <nil>} untyped int
2025/10/11 16:13:19 SliceLit <nil> 7 false
2025/10/11 16:13:19 RangeAssignThen
2025/10/11 16:13:19.355167 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:19.355183 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00044ac00 {
.  var x int
}

2025/10/11 16:13:19 VBlock
2025/10/11 16:13:19 VarRef sum int
2025/10/11 16:13:19.355208 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:13:19.355222 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:13:19 Val sum int
2025/10/11 16:13:19.355245 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:13:19.355254 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:13:19 Val x int
2025/10/11 16:13:19.355268 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:19.355277 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:19 BinaryOp +
2025/10/11 16:13:19 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:19 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:19 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:19.355346 [INFO] typesutil/gopinfo.go:215: ==> Type: &{sum 80 + x} int
2025/10/11 16:13:19 Assign 1 1
2025/10/11 16:13:19 ==> MatchType int, int
2025/10/11 16:13:19 DefineVarStart [c]
2025/10/11 16:13:19 Val sum int
2025/10/11 16:13:19.355385 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/10/11 16:13:19.355396 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/10/11 16:13:19 EndInit 1
2025/10/11 16:13:19.355411 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c int
2025/10/11 16:13:19 VarRef _
2025/10/11 16:13:19 Val c int
2025/10/11 16:13:19.355435 [INFO] typesutil/gopinfo.go:265: ==> Use: c var c int
2025/10/11 16:13:19.355443 [INFO] typesutil/gopinfo.go:215: ==> Type: c int
2025/10/11 16:13:19 Assign 1 1
2025/10/11 16:13:19.355466 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc00044ad20 {
.  var c int
}

2025/10/11 16:13:19 End // Vblock
2025/10/11 16:13:19 End // ForRange
2025/10/11 16:13:19.355497 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00044ab40 {
.  var sum int
}

2025/10/11 16:13:19 End // Func
2025/10/11 16:13:19.355662 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:20 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:20 ==> NewOverloadFunc NewRange
2025/10/11 16:13:20 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:20 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:20 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:20 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:20 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:20 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:20 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:20 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:20 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:20 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:20 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:20 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:20 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:20 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:20.615542 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003a03c0 {
}

2025/10/11 16:13:20 ==> Preload func test
2025/10/11 16:13:20 ==> Preload func _
2025/10/11 16:13:20 ==> Load func test
2025/10/11 16:13:20.615643 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:20.615668 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:20.615679 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:20.615691 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:20.615705 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:20.615717 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:20.615744 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 <nil> 0xc000980090 0xc0009800c0} func(int) int
2025/10/11 16:13:20.615758 [INFO] typesutil/gopinfo.go:251: ==> Def: fn var fn func(int) int
2025/10/11 16:13:20.615781 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test(fn func(int) int)
2025/10/11 16:13:20 NewFunc test func(fn func(int) int)
2025/10/11 16:13:20.615818 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc0003a0d80 {
.  var fn func(int) int
}

2025/10/11 16:13:20 End // Func
2025/10/11 16:13:20 ==> Load func _
2025/10/11 16:13:20.615865 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:20 NewFunc _ func()
2025/10/11 16:13:20 Val test func(fn func(int) int)
2025/10/11 16:13:20.615903 [INFO] typesutil/gopinfo.go:265: ==> Use: test func test(fn func(int) int)
2025/10/11 16:13:20.615917 [INFO] typesutil/gopinfo.go:215: ==> Type: test func(fn func(int) int)
2025/10/11 16:13:20.615931 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:20.615942 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:20.615951 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:20.615964 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:20.615978 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:20.615988 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:20.616000 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:20.616020 [INFO] typesutil/gopinfo.go:215: ==> Type: &{57 <nil> 0xc000980270 0xc0009802a0} func(x int) int
2025/10/11 16:13:20.616056 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002aae20 0xc000980360} func(x int) int
2025/10/11 16:13:20 NewClosure func(x int) int
2025/10/11 16:13:20 DefineVarStart [y]
2025/10/11 16:13:20 Val x int
2025/10/11 16:13:20.616103 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:20.616118 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:20 Val x int
2025/10/11 16:13:20.616159 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:20.616167 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:20 BinaryOp *
2025/10/11 16:13:20 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:20 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:20 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:20.616255 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 81 * x} int
2025/10/11 16:13:20 EndInit 1
2025/10/11 16:13:20.616272 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/10/11 16:13:20 Val y int
2025/10/11 16:13:20.616290 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y int
2025/10/11 16:13:20.616302 [INFO] typesutil/gopinfo.go:215: ==> Type: y int
2025/10/11 16:13:20 Return 1
2025/10/11 16:13:20 ==> MatchType int, int
2025/10/11 16:13:20.616336 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003a0fc0 {
.  var x int
.  var y int
}

2025/10/11 16:13:20 End // Func
2025/10/11 16:13:20 Call 1 0 // func(fn func(int) int)
2025/10/11 16:13:20 ==> MatchFuncCall func(fn func(int) int) args: 1 flags: 0
2025/10/11 16:13:20 ==> MatchType func(x int) int, func(int) int
2025/10/11 16:13:20.616403 [INFO] typesutil/gopinfo.go:215: ==> Type: &{test 56 [0xc0005e6000] 0 [] 96 0} ()
2025/10/11 16:13:20.616422 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003a0e40 {
}

2025/10/11 16:13:20 End // Func
2025/10/11 16:13:20.616584 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:21 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:21 ==> NewOverloadFunc NewRange
2025/10/11 16:13:21 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:21 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:21 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:21 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:21 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:21 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:21 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:21 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:21 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:21 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:21 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:21 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:21 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:21 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:21.797934 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000175020 {
}

2025/10/11 16:13:21 ==> Preload func test
2025/10/11 16:13:21 ==> Preload func _
2025/10/11 16:13:21 ==> Load func test
2025/10/11 16:13:21.798024 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:21.798054 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:21.798067 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:21.798081 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:21.798091 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:21.798103 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:21.798129 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 <nil> 0xc000195bf0 0xc000980000} func(int) int
2025/10/11 16:13:21.798143 [INFO] typesutil/gopinfo.go:251: ==> Def: fn var fn func(int) int
2025/10/11 16:13:21.798164 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test(fn func(int) int)
2025/10/11 16:13:21 NewFunc test func(fn func(int) int)
2025/10/11 16:13:21.798201 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc000175200 {
.  var fn func(int) int
}

2025/10/11 16:13:21 End // Func
2025/10/11 16:13:21 ==> Load func _
2025/10/11 16:13:21.798240 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:21 NewFunc _ func()
2025/10/11 16:13:21 Val test func(fn func(int) int)
2025/10/11 16:13:21.798279 [INFO] typesutil/gopinfo.go:265: ==> Use: test func test(fn func(int) int)
2025/10/11 16:13:21.798293 [INFO] typesutil/gopinfo.go:215: ==> Type: test func(fn func(int) int)
2025/10/11 16:13:21.798310 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:21 NewClosure func(x int) int
2025/10/11 16:13:21.798336 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:21 Val x int
2025/10/11 16:13:21.798358 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:21.798371 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:21 Val x int
2025/10/11 16:13:21.798389 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:21.798400 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:21 BinaryOp *
2025/10/11 16:13:21 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:21 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:21 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:21.798500 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 64 * x} int
2025/10/11 16:13:21.798518 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000175440 {
.  var x int
}

2025/10/11 16:13:21 Return 1
2025/10/11 16:13:21 ==> MatchType int, int
2025/10/11 16:13:21 End // Func
2025/10/11 16:13:21 Call 1 0 // func(fn func(int) int)
2025/10/11 16:13:21 ==> MatchFuncCall func(fn func(int) int) args: 1 flags: 0
2025/10/11 16:13:21 ==> MatchType func(x int) int, func(int) int
2025/10/11 16:13:21.798602 [INFO] typesutil/gopinfo.go:215: ==> Type: &{test 56 [0xc000753b30] 0 [] 67 0} ()
2025/10/11 16:13:21.798620 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0001752c0 {
}

2025/10/11 16:13:21 End // Func
2025/10/11 16:13:21.798798 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:22 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:22 ==> NewOverloadFunc NewRange
2025/10/11 16:13:22 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:22 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:22 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:22 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:22 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:22 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:22 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:22 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:22 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:22 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:22 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:22 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:22 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:22 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:23.093798 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000145980 {
}

2025/10/11 16:13:23 ==> Preload func test
2025/10/11 16:13:23 ==> Preload func _
2025/10/11 16:13:23 ==> Load func test
2025/10/11 16:13:23.093867 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:23.093883 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:23.093891 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:23.093899 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:23.093906 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:23.093912 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:23.093929 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 <nil> 0xc0002f5380 0xc0002f53b0} func(int) int
2025/10/11 16:13:23.093938 [INFO] typesutil/gopinfo.go:251: ==> Def: fn var fn func(int) int
2025/10/11 16:13:23.093954 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test(fn func(int) int)
2025/10/11 16:13:23 NewFunc test func(fn func(int) int)
2025/10/11 16:13:23.093979 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc00016a5a0 {
.  var fn func(int) int
}

2025/10/11 16:13:23 End // Func
2025/10/11 16:13:23 ==> Load func _
2025/10/11 16:13:23.094004 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:23 NewFunc _ func()
2025/10/11 16:13:23 Val test func(fn func(int) int)
2025/10/11 16:13:23.094034 [INFO] typesutil/gopinfo.go:265: ==> Use: test func test(fn func(int) int)
2025/10/11 16:13:23.094043 [INFO] typesutil/gopinfo.go:215: ==> Type: test func(fn func(int) int)
2025/10/11 16:13:23.094056 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:23 NewClosure func(x int) int
2025/10/11 16:13:23.094072 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:23 DefineVarStart [y]
2025/10/11 16:13:23 Val x int
2025/10/11 16:13:23.094098 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:23.094106 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:23 Val x int
2025/10/11 16:13:23.094117 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:23.094125 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:23 BinaryOp *
2025/10/11 16:13:23 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:23 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:23 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:23.094185 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 71 * x} int
2025/10/11 16:13:23 EndInit 1
2025/10/11 16:13:23.094199 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/10/11 16:13:23 Val y int
2025/10/11 16:13:23.094214 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y int
2025/10/11 16:13:23.094222 [INFO] typesutil/gopinfo.go:215: ==> Type: y int
2025/10/11 16:13:23 Return 1
2025/10/11 16:13:23 ==> MatchType int, int
2025/10/11 16:13:23.094249 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00016b020 {
.  var x int
.  var y int
}

2025/10/11 16:13:23 End // Func
2025/10/11 16:13:23 Call 1 0 // func(fn func(int) int)
2025/10/11 16:13:23 ==> MatchFuncCall func(fn func(int) int) args: 1 flags: 0
2025/10/11 16:13:23 ==> MatchType func(x int) int, func(int) int
2025/10/11 16:13:23.094301 [INFO] typesutil/gopinfo.go:215: ==> Type: &{test 56 [0xc0005a9580] 0 [] 86 0} ()
2025/10/11 16:13:23.094311 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00016a960 {
}

2025/10/11 16:13:23 End // Func
2025/10/11 16:13:23.094433 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:23 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:23 ==> NewOverloadFunc NewRange
2025/10/11 16:13:23 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:23 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:23 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:23 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:23 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:23 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:23 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:23 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:23 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:23 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:23 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:23 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:23 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:23 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:24.382888 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002ba840 {
}

2025/10/11 16:13:24 ==> Preload func _
2025/10/11 16:13:24 ==> Load func _
2025/10/11 16:13:24.382968 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:24 NewFunc _ func()
2025/10/11 16:13:24 DefineVarStart [b]
2025/10/11 16:13:24 NewClosure func() (_xgo_ok bool)
2025/10/11 16:13:24 ForRange [_ x]
2025/10/11 16:13:24 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:13:24.383075 [INFO] typesutil/gopinfo.go:215: ==> Type: &{40 STRING "1" <nil>} untyped string
2025/10/11 16:13:24 Val &{0 STRING "3"} *ast.BasicLit
2025/10/11 16:13:24.383108 [INFO] typesutil/gopinfo.go:215: ==> Type: &{45 STRING "3" <nil>} untyped string
2025/10/11 16:13:24 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:13:24.383135 [INFO] typesutil/gopinfo.go:215: ==> Type: &{50 STRING "5" <nil>} untyped string
2025/10/11 16:13:24 Val &{0 STRING "7"} *ast.BasicLit
2025/10/11 16:13:24.383163 [INFO] typesutil/gopinfo.go:215: ==> Type: &{55 STRING "7" <nil>} untyped string
2025/10/11 16:13:24 Val &{0 STRING "11"} *ast.BasicLit
2025/10/11 16:13:24.383190 [INFO] typesutil/gopinfo.go:215: ==> Type: &{60 STRING "11" <nil>} untyped string
2025/10/11 16:13:24 SliceLit <nil> 5 false
2025/10/11 16:13:24 RangeAssignThen
2025/10/11 16:13:24.383225 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x string
2025/10/11 16:13:24.383249 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0002baa80 {
.  var x string
}

2025/10/11 16:13:24 If
2025/10/11 16:13:24 Val x string
2025/10/11 16:13:24.383296 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x string
2025/10/11 16:13:24.383310 [INFO] typesutil/gopinfo.go:215: ==> Type: x string
2025/10/11 16:13:24 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:13:24.383335 [INFO] typesutil/gopinfo.go:215: ==> Type: &{72 STRING "5" <nil>} untyped string
2025/10/11 16:13:24 BinaryOp ==
2025/10/11 16:13:24.383361 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 69 == 0xc0006113e0} untyped bool
2025/10/11 16:13:24 Then
2025/10/11 16:13:24 Val true bool
2025/10/11 16:13:24 Return 1
2025/10/11 16:13:24 ==> MatchType untyped bool (true), bool
2025/10/11 16:13:24 End // If
2025/10/11 16:13:24 End // ForRange
2025/10/11 16:13:24 Return 0
2025/10/11 16:13:24 End // Func
2025/10/11 16:13:24 Call 0 0 // func() (_xgo_ok bool)
2025/10/11 16:13:24 ==> MatchFuncCall func() (_xgo_ok bool) args: 0 flags: 0
2025/10/11 16:13:24 EndInit 1
2025/10/11 16:13:24.383494 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b bool
2025/10/11 16:13:24 VarRef _
2025/10/11 16:13:24 Val b bool
2025/10/11 16:13:24.383525 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b bool
2025/10/11 16:13:24.383543 [INFO] typesutil/gopinfo.go:215: ==> Type: b bool
2025/10/11 16:13:24 Assign 1 1
2025/10/11 16:13:24.383571 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002ba900 {
.  var b bool
}

2025/10/11 16:13:24 End // Func
2025/10/11 16:13:24.383783 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:25 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:25 ==> NewOverloadFunc NewRange
2025/10/11 16:13:25 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:25 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:25 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:25 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:25 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:25 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:25 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:25 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:25 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:25 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:25 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:25 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:25 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:25 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:25.643536 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0005a6360 {
}

2025/10/11 16:13:25 ==> Preload func _
2025/10/11 16:13:25 ==> Load func _
2025/10/11 16:13:25.643764 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:25 NewFunc _ func()
2025/10/11 16:13:25 DefineVarStart [b ok]
2025/10/11 16:13:25 NewClosure func() (_xgo_ret unboundType{typ: <nil>}, _xgo_ok bool)
2025/10/11 16:13:25 ForRange [i x]
2025/10/11 16:13:25 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:13:25.644116 [INFO] typesutil/gopinfo.go:215: ==> Type: &{49 STRING "1" <nil>} untyped string
2025/10/11 16:13:25 Val &{0 STRING "3"} *ast.BasicLit
2025/10/11 16:13:25.644714 [INFO] typesutil/gopinfo.go:215: ==> Type: &{54 STRING "3" <nil>} untyped string
2025/10/11 16:13:25 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:13:25.644741 [INFO] typesutil/gopinfo.go:215: ==> Type: &{59 STRING "5" <nil>} untyped string
2025/10/11 16:13:25 Val &{0 STRING "7"} *ast.BasicLit
2025/10/11 16:13:25.644764 [INFO] typesutil/gopinfo.go:215: ==> Type: &{64 STRING "7" <nil>} untyped string
2025/10/11 16:13:25 Val &{0 STRING "11"} *ast.BasicLit
2025/10/11 16:13:25.644788 [INFO] typesutil/gopinfo.go:215: ==> Type: &{69 STRING "11" <nil>} untyped string
2025/10/11 16:13:25 SliceLit <nil> 5 false
2025/10/11 16:13:25 RangeAssignThen
2025/10/11 16:13:25.644832 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:13:25.644848 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x string
2025/10/11 16:13:25.644883 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0006b8240 {
.  var i int
.  var x string
}

2025/10/11 16:13:25 If
2025/10/11 16:13:25 Val x string
2025/10/11 16:13:25.644929 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x string
2025/10/11 16:13:25.644943 [INFO] typesutil/gopinfo.go:215: ==> Type: x string
2025/10/11 16:13:25 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:13:25.644969 [INFO] typesutil/gopinfo.go:215: ==> Type: &{81 STRING "5" <nil>} untyped string
2025/10/11 16:13:25 BinaryOp ==
2025/10/11 16:13:25.644998 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 78 == 0xc00091ddd0} untyped bool
2025/10/11 16:13:25 Then
2025/10/11 16:13:25 Val i int
2025/10/11 16:13:25.645035 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:13:25.645053 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:13:25 Val true bool
2025/10/11 16:13:25 Return 2
2025/10/11 16:13:25 ==> MatchType int, unboundType{typ: <nil>}
2025/10/11 16:13:25 ==> MatchType untyped bool (true), bool
2025/10/11 16:13:25 End // If
2025/10/11 16:13:25 End // ForRange
2025/10/11 16:13:25 Return 0
2025/10/11 16:13:25 End // Func
2025/10/11 16:13:25 Call 0 0 // func() (_xgo_ret int, _xgo_ok bool)
2025/10/11 16:13:25 ==> MatchFuncCall func() (_xgo_ret int, _xgo_ok bool) args: 0 flags: 0
2025/10/11 16:13:25 EndInit 1
2025/10/11 16:13:25.645197 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/10/11 16:13:25.645211 [INFO] typesutil/gopinfo.go:251: ==> Def: ok var ok bool
2025/10/11 16:13:25 VarRef _
2025/10/11 16:13:25 Val b int
2025/10/11 16:13:25.645241 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b int
2025/10/11 16:13:25.645252 [INFO] typesutil/gopinfo.go:215: ==> Type: b int
2025/10/11 16:13:25 Assign 1 1
2025/10/11 16:13:25 VarRef _
2025/10/11 16:13:25 Val ok bool
2025/10/11 16:13:25.645286 [INFO] typesutil/gopinfo.go:265: ==> Use: ok var ok bool
2025/10/11 16:13:25.645297 [INFO] typesutil/gopinfo.go:215: ==> Type: ok bool
2025/10/11 16:13:25 Assign 1 1
2025/10/11 16:13:25.645328 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0006b8060 {
.  var b int
.  var ok bool
}

2025/10/11 16:13:25 End // Func
2025/10/11 16:13:25.645520 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:26 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:26 ==> NewOverloadFunc NewRange
2025/10/11 16:13:26 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:26 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:26 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:26 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:26 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:26 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:26 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:26 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:26 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:26 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:26 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:26 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:26 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:26 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:26.890895 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000522c60 {
}

2025/10/11 16:13:26 ==> Preload func _
2025/10/11 16:13:26 ==> Load func _
2025/10/11 16:13:26.890978 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:26 NewFunc _ func()
2025/10/11 16:13:26 DefineVarStart [a]
2025/10/11 16:13:26 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:13:26 ForRange [_ x]
2025/10/11 16:13:26 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:13:26.891085 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 INT 1 <nil>} untyped int
2025/10/11 16:13:26 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/10/11 16:13:26.891133 [INFO] typesutil/gopinfo.go:215: ==> Type: &{47 FLOAT 3.4 <nil>} untyped float
2025/10/11 16:13:26 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:13:26.891161 [INFO] typesutil/gopinfo.go:215: ==> Type: &{52 INT 5 <nil>} untyped int
2025/10/11 16:13:26 SliceLit <nil> 3 false
2025/10/11 16:13:26 RangeAssignThen
2025/10/11 16:13:26.891203 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/10/11 16:13:26.891224 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc000522ea0 {
.  var x float64
}

2025/10/11 16:13:26 If
2025/10/11 16:13:26 Val x float64
2025/10/11 16:13:26.891254 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:13:26.891269 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:13:26 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:13:26.891294 [INFO] typesutil/gopinfo.go:215: ==> Type: &{62 INT 2 <nil>} untyped int
2025/10/11 16:13:26 BinaryOp >
2025/10/11 16:13:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:13:26 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:26 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/10/11 16:13:26.891390 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 60 > 0xc000610450} untyped bool
2025/10/11 16:13:26 Then
2025/10/11 16:13:26 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:13:26 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:26 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:13:26 Val x float64
2025/10/11 16:13:26.891450 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:13:26.891461 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:13:26 Val x float64
2025/10/11 16:13:26.891480 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/10/11 16:13:26.891491 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/10/11 16:13:26 BinaryOp *
2025/10/11 16:13:26 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:26 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:26 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:13:26.891560 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 31 * x} float64
2025/10/11 16:13:26 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:26 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:13:26 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:13:26 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:13:26 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/10/11 16:13:26 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:26 Assign 1 1
2025/10/11 16:13:26 ==> MatchType []float64, unboundType{typ: <nil>}
2025/10/11 16:13:26 End // If
2025/10/11 16:13:26 End // ForRange
2025/10/11 16:13:26 Return 0
2025/10/11 16:13:26 End // Func
2025/10/11 16:13:26 Call 0 0 // func() (_xgo_ret []float64)
2025/10/11 16:13:26 ==> MatchFuncCall func() (_xgo_ret []float64) args: 0 flags: 0
2025/10/11 16:13:26 EndInit 1
2025/10/11 16:13:26.891757 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []float64
2025/10/11 16:13:26 VarRef _
2025/10/11 16:13:26 Val a []float64
2025/10/11 16:13:26.891787 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []float64
2025/10/11 16:13:26.891800 [INFO] typesutil/gopinfo.go:215: ==> Type: a []float64
2025/10/11 16:13:26 Assign 1 1
2025/10/11 16:13:26.891828 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000522d20 {
.  var a []float64
}

2025/10/11 16:13:26 End // Func
2025/10/11 16:13:26.892082 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:27 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:27 ==> NewOverloadFunc NewRange
2025/10/11 16:13:27 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:27 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:27 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:27 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:27 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:27 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:27 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:27 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:27 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:27 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:27 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:27 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:27 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:27 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:28.131696 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00046cea0 {
}

2025/10/11 16:13:28 ==> Preload func _
2025/10/11 16:13:28 ==> Load func _
2025/10/11 16:13:28.131796 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:28 NewFunc _ func()
2025/10/11 16:13:28 DefineVarStart [arr]
2025/10/11 16:13:28 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:13:28.131885 [INFO] typesutil/gopinfo.go:215: ==> Type: &{32 INT 1 <nil>} untyped int
2025/10/11 16:13:28 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:13:28.131914 [INFO] typesutil/gopinfo.go:215: ==> Type: &{35 INT 2 <nil>} untyped int
2025/10/11 16:13:28 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:13:28.131941 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 INT 3 <nil>} untyped int
2025/10/11 16:13:28 Val &{0 FLOAT 4.1} *ast.BasicLit
2025/10/11 16:13:28.131981 [INFO] typesutil/gopinfo.go:215: ==> Type: &{41 FLOAT 4.1 <nil>} untyped float
2025/10/11 16:13:28 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:13:28.132007 [INFO] typesutil/gopinfo.go:215: ==> Type: &{46 INT 5 <nil>} untyped int
2025/10/11 16:13:28 Val &{0 INT 6} *ast.BasicLit
2025/10/11 16:13:28.132028 [INFO] typesutil/gopinfo.go:215: ==> Type: &{49 INT 6 <nil>} untyped int
2025/10/11 16:13:28 SliceLit <nil> 6 false
2025/10/11 16:13:28 EndInit 1
2025/10/11 16:13:28.132102 [INFO] typesutil/gopinfo.go:251: ==> Def: arr var arr []float64
2025/10/11 16:13:28 DefineVarStart [x]
2025/10/11 16:13:28 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:13:28 ForRange [_ b]
2025/10/11 16:13:28 Val arr []float64
2025/10/11 16:13:28.132201 [INFO] typesutil/gopinfo.go:265: ==> Use: arr var arr []float64
2025/10/11 16:13:28.132217 [INFO] typesutil/gopinfo.go:215: ==> Type: arr []float64
2025/10/11 16:13:28 RangeAssignThen
2025/10/11 16:13:28.132253 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b float64
2025/10/11 16:13:28.132270 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00046d1a0 {
.  var b float64
}

2025/10/11 16:13:28 If
2025/10/11 16:13:28 Val b float64
2025/10/11 16:13:28.132293 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/10/11 16:13:28.132304 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/10/11 16:13:28 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:13:28.132336 [INFO] typesutil/gopinfo.go:215: ==> Type: &{103 INT 2 <nil>} untyped int
2025/10/11 16:13:28 BinaryOp >
2025/10/11 16:13:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:13:28 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:28 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/10/11 16:13:28.132420 [INFO] typesutil/gopinfo.go:215: ==> Type: &{b 101 > 0xc0002f5b90} untyped bool
2025/10/11 16:13:28 Then
2025/10/11 16:13:28 ForRange [_ a]
2025/10/11 16:13:28 Val arr []float64
2025/10/11 16:13:28.132452 [INFO] typesutil/gopinfo.go:265: ==> Use: arr var arr []float64
2025/10/11 16:13:28.132472 [INFO] typesutil/gopinfo.go:215: ==> Type: arr []float64
2025/10/11 16:13:28 RangeAssignThen
2025/10/11 16:13:28.132489 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a float64
2025/10/11 16:13:28.132504 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00046d440 {
.  var a float64
}

2025/10/11 16:13:28 If
2025/10/11 16:13:28 Val a float64
2025/10/11 16:13:28.132526 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/10/11 16:13:28.132534 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/10/11 16:13:28 Val b float64
2025/10/11 16:13:28.132552 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/10/11 16:13:28.132561 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/10/11 16:13:28 BinaryOp <
2025/10/11 16:13:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:13:28 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:28 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:13:28.132616 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 81 < b} untyped bool
2025/10/11 16:13:28 Then
2025/10/11 16:13:28 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:13:28 Val append func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:28 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:13:28 Val a float64
2025/10/11 16:13:28.132668 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/10/11 16:13:28.132682 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/10/11 16:13:28 Val b float64
2025/10/11 16:13:28.132703 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/10/11 16:13:28.132712 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/10/11 16:13:28 SliceLit <nil> 2 false
2025/10/11 16:13:28 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:13:28 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/10/11 16:13:28 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/10/11 16:13:28 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/10/11 16:13:28 ==> MatchType []float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:28 Assign 1 1
2025/10/11 16:13:28 ==> MatchType [][]float64, unboundType{typ: <nil>}
2025/10/11 16:13:28 End // If
2025/10/11 16:13:28 End // ForRange
2025/10/11 16:13:28 End // If
2025/10/11 16:13:28 End // ForRange
2025/10/11 16:13:28 Return 0
2025/10/11 16:13:28 End // Func
2025/10/11 16:13:28 Call 0 0 // func() (_xgo_ret [][]float64)
2025/10/11 16:13:28 ==> MatchFuncCall func() (_xgo_ret [][]float64) args: 0 flags: 0
2025/10/11 16:13:28 EndInit 1
2025/10/11 16:13:28.132878 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x [][]float64
2025/10/11 16:13:28 VarRef _
2025/10/11 16:13:28 Val x [][]float64
2025/10/11 16:13:28.132904 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x [][]float64
2025/10/11 16:13:28.132915 [INFO] typesutil/gopinfo.go:215: ==> Type: x [][]float64
2025/10/11 16:13:28 Assign 1 1
2025/10/11 16:13:28.132940 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00046cf60 {
.  var arr []float64
.  var x [][]float64
}

2025/10/11 16:13:28 End // Func
2025/10/11 16:13:28.133107 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:28 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:28 ==> NewOverloadFunc NewRange
2025/10/11 16:13:28 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:28 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:28 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:28 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:28 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:28 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:28 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:28 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:28 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:28 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:28 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:28 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:28 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:28 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:29.385442 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00034d980 {
}

2025/10/11 16:13:29 ==> Preload func _
2025/10/11 16:13:29 ==> Load func _
2025/10/11 16:13:29.385527 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:29 NewFunc _ func()
2025/10/11 16:13:29 DefineVarStart [y]
2025/10/11 16:13:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:13:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:13:29 ZeroLit // unboundType{typ: <nil>}
2025/10/11 16:13:29 Assign 1 1
2025/10/11 16:13:29 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/10/11 16:13:29 ForRange [i x]
2025/10/11 16:13:29 Val &{0 STRING "1"} *ast.BasicLit
2025/10/11 16:13:29.385671 [INFO] typesutil/gopinfo.go:215: ==> Type: &{48 STRING "1" <nil>} untyped string
2025/10/11 16:13:29 Val &{0 STRING "3"} *ast.BasicLit
2025/10/11 16:13:29.385705 [INFO] typesutil/gopinfo.go:215: ==> Type: &{53 STRING "3" <nil>} untyped string
2025/10/11 16:13:29 Val &{0 STRING "5"} *ast.BasicLit
2025/10/11 16:13:29.385731 [INFO] typesutil/gopinfo.go:215: ==> Type: &{58 STRING "5" <nil>} untyped string
2025/10/11 16:13:29 Val &{0 STRING "7"} *ast.BasicLit
2025/10/11 16:13:29.385757 [INFO] typesutil/gopinfo.go:215: ==> Type: &{63 STRING "7" <nil>} untyped string
2025/10/11 16:13:29 Val &{0 STRING "11"} *ast.BasicLit
2025/10/11 16:13:29.385784 [INFO] typesutil/gopinfo.go:215: ==> Type: &{68 STRING "11" <nil>} untyped string
2025/10/11 16:13:29 SliceLit <nil> 5 false
2025/10/11 16:13:29 RangeAssignThen
2025/10/11 16:13:29.385821 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:13:29.385835 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x string
2025/10/11 16:13:29.385860 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00034dbc0 {
.  var i int
.  var x string
}

2025/10/11 16:13:29 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:13:29 Val x string
2025/10/11 16:13:29.385899 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x string
2025/10/11 16:13:29.385913 [INFO] typesutil/gopinfo.go:215: ==> Type: x string
2025/10/11 16:13:29 IndexRef 1
2025/10/11 16:13:29 Val i int
2025/10/11 16:13:29.385945 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/10/11 16:13:29.385958 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/10/11 16:13:29 Assign 1 1
2025/10/11 16:13:29 ==> MatchType int, unboundMapElemType{key: string}
2025/10/11 16:13:29 End // ForRange
2025/10/11 16:13:29 Return 0
2025/10/11 16:13:29 End // Func
2025/10/11 16:13:29 Call 0 0 // func() (_xgo_ret map[string]int)
2025/10/11 16:13:29 ==> MatchFuncCall func() (_xgo_ret map[string]int) args: 0 flags: 0
2025/10/11 16:13:29 EndInit 1
2025/10/11 16:13:29.386065 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y map[string]int
2025/10/11 16:13:29 VarRef _
2025/10/11 16:13:29 Val y map[string]int
2025/10/11 16:13:29.386096 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y map[string]int
2025/10/11 16:13:29.386110 [INFO] typesutil/gopinfo.go:215: ==> Type: y map[string]int
2025/10/11 16:13:29 Assign 1 1
2025/10/11 16:13:29.386140 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00034da40 {
.  var y map[string]int
}

2025/10/11 16:13:29 End // Func
2025/10/11 16:13:29.386368 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:30 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:30 ==> NewOverloadFunc NewRange
2025/10/11 16:13:30 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:30 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:30 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:30 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:30 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:30 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:30 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:30 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:30 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:30 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:30 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:30 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:30 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:30 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:30.646952 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000638480 {
}

2025/10/11 16:13:30 ==> Preload func _
2025/10/11 16:13:30 ==> Load func _
2025/10/11 16:13:30.647026 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:30 NewFunc _ func()
2025/10/11 16:13:30 DefineVarStart [z]
2025/10/11 16:13:30 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/10/11 16:13:30 VarRef _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:13:30 ZeroLit // unboundType{typ: <nil>}
2025/10/11 16:13:30 Assign 1 1
2025/10/11 16:13:30 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/10/11 16:13:30 ForRange [k v]
2025/10/11 16:13:30 Val &{0 STRING "Hello"} *ast.BasicLit
2025/10/11 16:13:30.647149 [INFO] typesutil/gopinfo.go:215: ==> Type: &{48 STRING "Hello" <nil>} untyped string
2025/10/11 16:13:30 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:13:30.647185 [INFO] typesutil/gopinfo.go:215: ==> Type: &{57 INT 1 <nil>} untyped int
2025/10/11 16:13:30 Val &{0 STRING "Hi"} *ast.BasicLit
2025/10/11 16:13:30.647206 [INFO] typesutil/gopinfo.go:215: ==> Type: &{60 STRING "Hi" <nil>} untyped string
2025/10/11 16:13:30 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:13:30.647225 [INFO] typesutil/gopinfo.go:215: ==> Type: &{66 INT 3 <nil>} untyped int
2025/10/11 16:13:30 Val &{0 STRING "xsw"} *ast.BasicLit
2025/10/11 16:13:30.647245 [INFO] typesutil/gopinfo.go:215: ==> Type: &{69 STRING "xsw" <nil>} untyped string
2025/10/11 16:13:30 Val &{0 INT 5} *ast.BasicLit
2025/10/11 16:13:30.647263 [INFO] typesutil/gopinfo.go:215: ==> Type: &{76 INT 5 <nil>} untyped int
2025/10/11 16:13:30 Val &{0 STRING "XGo"} *ast.BasicLit
2025/10/11 16:13:30.647283 [INFO] typesutil/gopinfo.go:215: ==> Type: &{79 STRING "XGo" <nil>} untyped string
2025/10/11 16:13:30 Val &{0 INT 7} *ast.BasicLit
2025/10/11 16:13:30.647301 [INFO] typesutil/gopinfo.go:215: ==> Type: &{86 INT 7 <nil>} untyped int
2025/10/11 16:13:30 MapLit <nil> 8
2025/10/11 16:13:30.647322 [INFO] typesutil/gopinfo.go:215: ==> Type: <nil> <nil>
2025/10/11 16:13:30.647343 [INFO] typesutil/gopinfo.go:215: ==> Type: &{<nil> 47 [0xc0002f5b60 0xc0002f5bf0 0xc0002f5c80 0xc0002f5d10] 87 false} <nil>
2025/10/11 16:13:30 RangeAssignThen
2025/10/11 16:13:30.647362 [INFO] typesutil/gopinfo.go:251: ==> Def: k var k string
2025/10/11 16:13:30.647374 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v int
2025/10/11 16:13:30.647394 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0006386c0 {
.  var k string
.  var v int
}

2025/10/11 16:13:30 If
2025/10/11 16:13:30 Val v int
2025/10/11 16:13:30.647426 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v int
2025/10/11 16:13:30.647437 [INFO] typesutil/gopinfo.go:215: ==> Type: v int
2025/10/11 16:13:30 Val &{0 INT 3} *ast.BasicLit
2025/10/11 16:13:30.647456 [INFO] typesutil/gopinfo.go:215: ==> Type: &{94 INT 3 <nil>} untyped int
2025/10/11 16:13:30 BinaryOp >
2025/10/11 16:13:30 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/10/11 16:13:30 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:30 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/10/11 16:13:30.647582 [INFO] typesutil/gopinfo.go:215: ==> Type: &{v 92 > 0xc0002f5d40} untyped bool
2025/10/11 16:13:30 Then
2025/10/11 16:13:30 Val _xgo_ret unboundType{typ: <nil>}
2025/10/11 16:13:30 Val v int
2025/10/11 16:13:30.647904 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v int
2025/10/11 16:13:30.647923 [INFO] typesutil/gopinfo.go:215: ==> Type: v int
2025/10/11 16:13:30 IndexRef 1
2025/10/11 16:13:30 Val k string
2025/10/11 16:13:30.648389 [INFO] typesutil/gopinfo.go:265: ==> Use: k var k string
2025/10/11 16:13:30.648620 [INFO] typesutil/gopinfo.go:215: ==> Type: k string
2025/10/11 16:13:30 Assign 1 1
2025/10/11 16:13:30 ==> MatchType string, unboundMapElemType{key: int}
2025/10/11 16:13:30 End // If
2025/10/11 16:13:30 End // ForRange
2025/10/11 16:13:30 Return 0
2025/10/11 16:13:30 End // Func
2025/10/11 16:13:30 Call 0 0 // func() (_xgo_ret map[int]string)
2025/10/11 16:13:30 ==> MatchFuncCall func() (_xgo_ret map[int]string) args: 0 flags: 0
2025/10/11 16:13:30 EndInit 1
2025/10/11 16:13:30.648864 [INFO] typesutil/gopinfo.go:251: ==> Def: z var z map[int]string
2025/10/11 16:13:30 VarRef _
2025/10/11 16:13:30 Val z map[int]string
2025/10/11 16:13:30.648909 [INFO] typesutil/gopinfo.go:265: ==> Use: z var z map[int]string
2025/10/11 16:13:30.648924 [INFO] typesutil/gopinfo.go:215: ==> Type: z map[int]string
2025/10/11 16:13:30 Assign 1 1
2025/10/11 16:13:30.648976 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000638540 {
.  var z map[int]string
}

2025/10/11 16:13:30 End // Func
--- PASS: TestScopesInfo (41.64s)
=== RUN   TestAddress
2025/10/11 16:13:30.650727 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:31 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:31 ==> NewOverloadFunc NewRange
2025/10/11 16:13:31 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:31 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:31 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:31 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:31 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:31 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:31 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:31 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:31 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:31 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:31 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:31 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:31 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:31 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:31.898379 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00025b8c0 {
}

2025/10/11 16:13:31 ==> Preload type foo
2025/10/11 16:13:31 ==> Preload method foo.ptr
2025/10/11 16:13:31 ==> Preload method foo.clone
2025/10/11 16:13:31 ==> Preload type nested
2025/10/11 16:13:31 ==> Preload func _
2025/10/11 16:13:31 ==> Load > NewType foo
2025/10/11 16:13:31 NewType foo
2025/10/11 16:13:31 ==> Load > InitType foo
2025/10/11 16:13:31.898492 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:31.898513 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:31.898524 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:31.898538 [INFO] typesutil/gopinfo.go:251: ==> Def: c field c int
2025/10/11 16:13:31.898553 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:31.898564 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:31.898575 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:31.898594 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 int} *int
2025/10/11 16:13:31.898607 [INFO] typesutil/gopinfo.go:251: ==> Def: p field p *int
2025/10/11 16:13:31.898630 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 0xc000998000 false} struct{c int; p *int}
2025/10/11 16:13:31 InitType foo struct{c int; p *int}
2025/10/11 16:13:31.898676 [INFO] typesutil/gopinfo.go:251: ==> Def: foo type foo struct{c int; p *int}
2025/10/11 16:13:31 ==> LookupParent foo => type foo struct{c int; p *int}
2025/10/11 16:13:31.898701 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/10/11 16:13:31.898712 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.898726 [INFO] typesutil/gopinfo.go:251: ==> Def: f var f foo
2025/10/11 16:13:31 ==> Load method foo.ptr
2025/10/11 16:13:31 ==> LookupParent foo => type foo struct{c int; p *int}
2025/10/11 16:13:31.898759 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/10/11 16:13:31.898771 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.898782 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.898798 [INFO] typesutil/gopinfo.go:215: ==> Type: &{71 foo} *foo
2025/10/11 16:13:31.898818 [INFO] typesutil/gopinfo.go:251: ==> Def: ptr func (foo).ptr() *foo
2025/10/11 16:13:31 ==> LookupParent foo => type foo struct{c int; p *int}
2025/10/11 16:13:31.898843 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/10/11 16:13:31.898855 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.898866 [INFO] typesutil/gopinfo.go:251: ==> Def: f var f foo
2025/10/11 16:13:31 ==> Load method foo.clone
2025/10/11 16:13:31 ==> LookupParent foo => type foo struct{c int; p *int}
2025/10/11 16:13:31.898894 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/10/11 16:13:31.898909 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.898923 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.898938 [INFO] typesutil/gopinfo.go:251: ==> Def: clone func (foo).clone() foo
2025/10/11 16:13:31 ==> Load > NewType nested
2025/10/11 16:13:31 NewType nested
2025/10/11 16:13:31 ==> Load > InitType nested
2025/10/11 16:13:31 ==> LookupParent foo => type foo struct{c int; p *int}
2025/10/11 16:13:31.898980 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/10/11 16:13:31.898991 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.899005 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.899018 [INFO] typesutil/gopinfo.go:251: ==> Def: f field f foo
2025/10/11 16:13:31 ==> LookupParent foo => type foo struct{c int; p *int}
2025/10/11 16:13:31.899041 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/10/11 16:13:31.899052 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.899063 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31 Val &{0 INT 2} *ast.BasicLit
2025/10/11 16:13:31.899102 [INFO] typesutil/gopinfo.go:215: ==> Type: &{161 INT 2 <nil>} untyped int
2025/10/11 16:13:31.899122 [INFO] typesutil/gopinfo.go:215: ==> Type: &{160 0xc0005b6900 foo} [2]foo
2025/10/11 16:13:31.899135 [INFO] typesutil/gopinfo.go:251: ==> Def: a field a [2]foo
2025/10/11 16:13:31 ==> LookupParent foo => type foo struct{c int; p *int}
2025/10/11 16:13:31.899162 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/10/11 16:13:31.899178 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.899189 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.899253 [INFO] typesutil/gopinfo.go:215: ==> Type: &{170 <nil> foo} []foo
2025/10/11 16:13:31.899281 [INFO] typesutil/gopinfo.go:251: ==> Def: s field s []foo
2025/10/11 16:13:31.899296 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:31.899307 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:31.899318 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:31 ==> LookupParent foo => type foo struct{c int; p *int}
2025/10/11 16:13:31.899341 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/10/11 16:13:31.899353 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.899363 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/10/11 16:13:31.899380 [INFO] typesutil/gopinfo.go:215: ==> Type: &{179 int foo} map[int]foo
2025/10/11 16:13:31.899396 [INFO] typesutil/gopinfo.go:251: ==> Def: m field m map[int]foo
2025/10/11 16:13:31.899421 [INFO] typesutil/gopinfo.go:215: ==> Type: &{141 0xc0005b69c0 false} struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31 InitType nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31.899456 [INFO] typesutil/gopinfo.go:251: ==> Def: nested type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31 ==> Load func _
2025/10/11 16:13:31.899476 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:31 NewFunc _ func()
2025/10/11 16:13:31 DefineVarStart [getNested]
2025/10/11 16:13:31 ==> LookupParent nested => type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31.899530 [INFO] typesutil/gopinfo.go:265: ==> Use: nested type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31.899541 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/10/11 16:13:31.899552 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/10/11 16:13:31.899570 [INFO] typesutil/gopinfo.go:215: ==> Type: &{219 <nil> 0xc0005b6ab0 0xc0005b6ae0} func() nested
2025/10/11 16:13:31.899585 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000580580 0xc0005b6b70} func() nested
2025/10/11 16:13:31 NewClosure func() nested
2025/10/11 16:13:31 ==> LookupParent nested => type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31.899626 [INFO] typesutil/gopinfo.go:265: ==> Use: nested type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31.899637 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/10/11 16:13:31.899647 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/10/11 16:13:31 StructLit nested 0 false
2025/10/11 16:13:31.899667 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/10/11 16:13:31.899684 [INFO] typesutil/gopinfo.go:215: ==> Type: &{nested 248 [] 249 false} nested
2025/10/11 16:13:31 Return 1
2025/10/11 16:13:31 ==> MatchType nested, nested
2025/10/11 16:13:31 ==> EnsureLoaded nested
2025/10/11 16:13:31 ==> EnsureLoaded nested
2025/10/11 16:13:31.899733 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000264060 {
}

2025/10/11 16:13:31 End // Func
2025/10/11 16:13:31 EndInit 1
2025/10/11 16:13:31.899769 [INFO] typesutil/gopinfo.go:251: ==> Def: getNested var getNested func() nested
2025/10/11 16:13:31 DefineVarStart [getNestedPtr]
2025/10/11 16:13:31 ==> LookupParent nested => type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31.899809 [INFO] typesutil/gopinfo.go:265: ==> Use: nested type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31.899824 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/10/11 16:13:31.899839 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/10/11 16:13:31.899853 [INFO] typesutil/gopinfo.go:215: ==> Type: &{277 nested} *nested
2025/10/11 16:13:31.899869 [INFO] typesutil/gopinfo.go:215: ==> Type: &{270 <nil> 0xc0005b6bd0 0xc0005b6c00} func() *nested
2025/10/11 16:13:31.899928 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000580620 0xc0005b6c60} func() *nested
2025/10/11 16:13:31 NewClosure func() *nested
2025/10/11 16:13:31 ==> LookupParent nested => type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31.899971 [INFO] typesutil/gopinfo.go:265: ==> Use: nested type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/10/11 16:13:31.899992 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/10/11 16:13:31.900012 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/10/11 16:13:31 StructLit nested 0 false
2025/10/11 16:13:31.900030 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/10/11 16:13:31.900071 [INFO] typesutil/gopinfo.go:215: ==> Type: &{nested 301 [] 302 false} nested
2025/10/11 16:13:31 UnaryOp & flags: 0
2025/10/11 16:13:31 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:13:31.900115 [INFO] typesutil/gopinfo.go:215: ==> Type: &{294 & 0xc000342600} *nested
2025/10/11 16:13:31 Return 1
2025/10/11 16:13:31 ==> MatchType *nested, *nested
2025/10/11 16:13:31 ==> EnsureLoaded nested
2025/10/11 16:13:31 ==> EnsureLoaded nested
2025/10/11 16:13:31.900164 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0002641e0 {
}

2025/10/11 16:13:31 End // Func
2025/10/11 16:13:31 EndInit 1
2025/10/11 16:13:31.900195 [INFO] typesutil/gopinfo.go:251: ==> Def: getNestedPtr var getNestedPtr func() *nested
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNested func() nested
2025/10/11 16:13:31.900230 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/10/11 16:13:31.900243 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/10/11 16:13:31 Call 0 0 // func() nested
2025/10/11 16:13:31 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/10/11 16:13:31.900280 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 321 [] 0 [] 322 0} nested
2025/10/11 16:13:31 Member f 2 // nested
2025/10/11 16:13:31.900307 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/10/11 16:13:31.900323 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e80c0 f} foo
2025/10/11 16:13:31 Member c 2 // foo
2025/10/11 16:13:31.900343 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.900357 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e138 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNested func() nested
2025/10/11 16:13:31.900403 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/10/11 16:13:31.900411 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/10/11 16:13:31 Call 0 0 // func() nested
2025/10/11 16:13:31 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/10/11 16:13:31.900436 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 342 [] 0 [] 343 0} nested
2025/10/11 16:13:31 Member a 2 // nested
2025/10/11 16:13:31.900455 [INFO] typesutil/gopinfo.go:265: ==> Use: a field a [2]foo
2025/10/11 16:13:31.900465 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e81e0 a} [2]foo
2025/10/11 16:13:31 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:31.900484 [INFO] typesutil/gopinfo.go:215: ==> Type: &{347 INT 0 <nil>} untyped int
2025/10/11 16:13:31 Index 1 false
2025/10/11 16:13:31.900504 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e168 346 0xc0005b6c90 348} foo
2025/10/11 16:13:31 Member c 2 // foo
2025/10/11 16:13:31.900519 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.900529 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005b6cc0 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNested func() nested
2025/10/11 16:13:31.900554 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/10/11 16:13:31.900562 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/10/11 16:13:31 Call 0 0 // func() nested
2025/10/11 16:13:31 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/10/11 16:13:31.900590 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 366 [] 0 [] 367 0} nested
2025/10/11 16:13:31 Member s 2 // nested
2025/10/11 16:13:31.900605 [INFO] typesutil/gopinfo.go:265: ==> Use: s field s []foo
2025/10/11 16:13:31.900617 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e83c0 s} []foo
2025/10/11 16:13:31 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:31.900637 [INFO] typesutil/gopinfo.go:215: ==> Type: &{371 INT 0 <nil>} untyped int
2025/10/11 16:13:31 Index 1 false
2025/10/11 16:13:31.900704 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e228 370 0xc0005b6cf0 372} foo
2025/10/11 16:13:31 Member c 2 // foo
2025/10/11 16:13:31.900723 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.900733 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005b6d20 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNested func() nested
2025/10/11 16:13:31.900761 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/10/11 16:13:31.900769 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/10/11 16:13:31 Call 0 0 // func() nested
2025/10/11 16:13:31 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/10/11 16:13:31.900794 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 390 [] 0 [] 391 0} nested
2025/10/11 16:13:31 Member m 2 // nested
2025/10/11 16:13:31.900814 [INFO] typesutil/gopinfo.go:265: ==> Use: m field m map[int]foo
2025/10/11 16:13:31.900825 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e8780 m} map[int]foo
2025/10/11 16:13:31 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:31.900845 [INFO] typesutil/gopinfo.go:215: ==> Type: &{395 INT 0 <nil>} untyped int
2025/10/11 16:13:31 Index 1 false
2025/10/11 16:13:31.900859 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e258 394 0xc0005b6d50 396} foo
2025/10/11 16:13:31 Member c 2 // foo
2025/10/11 16:13:31.900874 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.900884 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005b6d80 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNested func() nested
2025/10/11 16:13:31.900910 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/10/11 16:13:31.900918 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/10/11 16:13:31 Call 0 0 // func() nested
2025/10/11 16:13:31 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/10/11 16:13:31.900943 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 414 [] 0 [] 415 0} nested
2025/10/11 16:13:31 Member f 2 // nested
2025/10/11 16:13:31.900959 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/10/11 16:13:31.900973 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e8ba0 f} foo
2025/10/11 16:13:31 Member ptr 1 // foo
2025/10/11 16:13:31.900992 [INFO] typesutil/gopinfo.go:265: ==> Use: ptr func (foo).ptr() *foo
2025/10/11 16:13:31.901021 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e288 ptr} func() *foo
2025/10/11 16:13:31 Call 0 0 // func() *foo
2025/10/11 16:13:31 ==> MatchFuncCall func() *foo args: 0 flags: 0
2025/10/11 16:13:31.901058 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e2a0 422 [] 0 [] 423 0} *foo
2025/10/11 16:13:31 Member c 2 // *foo
2025/10/11 16:13:31.901076 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.901085 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e8c00 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNested func() nested
2025/10/11 16:13:31.901114 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/10/11 16:13:31.901121 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/10/11 16:13:31 Call 0 0 // func() nested
2025/10/11 16:13:31 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/10/11 16:13:31.901149 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 441 [] 0 [] 442 0} nested
2025/10/11 16:13:31 Member f 2 // nested
2025/10/11 16:13:31.901163 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/10/11 16:13:31.901173 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e8c60 f} foo
2025/10/11 16:13:31 Member clone 1 // foo
2025/10/11 16:13:31.901189 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (foo).clone() foo
2025/10/11 16:13:31.901200 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e2d0 clone} func() foo
2025/10/11 16:13:31 Call 0 0 // func() foo
2025/10/11 16:13:31 ==> MatchFuncCall func() foo args: 0 flags: 0
2025/10/11 16:13:31.901222 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e2e8 451 [] 0 [] 452 0} foo
2025/10/11 16:13:31 Member c 2 // foo
2025/10/11 16:13:31.901236 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.901245 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e8cc0 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNested func() nested
2025/10/11 16:13:31.901271 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/10/11 16:13:31.901280 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/10/11 16:13:31 Call 0 0 // func() nested
2025/10/11 16:13:31 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/10/11 16:13:31.901306 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 470 [] 0 [] 471 0} nested
2025/10/11 16:13:31 Member f 2 // nested
2025/10/11 16:13:31.901320 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/10/11 16:13:31.901331 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e8d20 f} foo
2025/10/11 16:13:31 Member clone 1 // foo
2025/10/11 16:13:31.901346 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (foo).clone() foo
2025/10/11 16:13:31.901355 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e318 clone} func() foo
2025/10/11 16:13:31 Call 0 0 // func() foo
2025/10/11 16:13:31 ==> MatchFuncCall func() foo args: 0 flags: 0
2025/10/11 16:13:31.901378 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e330 480 [] 0 [] 481 0} foo
2025/10/11 16:13:31 Member ptr 1 // foo
2025/10/11 16:13:31.901393 [INFO] typesutil/gopinfo.go:265: ==> Use: ptr func (foo).ptr() *foo
2025/10/11 16:13:31.901402 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e9320 ptr} func() *foo
2025/10/11 16:13:31 Call 0 0 // func() *foo
2025/10/11 16:13:31 ==> MatchFuncCall func() *foo args: 0 flags: 0
2025/10/11 16:13:31.901428 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e348 486 [] 0 [] 487 0} *foo
2025/10/11 16:13:31 Member c 2 // *foo
2025/10/11 16:13:31.901445 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.901455 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e9500 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNestedPtr func() *nested
2025/10/11 16:13:31.901480 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/10/11 16:13:31.901489 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/10/11 16:13:31 Call 0 0 // func() *nested
2025/10/11 16:13:31 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/10/11 16:13:31.901513 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 509 [] 0 [] 510 0} *nested
2025/10/11 16:13:31 Member f 2 // *nested
2025/10/11 16:13:31.901530 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/10/11 16:13:31.901538 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e9740 f} foo
2025/10/11 16:13:31 Member c 2 // foo
2025/10/11 16:13:31.901552 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.901561 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e378 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNestedPtr func() *nested
2025/10/11 16:13:31.901585 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/10/11 16:13:31.901594 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/10/11 16:13:31 Call 0 0 // func() *nested
2025/10/11 16:13:31 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/10/11 16:13:31.901620 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 533 [] 0 [] 534 0} *nested
2025/10/11 16:13:31 Member a 2 // *nested
2025/10/11 16:13:31.901638 [INFO] typesutil/gopinfo.go:265: ==> Use: a field a [2]foo
2025/10/11 16:13:31.901647 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e97a0 a} [2]foo
2025/10/11 16:13:31 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:31.901668 [INFO] typesutil/gopinfo.go:215: ==> Type: &{538 INT 0 <nil>} untyped int
2025/10/11 16:13:31 Index 1 false
2025/10/11 16:13:31.901682 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e3a8 537 0xc0005b6db0 539} foo
2025/10/11 16:13:31 Member c 2 // foo
2025/10/11 16:13:31.901698 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.901708 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005b6de0 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNestedPtr func() *nested
2025/10/11 16:13:31.901732 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/10/11 16:13:31.901741 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/10/11 16:13:31 Call 0 0 // func() *nested
2025/10/11 16:13:31 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/10/11 16:13:31.901766 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 560 [] 0 [] 561 0} *nested
2025/10/11 16:13:31 Member s 2 // *nested
2025/10/11 16:13:31.901781 [INFO] typesutil/gopinfo.go:265: ==> Use: s field s []foo
2025/10/11 16:13:31.901792 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e98c0 s} []foo
2025/10/11 16:13:31 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:31.901808 [INFO] typesutil/gopinfo.go:215: ==> Type: &{565 INT 0 <nil>} untyped int
2025/10/11 16:13:31 Index 1 false
2025/10/11 16:13:31.901826 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e3d8 564 0xc0005b6e10 566} foo
2025/10/11 16:13:31 Member c 2 // foo
2025/10/11 16:13:31.901842 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.901852 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005b6e40 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNestedPtr func() *nested
2025/10/11 16:13:31.901875 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/10/11 16:13:31.901884 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/10/11 16:13:31 Call 0 0 // func() *nested
2025/10/11 16:13:31 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/10/11 16:13:31.901908 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 587 [] 0 [] 588 0} *nested
2025/10/11 16:13:31 Member m 2 // *nested
2025/10/11 16:13:31.901922 [INFO] typesutil/gopinfo.go:265: ==> Use: m field m map[int]foo
2025/10/11 16:13:31.901932 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e99e0 m} map[int]foo
2025/10/11 16:13:31 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:31.901952 [INFO] typesutil/gopinfo.go:215: ==> Type: &{592 INT 0 <nil>} untyped int
2025/10/11 16:13:31 Index 1 false
2025/10/11 16:13:31.901966 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e408 591 0xc0005b6e70 593} foo
2025/10/11 16:13:31 Member c 2 // foo
2025/10/11 16:13:31.901981 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.901992 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005b6ea0 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNestedPtr func() *nested
2025/10/11 16:13:31.902021 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/10/11 16:13:31.902029 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/10/11 16:13:31 Call 0 0 // func() *nested
2025/10/11 16:13:31 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/10/11 16:13:31.902052 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 614 [] 0 [] 615 0} *nested
2025/10/11 16:13:31 Member f 2 // *nested
2025/10/11 16:13:31.902067 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/10/11 16:13:31.902075 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e9b00 f} foo
2025/10/11 16:13:31 Member ptr 1 // foo
2025/10/11 16:13:31.902096 [INFO] typesutil/gopinfo.go:265: ==> Use: ptr func (foo).ptr() *foo
2025/10/11 16:13:31.902105 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e438 ptr} func() *foo
2025/10/11 16:13:31 Call 0 0 // func() *foo
2025/10/11 16:13:31 ==> MatchFuncCall func() *foo args: 0 flags: 0
2025/10/11 16:13:31.902129 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e450 622 [] 0 [] 623 0} *foo
2025/10/11 16:13:31 Member c 2 // *foo
2025/10/11 16:13:31.902147 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.902157 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e9c80 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNestedPtr func() *nested
2025/10/11 16:13:31.902180 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/10/11 16:13:31.902197 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/10/11 16:13:31 Call 0 0 // func() *nested
2025/10/11 16:13:31 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/10/11 16:13:31.902222 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 644 [] 0 [] 645 0} *nested
2025/10/11 16:13:31 Member f 2 // *nested
2025/10/11 16:13:31.902236 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/10/11 16:13:31.902245 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e9ce0 f} foo
2025/10/11 16:13:31 Member clone 1 // foo
2025/10/11 16:13:31.902260 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (foo).clone() foo
2025/10/11 16:13:31.902269 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e480 clone} func() foo
2025/10/11 16:13:31 Call 0 0 // func() foo
2025/10/11 16:13:31 ==> MatchFuncCall func() foo args: 0 flags: 0
2025/10/11 16:13:31.902293 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e498 654 [] 0 [] 655 0} foo
2025/10/11 16:13:31 Member c 2 // foo
2025/10/11 16:13:31.902306 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.902321 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e9d40 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31 VarRef _
2025/10/11 16:13:31 Val getNestedPtr func() *nested
2025/10/11 16:13:31.902346 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/10/11 16:13:31.902355 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/10/11 16:13:31 Call 0 0 // func() *nested
2025/10/11 16:13:31 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/10/11 16:13:31.902379 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 676 [] 0 [] 677 0} *nested
2025/10/11 16:13:31 Member f 2 // *nested
2025/10/11 16:13:31.902394 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/10/11 16:13:31.902405 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e9da0 f} foo
2025/10/11 16:13:31 Member clone 1 // foo
2025/10/11 16:13:31.902422 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (foo).clone() foo
2025/10/11 16:13:31.902431 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e4c8 clone} func() foo
2025/10/11 16:13:31 Call 0 0 // func() foo
2025/10/11 16:13:31 ==> MatchFuncCall func() foo args: 0 flags: 0
2025/10/11 16:13:31.902454 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e4e0 686 [] 0 [] 687 0} foo
2025/10/11 16:13:31 Member ptr 1 // foo
2025/10/11 16:13:31.902469 [INFO] typesutil/gopinfo.go:265: ==> Use: ptr func (foo).ptr() *foo
2025/10/11 16:13:31.902499 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002e9e00 ptr} func() *foo
2025/10/11 16:13:31 Call 0 0 // func() *foo
2025/10/11 16:13:31 ==> MatchFuncCall func() *foo args: 0 flags: 0
2025/10/11 16:13:31.902545 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00000e4f8 692 [] 0 [] 693 0} *foo
2025/10/11 16:13:31 Member c 2 // *foo
2025/10/11 16:13:31.902559 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/10/11 16:13:31.902570 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003fa060 c} int
2025/10/11 16:13:31 Assign 1 1
2025/10/11 16:13:31.902592 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00025bec0 {
.  var getNested func() nested
.  var getNestedPtr func() *nested
}

2025/10/11 16:13:31 End // Func
2025/10/11 16:13:31 NewFunc ptr (foo) func() *foo
2025/10/11 16:13:31 Val f foo
2025/10/11 16:13:31.902625 [INFO] typesutil/gopinfo.go:265: ==> Use: f var f foo
2025/10/11 16:13:31.902632 [INFO] typesutil/gopinfo.go:215: ==> Type: f foo
2025/10/11 16:13:31 UnaryOp & flags: 0
2025/10/11 16:13:31 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:13:31.902661 [INFO] typesutil/gopinfo.go:215: ==> Type: &{85 & f} *foo
2025/10/11 16:13:31 Return 1
2025/10/11 16:13:31 ==> MatchType *foo, *foo
2025/10/11 16:13:31.902690 [INFO] typesutil/gopinfo.go:332: ==> Scope: func ptr scope 0xc000264ae0 {
.  var f foo
}

2025/10/11 16:13:31 End // Func
2025/10/11 16:13:31 NewFunc clone (foo) func() foo
2025/10/11 16:13:31 Val f foo
2025/10/11 16:13:31.902724 [INFO] typesutil/gopinfo.go:265: ==> Use: f var f foo
2025/10/11 16:13:31.902733 [INFO] typesutil/gopinfo.go:215: ==> Type: f foo
2025/10/11 16:13:31 Return 1
2025/10/11 16:13:31 ==> MatchType foo, foo
2025/10/11 16:13:31.902754 [INFO] typesutil/gopinfo.go:332: ==> Scope: func clone scope 0xc000264b40 {
.  var f foo
}

2025/10/11 16:13:31 End // Func
    info_test.go:226: ====== check types pass (count: 118) ======
        000:  3:10 | struct {
        	c int
        	p *int
        } *ast.StructType                | type    : struct{c int; p *int} | type
        001:  3:20 | int                 *ast.Ident                     | type    : int | type
        002:  3:27 | *int                *ast.StarExpr                  | type    : *int | type
        003:  3:28 | int                 *ast.Ident                     | type    : int | type
        004:  5: 9 | foo                 *ast.Ident                     | type    : foo | type
        005:  5:20 | *foo                *ast.StarExpr                  | type    : *foo | type
        006:  5:21 | foo                 *ast.Ident                     | type    : foo | type
        007:  5:34 | &f                  *ast.UnaryExpr                 | value   : *foo | value
        008:  5:35 | f                   *ast.Ident                     | var     : foo | variable
        009:  6: 9 | foo                 *ast.Ident                     | type    : foo | type
        010:  6:22 | foo                 *ast.Ident                     | type    : foo | type
        011:  6:35 | f                   *ast.Ident                     | var     : foo | variable
        012:  8:13 | struct {
        	f foo
        	a [2]foo
        	s []foo
        	m map[int]foo
        } *ast.StructType                | type    : struct{f foo; a [2]foo; s []foo; m map[int]foo} | type
        013:  9: 4 | foo                 *ast.Ident                     | type    : foo | type
        014: 10: 4 | [2]foo              *ast.ArrayType                 | type    : [2]foo | type
        015: 10: 5 | 2                   *ast.BasicLit                  | value   : INT = 2 | constant
        016: 10: 7 | foo                 *ast.Ident                     | type    : foo | type
        017: 11: 4 | []foo               *ast.ArrayType                 | type    : []foo | type
        018: 11: 6 | foo                 *ast.Ident                     | type    : foo | type
        019: 12: 4 | map[int]foo         *ast.MapType                   | type    : map[int]foo | type
        020: 12: 8 | int                 *ast.Ident                     | type    : int | type
        021: 12:12 | foo                 *ast.Ident                     | type    : foo | type
        022: 16:15 | func() nested       *ast.FuncType                  | type    : func() nested | type
        023: 16:15 | func() nested { return nested{} } *ast.FuncLit                   | value   : func() nested | value
        024: 16:22 | nested              *ast.Ident                     | type    : nested | type
        025: 16:38 | nested              *ast.Ident                     | type    : nested | type
        026: 16:38 | nested{}            *ast.CompositeLit              | value   : nested | value
        027: 17:18 | func() *nested      *ast.FuncType                  | type    : func() *nested | type
        028: 17:18 | func() *nested { return &nested{} } *ast.FuncLit                   | value   : func() *nested | value
        029: 17:25 | *nested             *ast.StarExpr                  | type    : *nested | type
        030: 17:26 | nested              *ast.Ident                     | type    : nested | type
        031: 17:42 | &nested{}           *ast.UnaryExpr                 | value   : *nested | value
        032: 17:43 | nested              *ast.Ident                     | type    : nested | type
        033: 17:43 | nested{}            *ast.CompositeLit              | value   : nested | value
        034: 19: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        035: 19: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        036: 19: 6 | getNested().f       *ast.SelectorExpr              | value   : foo | value
        037: 19: 6 | getNested().f.c     *ast.SelectorExpr              | value   : int | value
        038: 20: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        039: 20: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        040: 20: 6 | getNested().a       *ast.SelectorExpr              | value   : [2]foo | value
        041: 20: 6 | getNested().a[0]    *ast.IndexExpr                 | value   : foo | value
        042: 20: 6 | getNested().a[0].c  *ast.SelectorExpr              | value   : int | value
        043: 20:20 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        044: 21: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        045: 21: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        046: 21: 6 | getNested().s       *ast.SelectorExpr              | value   : []foo | value
        047: 21: 6 | getNested().s[0]    *ast.IndexExpr                 | var     : foo | variable
        048: 21: 6 | getNested().s[0].c  *ast.SelectorExpr              | var     : int | variable
        049: 21:20 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        050: 22: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        051: 22: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        052: 22: 6 | getNested().m       *ast.SelectorExpr              | value   : map[int]foo | value
        053: 22: 6 | getNested().m[0]    *ast.IndexExpr                 | mapindex : foo | map index expression
        054: 22: 6 | getNested().m[0].c  *ast.SelectorExpr              | value   : int | value
        055: 22:20 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        056: 23: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        057: 23: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        058: 23: 6 | getNested().f       *ast.SelectorExpr              | value   : foo | value
        059: 23: 6 | getNested().f.ptr   *ast.SelectorExpr              | value   : func() *foo | value
        060: 23: 6 | getNested().f.ptr() *ast.CallExpr                  | value   : *foo | value
        061: 23: 6 | getNested().f.ptr().c *ast.SelectorExpr              | var     : int | variable
        062: 24: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        063: 24: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        064: 24: 6 | getNested().f       *ast.SelectorExpr              | value   : foo | value
        065: 24: 6 | getNested().f.clone *ast.SelectorExpr              | value   : func() foo | value
        066: 24: 6 | getNested().f.clone() *ast.CallExpr                  | value   : foo | value
        067: 24: 6 | getNested().f.clone().c *ast.SelectorExpr              | value   : int | value
        068: 25: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        069: 25: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        070: 25: 6 | getNested().f       *ast.SelectorExpr              | value   : foo | value
        071: 25: 6 | getNested().f.clone *ast.SelectorExpr              | value   : func() foo | value
        072: 25: 6 | getNested().f.clone() *ast.CallExpr                  | value   : foo | value
        073: 25: 6 | getNested().f.clone().ptr *ast.SelectorExpr              | value   : func() *foo | value
        074: 25: 6 | getNested().f.clone().ptr() *ast.CallExpr                  | value   : *foo | value
        075: 25: 6 | getNested().f.clone().ptr().c *ast.SelectorExpr              | var     : int | variable
        076: 27: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        077: 27: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        078: 27: 6 | getNestedPtr().f    *ast.SelectorExpr              | var     : foo | variable
        079: 27: 6 | getNestedPtr().f.c  *ast.SelectorExpr              | var     : int | variable
        080: 28: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        081: 28: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        082: 28: 6 | getNestedPtr().a    *ast.SelectorExpr              | var     : [2]foo | variable
        083: 28: 6 | getNestedPtr().a[0] *ast.IndexExpr                 | var     : foo | variable
        084: 28: 6 | getNestedPtr().a[0].c *ast.SelectorExpr              | var     : int | variable
        085: 28:23 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        086: 29: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        087: 29: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        088: 29: 6 | getNestedPtr().s    *ast.SelectorExpr              | var     : []foo | variable
        089: 29: 6 | getNestedPtr().s[0] *ast.IndexExpr                 | var     : foo | variable
        090: 29: 6 | getNestedPtr().s[0].c *ast.SelectorExpr              | var     : int | variable
        091: 29:23 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        092: 30: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        093: 30: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        094: 30: 6 | getNestedPtr().m    *ast.SelectorExpr              | var     : map[int]foo | variable
        095: 30: 6 | getNestedPtr().m[0] *ast.IndexExpr                 | mapindex : foo | map index expression
        096: 30: 6 | getNestedPtr().m[0].c *ast.SelectorExpr              | value   : int | value
        097: 30:23 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        098: 31: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        099: 31: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        100: 31: 6 | getNestedPtr().f    *ast.SelectorExpr              | var     : foo | variable
        101: 31: 6 | getNestedPtr().f.ptr *ast.SelectorExpr              | value   : func() *foo | value
        102: 31: 6 | getNestedPtr().f.ptr() *ast.CallExpr                  | value   : *foo | value
        103: 31: 6 | getNestedPtr().f.ptr().c *ast.SelectorExpr              | var     : int | variable
        104: 32: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        105: 32: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        106: 32: 6 | getNestedPtr().f    *ast.SelectorExpr              | var     : foo | variable
        107: 32: 6 | getNestedPtr().f.clone *ast.SelectorExpr              | value   : func() foo | value
        108: 32: 6 | getNestedPtr().f.clone() *ast.CallExpr                  | value   : foo | value
        109: 32: 6 | getNestedPtr().f.clone().c *ast.SelectorExpr              | value   : int | value
        110: 33: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        111: 33: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        112: 33: 6 | getNestedPtr().f    *ast.SelectorExpr              | var     : foo | variable
        113: 33: 6 | getNestedPtr().f.clone *ast.SelectorExpr              | value   : func() foo | value
        114: 33: 6 | getNestedPtr().f.clone() *ast.CallExpr                  | value   : foo | value
        115: 33: 6 | getNestedPtr().f.clone().ptr *ast.SelectorExpr              | value   : func() *foo | value
        116: 33: 6 | getNestedPtr().f.clone().ptr() *ast.CallExpr                  | value   : *foo | value
        117: 33: 6 | getNestedPtr().f.clone().ptr().c *ast.SelectorExpr              | var     : int | variable
    info_test.go:226: ====== check defs pass (count: 15) ======
        000:  3: 6 | foo                 | type foo struct{c int; p *int}
        001:  3:18 | c                   | field c int
        002:  3:25 | p                   | field p *int
        003:  5: 7 | f                   | var f foo
        004:  5:14 | ptr                 | func (foo).ptr() *foo
        005:  6: 7 | f                   | var f foo
        006:  6:14 | clone               | func (foo).clone() foo
        007:  8: 6 | nested              | type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
        008:  9: 2 | f                   | field f foo
        009: 10: 2 | a                   | field a [2]foo
        010: 11: 2 | s                   | field s []foo
        011: 12: 2 | m                   | field m map[int]foo
        012: 15: 6 | _                   | func _()
        013: 16: 2 | getNested           | var getNested func() nested
        014: 17: 2 | getNestedPtr        | var getNestedPtr func() *nested
    info_test.go:226: ====== check uses pass (count: 67) ======
        000:  3:20 | int                 | type int
        001:  3:28 | int                 | type int
        002:  5: 9 | foo                 | type foo struct{c int; p *int}
        003:  5:21 | foo                 | type foo struct{c int; p *int}
        004:  5:35 | f                   | var f foo
        005:  6: 9 | foo                 | type foo struct{c int; p *int}
        006:  6:22 | foo                 | type foo struct{c int; p *int}
        007:  6:35 | f                   | var f foo
        008:  9: 4 | foo                 | type foo struct{c int; p *int}
        009: 10: 7 | foo                 | type foo struct{c int; p *int}
        010: 11: 6 | foo                 | type foo struct{c int; p *int}
        011: 12: 8 | int                 | type int
        012: 12:12 | foo                 | type foo struct{c int; p *int}
        013: 16:22 | nested              | type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
        014: 16:38 | nested              | type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
        015: 17:26 | nested              | type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
        016: 17:43 | nested              | type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
        017: 19: 6 | getNested           | var getNested func() nested
        018: 19:18 | f                   | field f foo
        019: 19:20 | c                   | field c int
        020: 20: 6 | getNested           | var getNested func() nested
        021: 20:18 | a                   | field a [2]foo
        022: 20:23 | c                   | field c int
        023: 21: 6 | getNested           | var getNested func() nested
        024: 21:18 | s                   | field s []foo
        025: 21:23 | c                   | field c int
        026: 22: 6 | getNested           | var getNested func() nested
        027: 22:18 | m                   | field m map[int]foo
        028: 22:23 | c                   | field c int
        029: 23: 6 | getNested           | var getNested func() nested
        030: 23:18 | f                   | field f foo
        031: 23:20 | ptr                 | func (foo).ptr() *foo
        032: 23:26 | c                   | field c int
        033: 24: 6 | getNested           | var getNested func() nested
        034: 24:18 | f                   | field f foo
        035: 24:20 | clone               | func (foo).clone() foo
        036: 24:28 | c                   | field c int
        037: 25: 6 | getNested           | var getNested func() nested
        038: 25:18 | f                   | field f foo
        039: 25:20 | clone               | func (foo).clone() foo
        040: 25:28 | ptr                 | func (foo).ptr() *foo
        041: 25:34 | c                   | field c int
        042: 27: 6 | getNestedPtr        | var getNestedPtr func() *nested
        043: 27:21 | f                   | field f foo
        044: 27:23 | c                   | field c int
        045: 28: 6 | getNestedPtr        | var getNestedPtr func() *nested
        046: 28:21 | a                   | field a [2]foo
        047: 28:26 | c                   | field c int
        048: 29: 6 | getNestedPtr        | var getNestedPtr func() *nested
        049: 29:21 | s                   | field s []foo
        050: 29:26 | c                   | field c int
        051: 30: 6 | getNestedPtr        | var getNestedPtr func() *nested
        052: 30:21 | m                   | field m map[int]foo
        053: 30:26 | c                   | field c int
        054: 31: 6 | getNestedPtr        | var getNestedPtr func() *nested
        055: 31:21 | f                   | field f foo
        056: 31:23 | ptr                 | func (foo).ptr() *foo
        057: 31:29 | c                   | field c int
        058: 32: 6 | getNestedPtr        | var getNestedPtr func() *nested
        059: 32:21 | f                   | field f foo
        060: 32:23 | clone               | func (foo).clone() foo
        061: 32:31 | c                   | field c int
        062: 33: 6 | getNestedPtr        | var getNestedPtr func() *nested
        063: 33:21 | f                   | field f foo
        064: 33:23 | clone               | func (foo).clone() foo
        065: 33:31 | ptr                 | func (foo).ptr() *foo
        066: 33:37 | c                   | field c int
--- PASS: TestAddress (1.26s)
=== RUN   TestAddress2
2025/10/11 16:13:31.909156 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:32 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:32 ==> NewOverloadFunc NewRange
2025/10/11 16:13:32 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:32 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:32 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:32 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:32 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:32 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:32 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:32 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:32 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:32 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:32 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:32 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:32 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:32 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:33.084252 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003952c0 {
}

2025/10/11 16:13:33.084296 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package os
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload type T
2025/10/11 16:13:33 ==> Preload method T._
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func f
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Preload func _
2025/10/11 16:13:33 ==> Load > NewType T
2025/10/11 16:13:33 NewType T
2025/10/11 16:13:33 ==> Load > InitType T
2025/10/11 16:13:33.084431 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.084448 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.084459 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33 InitType T int
2025/10/11 16:13:33.084478 [INFO] typesutil/gopinfo.go:251: ==> Def: T type T int
2025/10/11 16:13:33 ==> LookupParent T => type T int
2025/10/11 16:13:33.084496 [INFO] typesutil/gopinfo.go:265: ==> Use: T type T int
2025/10/11 16:13:33.084508 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/10/11 16:13:33.084520 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x T
2025/10/11 16:13:33 ==> Load method T._
2025/10/11 16:13:33.084545 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func (T)._()
2025/10/11 16:13:33 ==> Load func f
2025/10/11 16:13:33.084565 [INFO] typesutil/gopinfo.go:251: ==> Def: f func f()
2025/10/11 16:13:33 NewFunc f func()
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val f func()
2025/10/11 16:13:33.084601 [INFO] typesutil/gopinfo.go:265: ==> Use: f func f()
2025/10/11 16:13:33.084612 [INFO] typesutil/gopinfo.go:215: ==> Type: f func()
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.084629 [INFO] typesutil/gopinfo.go:332: ==> Scope: func f scope 0xc0003954a0 {
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.084657 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33.084680 [INFO] typesutil/gopinfo.go:265: ==> Use: os package os
2025/10/11 16:13:33.084694 [INFO] typesutil/gopinfo.go:265: ==> Use: Stdout var os.Stdout *os.File
2025/10/11 16:13:33 Val Stdout *os.File
2025/10/11 16:13:33.084724 [INFO] typesutil/gopinfo.go:215: ==> Type: &{os Stdout} *os.File
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.084740 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000395560 {
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.084758 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33.084778 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.084788 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.084797 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33 ==> Load var int [a]
2025/10/11 16:13:33 NewVarDefs
2025/10/11 16:13:33 NewVar [a]
2025/10/11 16:13:33.084829 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val a int
2025/10/11 16:13:33.084853 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/10/11 16:13:33.084863 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.084882 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000395620 {
.  var a int
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.084903 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33.084921 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.084931 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.084939 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.084954 [INFO] typesutil/gopinfo.go:215: ==> Type: &{103 int} *int
2025/10/11 16:13:33 ==> Load var *int [p]
2025/10/11 16:13:33 NewVarDefs
2025/10/11 16:13:33 NewVar [p]
2025/10/11 16:13:33.084985 [INFO] typesutil/gopinfo.go:251: ==> Def: p var p *int
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val p *int
2025/10/11 16:13:33.085011 [INFO] typesutil/gopinfo.go:265: ==> Use: p var p *int
2025/10/11 16:13:33.085027 [INFO] typesutil/gopinfo.go:215: ==> Type: p *int
2025/10/11 16:13:33 Star
2025/10/11 16:13:33.085046 [INFO] typesutil/gopinfo.go:215: ==> Type: &{113 p} int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.085064 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000395740 {
.  var p *int
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.085085 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33.085101 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.085111 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.085120 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.085134 [INFO] typesutil/gopinfo.go:215: ==> Type: &{136 <nil> int} []int
2025/10/11 16:13:33 ==> Load var []int [s]
2025/10/11 16:13:33 NewVarDefs
2025/10/11 16:13:33 NewVar [s]
2025/10/11 16:13:33.085164 [INFO] typesutil/gopinfo.go:251: ==> Def: s var s []int
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val s []int
2025/10/11 16:13:33.085184 [INFO] typesutil/gopinfo.go:265: ==> Use: s var s []int
2025/10/11 16:13:33.085196 [INFO] typesutil/gopinfo.go:215: ==> Type: s []int
2025/10/11 16:13:33 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:33.085228 [INFO] typesutil/gopinfo.go:215: ==> Type: &{149 INT 0 <nil>} untyped int
2025/10/11 16:13:33 Index 1 false
2025/10/11 16:13:33.085252 [INFO] typesutil/gopinfo.go:215: ==> Type: &{s 148 0xc000227200 150} int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.085272 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000395860 {
.  var s []int
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.085290 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33.085309 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.085317 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.085327 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.085338 [INFO] typesutil/gopinfo.go:251: ==> Def: f field f int
2025/10/11 16:13:33.085356 [INFO] typesutil/gopinfo.go:215: ==> Type: &{172 0xc000227410 false} struct{f int}
2025/10/11 16:13:33 ==> Load var struct{f int} [s]
2025/10/11 16:13:33 NewVarDefs
2025/10/11 16:13:33 NewVar [s]
2025/10/11 16:13:33.085389 [INFO] typesutil/gopinfo.go:251: ==> Def: s var s struct{f int}
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val s struct{f int}
2025/10/11 16:13:33.085465 [INFO] typesutil/gopinfo.go:265: ==> Use: s var s struct{f int}
2025/10/11 16:13:33.085481 [INFO] typesutil/gopinfo.go:215: ==> Type: s struct{f int}
2025/10/11 16:13:33 Member f 2 // struct{f int}
2025/10/11 16:13:33.085501 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f int
2025/10/11 16:13:33.085514 [INFO] typesutil/gopinfo.go:215: ==> Type: &{s f} int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.085532 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000395980 {
.  var s struct{f int}
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.085556 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33.085579 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.085590 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.085599 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33 Val &{0 INT 10} *ast.BasicLit
2025/10/11 16:13:33.085620 [INFO] typesutil/gopinfo.go:215: ==> Type: &{216 INT 10 <nil>} untyped int
2025/10/11 16:13:33.085635 [INFO] typesutil/gopinfo.go:215: ==> Type: &{215 0xc000227530 int} [10]int
2025/10/11 16:13:33 ==> Load var [10]int [a]
2025/10/11 16:13:33 NewVarDefs
2025/10/11 16:13:33 NewVar [a]
2025/10/11 16:13:33.085665 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a [10]int
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val a [10]int
2025/10/11 16:13:33.085690 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a [10]int
2025/10/11 16:13:33.085698 [INFO] typesutil/gopinfo.go:215: ==> Type: a [10]int
2025/10/11 16:13:33 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:33.085719 [INFO] typesutil/gopinfo.go:215: ==> Type: &{230 INT 0 <nil>} untyped int
2025/10/11 16:13:33 Index 1 false
2025/10/11 16:13:33.085738 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 229 0xc000227590 231} int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.085755 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000395b00 {
.  var a [10]int
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.085774 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.085784 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.085794 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.085803 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:33.085816 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(x int)
2025/10/11 16:13:33 NewFunc _ func(x int)
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val x int
2025/10/11 16:13:33.085848 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:33.085857 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.085874 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000395c80 {
.  var x int
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.085896 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.085905 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.085914 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.085925 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:33.085937 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _() (x int)
2025/10/11 16:13:33 NewFunc _ func() (x int)
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val x int
2025/10/11 16:13:33.085964 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:33.085978 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33 Return 0
2025/10/11 16:13:33.086014 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000395da0 {
.  var x int
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.086034 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33.086049 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.086060 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.086070 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33 ==> Load var int [a b]
2025/10/11 16:13:33 NewVarDefs
2025/10/11 16:13:33 NewVar [a b]
2025/10/11 16:13:33.086100 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/10/11 16:13:33.086109 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val a int
2025/10/11 16:13:33.086128 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/10/11 16:13:33.086138 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/10/11 16:13:33 Val b int
2025/10/11 16:13:33.086152 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b int
2025/10/11 16:13:33.086164 [INFO] typesutil/gopinfo.go:215: ==> Type: b int
2025/10/11 16:13:33 BinaryOp +
2025/10/11 16:13:33 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:33 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:33 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:33.086235 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 365 + b} int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.086256 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000395e60 {
.  var a int
.  var b int
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.086280 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33.086302 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.086311 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.086319 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.086335 [INFO] typesutil/gopinfo.go:215: ==> Type: &{388 <nil> int} []int
2025/10/11 16:13:33 Val &{0 INT 1} *ast.BasicLit
2025/10/11 16:13:33.086356 [INFO] typesutil/gopinfo.go:215: ==> Type: &{394 INT 1 <nil>} untyped int
2025/10/11 16:13:33 SliceLit []int 1 false
2025/10/11 16:13:33.086379 [INFO] typesutil/gopinfo.go:215: ==> Type: &{388 <nil> int} []int
2025/10/11 16:13:33.086395 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000227b60 393 [0xc000227b90] 395 false} []int
2025/10/11 16:13:33 UnaryOp & flags: 0
2025/10/11 16:13:33 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/10/11 16:13:33.086426 [INFO] typesutil/gopinfo.go:215: ==> Type: &{387 & 0xc00025e740} *[]int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.086443 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003d6180 {
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.086465 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33.086487 [INFO] typesutil/gopinfo.go:215: ==> Type: &{415 <nil> 0xc000227ce0 <nil>} func()
2025/10/11 16:13:33.086500 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00053aa40 0xc000227d70} func()
2025/10/11 16:13:33 NewClosure func()
2025/10/11 16:13:33.086518 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003d6300 {
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.086540 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003d6240 {
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.086557 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33.086574 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.086584 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.086594 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.086603 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.086613 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.086622 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.086635 [INFO] typesutil/gopinfo.go:215: ==> Type: &{463 int int} map[int]int
2025/10/11 16:13:33 ==> Load var map[int]int [m]
2025/10/11 16:13:33 NewVarDefs
2025/10/11 16:13:33 NewVar [m]
2025/10/11 16:13:33.086663 [INFO] typesutil/gopinfo.go:251: ==> Def: m var m map[int]int
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val m map[int]int
2025/10/11 16:13:33.086688 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]int
2025/10/11 16:13:33.086697 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]int
2025/10/11 16:13:33 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:33.086718 [INFO] typesutil/gopinfo.go:215: ==> Type: &{482 INT 0 <nil>} untyped int
2025/10/11 16:13:33 Index 1 false
2025/10/11 16:13:33.086735 [INFO] typesutil/gopinfo.go:215: ==> Type: &{m 481 0xc00071c090 483} int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val m map[int]int
2025/10/11 16:13:33.086765 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]int
2025/10/11 16:13:33.086775 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]int
2025/10/11 16:13:33 Val &{0 INT 0} *ast.BasicLit
2025/10/11 16:13:33.086798 [INFO] typesutil/gopinfo.go:215: ==> Type: &{495 INT 0 <nil>} untyped int
2025/10/11 16:13:33 Index 1 true
2025/10/11 16:13:33.086816 [INFO] typesutil/gopinfo.go:215: ==> Type: &{m 494 0xc00071c0f0 496} (int, bool)
2025/10/11 16:13:33 Assign 2 1
2025/10/11 16:13:33.086834 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003d63c0 {
.  var m map[int]int
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 ==> Load func _
2025/10/11 16:13:33.086856 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/10/11 16:13:33 NewFunc _ func()
2025/10/11 16:13:33.086875 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:33.086889 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.086900 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:33.086915 [INFO] typesutil/gopinfo.go:215: ==> Type: &{519 0 3 int} chan int
2025/10/11 16:13:33 ==> Load var chan int [ch]
2025/10/11 16:13:33 NewVarDefs
2025/10/11 16:13:33 NewVar [ch]
2025/10/11 16:13:33.086944 [INFO] typesutil/gopinfo.go:251: ==> Def: ch var ch chan int
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val ch chan int
2025/10/11 16:13:33.086970 [INFO] typesutil/gopinfo.go:265: ==> Use: ch var ch chan int
2025/10/11 16:13:33.086979 [INFO] typesutil/gopinfo.go:215: ==> Type: ch chan int
2025/10/11 16:13:33 UnaryOp <- flags: 0
2025/10/11 16:13:33 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/10/11 16:13:33.087007 [INFO] typesutil/gopinfo.go:215: ==> Type: &{533 <- ch} int
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val ch chan int
2025/10/11 16:13:33.087040 [INFO] typesutil/gopinfo.go:265: ==> Use: ch var ch chan int
2025/10/11 16:13:33.087048 [INFO] typesutil/gopinfo.go:215: ==> Type: ch chan int
2025/10/11 16:13:33 UnaryOp <- flags: 2
2025/10/11 16:13:33 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 2
2025/10/11 16:13:33.087076 [INFO] typesutil/gopinfo.go:215: ==> Type: &{546 <- ch} (int, bool)
2025/10/11 16:13:33 Assign 2 1
2025/10/11 16:13:33.087094 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003d65a0 {
.  var ch chan int
}

2025/10/11 16:13:33 End // Func
2025/10/11 16:13:33 NewFunc _ (T) func()
2025/10/11 16:13:33 VarRef _
2025/10/11 16:13:33 Val x T
2025/10/11 16:13:33.087132 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x T
2025/10/11 16:13:33.087141 [INFO] typesutil/gopinfo.go:215: ==> Type: x T
2025/10/11 16:13:33 Assign 1 1
2025/10/11 16:13:33.087157 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003d6720 {
.  var x T
}

2025/10/11 16:13:33 End // Func
    info_test.go:226: ====== check types pass (count: 56) ======
        000:  4:16 | os.Stdout           *ast.SelectorExpr              | var     : *os.File | variable
        001:  6: 8 | int                 *ast.Ident                     | type    : int | type
        002:  7: 6 | a                   *ast.Ident                     | var     : int | variable
        003: 10: 8 | *int                *ast.StarExpr                  | type    : *int | type
        004: 10: 9 | int                 *ast.Ident                     | type    : int | type
        005: 11: 6 | *p                  *ast.StarExpr                  | var     : int | variable
        006: 11: 7 | p                   *ast.Ident                     | var     : *int | variable
        007: 14: 8 | []int               *ast.ArrayType                 | type    : []int | type
        008: 14:10 | int                 *ast.Ident                     | type    : int | type
        009: 15: 6 | s                   *ast.Ident                     | var     : []int | variable
        010: 15: 6 | s[0]                *ast.IndexExpr                 | var     : int | variable
        011: 15: 8 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        012: 18: 8 | struct{ f int }     *ast.StructType                | type    : struct{f int} | type
        013: 18:17 | int                 *ast.Ident                     | type    : int | type
        014: 19: 6 | s                   *ast.Ident                     | var     : struct{f int} | variable
        015: 19: 6 | s.f                 *ast.SelectorExpr              | var     : int | variable
        016: 22: 8 | [10]int             *ast.ArrayType                 | type    : [10]int | type
        017: 22: 9 | 10                  *ast.BasicLit                  | value   : INT = 10 | constant
        018: 22:12 | int                 *ast.Ident                     | type    : int | type
        019: 23: 6 | a                   *ast.Ident                     | var     : [10]int | variable
        020: 23: 6 | a[0]                *ast.IndexExpr                 | var     : int | variable
        021: 23: 8 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        022: 25:10 | int                 *ast.Ident                     | type    : int | type
        023: 26: 6 | x                   *ast.Ident                     | var     : int | variable
        024: 28:12 | int                 *ast.Ident                     | type    : int | type
        025: 29: 6 | x                   *ast.Ident                     | var     : int | variable
        026: 32: 8 | int                 *ast.Ident                     | type    : int | type
        027: 33: 9 | T                   *ast.Ident                     | type    : T | type
        028: 34: 6 | x                   *ast.Ident                     | var     : T | variable
        029: 38:11 | int                 *ast.Ident                     | type    : int | type
        030: 39: 6 | a                   *ast.Ident                     | var     : int | variable
        031: 39: 6 | a + b               *ast.BinaryExpr                | value   : int | value
        032: 39:10 | b                   *ast.Ident                     | var     : int | variable
        033: 42: 6 | &[]int{1}           *ast.UnaryExpr                 | value   : *[]int | value
        034: 42: 7 | []int               *ast.ArrayType                 | type    : []int | type
        035: 42: 7 | []int{1}            *ast.CompositeLit              | value   : []int | value
        036: 42: 9 | int                 *ast.Ident                     | type    : int | type
        037: 42:13 | 1                   *ast.BasicLit                  | value   : INT = 1 | constant
        038: 45: 6 | func()              *ast.FuncType                  | type    : func() | type
        039: 45: 6 | func() {}           *ast.FuncLit                   | value   : func() | value
        040: 47:16 | f                   *ast.Ident                     | value   : func() | value
        041: 49: 8 | map[int]int         *ast.MapType                   | type    : map[int]int | type
        042: 49:12 | int                 *ast.Ident                     | type    : int | type
        043: 49:16 | int                 *ast.Ident                     | type    : int | type
        044: 50: 6 | m                   *ast.Ident                     | var     : map[int]int | variable
        045: 50: 6 | m[0]                *ast.IndexExpr                 | mapindex : int | map index expression
        046: 50: 8 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        047: 51: 9 | m                   *ast.Ident                     | var     : map[int]int | variable
        048: 51: 9 | m[0]                *ast.IndexExpr                 | mapindex : (int, bool) | map index expression
        049: 51:11 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        050: 54: 9 | chan int            *ast.ChanType                  | type    : chan int | type
        051: 54:14 | int                 *ast.Ident                     | type    : int | type
        052: 55: 6 | <-ch                *ast.UnaryExpr                 | value   : int | comma, error expression
        053: 55: 8 | ch                  *ast.Ident                     | var     : chan int | variable
        054: 56: 9 | <-ch                *ast.UnaryExpr                 | value   : (int, bool) | comma, error expression
        055: 56:11 | ch                  *ast.Ident                     | var     : chan int | variable
    info_test.go:226: ====== check defs pass (count: 29) ======
        000:  4: 6 | _                   | func _()
        001:  5: 6 | _                   | func _()
        002:  6: 6 | a                   | var a int
        003:  9: 6 | _                   | func _()
        004: 10: 6 | p                   | var p *int
        005: 13: 6 | _                   | func _()
        006: 14: 6 | s                   | var s []int
        007: 17: 6 | _                   | func _()
        008: 18: 6 | s                   | var s struct{f int}
        009: 18:15 | f                   | field f int
        010: 21: 6 | _                   | func _()
        011: 22: 6 | a                   | var a [10]int
        012: 25: 6 | _                   | func _(x int)
        013: 25: 8 | x                   | var x int
        014: 28: 6 | _                   | func _() (x int)
        015: 28:10 | x                   | var x int
        016: 32: 6 | T                   | type T int
        017: 33: 7 | x                   | var x T
        018: 33:12 | _                   | func (T)._()
        019: 37: 6 | _                   | func _()
        020: 38: 6 | a                   | var a int
        021: 38: 9 | b                   | var b int
        022: 41: 6 | _                   | func _()
        023: 44: 6 | _                   | func _()
        024: 47: 6 | f                   | func f()
        025: 48: 6 | _                   | func _()
        026: 49: 6 | m                   | var m map[int]int
        027: 53: 6 | _                   | func _()
        028: 54: 6 | ch                  | var ch chan int
    info_test.go:226: ====== check uses pass (count: 32) ======
        000:  4:16 | os                  | package os
        001:  4:19 | Stdout              | var os.Stdout *os.File
        002:  6: 8 | int                 | type int
        003:  7: 6 | a                   | var a int
        004: 10: 9 | int                 | type int
        005: 11: 7 | p                   | var p *int
        006: 14:10 | int                 | type int
        007: 15: 6 | s                   | var s []int
        008: 18:17 | int                 | type int
        009: 19: 6 | s                   | var s struct{f int}
        010: 19: 8 | f                   | field f int
        011: 22:12 | int                 | type int
        012: 23: 6 | a                   | var a [10]int
        013: 25:10 | int                 | type int
        014: 26: 6 | x                   | var x int
        015: 28:12 | int                 | type int
        016: 29: 6 | x                   | var x int
        017: 32: 8 | int                 | type int
        018: 33: 9 | T                   | type T int
        019: 34: 6 | x                   | var x T
        020: 38:11 | int                 | type int
        021: 39: 6 | a                   | var a int
        022: 39:10 | b                   | var b int
        023: 42: 9 | int                 | type int
        024: 47:16 | f                   | func f()
        025: 49:12 | int                 | type int
        026: 49:16 | int                 | type int
        027: 50: 6 | m                   | var m map[int]int
        028: 51: 9 | m                   | var m map[int]int
        029: 54:14 | int                 | type int
        030: 55: 8 | ch                  | var ch chan int
        031: 56:11 | ch                  | var ch chan int
--- PASS: TestAddress2 (1.18s)
=== RUN   TestMixedPackage
2025/10/11 16:13:33.091899 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/10/11 16:13:33 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:33 ==> NewOverloadFunc NewRange
2025/10/11 16:13:33 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:33 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:33 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:33 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:33 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:33 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:33 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:33 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:33 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:33 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:33 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:33 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:33 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:33 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:34.325033 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003cbb60 {
}

2025/10/11 16:13:34 ==> Preload func main
2025/10/11 16:13:34 ==> Preload func Test__0
2025/10/11 16:13:34 ==> Preload func Test__1
2025/10/11 16:13:34 ==> Preload type N
2025/10/11 16:13:34 ==> Preload method N.Test__0
2025/10/11 16:13:34 ==> Preload method N.Test__1
2025/10/11 16:13:34 ==> Load > NewType N
2025/10/11 16:13:34 ==> Load > InitType N
2025/10/11 16:13:34 ==> LookupParent N => type main.N struct{}
2025/10/11 16:13:34 ==> Load method *main.N.Test__0
2025/10/11 16:13:34 ==> LookupParent N => type main.N struct{}
2025/10/11 16:13:34 ==> Load method *main.N.Test__1
2025/10/11 16:13:34 ==> Load func Test__0
2025/10/11 16:13:34 ==> Load func Test__1
2025/10/11 16:13:34 ==> NewOverloadMethod N Test
2025/10/11 16:13:34 ==> NewOverloadFunc Test
2025/10/11 16:13:34 ==> Load func main
2025/10/11 16:13:34.325290 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:13:34 NewFunc main func()
2025/10/11 16:13:34 Val Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34.325344 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34.325357 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Test TyOverloadFunc
2025/10/11 16:13:34.325376 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/10/11 16:13:34 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:13:34.325427 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test__0()
2025/10/11 16:13:34.325440 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func()
2025/10/11 16:13:34 Val Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34.325469 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34.325480 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Test TyOverloadFunc
2025/10/11 16:13:34.325496 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:13:34.325539 [INFO] typesutil/gopinfo.go:215: ==> Type: &{12 INT 100 <nil>} untyped int
2025/10/11 16:13:34 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/10/11 16:13:34 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:13:34 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/10/11 16:13:34 ==> MatchType untyped int (100), int
2025/10/11 16:13:34.325625 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test__1(n int)
2025/10/11 16:13:34.325638 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(n int)
2025/10/11 16:13:34.325665 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Test 0 [0xc00069fd40] 0 [] 0 15} ()
2025/10/11 16:13:34 ==> LookupParent N => type main.N struct{}
2025/10/11 16:13:34.325700 [INFO] typesutil/gopinfo.go:265: ==> Use: N type main.N struct{}
2025/10/11 16:13:34.325716 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/10/11 16:13:34.325730 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/10/11 16:13:34 ==> Load var main.N [n]
2025/10/11 16:13:34 NewVarDefs
2025/10/11 16:13:34 NewVar [n]
2025/10/11 16:13:34.325774 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n main.N
2025/10/11 16:13:34 Val n main.N
2025/10/11 16:13:34.325798 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n main.N
2025/10/11 16:13:34.325811 [INFO] typesutil/gopinfo.go:215: ==> Type: n main.N
2025/10/11 16:13:34 Member test 1 // main.N
2025/10/11 16:13:34.325840 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (main.N).Test(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34.325851 [INFO] typesutil/gopinfo.go:274: ==> Overloads: test TyOverloadMethod
2025/10/11 16:13:34.325869 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34 ==> MatchFuncCall TyOverloadMethod args: 0 flags: 0
2025/10/11 16:13:34 ==> MatchFuncCall func() args: 0 flags: 0
2025/10/11 16:13:34.325914 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (*main.N).Test__0()
2025/10/11 16:13:34.325928 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func()
2025/10/11 16:13:34 Val n main.N
2025/10/11 16:13:34.325954 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n main.N
2025/10/11 16:13:34.325967 [INFO] typesutil/gopinfo.go:215: ==> Type: n main.N
2025/10/11 16:13:34 Member test 1 // main.N
2025/10/11 16:13:34.325993 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (main.N).Test(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34.326005 [INFO] typesutil/gopinfo.go:274: ==> Overloads: test TyOverloadMethod
2025/10/11 16:13:34.326025 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:13:34.326058 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 INT 100 <nil>} untyped int
2025/10/11 16:13:34 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:34 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:13:34 ==> MatchFuncCall func() args: 1 flags: 0
2025/10/11 16:13:34 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/10/11 16:13:34 ==> MatchType untyped int (100), int
2025/10/11 16:13:34.326131 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (*main.N).Test__1(n int)
2025/10/11 16:13:34.326146 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(n int)
2025/10/11 16:13:34.326167 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00062ccf0 0 [0xc00069fd70] 0 [] 0 41} ()
2025/10/11 16:13:34.326192 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0003d6300 {
.  var n main.N
}

2025/10/11 16:13:34 End // Func
2025/10/11 16:13:34 ==> NewOverloadMethod N Test
2025/10/11 16:13:34 ==> NewOverloadFunc Test
--- PASS: TestMixedPackage (1.24s)
=== RUN   TestGopOverloadUses
2025/10/11 16:13:34.329359 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:13:35 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:35 ==> NewOverloadFunc NewRange
2025/10/11 16:13:35 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:35 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:35 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:35 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:35 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:35 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:35 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:35 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:35 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:35 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:35 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:35 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:35 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:35 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:35.679091 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0002afb60 {
}

2025/10/11 16:13:35 ==> Preload func MulInt
2025/10/11 16:13:35 ==> Preload func MulFloat
2025/10/11 16:13:35 ==> Preload func Mul__2
2025/10/11 16:13:35 NewConstDefs
2025/10/11 16:13:35 ==> Preload const [Gopo_Mul]
2025/10/11 16:13:35 ==> Preload func main
2025/10/11 16:13:35 ==> Load func MulInt
2025/10/11 16:13:35.679202 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:35.679223 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:35.679236 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:35.679250 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/10/11 16:13:35.679264 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/10/11 16:13:35.679275 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:35.679288 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:35.679299 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:35.679320 [INFO] typesutil/gopinfo.go:251: ==> Def: MulInt func main.MulInt(a int, b int) int
2025/10/11 16:13:35 NewFunc MulInt func(a int, b int) int
2025/10/11 16:13:35 Val a int
2025/10/11 16:13:35.679365 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/10/11 16:13:35.679376 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/10/11 16:13:35 Val b int
2025/10/11 16:13:35.679398 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b int
2025/10/11 16:13:35.679409 [INFO] typesutil/gopinfo.go:215: ==> Type: b int
2025/10/11 16:13:35 BinaryOp *
2025/10/11 16:13:35 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:35 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:35 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:35.679493 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 40 * b} int
2025/10/11 16:13:35 Return 1
2025/10/11 16:13:35 ==> MatchType int, int
2025/10/11 16:13:35.679545 [INFO] typesutil/gopinfo.go:332: ==> Scope: func MulInt scope 0xc0002afe00 {
.  var a int
.  var b int
}

2025/10/11 16:13:35 End // Func
2025/10/11 16:13:35 ==> Load func MulFloat
2025/10/11 16:13:35.679587 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:13:35.679599 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:13:35.679610 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:13:35.679622 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a float64
2025/10/11 16:13:35.679635 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b float64
2025/10/11 16:13:35.679647 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:13:35.679659 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:13:35.679670 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:13:35.679688 [INFO] typesutil/gopinfo.go:251: ==> Def: MulFloat func main.MulFloat(a float64, b float64) float64
2025/10/11 16:13:35 NewFunc MulFloat func(a float64, b float64) float64
2025/10/11 16:13:35 Val a float64
2025/10/11 16:13:35.679723 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/10/11 16:13:35.679734 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/10/11 16:13:35 Val b float64
2025/10/11 16:13:35.679751 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/10/11 16:13:35.679765 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/10/11 16:13:35 BinaryOp *
2025/10/11 16:13:35 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:35 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:35 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:13:35.679828 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 95 * b} float64
2025/10/11 16:13:35 Return 1
2025/10/11 16:13:35 ==> MatchType float64, float64
2025/10/11 16:13:35.679864 [INFO] typesutil/gopinfo.go:332: ==> Scope: func MulFloat scope 0xc0002bc240 {
.  var a float64
.  var b float64
}

2025/10/11 16:13:35 End // Func
2025/10/11 16:13:35 ==> Load func Mul__2
2025/10/11 16:13:35.679901 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:35.679914 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:35.679925 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:35.680423 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/10/11 16:13:35.680443 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/10/11 16:13:35.680457 [INFO] typesutil/gopinfo.go:251: ==> Def: z var z int
2025/10/11 16:13:35.680475 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:35.680620 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:35.680650 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:35.680689 [INFO] typesutil/gopinfo.go:251: ==> Def: Mul__2 func main.Mul__2(x int, y int, z int) int
2025/10/11 16:13:35 NewFunc Mul__2 func(x int, y int, z int) int
2025/10/11 16:13:35 Val x int
2025/10/11 16:13:35.680797 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/10/11 16:13:35.680816 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/10/11 16:13:35 Val y int
2025/10/11 16:13:35.680840 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y int
2025/10/11 16:13:35.680853 [INFO] typesutil/gopinfo.go:215: ==> Type: y int
2025/10/11 16:13:35 BinaryOp *
2025/10/11 16:13:35 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:35 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:35 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:35.681035 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 169 * y} int
2025/10/11 16:13:35 Val z int
2025/10/11 16:13:35.681078 [INFO] typesutil/gopinfo.go:265: ==> Use: z var z int
2025/10/11 16:13:35.681092 [INFO] typesutil/gopinfo.go:215: ==> Type: z int
2025/10/11 16:13:35 BinaryOp *
2025/10/11 16:13:35 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:35 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:35 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:35.681196 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000892750 173 * z} int
2025/10/11 16:13:35 Return 1
2025/10/11 16:13:35 ==> MatchType int, int
2025/10/11 16:13:35.681260 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Mul__2 scope 0xc0002de0c0 {
.  var x int
.  var y int
.  var z int
}

2025/10/11 16:13:35 End // Func
2025/10/11 16:13:35 ==> Load const [Gopo_Mul] <nil>
2025/10/11 16:13:35 NewConst [Gopo_Mul] 0
2025/10/11 16:13:35 Val &{0 STRING "MulInt,MulFloat,"} *ast.BasicLit
2025/10/11 16:13:35.681440 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING "MulInt,MulFloat," <nil>} untyped string
2025/10/11 16:13:35 EndInit 1
2025/10/11 16:13:35.681529 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_Mul const main.Gopo_Mul untyped string
2025/10/11 16:13:35 ==> NewOverloadFunc Mul
2025/10/11 16:13:35 ==> Load func main
2025/10/11 16:13:35.681605 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/10/11 16:13:35 NewFunc main func()
2025/10/11 16:13:35 Val Mul func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:35.681694 [INFO] typesutil/gopinfo.go:265: ==> Use: Mul func main.Mul(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:35.682099 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Mul TyOverloadFunc
2025/10/11 16:13:35.682149 [INFO] typesutil/gopinfo.go:215: ==> Type: Mul func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:35 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:13:35.682210 [INFO] typesutil/gopinfo.go:215: ==> Type: &{187 INT 100 <nil>} untyped int
2025/10/11 16:13:35 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:13:35.682234 [INFO] typesutil/gopinfo.go:215: ==> Type: &{191 INT 200 <nil>} untyped int
2025/10/11 16:13:35 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:35 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:13:35 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/10/11 16:13:35 ==> MatchType untyped int (100), int
2025/10/11 16:13:35 ==> MatchType untyped int (200), int
2025/10/11 16:13:35.682311 [INFO] typesutil/gopinfo.go:265: ==> Use: Mul func main.MulInt(a int, b int) int
2025/10/11 16:13:35.682326 [INFO] typesutil/gopinfo.go:215: ==> Type: Mul func(a int, b int) int
2025/10/11 16:13:35.682348 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mul 0 [0xc000892840 0xc000892870] 0 [] 0 194} int
2025/10/11 16:13:35 Val Mul func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:35.682381 [INFO] typesutil/gopinfo.go:265: ==> Use: Mul func main.Mul(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:35.682396 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Mul TyOverloadFunc
2025/10/11 16:13:35.682409 [INFO] typesutil/gopinfo.go:215: ==> Type: Mul func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:35 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:13:35.682434 [INFO] typesutil/gopinfo.go:215: ==> Type: &{199 INT 100 <nil>} untyped int
2025/10/11 16:13:35 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:13:35.682456 [INFO] typesutil/gopinfo.go:215: ==> Type: &{203 INT 200 <nil>} untyped int
2025/10/11 16:13:35 Val &{0 INT 300} *ast.BasicLit
2025/10/11 16:13:35.682476 [INFO] typesutil/gopinfo.go:215: ==> Type: &{207 INT 300 <nil>} untyped int
2025/10/11 16:13:35 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:35 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:13:35 ==> MatchFuncCall func(a int, b int) int args: 3 flags: 0
2025/10/11 16:13:35 ==> MatchFuncCall func(a float64, b float64) float64 args: 3 flags: 0
2025/10/11 16:13:35 ==> MatchFuncCall func(x int, y int, z int) int args: 3 flags: 0
2025/10/11 16:13:35 ==> MatchType untyped int (100), int
2025/10/11 16:13:35 ==> MatchType untyped int (200), int
2025/10/11 16:13:35 ==> MatchType untyped int (300), int
2025/10/11 16:13:35.682591 [INFO] typesutil/gopinfo.go:265: ==> Use: Mul func main.Mul__2(x int, y int, z int) int
2025/10/11 16:13:35.682613 [INFO] typesutil/gopinfo.go:215: ==> Type: Mul func(x int, y int, z int) int
2025/10/11 16:13:35.682632 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mul 0 [0xc0008928a0 0xc0008928d0 0xc000892900] 0 [] 0 210} int
2025/10/11 16:13:35.682653 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0000137a0 {
}

2025/10/11 16:13:35 End // Func
2025/10/11 16:13:35.682685 [INFO] typesutil/gopinfo.go:215: ==> Type: &{134 <nil> 0xc0008926c0 0xc0008926f0} func(x int, y int, z int) int
2025/10/11 16:13:35.682711 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0008205c0 0xc0008927b0} func(x int, y int, z int) int
2025/10/11 16:13:35.682734 [INFO] typesutil/gopinfo.go:292: ==> Implicit: func main.Mul__2(x int, y int, z int) int
2025/10/11 16:13:35.682748 [INFO] typesutil/gopinfo.go:251: ==> Def: Mul func main.Mul(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:35.682763 [INFO] typesutil/gopinfo.go:265: ==> Use: MulInt func main.MulInt(a int, b int) int
2025/10/11 16:13:35.682777 [INFO] typesutil/gopinfo.go:265: ==> Use: MulFloat func main.MulFloat(a float64, b float64) float64
    info_test.go:190: == types ==
        000:  0: 0 | "MulInt,MulFloat,"  *ast.BasicLit                  | value   : untyped string = "MulInt,MulFloat," | constant
        001:  2:18 | int                 *ast.Ident                     | type    : int | type
        002:  2:23 | int                 *ast.Ident                     | type    : int | type
        003:  3: 9 | a                   *ast.Ident                     | var     : int | variable
        004:  3: 9 | a * b               *ast.BinaryExpr                | value   : int | value
        005:  3:13 | b                   *ast.Ident                     | var     : int | variable
        006:  6:20 | float64             *ast.Ident                     | type    : float64 | type
        007:  6:29 | float64             *ast.Ident                     | type    : float64 | type
        008:  7: 9 | a                   *ast.Ident                     | var     : float64 | variable
        009:  7: 9 | a * b               *ast.BinaryExpr                | value   : float64 | value
        010:  7:13 | b                   *ast.Ident                     | var     : float64 | variable
        011: 13: 2 | func(x, y, z int) int *ast.FuncType                  | type    : func(x int, y int, z int) int | type
        012: 13: 2 | func(x, y, z int) int {
        	return x * y * z
        } *ast.FuncLit                   | value   : func(x int, y int, z int) int | value
        013: 13:15 | int                 *ast.Ident                     | type    : int | type
        014: 13:20 | int                 *ast.Ident                     | type    : int | type
        015: 14:10 | x                   *ast.Ident                     | var     : int | variable
        016: 14:10 | x * y               *ast.BinaryExpr                | value   : int | value
        017: 14:10 | x * y * z           *ast.BinaryExpr                | value   : int | value
        018: 14:14 | y                   *ast.Ident                     | var     : int | variable
        019: 14:18 | z                   *ast.Ident                     | var     : int | variable
        020: 18: 1 | Mul                 *ast.Ident                     | value   : func(a int, b int) int | value
        021: 18: 1 | Mul 100, 200        *ast.CallExpr                  | value   : int | value
        022: 18: 5 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        023: 18: 9 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        024: 19: 1 | Mul                 *ast.Ident                     | value   : func(x int, y int, z int) int | value
        025: 19: 1 | Mul 100, 200, 300   *ast.CallExpr                  | value   : int | value
        026: 19: 5 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        027: 19: 9 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        028: 19:13 | 300                 *ast.BasicLit                  | value   : untyped int = 300 | constant
        == defs ==
        000:  0: 0 | Gopo_Mul            | const main.Gopo_Mul untyped string
        001:  2: 6 | MulInt              | func main.MulInt(a int, b int) int
        002:  2:13 | a                   | var a int
        003:  2:16 | b                   | var b int
        004:  6: 6 | MulFloat            | func main.MulFloat(a float64, b float64) float64
        005:  6:15 | a                   | var a float64
        006:  6:18 | b                   | var b float64
        007: 10: 6 | Mul                 | func main.Mul(__xgo_overload_args__ interface{_()})
        008: 13: 2 | Mul__2              | func main.Mul__2(x int, y int, z int) int
        009: 13: 7 | x                   | var x int
        010: 13:10 | y                   | var y int
        011: 13:13 | z                   | var z int
        012: 18: 1 | main                | func main.main()
        == uses ==
        000:  2:18 | int                 | type int
        001:  2:23 | int                 | type int
        002:  3: 9 | a                   | var a int
        003:  3:13 | b                   | var b int
        004:  6:20 | float64             | type float64
        005:  6:29 | float64             | type float64
        006:  7: 9 | a                   | var a float64
        007:  7:13 | b                   | var b float64
        008: 11: 2 | MulInt              | func main.MulInt(a int, b int) int
        009: 12: 2 | MulFloat            | func main.MulFloat(a float64, b float64) float64
        010: 13:15 | int                 | type int
        011: 13:20 | int                 | type int
        012: 14:10 | x                   | var x int
        013: 14:14 | y                   | var y int
        014: 14:18 | z                   | var z int
        015: 18: 1 | Mul                 | func main.MulInt(a int, b int) int
        016: 19: 1 | Mul                 | func main.Mul__2(x int, y int, z int) int
        == overloads ==
        000: 18: 1 | Mul                 | func main.Mul(__xgo_overload_args__ interface{_()})
        001: 19: 1 | Mul                 | func main.Mul(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:35.684025 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:13:36 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:36 ==> NewOverloadFunc NewRange
2025/10/11 16:13:36 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:36 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:36 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:36 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:36 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:36 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:36 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:36 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:36 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:36 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:36 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:36 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:36 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:36 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:36.984552 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00025de60 {
}

2025/10/11 16:13:36 ==> Preload type foo
2025/10/11 16:13:36 ==> Preload method foo.mulInt
2025/10/11 16:13:36 ==> Preload method foo.mulFoo
2025/10/11 16:13:36 NewConstDefs
2025/10/11 16:13:36 ==> Preload const [Gopo_foo_mul]
2025/10/11 16:13:36 ==> Preload var [a b]
2025/10/11 16:13:36 ==> Preload var [c]
2025/10/11 16:13:36 ==> Preload var [d]
2025/10/11 16:13:36 ==> Load > NewType foo
2025/10/11 16:13:36 NewType foo
2025/10/11 16:13:36 ==> Load > InitType foo
2025/10/11 16:13:36.984717 [INFO] typesutil/gopinfo.go:215: ==> Type: &{11 0xc000525b00 false} struct{}
2025/10/11 16:13:36 InitType foo struct{}
2025/10/11 16:13:36.984751 [INFO] typesutil/gopinfo.go:251: ==> Def: foo type main.foo struct{}
2025/10/11 16:13:36 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:13:36.984787 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:13:36.984803 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:13:36.984822 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a *main.foo
2025/10/11 16:13:36 ==> Load method *main.foo.mulInt
2025/10/11 16:13:36.984848 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:36.984860 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:36.984871 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:36.984884 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/10/11 16:13:36 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:13:36.984907 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:13:36.984918 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:13:36.984930 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:13:36.984946 [INFO] typesutil/gopinfo.go:215: ==> Type: &{51 foo} *main.foo
2025/10/11 16:13:36.984968 [INFO] typesutil/gopinfo.go:251: ==> Def: mulInt func (*main.foo).mulInt(b int) *main.foo
2025/10/11 16:13:36 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:13:36.984990 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:13:36.985002 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:13:36.985015 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a *main.foo
2025/10/11 16:13:36 ==> Load method *main.foo.mulFoo
2025/10/11 16:13:36 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:13:36.985046 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:13:36.985057 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:13:36.985067 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:13:36.985081 [INFO] typesutil/gopinfo.go:215: ==> Type: &{94 foo} *main.foo
2025/10/11 16:13:36.985093 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b *main.foo
2025/10/11 16:13:36 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:13:36.985115 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:13:36.985130 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:13:36.985147 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:13:36.985163 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 foo} *main.foo
2025/10/11 16:13:36.985180 [INFO] typesutil/gopinfo.go:251: ==> Def: mulFoo func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/10/11 16:13:36 ==> Load const [Gopo_foo_mul] <nil>
2025/10/11 16:13:36 NewConst [Gopo_foo_mul] 0
2025/10/11 16:13:36 Val &{0 STRING ".mulInt,.mulFoo"} *ast.BasicLit
2025/10/11 16:13:36.985234 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING ".mulInt,.mulFoo" <nil>} untyped string
2025/10/11 16:13:36 EndInit 1
2025/10/11 16:13:36.985255 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_foo_mul const main.Gopo_foo_mul untyped string
2025/10/11 16:13:36 ==> NewOverloadMethod foo mul
2025/10/11 16:13:36 ==> LookupParent foo => type main.foo struct{}
2025/10/11 16:13:36.985300 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:13:36.985313 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:13:36.985324 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/10/11 16:13:36.985337 [INFO] typesutil/gopinfo.go:215: ==> Type: &{179 foo} *main.foo
2025/10/11 16:13:36 ==> Load var *main.foo [a b]
2025/10/11 16:13:36 NewVarDefs
2025/10/11 16:13:36 NewVar [a b]
2025/10/11 16:13:36.985386 [INFO] typesutil/gopinfo.go:251: ==> Def: a var main.a *main.foo
2025/10/11 16:13:36.985400 [INFO] typesutil/gopinfo.go:251: ==> Def: b var main.b *main.foo
2025/10/11 16:13:36 ==> Load var <nil> [c]
2025/10/11 16:13:36 NewVarDefs
2025/10/11 16:13:36 NewVar [c]
2025/10/11 16:13:36 Val a *main.foo
2025/10/11 16:13:36.985444 [INFO] typesutil/gopinfo.go:265: ==> Use: a var main.a *main.foo
2025/10/11 16:13:36.985456 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/10/11 16:13:36 Member mul 1 // *main.foo
2025/10/11 16:13:36.985487 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:36.985514 [INFO] typesutil/gopinfo.go:274: ==> Overloads: mul TyOverloadMethod
2025/10/11 16:13:36.985537 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:36 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:13:36.985573 [INFO] typesutil/gopinfo.go:215: ==> Type: &{198 INT 100 <nil>} untyped int
2025/10/11 16:13:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:36 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:13:36 ==> MatchFuncCall func(b int) *main.foo args: 1 flags: 0
2025/10/11 16:13:36 ==> MatchType untyped int (100), int
2025/10/11 16:13:36.985638 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (*main.foo).mulInt(b int) *main.foo
2025/10/11 16:13:36.985664 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(b int) *main.foo
2025/10/11 16:13:36.985684 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0008884b0 197 [0xc000525e30] 0 [] 201 0} *main.foo
2025/10/11 16:13:36 EndInit 1
2025/10/11 16:13:36.985705 [INFO] typesutil/gopinfo.go:251: ==> Def: c var main.c *main.foo
2025/10/11 16:13:36 ==> Load var <nil> [d]
2025/10/11 16:13:36 NewVarDefs
2025/10/11 16:13:36 NewVar [d]
2025/10/11 16:13:36 Val a *main.foo
2025/10/11 16:13:36.985746 [INFO] typesutil/gopinfo.go:265: ==> Use: a var main.a *main.foo
2025/10/11 16:13:36.985758 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/10/11 16:13:36 Member mul 1 // *main.foo
2025/10/11 16:13:36.985781 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:36.985790 [INFO] typesutil/gopinfo.go:274: ==> Overloads: mul TyOverloadMethod
2025/10/11 16:13:36.985804 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:36 Val c *main.foo
2025/10/11 16:13:36.985826 [INFO] typesutil/gopinfo.go:265: ==> Use: c var main.c *main.foo
2025/10/11 16:13:36.985837 [INFO] typesutil/gopinfo.go:215: ==> Type: c *main.foo
2025/10/11 16:13:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:36 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/10/11 16:13:36 ==> MatchFuncCall func(b int) *main.foo args: 1 flags: 0
2025/10/11 16:13:36 ==> MatchType *main.foo, int
2025/10/11 16:13:36 ==> MatchFuncCall func(b *main.foo) *main.foo args: 1 flags: 0
2025/10/11 16:13:36 ==> MatchType *main.foo, *main.foo
2025/10/11 16:13:36.985909 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/10/11 16:13:36.985924 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(b *main.foo) *main.foo
2025/10/11 16:13:36.985943 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0008884c8 216 [c] 0 [] 218 0} *main.foo
2025/10/11 16:13:36 EndInit 1
2025/10/11 16:13:36.985961 [INFO] typesutil/gopinfo.go:251: ==> Def: d var main.d *main.foo
2025/10/11 16:13:36 NewFunc mulInt (*main.foo) func(b int) *main.foo
2025/10/11 16:13:36 Val a *main.foo
2025/10/11 16:13:36.986001 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a *main.foo
2025/10/11 16:13:36.986017 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/10/11 16:13:36 Return 1
2025/10/11 16:13:36 ==> MatchType *main.foo, *main.foo
2025/10/11 16:13:36.986056 [INFO] typesutil/gopinfo.go:332: ==> Scope: func mulInt scope 0xc0002ae780 {
.  var a *main.foo
.  var b int
}

2025/10/11 16:13:36 End // Func
2025/10/11 16:13:36 NewFunc mulFoo (*main.foo) func(b *main.foo) *main.foo
2025/10/11 16:13:36 Val a *main.foo
2025/10/11 16:13:36.986112 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a *main.foo
2025/10/11 16:13:36.986123 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/10/11 16:13:36 Return 1
2025/10/11 16:13:36 ==> MatchType *main.foo, *main.foo
2025/10/11 16:13:36.986158 [INFO] typesutil/gopinfo.go:332: ==> Scope: func mulFoo scope 0xc0002ae7e0 {
.  var a *main.foo
.  var b *main.foo
}

2025/10/11 16:13:36 End // Func
2025/10/11 16:13:36.986183 [INFO] typesutil/gopinfo.go:251: ==> Def: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:36.986199 [INFO] typesutil/gopinfo.go:265: ==> Use: mulInt func (*main.foo).mulInt(b int) *main.foo
2025/10/11 16:13:36.986219 [INFO] typesutil/gopinfo.go:265: ==> Use: mulFoo func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/10/11 16:13:36.986231 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:13:36.986245 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/10/11 16:13:36.986256 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
    info_test.go:190: == types ==
        000:  0: 0 | ".mulInt,.mulFoo"   *ast.BasicLit                  | value   : untyped string = ".mulInt,.mulFoo" | constant
        001:  2:10 | struct {
        }          *ast.StructType                | type    : struct{} | type
        002:  5:10 | foo                 *ast.Ident                     | type    : main.foo | type
        003:  5:24 | int                 *ast.Ident                     | type    : int | type
        004:  5:29 | *foo                *ast.StarExpr                  | type    : *main.foo | type
        005:  5:30 | foo                 *ast.Ident                     | type    : main.foo | type
        006:  6: 9 | a                   *ast.Ident                     | var     : *main.foo | variable
        007:  9:10 | foo                 *ast.Ident                     | type    : main.foo | type
        008:  9:24 | *foo                *ast.StarExpr                  | type    : *main.foo | type
        009:  9:25 | foo                 *ast.Ident                     | type    : main.foo | type
        010:  9:30 | *foo                *ast.StarExpr                  | type    : *main.foo | type
        011:  9:31 | foo                 *ast.Ident                     | type    : main.foo | type
        012: 10: 9 | a                   *ast.Ident                     | var     : *main.foo | variable
        013: 18:10 | *foo                *ast.StarExpr                  | type    : *main.foo | type
        014: 18:11 | foo                 *ast.Ident                     | type    : main.foo | type
        015: 19: 9 | a                   *ast.Ident                     | var     : *main.foo | variable
        016: 19: 9 | a.mul               *ast.SelectorExpr              | value   : func(b int) *main.foo | value
        017: 19: 9 | a.mul(100)          *ast.CallExpr                  | value   : *main.foo | value
        018: 19:15 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        019: 20: 9 | a                   *ast.Ident                     | var     : *main.foo | variable
        020: 20: 9 | a.mul               *ast.SelectorExpr              | value   : func(b *main.foo) *main.foo | value
        021: 20: 9 | a.mul(c)            *ast.CallExpr                  | value   : *main.foo | value
        022: 20:15 | c                   *ast.Ident                     | var     : *main.foo | variable
        == defs ==
        000:  0: 0 | Gopo_foo_mul        | const main.Gopo_foo_mul untyped string
        001:  2: 6 | foo                 | type main.foo struct{}
        002:  5: 7 | a                   | var a *main.foo
        003:  5:15 | mulInt              | func (*main.foo).mulInt(b int) *main.foo
        004:  5:22 | b                   | var b int
        005:  9: 7 | a                   | var a *main.foo
        006:  9:15 | mulFoo              | func (*main.foo).mulFoo(b *main.foo) *main.foo
        007:  9:22 | b                   | var b *main.foo
        008: 13:12 | mul                 | func (main.foo).mul(__xgo_overload_args__ interface{_()})
        009: 18: 5 | a                   | var main.a *main.foo
        010: 18: 8 | b                   | var main.b *main.foo
        011: 19: 5 | c                   | var main.c *main.foo
        012: 20: 5 | d                   | var main.d *main.foo
        == uses ==
        000:  5:10 | foo                 | type main.foo struct{}
        001:  5:24 | int                 | type int
        002:  5:30 | foo                 | type main.foo struct{}
        003:  6: 9 | a                   | var a *main.foo
        004:  9:10 | foo                 | type main.foo struct{}
        005:  9:25 | foo                 | type main.foo struct{}
        006:  9:31 | foo                 | type main.foo struct{}
        007: 10: 9 | a                   | var a *main.foo
        008: 13: 7 | foo                 | type main.foo struct{}
        009: 14: 3 | foo                 | type main.foo struct{}
        010: 14: 8 | mulInt              | func (*main.foo).mulInt(b int) *main.foo
        011: 15: 3 | foo                 | type main.foo struct{}
        012: 15: 8 | mulFoo              | func (*main.foo).mulFoo(b *main.foo) *main.foo
        013: 18:11 | foo                 | type main.foo struct{}
        014: 19: 9 | a                   | var main.a *main.foo
        015: 19:11 | mul                 | func (*main.foo).mulInt(b int) *main.foo
        016: 20: 9 | a                   | var main.a *main.foo
        017: 20:11 | mul                 | func (*main.foo).mulFoo(b *main.foo) *main.foo
        018: 20:15 | c                   | var main.c *main.foo
        == overloads ==
        000: 19:11 | mul                 | func (main.foo).mul(__xgo_overload_args__ interface{_()})
        001: 20:11 | mul                 | func (main.foo).mul(__xgo_overload_args__ interface{_()})
--- PASS: TestGopOverloadUses (2.66s)
=== RUN   TestGopOverloadDecl
2025/10/11 16:13:36.989478 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:13:37 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:37 ==> NewOverloadFunc NewRange
2025/10/11 16:13:37 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:37 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:37 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:37 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:37 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:37 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:37 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:37 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:37 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:37 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:37 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:37 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:37 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:37 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:38.310794 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0002f1800 {
}

2025/10/11 16:13:38 ==> Preload func addInt0
2025/10/11 16:13:38 ==> Preload func addInt1
2025/10/11 16:13:38 ==> Preload func addInt2
2025/10/11 16:13:38 ==> Preload var [addInt3]
2025/10/11 16:13:38 ==> Preload func add__4
2025/10/11 16:13:38 NewConstDefs
2025/10/11 16:13:38 ==> Preload const [Gopo_add]
2025/10/11 16:13:38 ==> Preload func init
2025/10/11 16:13:38 ==> Load func addInt0
2025/10/11 16:13:38.310960 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt0 func main.addInt0()
2025/10/11 16:13:38 NewFunc addInt0 func()
2025/10/11 16:13:38.310991 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt0 scope 0xc0002f1920 {
}

2025/10/11 16:13:38 End // Func
2025/10/11 16:13:38 ==> Load func addInt1
2025/10/11 16:13:38.311025 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:38.311042 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:38.311055 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:38.311071 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:13:38.311087 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt1 func main.addInt1(i int)
2025/10/11 16:13:38 NewFunc addInt1 func(i int)
2025/10/11 16:13:38.311114 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt1 scope 0xc0002f1a40 {
.  var i int
}

2025/10/11 16:13:38 End // Func
2025/10/11 16:13:38 ==> Load func addInt2
2025/10/11 16:13:38.311141 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:38.311153 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:38.311165 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:38.311177 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:13:38.311189 [INFO] typesutil/gopinfo.go:251: ==> Def: j var j int
2025/10/11 16:13:38.311203 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt2 func main.addInt2(i int, j int)
2025/10/11 16:13:38 NewFunc addInt2 func(i int, j int)
2025/10/11 16:13:38.311235 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt2 scope 0xc0002f1bc0 {
.  var i int
.  var j int
}

2025/10/11 16:13:38 End // Func
2025/10/11 16:13:38 ==> Load var <nil> [addInt3]
2025/10/11 16:13:38 NewVarDefs
2025/10/11 16:13:38 NewVar [addInt3]
2025/10/11 16:13:38.311293 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:38.311304 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:38.311316 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:38.311330 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/10/11 16:13:38.311341 [INFO] typesutil/gopinfo.go:251: ==> Def: j var j int
2025/10/11 16:13:38.311352 [INFO] typesutil/gopinfo.go:251: ==> Def: k var k int
2025/10/11 16:13:38.311379 [INFO] typesutil/gopinfo.go:215: ==> Type: &{89 <nil> 0xc000525200 <nil>} func(i int, j int, k int)
2025/10/11 16:13:38.311403 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00088c7c0 0xc000525260} func(i int, j int, k int)
2025/10/11 16:13:38 NewClosure func(i int, j int, k int)
2025/10/11 16:13:38.311435 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0002f1da0 {
.  var i int
.  var j int
.  var k int
}

2025/10/11 16:13:38 End // Func
2025/10/11 16:13:38 EndInit 1
2025/10/11 16:13:38.311476 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt3 var main.addInt3 func(i int, j int, k int)
2025/10/11 16:13:38 ==> Load func add__4
2025/10/11 16:13:38.311496 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:13:38.311507 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:38.311519 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:38.311531 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a string
2025/10/11 16:13:38.311542 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b string
2025/10/11 16:13:38.311554 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:13:38.311565 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:38.311577 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:38.311597 [INFO] typesutil/gopinfo.go:251: ==> Def: add__4 func main.add__4(a string, b string) string
2025/10/11 16:13:38 NewFunc add__4 func(a string, b string) string
2025/10/11 16:13:38 Val a string
2025/10/11 16:13:38.311632 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a string
2025/10/11 16:13:38.311645 [INFO] typesutil/gopinfo.go:215: ==> Type: a string
2025/10/11 16:13:38 Val b string
2025/10/11 16:13:38.311663 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b string
2025/10/11 16:13:38.311679 [INFO] typesutil/gopinfo.go:215: ==> Type: b string
2025/10/11 16:13:38 BinaryOp +
2025/10/11 16:13:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:38 ==> MatchType string, unboundFuncParam{typ: string}
2025/10/11 16:13:38.311768 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 200 + b} string
2025/10/11 16:13:38 Return 1
2025/10/11 16:13:38 ==> MatchType string, string
2025/10/11 16:13:38.311806 [INFO] typesutil/gopinfo.go:332: ==> Scope: func add__4 scope 0xc000338060 {
.  var a string
.  var b string
}

2025/10/11 16:13:38 End // Func
2025/10/11 16:13:38 ==> Load const [Gopo_add] <nil>
2025/10/11 16:13:38 NewConst [Gopo_add] 0
2025/10/11 16:13:38 Val &{0 STRING "addInt0,addInt1,addInt2,addInt3,"} *ast.BasicLit
2025/10/11 16:13:38.311866 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING "addInt0,addInt1,addInt2,addInt3," <nil>} untyped string
2025/10/11 16:13:38 EndInit 1
2025/10/11 16:13:38.311886 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_add const main.Gopo_add untyped string
2025/10/11 16:13:38 ==> NewOverloadFunc add
2025/10/11 16:13:38 ==> Load func init
2025/10/11 16:13:38.311927 [INFO] typesutil/gopinfo.go:251: ==> Def: init func main.init()
2025/10/11 16:13:38 NewFunc init func()
2025/10/11 16:13:38 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38.311970 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38.311982 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/10/11 16:13:38.311996 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:13:38.312026 [INFO] typesutil/gopinfo.go:215: ==> Type: &{229 INT 100 <nil>} untyped int
2025/10/11 16:13:38 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:13:38.312085 [INFO] typesutil/gopinfo.go:215: ==> Type: &{234 INT 200 <nil>} untyped int
2025/10/11 16:13:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func() args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func(i int) args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func(i int, j int) args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchType untyped int (100), int
2025/10/11 16:13:38 ==> MatchType untyped int (200), int
2025/10/11 16:13:38.312196 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.addInt2(i int, j int)
2025/10/11 16:13:38.312212 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(i int, j int)
2025/10/11 16:13:38.312241 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc000525470 0xc0005254a0] 0 [] 0 237} ()
2025/10/11 16:13:38 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38.312276 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38.312286 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/10/11 16:13:38.312300 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:13:38.312323 [INFO] typesutil/gopinfo.go:215: ==> Type: &{243 INT 100 <nil>} untyped int
2025/10/11 16:13:38 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:13:38.312344 [INFO] typesutil/gopinfo.go:215: ==> Type: &{248 INT 200 <nil>} untyped int
2025/10/11 16:13:38 Val &{0 INT 300} *ast.BasicLit
2025/10/11 16:13:38.312363 [INFO] typesutil/gopinfo.go:215: ==> Type: &{253 INT 300 <nil>} untyped int
2025/10/11 16:13:38 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func() args: 3 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func(i int) args: 3 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func(i int, j int) args: 3 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func(i int, j int, k int) args: 3 flags: 0
2025/10/11 16:13:38 ==> MatchType untyped int (100), int
2025/10/11 16:13:38 ==> MatchType untyped int (200), int
2025/10/11 16:13:38 ==> MatchType untyped int (300), int
2025/10/11 16:13:38.312482 [INFO] typesutil/gopinfo.go:265: ==> Use: add var main.addInt3 func(i int, j int, k int)
2025/10/11 16:13:38.312495 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(i int, j int, k int)
2025/10/11 16:13:38.312514 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc0005254d0 0xc000525500 0xc000525530] 0 [] 0 256} ()
2025/10/11 16:13:38 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38.312547 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38.312557 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/10/11 16:13:38.312569 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:13:38.312593 [INFO] typesutil/gopinfo.go:215: ==> Type: &{262 STRING "hello" <nil>} untyped string
2025/10/11 16:13:38 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:13:38.312617 [INFO] typesutil/gopinfo.go:215: ==> Type: &{271 STRING "world" <nil>} untyped string
2025/10/11 16:13:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func() args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func(i int) args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func(i int, j int) args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchType untyped string ("hello"), int
2025/10/11 16:13:38 ==> MatchFuncCall func(i int, j int, k int) args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/10/11 16:13:38 ==> MatchType untyped string ("hello"), string
2025/10/11 16:13:38 ==> MatchType untyped string ("world"), string
2025/10/11 16:13:38.312750 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add__4(a string, b string) string
2025/10/11 16:13:38.312766 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(a string, b string) string
2025/10/11 16:13:38.312783 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 261 [0xc000525560 0xc000525590] 0 [] 278 0} string
2025/10/11 16:13:38.312797 [INFO] typesutil/gopinfo.go:332: ==> Scope: func init scope 0xc000338480 {
}

2025/10/11 16:13:38 End // Func
2025/10/11 16:13:38.312822 [INFO] typesutil/gopinfo.go:215: ==> Type: &{162 <nil> 0xc0005252f0 0xc000525320} func(a string, b string) string
2025/10/11 16:13:38.312836 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00088c920 0xc0005253b0} func(a string, b string) string
2025/10/11 16:13:38.312848 [INFO] typesutil/gopinfo.go:292: ==> Implicit: func main.add__4(a string, b string) string
2025/10/11 16:13:38.312862 [INFO] typesutil/gopinfo.go:251: ==> Def: add func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38.312876 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt0 func main.addInt0()
2025/10/11 16:13:38.312889 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt1 func main.addInt1(i int)
2025/10/11 16:13:38.312901 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt2 func main.addInt2(i int, j int)
2025/10/11 16:13:38.312915 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt3 var main.addInt3 func(i int, j int, k int)
    info_test.go:190: == types ==
        000:  0: 0 | "addInt0,addInt1,addInt2,addInt3," *ast.BasicLit                  | value   : untyped string = "addInt0,addInt1,addInt2,addInt3," | constant
        001:  5:16 | int                 *ast.Ident                     | type    : int | type
        002:  8:19 | int                 *ast.Ident                     | type    : int | type
        003: 11:15 | func(i, j, k int)   *ast.FuncType                  | type    : func(i int, j int, k int) | type
        004: 11:15 | func(i, j, k int) {
        } *ast.FuncLit                   | value   : func(i int, j int, k int) | value
        005: 11:28 | int                 *ast.Ident                     | type    : int | type
        006: 19: 2 | func(a, b string) string *ast.FuncType                  | type    : func(a string, b string) string | type
        007: 19: 2 | func(a, b string) string {
        	return a + b
        } *ast.FuncLit                   | value   : func(a string, b string) string | value
        008: 19:12 | string              *ast.Ident                     | type    : string | type
        009: 19:20 | string              *ast.Ident                     | type    : string | type
        010: 20:10 | a                   *ast.Ident                     | var     : string | variable
        011: 20:10 | a + b               *ast.BinaryExpr                | value   : string | value
        012: 20:14 | b                   *ast.Ident                     | var     : string | variable
        013: 25: 2 | add                 *ast.Ident                     | value   : func(i int, j int) | value
        014: 25: 2 | add 100, 200        *ast.CallExpr                  | void    : () | no value
        015: 25: 6 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        016: 25:11 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        017: 26: 2 | add                 *ast.Ident                     | var     : func(i int, j int, k int) | variable
        018: 26: 2 | add 100, 200, 300   *ast.CallExpr                  | void    : () | no value
        019: 26: 6 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        020: 26:11 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        021: 26:16 | 300                 *ast.BasicLit                  | value   : untyped int = 300 | constant
        022: 27: 2 | add                 *ast.Ident                     | value   : func(a string, b string) string | value
        023: 27: 2 | add("hello", "world") *ast.CallExpr                  | value   : string | value
        024: 27: 6 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        025: 27:15 | "world"             *ast.BasicLit                  | value   : untyped string = "world" | constant
        == defs ==
        000:  0: 0 | Gopo_add            | const main.Gopo_add untyped string
        001:  2: 6 | addInt0             | func main.addInt0()
        002:  5: 6 | addInt1             | func main.addInt1(i int)
        003:  5:14 | i                   | var i int
        004:  8: 6 | addInt2             | func main.addInt2(i int, j int)
        005:  8:14 | i                   | var i int
        006:  8:17 | j                   | var j int
        007: 11: 5 | addInt3             | var main.addInt3 func(i int, j int, k int)
        008: 11:20 | i                   | var i int
        009: 11:23 | j                   | var j int
        010: 11:26 | k                   | var k int
        011: 14: 6 | add                 | func main.add(__xgo_overload_args__ interface{_()})
        012: 19: 2 | add__4              | func main.add__4(a string, b string) string
        013: 19: 7 | a                   | var a string
        014: 19:10 | b                   | var b string
        015: 24: 6 | init                | func main.init()
        == uses ==
        000:  5:16 | int                 | type int
        001:  8:19 | int                 | type int
        002: 11:28 | int                 | type int
        003: 15: 2 | addInt0             | func main.addInt0()
        004: 16: 2 | addInt1             | func main.addInt1(i int)
        005: 17: 2 | addInt2             | func main.addInt2(i int, j int)
        006: 18: 2 | addInt3             | var main.addInt3 func(i int, j int, k int)
        007: 19:12 | string              | type string
        008: 19:20 | string              | type string
        009: 20:10 | a                   | var a string
        010: 20:14 | b                   | var b string
        011: 25: 2 | add                 | func main.addInt2(i int, j int)
        012: 26: 2 | add                 | var main.addInt3 func(i int, j int, k int)
        013: 27: 2 | add                 | func main.add__4(a string, b string) string
        == overloads ==
        000: 25: 2 | add                 | func main.add(__xgo_overload_args__ interface{_()})
        001: 26: 2 | add                 | func main.add(__xgo_overload_args__ interface{_()})
        002: 27: 2 | add                 | func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:38.314243 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:13:39 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:39 ==> NewOverloadFunc NewRange
2025/10/11 16:13:39 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:39 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:39 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:39 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:39 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:39 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:39 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:39 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:39 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:39 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:39 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:39 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:39 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:39 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:39.606118 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003fd1a0 {
}

2025/10/11 16:13:39 ==> Preload func add__0
2025/10/11 16:13:39 ==> Preload func add__1
2025/10/11 16:13:39 ==> Preload func init
2025/10/11 16:13:39 ==> Load func add__0
2025/10/11 16:13:39.606221 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:39.606242 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:39.606255 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:39.606270 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/10/11 16:13:39.606285 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/10/11 16:13:39.606300 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:39.606311 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:39.606325 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:39.606352 [INFO] typesutil/gopinfo.go:251: ==> Def: add__0 func main.add__0(a int, b int) int
2025/10/11 16:13:39 NewFunc add__0 func(a int, b int) int
2025/10/11 16:13:39 Val a int
2025/10/11 16:13:39.606398 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/10/11 16:13:39.606410 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/10/11 16:13:39 Val b int
2025/10/11 16:13:39.606432 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b int
2025/10/11 16:13:39.606445 [INFO] typesutil/gopinfo.go:215: ==> Type: b int
2025/10/11 16:13:39 BinaryOp +
2025/10/11 16:13:39 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:39 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:39 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:39.606550 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 48 + b} int
2025/10/11 16:13:39 Return 1
2025/10/11 16:13:39 ==> MatchType int, int
2025/10/11 16:13:39.606594 [INFO] typesutil/gopinfo.go:332: ==> Scope: func add__0 scope 0xc0003fd380 {
.  var a int
.  var b int
}

2025/10/11 16:13:39 End // Func
2025/10/11 16:13:39 ==> Load func add__1
2025/10/11 16:13:39.606636 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:13:39.606648 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:39.606659 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:39.606672 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a string
2025/10/11 16:13:39.606685 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b string
2025/10/11 16:13:39.606698 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:13:39.606710 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:39.606722 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:39.606742 [INFO] typesutil/gopinfo.go:251: ==> Def: add__1 func main.add__1(a string, b string) string
2025/10/11 16:13:39 NewFunc add__1 func(a string, b string) string
2025/10/11 16:13:39 Val a string
2025/10/11 16:13:39.606781 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a string
2025/10/11 16:13:39.606794 [INFO] typesutil/gopinfo.go:215: ==> Type: a string
2025/10/11 16:13:39 Val b string
2025/10/11 16:13:39.606814 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b string
2025/10/11 16:13:39.606828 [INFO] typesutil/gopinfo.go:215: ==> Type: b string
2025/10/11 16:13:39 BinaryOp +
2025/10/11 16:13:39 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:39 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:39 ==> MatchType string, unboundFuncParam{typ: string}
2025/10/11 16:13:39.606896 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 94 + b} string
2025/10/11 16:13:39 Return 1
2025/10/11 16:13:39 ==> MatchType string, string
2025/10/11 16:13:39.606936 [INFO] typesutil/gopinfo.go:332: ==> Scope: func add__1 scope 0xc0003fd680 {
.  var a string
.  var b string
}

2025/10/11 16:13:39 End // Func
2025/10/11 16:13:39 ==> NewOverloadFunc add
2025/10/11 16:13:39 ==> Load func init
2025/10/11 16:13:39.606984 [INFO] typesutil/gopinfo.go:251: ==> Def: init func main.init()
2025/10/11 16:13:39 NewFunc init func()
2025/10/11 16:13:39 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:39.607029 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:39.607044 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/10/11 16:13:39.607079 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:39 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:13:39.607118 [INFO] typesutil/gopinfo.go:215: ==> Type: &{123 INT 100 <nil>} untyped int
2025/10/11 16:13:39 Val &{0 INT 200} *ast.BasicLit
2025/10/11 16:13:39.607146 [INFO] typesutil/gopinfo.go:215: ==> Type: &{128 INT 200 <nil>} untyped int
2025/10/11 16:13:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:13:39 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/10/11 16:13:39 ==> MatchType untyped int (100), int
2025/10/11 16:13:39 ==> MatchType untyped int (200), int
2025/10/11 16:13:39.607234 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add__0(a int, b int) int
2025/10/11 16:13:39.607253 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(a int, b int) int
2025/10/11 16:13:39.607279 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc0005b7b60 0xc0005b7b90] 0 [] 0 131} int
2025/10/11 16:13:39 Val add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:39.607309 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:39.607320 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/10/11 16:13:39.607340 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/10/11 16:13:39.607372 [INFO] typesutil/gopinfo.go:215: ==> Type: &{137 STRING "hello" <nil>} untyped string
2025/10/11 16:13:39 Val &{0 STRING "world"} *ast.BasicLit
2025/10/11 16:13:39.607396 [INFO] typesutil/gopinfo.go:215: ==> Type: &{146 STRING "world" <nil>} untyped string
2025/10/11 16:13:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/10/11 16:13:39 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/10/11 16:13:39 ==> MatchType untyped string ("hello"), int
2025/10/11 16:13:39 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/10/11 16:13:39 ==> MatchType untyped string ("hello"), string
2025/10/11 16:13:39 ==> MatchType untyped string ("world"), string
2025/10/11 16:13:39.607485 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add__1(a string, b string) string
2025/10/11 16:13:39.607501 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(a string, b string) string
2025/10/11 16:13:39.607520 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc0005b7bc0 0xc0005b7bf0] 0 [] 0 153} string
2025/10/11 16:13:39.607536 [INFO] typesutil/gopinfo.go:332: ==> Scope: func init scope 0xc0003fd9e0 {
}

2025/10/11 16:13:39 End // Func
2025/10/11 16:13:39.607566 [INFO] typesutil/gopinfo.go:215: ==> Type: &{16 <nil> 0xc0005b78c0 0xc0005b78f0} func(a int, b int) int
2025/10/11 16:13:39.607587 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005826e0 0xc0005b7980} func(a int, b int) int
2025/10/11 16:13:39.607599 [INFO] typesutil/gopinfo.go:292: ==> Implicit: func main.add__0(a int, b int) int
2025/10/11 16:13:39.607619 [INFO] typesutil/gopinfo.go:215: ==> Type: &{56 <nil> 0xc0005b79e0 0xc0005b7a10} func(a string, b string) string
2025/10/11 16:13:39.607634 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000582820 0xc0005b7aa0} func(a string, b string) string
2025/10/11 16:13:39.607647 [INFO] typesutil/gopinfo.go:292: ==> Implicit: func main.add__1(a string, b string) string
2025/10/11 16:13:39.607662 [INFO] typesutil/gopinfo.go:251: ==> Def: add func main.add(__xgo_overload_args__ interface{_()})
    info_test.go:190: == types ==
        000:  3: 2 | func(a, b int) int  *ast.FuncType                  | type    : func(a int, b int) int | type
        001:  3: 2 | func(a, b int) int {
        	return a + b
        } *ast.FuncLit                   | value   : func(a int, b int) int | value
        002:  3:12 | int                 *ast.Ident                     | type    : int | type
        003:  3:17 | int                 *ast.Ident                     | type    : int | type
        004:  4:10 | a                   *ast.Ident                     | var     : int | variable
        005:  4:10 | a + b               *ast.BinaryExpr                | value   : int | value
        006:  4:14 | b                   *ast.Ident                     | var     : int | variable
        007:  6: 2 | func(a, b string) string *ast.FuncType                  | type    : func(a string, b string) string | type
        008:  6: 2 | func(a, b string) string {
        	return a + b
        } *ast.FuncLit                   | value   : func(a string, b string) string | value
        009:  6:12 | string              *ast.Ident                     | type    : string | type
        010:  6:20 | string              *ast.Ident                     | type    : string | type
        011:  7:10 | a                   *ast.Ident                     | var     : string | variable
        012:  7:10 | a + b               *ast.BinaryExpr                | value   : string | value
        013:  7:14 | b                   *ast.Ident                     | var     : string | variable
        014: 12: 2 | add                 *ast.Ident                     | value   : func(a int, b int) int | value
        015: 12: 2 | add 100, 200        *ast.CallExpr                  | value   : int | value
        016: 12: 6 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        017: 12:11 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        018: 13: 2 | add                 *ast.Ident                     | value   : func(a string, b string) string | value
        019: 13: 2 | add "hello", "world" *ast.CallExpr                  | value   : string | value
        020: 13: 6 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        021: 13:15 | "world"             *ast.BasicLit                  | value   : untyped string = "world" | constant
        == defs ==
        000:  2: 6 | add                 | func main.add(__xgo_overload_args__ interface{_()})
        001:  3: 2 | add__0              | func main.add__0(a int, b int) int
        002:  3: 7 | a                   | var a int
        003:  3:10 | b                   | var b int
        004:  6: 2 | add__1              | func main.add__1(a string, b string) string
        005:  6: 7 | a                   | var a string
        006:  6:10 | b                   | var b string
        007: 11: 6 | init                | func main.init()
        == uses ==
        000:  3:12 | int                 | type int
        001:  3:17 | int                 | type int
        002:  4:10 | a                   | var a int
        003:  4:14 | b                   | var b int
        004:  6:12 | string              | type string
        005:  6:20 | string              | type string
        006:  7:10 | a                   | var a string
        007:  7:14 | b                   | var b string
        008: 12: 2 | add                 | func main.add__0(a int, b int) int
        009: 13: 2 | add                 | func main.add__1(a string, b string) string
        == overloads ==
        000: 12: 2 | add                 | func main.add(__xgo_overload_args__ interface{_()})
        001: 13: 2 | add                 | func main.add(__xgo_overload_args__ interface{_()})
--- PASS: TestGopOverloadDecl (2.62s)
=== RUN   TestGoxOverloadInfo
2025/10/11 16:13:39.609237 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/10/11 16:13:40 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:40 ==> NewOverloadFunc NewRange
2025/10/11 16:13:40 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:40 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:40 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:40 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:40 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:40 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:40 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:40 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:40 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:40 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:40 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:40 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:40 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:40 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:40.850292 [INFO] typesutil/gopinfo.go:332: ==> Scope: Rect.gox scope 0xc000343020 {
}

2025/10/11 16:13:40 ==> Preload type Rect
2025/10/11 16:13:40 ==> Preload method Rect.addInt
2025/10/11 16:13:40 ==> Preload method Rect.addString
2025/10/11 16:13:40 ==> Preload method Rect.add__1
2025/10/11 16:13:40 NewConstDefs
2025/10/11 16:13:40 ==> Preload const [Gopo_Rect_add]
2025/10/11 16:13:40 ==> Load > NewType Rect
2025/10/11 16:13:40 NewType Rect
2025/10/11 16:13:40 ==> Load > InitType Rect
2025/10/11 16:13:40 InitType Rect struct{}
2025/10/11 16:13:40 ==> LookupParent Rect => type main.Rect struct{}
2025/10/11 16:13:40.850474 [INFO] typesutil/gopinfo.go:265: ==> Use: Rect type main.Rect struct{}
2025/10/11 16:13:40.850497 [INFO] typesutil/gopinfo.go:215: ==> Type: Rect main.Rect
2025/10/11 16:13:40.850515 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Rect
2025/10/11 16:13:40 ==> Load method *main.Rect.addInt
2025/10/11 16:13:40.850544 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:40.850558 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:40.850570 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:40.850584 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/10/11 16:13:40.850598 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/10/11 16:13:40.850611 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:40.850624 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:40.850636 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:40.850661 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt func (*main.Rect).addInt(a int, b int) int
2025/10/11 16:13:40 ==> LookupParent Rect => type main.Rect struct{}
2025/10/11 16:13:40.850687 [INFO] typesutil/gopinfo.go:265: ==> Use: Rect type main.Rect struct{}
2025/10/11 16:13:40.850700 [INFO] typesutil/gopinfo.go:215: ==> Type: Rect main.Rect
2025/10/11 16:13:40.850716 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Rect
2025/10/11 16:13:40 ==> Load method *main.Rect.addString
2025/10/11 16:13:40.850740 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:13:40.850753 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:40.850766 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:40.850779 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a string
2025/10/11 16:13:40.850795 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b string
2025/10/11 16:13:40.850806 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/10/11 16:13:40.850820 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:40.850831 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/10/11 16:13:40.850850 [INFO] typesutil/gopinfo.go:251: ==> Def: addString func (*main.Rect).addString(a string, b string) string
2025/10/11 16:13:40 ==> LookupParent Rect => type main.Rect struct{}
2025/10/11 16:13:40.850874 [INFO] typesutil/gopinfo.go:265: ==> Use: Rect type main.Rect struct{}
2025/10/11 16:13:40.850889 [INFO] typesutil/gopinfo.go:215: ==> Type: Rect main.Rect
2025/10/11 16:13:40.850902 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Rect
2025/10/11 16:13:40 ==> Load method *main.Rect.add__1
2025/10/11 16:13:40.850923 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:13:40.850934 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:13:40.850946 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:13:40.850958 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a float64
2025/10/11 16:13:40.850971 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b float64
2025/10/11 16:13:40.850988 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/10/11 16:13:40.851005 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:13:40.851017 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/10/11 16:13:40.851039 [INFO] typesutil/gopinfo.go:251: ==> Def: add__1 func (*main.Rect).add__1(a float64, b float64) float64
2025/10/11 16:13:40 ==> Load const [Gopo_Rect_add] <nil>
2025/10/11 16:13:40 NewConst [Gopo_Rect_add] 0
2025/10/11 16:13:40 Val &{0 STRING ".addInt,,.addString"} *ast.BasicLit
2025/10/11 16:13:40.851102 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING ".addInt,,.addString" <nil>} untyped string
2025/10/11 16:13:40 EndInit 1
2025/10/11 16:13:40.851128 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_Rect_add const main.Gopo_Rect_add untyped string
2025/10/11 16:13:40 ==> NewOverloadMethod Rect add
2025/10/11 16:13:40 NewFunc addInt (*main.Rect) func(a int, b int) int
2025/10/11 16:13:40 Val a int
2025/10/11 16:13:40.851202 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/10/11 16:13:40.851219 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/10/11 16:13:40 Val b int
2025/10/11 16:13:40.851243 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b int
2025/10/11 16:13:40.851258 [INFO] typesutil/gopinfo.go:215: ==> Type: b int
2025/10/11 16:13:40 BinaryOp +
2025/10/11 16:13:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/10/11 16:13:40.851355 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 40 + b} int
2025/10/11 16:13:40 Return 1
2025/10/11 16:13:40 ==> MatchType int, int
2025/10/11 16:13:40.851402 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt scope 0xc000365920 {
.  var a int
.  var b int
.  var this *main.Rect
}

2025/10/11 16:13:40 End // Func
2025/10/11 16:13:40 NewFunc addString (*main.Rect) func(a string, b string) string
2025/10/11 16:13:40 Val a string
2025/10/11 16:13:40.851467 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a string
2025/10/11 16:13:40.851480 [INFO] typesutil/gopinfo.go:215: ==> Type: a string
2025/10/11 16:13:40 Val b string
2025/10/11 16:13:40.851500 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b string
2025/10/11 16:13:40.851511 [INFO] typesutil/gopinfo.go:215: ==> Type: b string
2025/10/11 16:13:40 BinaryOp +
2025/10/11 16:13:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:40 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:40 ==> MatchType string, unboundFuncParam{typ: string}
2025/10/11 16:13:40.851573 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 94 + b} string
2025/10/11 16:13:40 Return 1
2025/10/11 16:13:40 ==> MatchType string, string
2025/10/11 16:13:40.851612 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addString scope 0xc000365c20 {
.  var a string
.  var b string
.  var this *main.Rect
}

2025/10/11 16:13:40 End // Func
2025/10/11 16:13:40 NewFunc add__1 (*main.Rect) func(a float64, b float64) float64
2025/10/11 16:13:40 Val a float64
2025/10/11 16:13:40.851667 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/10/11 16:13:40.851684 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/10/11 16:13:40 Val b float64
2025/10/11 16:13:40.851708 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/10/11 16:13:40.851719 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/10/11 16:13:40 BinaryOp +
2025/10/11 16:13:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/10/11 16:13:40 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/10/11 16:13:40 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/10/11 16:13:40.851780 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 163 + b} float64
2025/10/11 16:13:40 Return 1
2025/10/11 16:13:40 ==> MatchType float64, float64
2025/10/11 16:13:40.851820 [INFO] typesutil/gopinfo.go:332: ==> Scope: func add__1 scope 0xc0002f7740 {
.  var a float64
.  var b float64
.  var this *main.Rect
}

2025/10/11 16:13:40 End // Func
2025/10/11 16:13:40.851851 [INFO] typesutil/gopinfo.go:251: ==> Def: add func (main.Rect).add(__xgo_overload_args__ interface{_()})
2025/10/11 16:13:40.851873 [INFO] typesutil/gopinfo.go:265: ==> Use: Rect type main.Rect struct{}
2025/10/11 16:13:40.851893 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt func (*main.Rect).addInt(a int, b int) int
2025/10/11 16:13:40.851911 [INFO] typesutil/gopinfo.go:265: ==> Use: addString func (*main.Rect).addString(a string, b string) string
    info_test.go:190: == types ==
        000:  0: 0 | ".addInt,,.addString" *ast.BasicLit                  | value   : untyped string = ".addInt,,.addString" | constant
        001:  0: 0 | Rect                *ast.Ident                     | type    : main.Rect | type
        002:  2:18 | int                 *ast.Ident                     | type    : int | type
        003:  2:23 | int                 *ast.Ident                     | type    : int | type
        004:  3: 9 | a                   *ast.Ident                     | var     : int | variable
        005:  3: 9 | a + b               *ast.BinaryExpr                | value   : int | value
        006:  3:13 | b                   *ast.Ident                     | var     : int | variable
        007:  6:21 | string              *ast.Ident                     | type    : string | type
        008:  6:29 | string              *ast.Ident                     | type    : string | type
        009:  7: 9 | a                   *ast.Ident                     | var     : string | variable
        010:  7: 9 | a + b               *ast.BinaryExpr                | value   : string | value
        011:  7:13 | b                   *ast.Ident                     | var     : string | variable
        012: 12:12 | float64             *ast.Ident                     | type    : float64 | type
        013: 12:21 | float64             *ast.Ident                     | type    : float64 | type
        014: 13:10 | a                   *ast.Ident                     | var     : float64 | variable
        015: 13:10 | a + b               *ast.BinaryExpr                | value   : float64 | value
        016: 13:14 | b                   *ast.Ident                     | var     : float64 | variable
        == defs ==
        000:  0: 0 | Gopo_Rect_add       | const main.Gopo_Rect_add untyped string
        001:  0: 0 | this                | var this *main.Rect
        002:  2: 6 | addInt              | func (*main.Rect).addInt(a int, b int) int
        003:  2:13 | a                   | var a int
        004:  2:16 | b                   | var b int
        005:  6: 6 | addString           | func (*main.Rect).addString(a string, b string) string
        006:  6:16 | a                   | var a string
        007:  6:19 | b                   | var b string
        008: 10: 6 | add                 | func (main.Rect).add(__xgo_overload_args__ interface{_()})
        009: 12: 2 | add__1              | func (*main.Rect).add__1(a float64, b float64) float64
        010: 12: 7 | a                   | var a float64
        011: 12:10 | b                   | var b float64
        == uses ==
        000:  0: 0 | Rect                | type main.Rect struct{}
        001:  2:18 | int                 | type int
        002:  2:23 | int                 | type int
        003:  3: 9 | a                   | var a int
        004:  3:13 | b                   | var b int
        005:  6:21 | string              | type string
        006:  6:29 | string              | type string
        007:  7: 9 | a                   | var a string
        008:  7:13 | b                   | var b string
        009: 11: 2 | addInt              | func (*main.Rect).addInt(a int, b int) int
        010: 12:12 | float64             | type float64
        011: 12:21 | float64             | type float64
        012: 13:10 | a                   | var a float64
        013: 13:14 | b                   | var b float64
        014: 15: 2 | addString           | func (*main.Rect).addString(a string, b string) string
--- PASS: TestGoxOverloadInfo (1.24s)
=== RUN   TestTypesAlias
2025/10/11 16:13:40.852767 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/10/11 16:13:41 ==> Import github.com/qiniu/x/xgo
2025/10/11 16:13:41 ==> NewOverloadFunc NewRange
2025/10/11 16:13:41 ==> Import github.com/qiniu/x/xgo/ng
2025/10/11 16:13:41 ==> NewOverloadFunc Bigrat_Cast
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_Sub
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_LT
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_LE
2025/10/11 16:13:41 ==> NewOverloadFunc UntypedBigrat_Init
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Abs
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Cmp
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_GE
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_LE
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_Quo
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_EQ
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_Xor
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_Mul
2025/10/11 16:13:41 ==> NewOverloadFunc Bigint_Cast
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_Rcast
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_EQ
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_GT
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Cmp
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_Add
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_Rem
2025/10/11 16:13:41 ==> NewOverloadFunc Uint128_Cast
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_Mul
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 QuoRem
2025/10/11 16:13:41 ==> NewOverloadFunc Int128_Init
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_Sub
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_GT
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_Quo
2025/10/11 16:13:41 ==> NewOverloadFunc Uint128_Init
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_Add
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_LT
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_Or
2025/10/11 16:13:41 ==> NewOverloadFunc UntypedBigint_Init
2025/10/11 16:13:41 ==> NewOverloadFunc Bigint_Init
2025/10/11 16:13:41 ==> NewOverloadFunc Int128_Cast
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_And
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 QuoRem
2025/10/11 16:13:41 ==> NewOverloadMethod Bigint Gop_Rcast
2025/10/11 16:13:41 ==> NewOverloadFunc Bigrat_Init
2025/10/11 16:13:41 ==> NewOverloadMethod Int128 Gop_Rem
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/10/11 16:13:41 ==> NewOverloadMethod Uint128 Gop_GE
2025/10/11 16:13:42.058323 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003f9b00 {
}

2025/10/11 16:13:42.058377 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package fmt
2025/10/11 16:13:42 ==> Preload type T
2025/10/11 16:13:42 ==> Preload var [v]
2025/10/11 16:13:42 ==> Preload func demo
2025/10/11 16:13:42 ==> Preload func main
2025/10/11 16:13:42 ==> Load > AliasType T
2025/10/11 16:13:42.058458 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/10/11 16:13:42.058478 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:42.058492 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/10/11 16:13:42 AliasType T int
2025/10/11 16:13:42.058519 [INFO] typesutil/gopinfo.go:251: ==> Def: T type T
2025/10/11 16:13:42 ==> LookupParent T => type T
2025/10/11 16:13:42.058542 [INFO] typesutil/gopinfo.go:265: ==> Use: T type T
2025/10/11 16:13:42.058556 [INFO] typesutil/gopinfo.go:215: ==> Type: T int
2025/10/11 16:13:42.058569 [INFO] typesutil/gopinfo.go:215: ==> Type: T int
2025/10/11 16:13:42 ==> Load var int [v]
2025/10/11 16:13:42 NewVarDefs
2025/10/11 16:13:42 NewVar [v]
2025/10/11 16:13:42.058612 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v int
2025/10/11 16:13:42 ==> Load func demo
2025/10/11 16:13:42 ==> LookupParent T => type T
2025/10/11 16:13:42.058643 [INFO] typesutil/gopinfo.go:265: ==> Use: T type T
2025/10/11 16:13:42.058655 [INFO] typesutil/gopinfo.go:215: ==> Type: T int
2025/10/11 16:13:42.058667 [INFO] typesutil/gopinfo.go:215: ==> Type: T int
2025/10/11 16:13:42.058680 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v int
2025/10/11 16:13:42.058704 [INFO] typesutil/gopinfo.go:251: ==> Def: demo func demo(v int)
2025/10/11 16:13:42 NewFunc demo func(v int)
2025/10/11 16:13:42.058750 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/10/11 16:13:42.058771 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/10/11 16:13:42 Val Println func(a ...any) (n int, err error)
2025/10/11 16:13:42 Val v int
2025/10/11 16:13:42.058813 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v int
2025/10/11 16:13:42.058826 [INFO] typesutil/gopinfo.go:215: ==> Type: v int
2025/10/11 16:13:42 Call 1 0 // func(a ...any) (n int, err error)
2025/10/11 16:13:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/10/11 16:13:42 ==> MatchType int, any
2025/10/11 16:13:42.058895 [INFO] typesutil/gopinfo.go:215: ==> Type: &{fmt Println} func(a ...any) (n int, err error)
2025/10/11 16:13:42.058924 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00059d278 78 [v] 0 [] 80 0} (n int, err error)
2025/10/11 16:13:42.058946 [INFO] typesutil/gopinfo.go:332: ==> Scope: func demo scope 0xc0003f9da0 {
.  var v int
}

2025/10/11 16:13:42 End // Func
2025/10/11 16:13:42 ==> Load func main
2025/10/11 16:13:42.058985 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main()
2025/10/11 16:13:42 NewFunc main func()
2025/10/11 16:13:42 Val demo func(v int)
2025/10/11 16:13:42.059022 [INFO] typesutil/gopinfo.go:265: ==> Use: demo func demo(v int)
2025/10/11 16:13:42.059036 [INFO] typesutil/gopinfo.go:215: ==> Type: demo func(v int)
2025/10/11 16:13:42 Val &{0 INT 100} *ast.BasicLit
2025/10/11 16:13:42.059074 [INFO] typesutil/gopinfo.go:215: ==> Type: &{104 INT 100 <nil>} untyped int
2025/10/11 16:13:42 Call 1 0 // func(v int)
2025/10/11 16:13:42 ==> MatchFuncCall func(v int) args: 1 flags: 0
2025/10/11 16:13:42 ==> MatchType untyped int (100), int
2025/10/11 16:13:42.059138 [INFO] typesutil/gopinfo.go:215: ==> Type: &{demo 103 [0xc000227c80] 0 [] 107 0} ()
2025/10/11 16:13:42.059159 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0003f9ec0 {
}

2025/10/11 16:13:42 End // Func
    info_test.go:226: ====== check types pass (count: 9) ======
        000:  4:10 | int                 *ast.Ident                     | type    : int | type
        001:  5: 7 | T                   *ast.Ident                     | type    : int | type
        002:  6:13 | T                   *ast.Ident                     | type    : int | type
        003:  7: 2 | fmt.Println         *ast.SelectorExpr              | value   : func(a ...any) (n int, err error) | value
        004:  7: 2 | fmt.Println(v)      *ast.CallExpr                  | value   : (n int, err error) | value
        005:  7:14 | v                   *ast.Ident                     | var     : int | variable
        006: 10: 2 | demo                *ast.Ident                     | value   : func(v int) | value
        007: 10: 2 | demo(100)           *ast.CallExpr                  | void    : () | no value
        008: 10: 7 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
    info_test.go:226: ====== check defs pass (count: 5) ======
        000:  4: 6 | T                   | type T
        001:  5: 5 | v                   | var v int
        002:  6: 6 | demo                | func demo(v int)
        003:  6:11 | v                   | var v int
        004:  9: 6 | main                | func main()
    info_test.go:226: ====== check uses pass (count: 7) ======
        000:  4:10 | int                 | type int
        001:  5: 7 | T                   | type T
        002:  6:13 | T                   | type T
        003:  7: 2 | fmt                 | package fmt
        004:  7: 6 | Println             | func fmt.Println(a ...any) (n int, err error)
        005:  7:14 | v                   | var v int
        006: 10: 2 | demo                | func demo(v int)
--- PASS: TestTypesAlias (1.21s)
PASS
coverage: 87.1% of statements
ok  	github.com/goplus/xgo/x/typesutil	83.204s	coverage: 87.1% of statements
	github.com/goplus/xgo/x/typesutil/internal/typesutil		coverage: 0.0% of statements
	github.com/goplus/xgo/x/typesutil/typeparams		coverage: 0.0% of statements
	github.com/goplus/xgo/x/watcher		coverage: 0.0% of statements
	github.com/goplus/xgo/x/xgoenv		coverage: 0.0% of statements
=== RUN   TestIsLocal
--- PASS: TestIsLocal (0.00s)
=== RUN   TestParseOne
--- PASS: TestParseOne (0.00s)
=== RUN   TestParseAll_wildcard1
--- PASS: TestParseAll_wildcard1 (0.00s)
=== RUN   TestParseAll_wildcard2
--- PASS: TestParseAll_wildcard2 (0.00s)
=== RUN   TestParseAll_multiFiles
--- PASS: TestParseAll_multiFiles (0.00s)
=== RUN   TestParseAll_multiProjs
--- PASS: TestParseAll_multiProjs (0.00s)
=== RUN   TestParseAllErr
--- PASS: TestParseAllErr (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/x/xgoprojs	0.011s	coverage: 100.0% of statements
