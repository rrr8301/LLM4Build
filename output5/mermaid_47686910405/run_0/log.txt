
> mermaid-monorepo@10.2.4 test:coverage /app
> vitest --coverage

6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid-example-diagram/src/exampleDiagramDb.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid-example-diagram/src/exampleDiagramRenderer.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid-example-diagram/src/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/clusters.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/createLabel.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/edges.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/index.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/index.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-circle.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-ellipse.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-line.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-node.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-polygon.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-rect.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/markers.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/mermaid-graphlib.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/nodes.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/shapes/note.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/shapes/util.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/c4Db.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/c4Renderer.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/svgDraw.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/class/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/er/erMarkers.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/er/erRenderer.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/gantt/ganttDb.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/gantt/ganttRenderer.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/gantt/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/git/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/requirement/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/sankey/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/sequence/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/sequence/svgDraw.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/state/shapes.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/state/stateRenderer.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/state/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/timeline/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/timeline/svgDraw.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/timeline/timelineDb.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/user-journey/journeyDb.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/user-journey/styles.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/user-journey/svgDraw.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/insertElementsForSize.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/layout-algorithms/dagre/index.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/clusters.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/createLabel.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/edges.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/index.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-circle.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-ellipse.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-line.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-node.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-polygon.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-rect.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/markers.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/setupGraphViewbox.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/index.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-base.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-dark.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-default.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-forest.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-helpers.js' because it would overwrite input file.
6:55:22 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-neutral.js' because it would overwrite input file.

 DEV  v3.0.6 /app
      Coverage enabled with v8

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
25.465 : DEBUG :  Opting in, graph
25.465 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
25.465 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
25.465 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
25.465 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
25.465 : DEBUG :  Cluster identified C2 { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
25.465 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
25.465 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
25.465 : DEBUG :  Not a cluster a [33m0[39m
25.465 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
25.465 : WARN :  Cluster identified C1  Replacement id in edges:  a
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
25.465 : DEBUG :  Not a cluster b [33m0[39m
25.465 : DEBUG :  Extracting node c {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
25.465 : DEBUG :  Not a cluster c [33m0[39m
25.465 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.465 : INFO :  cp  a  to  C1  with parent  C1
25.465 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
25.465 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.465 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
25.465 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
25.465 : INFO :  Edge data {} C1
25.465 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
25.465 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
25.465 : INFO :  Copying as  a b {} [90mundefined[39m
25.465 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] {}
25.465 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.465 : INFO :  Edge data {} C1
25.465 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
25.465 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.465 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
25.465 : DEBUG :  Removing node a
25.465 : INFO :  cp  b  to  C1  with parent  C1
25.465 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
25.465 : WARN :  Cluster identified C2  Replacement id in edges:  c
25.465 : WARN :  Edge a -> b: {"v":"a","w":"b"}
25.465 : WARN :  Edge a -> b: {}
25.465 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
25.465 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
25.465 : WARN :  Edge C1 -> C2: {}
25.465 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
25.465 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.465 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
25.465 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.465 : INFO :  Edge data {} C1
25.465 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
25.465 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.465 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
25.465 : DEBUG :  Removing node b
25.465 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.465 : INFO :  cp  c  to  C2  with parent  C2
25.465 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
25.465 : WARN :  Fixing and trixing - removing XXX C1 C2 [90mundefined[39m
25.465 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
25.465 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.465 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
25.465 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.465 : INFO :  Edge data {} C2
25.465 : INFO :  Descendants of  C2  is  [ [32m'c'[39m ]
25.465 : WARN :  Adjusted Graph {
25.465 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.465 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
25.465 : DEBUG :  Removing node c
  nodes: [
25.465 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : DEBUG :  Done, no node has children [ [32m'a'[39m, [32m'b'[39m ]
25.465 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
25.465 : INFO :  [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]

    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.465 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
25.465 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
25.465 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m, [32m'b'[39m ]
25.465 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
25.465 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
25.465 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'c'[39m ]
25.465 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
25.465 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: {}, b: {} },
    _parent: { a: [32m'\x00'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {}, b: {} },
    _in: { a: {}, b: [36m[Object][39m },
    _preds: { a: {}, b: [36m[Object][39m },
    _out: { a: [36m[Object][39m, b: {} },
    _sucs: { a: [36m[Object][39m, b: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: {} },
    _nodeCount: [33m2[39m,
    _edgeCount: [33m1[39m
  }
}
25.465 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.465 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: {} },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.465 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
25.465 : DEBUG :  Opting in, graph
25.465 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
25.465 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
25.465 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
25.465 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
25.465 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
25.465 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
25.465 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
25.465 : DEBUG :  Not a cluster a [33m0[39m
25.465 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
25.465 : WARN :  Cluster identified C1  Replacement id in edges:  a
25.465 : WARN :  Cluster identified C2  Replacement id in edges:  c
25.465 : WARN :  Edge a -> b: {"v":"a","w":"b"}
25.465 : WARN :  Edge a -> b: {}
25.465 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
25.465 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
25.465 : WARN :  Edge C1 -> C2: {}
25.465 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
25.465 : WARN :  Fixing and trying - removing XXX C1 C2 [90mundefined[39m
25.465 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
25.465 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.465 : DEBUG :  Not a cluster b [33m0[39m
25.465 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
25.465 : DEBUG :  Not a cluster c [33m0[39m
25.465 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.465 : INFO :  cp  a  to  C1  with parent  C1
25.465 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
25.465 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.465 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.465 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
25.465 : INFO :  Edge data {} C1
25.465 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
25.465 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
25.465 : INFO :  Copying as  a b {} [90mundefined[39m
25.465 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] {}
25.465 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.465 : INFO :  Edge data {} C1
25.465 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
25.465 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.465 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
25.465 : DEBUG :  Removing node a
25.465 : INFO :  cp  b  to  C1  with parent  C1
25.465 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
25.465 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.465 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
25.465 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.465 : INFO :  Edge data {} C1
25.465 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
25.465 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.465 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
25.465 : DEBUG :  Removing node b
25.465 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.465 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
25.465 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
25.465 : INFO :  cp  c  to  C2  with parent  C2
25.465 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
25.465 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.465 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
25.465 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.465 : INFO :  Edge data {} C2
25.465 : INFO :  Descendants of  C2  is  [ [32m'c'[39m ]
25.465 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
25.465 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
25.465 : DEBUG :  Removing node c
25.465 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : DEBUG :  Done, no node has children [ [32m'a'[39m, [32m'b'[39m ]
25.465 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
25.465 : INFO :  [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]

  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
25.465 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m, [32m'b'[39m ]
25.465 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
25.465 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
25.465 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'c'[39m ]
25.465 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.465 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
25.465 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: {}, b: {} },
    _parent: { a: [32m'\x00'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {}, b: {} },
    _in: { a: {}, b: [36m[Object][39m },
    _preds: { a: {}, b: [36m[Object][39m },
    _out: { a: [36m[Object][39m, b: {} },
    _sucs: { a: [36m[Object][39m, b: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: {} },
    _nodeCount: [33m2[39m,
    _edgeCount: [33m1[39m
  }
}
25.465 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.465 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: {} },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.465 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
25.484 : DEBUG :  Opting in, graph
25.484 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
25.484 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
25.484 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
25.484 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
25.484 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
25.484 : WARN :  Cluster identified C1  Replacement id in edges:  b
25.484 : WARN :  Cluster identified C2  Replacement id in edges:  a
25.484 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'b'[39m }  leaves cluster  C2
25.484 : WARN :  Descendants of XXX  C2 :  [ [32m'a'[39m ]
25.484 : WARN :  Edge a -> b: {"v":"a","w":"b"}
25.484 : WARN :  Edge a -> b: {"name":"C1-internal-link"}
25.484 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
25.484 : WARN :  Edge C1 -> c: {"v":"C1","w":"c"}
25.484 : WARN :  Edge C1 -> c: {"name":"C1-external-link"}
25.484 : WARN :  Fix XXX Map(2) {
25.484 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
25.484 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.484 : DEBUG :  Not a cluster a [33m0[39m
25.484 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.484 : DEBUG :  Not a cluster b [33m0[39m
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: C1 c Translating:  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
25.484 : WARN :  Fixing and trying - removing XXX C1 c [90mundefined[39m
25.484 : WARN :  Fix Replacing with XXX C1 c [90mundefined[39m
25.484 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.484 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
25.484 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
25.484 : DEBUG :  Not a cluster c [33m0[39m
25.484 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
25.484 : INFO :  cp  b  to  C1  with parent  C1
25.484 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
25.484 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
25.484 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m } ]
25.484 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
25.484 : INFO :  Edge data { name: [32m'C1-internal-link'[39m } C1
25.484 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
25.484 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
25.484 : INFO :  Copying as  a b { name: [32m'C1-internal-link'[39m } [90mundefined[39m
25.484 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] { name: [32m'C1-internal-link'[39m }
25.484 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
25.484 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.484 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
25.484 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
25.484 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
25.484 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
25.484 : DEBUG :  Removing node b
25.484 : INFO :  cp  a  to  C1  with parent  C2
25.484 : DEBUG :  Setting parent a C2
25.484 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
25.484 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
25.484 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
25.484 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
25.484 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
25.484 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.484 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
25.484 : DEBUG :  Removing node a
25.484 : INFO :  cp  C2  to  C1  with parent  C2
25.484 : INFO :  In copy  C2 root C1 data { data: [33m5[39m } C1
25.484 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
25.484 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
25.484 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
25.484 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
25.484 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
25.484 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.484 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
25.484 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'b'[39m, [32m'C2'[39m ]
25.484 : WARN :  Copying children of  C2 root C1 data { data: [33m5[39m } C1
25.484 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
25.484 : DEBUG :  Removing node C2
25.484 : DEBUG :  Removing node C2
25.484 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.484 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.484 : DEBUG :  Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
25.484 : DEBUG :  Nodes =  [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ] [33m1[39m
25.484 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
25.484 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'a'[39m, [32m'C2'[39m ]
25.484 : WARN :  Setting parent a C2
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
25.484 : WARN :  New graph after copy node: ( C1 ) {
25.484 : DEBUG :  Not a cluster b [33m1[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.484 : DEBUG :  Extracting node a Map(2) {
  nodes: [
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m1[39m
    { v: [32m'C2'[39m, value: [36m[Object][39m }
25.484 : DEBUG :  Not a cluster a [33m1[39m
25.484 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m5[39m } [90mundefined[39m  Depth  [33m1[39m
25.484 : DEBUG :  Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
25.484 : INFO :  [ [32m'c'[39m, [32m'C1'[39m ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.484 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.484 : WARN :  New list of nodes [ [32m'c'[39m, [32m'C1'[39m ]
25.484 : WARN :   Now next level c { data: [33m3[39m }
25.484 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
25.483 : DEBUG :  Opting in, graph
25.483 : DEBUG :  Not a cluster  a { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
25.483 : DEBUG :  Not a cluster  b { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
25.483 : DEBUG :  Not a cluster  c { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
25.483 : DEBUG :  Cluster identified C1 { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
25.483 : DEBUG :  Cluster identified C2 { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
25.483 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
25.483 : DEBUG :  Extracting node a {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m, a: [36m[Object][39m, C2: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m, a: [32m'C2'[39m, C2: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {}, a: {}, C2: [36m[Object][39m },
    _in: { b: [36m[Object][39m, a: {}, C2: {} },
    _preds: { b: [36m[Object][39m, a: {}, C2: {} },
25.483 : DEBUG :  Not a cluster a [33m0[39m
25.483 : DEBUG :  Extracting node b {
    _out: { b: {}, a: [36m[Object][39m, C2: {} },
    _sucs: { b: {}, a: [36m[Object][39m, C2: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m1[39m
  }
}
25.484 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.483 : DEBUG :  Not a cluster b [33m0[39m
25.483 : DEBUG :  Extracting node c {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
25.483 : DEBUG :  Not a cluster c [33m0[39m
25.483 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
25.483 : INFO :  cp  b  to  C1  with parent  C1
25.483 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
25.483 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.483 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m } ]
25.483 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
25.483 : INFO :  Edge data { name: [32m'C1-internal-link'[39m } C1
25.483 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
25.483 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
25.483 : INFO :  Copying as  a b { name: [32m'C1-internal-link'[39m } [90mundefined[39m
25.483 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] { name: [32m'C1-internal-link'[39m }
25.483 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.483 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
25.483 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
25.483 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
25.483 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
25.483 : DEBUG :  Removing node b
25.483 : INFO :  cp  a  to  C1  with parent  C2
25.483 : DEBUG :  Setting parent a C2
25.483 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
25.483 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
25.483 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
25.483 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
25.483 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
25.483 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
} [90mundefined[39m
25.484 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
25.484 : WARN :  New list of nodes [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ]
25.484 : WARN :   Now next level b { data: [33m2[39m }
25.484 : WARN :   Now next level a { data: [33m1[39m }
25.484 : WARN :   Now next level C2 { data: [33m5[39m }

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
25.483 : WARN :  Cluster identified C1  Replacement id in edges:  b
25.483 : WARN :  Cluster identified C2  Replacement id in edges:  a
25.483 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'b'[39m }  leaves cluster  C2
25.483 : DEBUG :  Removing node a
25.483 : INFO :  cp  C2  to  C1  with parent  C2
25.483 : INFO :  In copy  C2 root C1 data { data: [33m5[39m } C1
25.483 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
25.483 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
25.483 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
25.483 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
25.483 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
25.483 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
25.483 : WARN :  Descendants of XXX  C2 :  [ [32m'a'[39m ]
25.483 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
25.483 : WARN :  Edge a -> b: {"v":"a","w":"b"}
25.483 : DEBUG :  Removing node C2
25.483 : WARN :  Edge a -> b: {"name":"C1-internal-link"}
25.483 : DEBUG :  Removing node C2
25.483 : WARN :  Fix XXX {
25.483 : DEBUG :  Old graph after copy {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.483 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.483 : WARN :  Edge C1 -> c: {"v":"C1","w":"c"}
25.483 : DEBUG :  {
25.483 : WARN :  Edge C1 -> c: {"name":"C1-external-link"}
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
25.483 : WARN :  Fix XXX {
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
}
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
25.483 : DEBUG :  Nodes =  [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ] [33m1[39m
} ids: C1 c Translating:  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
25.483 : DEBUG :  Extracting node b {
25.483 : WARN :  Fixing and trixing - removing XXX C1 c [90mundefined[39m
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
25.483 : WARN :  Fix Replacing with XXX C1 c [90mundefined[39m
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
25.483 : DEBUG :  Not a cluster b [33m1[39m
25.483 : DEBUG :  Extracting node a {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m1[39m
25.483 : DEBUG :  Not a cluster a [33m1[39m
25.483 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m5[39m } [90mundefined[39m  Depth  [33m1[39m
25.483 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.483 : DEBUG :  {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
25.483 : INFO :  [ [32m'c'[39m, [32m'C1'[39m ]

25.483 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.483 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
25.483 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.483 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
25.483 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'b'[39m, [32m'C2'[39m ]
25.483 : WARN :  Copying children of  C2 root C1 data { data: [33m5[39m } C1
25.483 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'a'[39m, [32m'C2'[39m ]
25.483 : WARN :  Setting parent a C2
25.483 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.483 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.483 : WARN :  New list of nodes [ [32m'c'[39m, [32m'C1'[39m ]
25.483 : WARN :   Now next level c { data: [33m3[39m }
25.483 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m, a: [36m[Object][39m, C2: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m, a: [32m'C2'[39m, C2: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {}, a: {}, C2: [36m[Object][39m },
    _in: { b: [36m[Object][39m, a: {}, C2: {} },
    _preds: { b: [36m[Object][39m, a: {}, C2: {} },
    _out: { b: {}, a: [36m[Object][39m, C2: {} },
    _sucs: { b: {}, a: [36m[Object][39m, C2: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m1[39m
  }
}
25.483 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.483 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
25.483 : WARN :  New list of nodes [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ]
25.483 : WARN :   Now next level b { data: [33m2[39m }
25.483 : WARN :   Now next level a { data: [33m1[39m }
25.483 : WARN :   Now next level C2 { data: [33m5[39m }

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
25.495 : INFO :  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ]
25.495 : DEBUG :  Opting in, graph
25.495 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
25.495 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
25.495 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
25.495 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
25.495 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
25.495 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.495 : DEBUG :  Not a cluster a [33m0[39m
25.495 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.495 : DEBUG :  Not a cluster b [33m0[39m
25.495 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.495 : INFO :  cp  a  to  C1  with parent  C1
25.495 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
25.495 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.495 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
25.495 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.495 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
25.495 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
25.495 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.495 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
25.495 : DEBUG :  Removing node a
25.495 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.495 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
25.495 : WARN :  Cluster identified C1  Replacement id in edges:  a
25.495 : WARN :  Cluster identified C2  Replacement id in edges:  b
25.495 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
25.495 : WARN :  Edge C1 -> C2: {"name":"C1-external-link"}
25.495 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
25.495 : WARN :  Fixing and trying - removing XXX C1 C2 [90mundefined[39m
25.495 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
25.495 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.495 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.495 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
25.495 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.495 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
25.495 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
25.495 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.495 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
25.495 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.495 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
25.495 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'b'[39m ]
25.495 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.495 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
25.495 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.495 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.495 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.495 : INFO :  cp  b  to  C2  with parent  C2
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.495 : WARN :  extractor -  [33m1[39m {
25.495 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
25.495 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

25.495 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
25.495 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.495 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C2
25.495 : INFO :  Descendants of  C2  is  [ [32m'b'[39m ]
25.495 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.495 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
25.495 : DEBUG :  Removing node b
25.495 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.495 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
25.495 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
25.495 : INFO :  [ [32m'C1'[39m, [32m'C2'[39m ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
25.496 : INFO :  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ]
25.496 : DEBUG :  Opting in, graph
25.496 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.496 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.496 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.496 : DEBUG :  Cluster identified C2 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.496 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
25.496 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
25.496 : WARN :  Cluster identified C1  Replacement id in edges:  a
25.496 : WARN :  Cluster identified C2  Replacement id in edges:  b
25.496 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
25.496 : WARN :  Edge C1 -> C2: {"name":"C1-external-link"}
25.496 : WARN :  Fix XXX {
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.496 : DEBUG :  Not a cluster a [33m0[39m
25.496 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.496 : DEBUG :  Not a cluster b [33m0[39m
25.496 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.496 : INFO :  cp  a  to  C1  with parent  C1
25.496 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
25.496 : WARN :  Fixing and trixing - removing XXX C1 C2 [90mundefined[39m
25.496 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
25.496 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
25.496 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.496 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
25.496 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.496 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
25.496 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
25.496 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.496 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
25.496 : DEBUG :  Removing node a
25.496 : DEBUG :  Old graph after copy {
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.496 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.496 : INFO :  cp  b  to  C2  with parent  C2
25.496 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
25.496 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.496 : WARN :  extractor -  [33m0[39m {
25.496 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
25.496 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.496 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
25.496 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.496 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C2
25.496 : INFO :  Descendants of  C2  is  [ [32m'b'[39m ]
25.496 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
25.496 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
25.496 : DEBUG :  Removing node b
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.496 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
25.496 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
25.496 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
25.496 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.496 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
25.496 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'C2'[39m }
}
  ],
25.496 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
25.496 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
25.496 : INFO :  [ [32m'C1'[39m, [32m'C2'[39m ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
25.502 : DEBUG :  Opting in, graph
25.502 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
25.502 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
25.502 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
25.502 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m ] [33m0[39m
25.502 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.502 : DEBUG :  Not a cluster a [33m0[39m
25.502 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.502 : DEBUG :  Not a cluster b [33m0[39m
25.502 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
25.502 : INFO :  cp  a  to  C1  with parent  C1
25.502 : INFO :  In copy  C1 root C1 data { data: [33m3[39m } C1
25.502 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.502 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
25.502 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.502 : INFO :  Edge data { data: [32m'link1'[39m } C1
25.502 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
25.502 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.502 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
25.502 : DEBUG :  Removing node a
25.502 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.502 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
25.502 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]

  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.496 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
25.496 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'b'[39m ]
25.496 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.496 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
25.496 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.496 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.496 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.496 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
25.501 : WARN :  Cluster identified C1  Replacement id in edges:  a
25.501 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
25.501 : WARN :  Edge C1 -> b: {"data":"link1"}
25.501 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m3[39m } }  ---  [90mundefined[39m
25.501 : WARN :  Fixing and trying - removing XXX C1 b 1
25.501 : WARN :  Fix Replacing with XXX C1 b 1
25.501 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.501 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.501 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
25.501 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.501 : WARN :  Copying children of  C1 root C1 data { data: [33m3[39m } C1
25.501 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
25.501 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.501 : WARN :  New list of nodes [ [32m'b'[39m, [32m'C1'[39m ]
25.501 : WARN :   Now next level b { data: [33m2[39m }
25.501 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m3[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.501 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

 ✓ packages/mermaid/src/diagrams/quadrant-chart/parser/quadrant.jison.spec.ts (14 tests) 46ms
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
25.508 : INFO :  { data: [33m4[39m }
25.508 : DEBUG :  Opting in, graph
25.508 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
25.508 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
25.508 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
25.508 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
25.508 : WARN :  Cluster identified C1  Replacement id in edges:  a
25.508 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
25.508 : WARN :  Edge C1 -> b: {"data":"link1"}
25.508 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
25.508 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ] [33m0[39m
25.508 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.508 : DEBUG :  Not a cluster a [33m0[39m
25.508 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.508 : DEBUG :  Not a cluster b [33m0[39m
25.508 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
25.508 : WARN :  Fixing and trying - removing XXX C1 b 1
25.508 : WARN :  Fix Replacing with XXX C1 b 1
25.508 : WARN :  Edge C1 -> c: {"v":"C1","w":"c","name":"2"}
25.508 : WARN :  Edge C1 -> c: {"data":"link2"}
25.508 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 c Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
25.508 : DEBUG :  Not a cluster c [33m0[39m
25.508 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
25.508 : WARN :  Fixing and trying - removing XXX C1 c 2
25.508 : WARN :  Fix Replacing with XXX C1 c 2
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
25.508 : WARN :  Adjusted Graph {
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.508 : INFO :  cp  a  to  C1  with parent  C1
25.508 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
25.508 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.508 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
25.508 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.508 : INFO :  Edge data { data: [32m'link1'[39m } C1
25.508 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
25.508 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.508 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
}
25.508 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
25.508 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
25.508 : INFO :  Edge data { data: [32m'link2'[39m } C1
25.508 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
25.508 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
25.508 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.508 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
25.508 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
25.508 : DEBUG :  Removing node a
25.508 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.508 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
25.508 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
25.508 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.508 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
25.508 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
25.506 : DEBUG :  Opting in, graph
25.506 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.506 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.506 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.506 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m ] [33m0[39m
}
25.506 : DEBUG :  Extracting node a {
25.508 : WARN :  New list of nodes [ [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ]
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.506 : DEBUG :  Not a cluster a [33m0[39m
25.506 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.506 : DEBUG :  Not a cluster b [33m0[39m
25.506 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
25.508 : WARN :   Now next level b { data: [33m2[39m }
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
25.506 : INFO :  cp  a  to  C1  with parent  C1
25.506 : INFO :  In copy  C1 root C1 data { data: [33m3[39m } C1
25.506 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.506 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
25.506 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.506 : INFO :  Edge data { data: [32m'link1'[39m } C1
25.506 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
25.506 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.506 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
25.506 : DEBUG :  Removing node a
25.506 : DEBUG :  Old graph after copy {
25.508 : WARN :   Now next level c { data: [33m3[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.508 : WARN :   Now next level C1 {
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  clusterNode: [33mtrue[39m,
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.506 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
25.506 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]

  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.508 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
25.506 : WARN :  Cluster identified C1  Replacement id in edges:  a
25.506 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
25.506 : WARN :  Edge C1 -> b: {"data":"link1"}
25.506 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m3[39m } }  ---  [90mundefined[39m
25.506 : WARN :  Fixing and trixing - removing XXX C1 b 1
25.506 : WARN :  Fix Replacing with XXX C1 b 1
25.506 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.506 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.506 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
25.506 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.506 : WARN :  Copying children of  C1 root C1 data { data: [33m3[39m } C1
25.506 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
25.506 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.506 : WARN :  New list of nodes [ [32m'b'[39m, [32m'C1'[39m ]
25.506 : WARN :   Now next level b { data: [33m2[39m }
25.506 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m3[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.506 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
25.515 : INFO :  { data: [33m4[39m }
25.515 : DEBUG :  Opting in, graph
25.515 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.515 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.515 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.515 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
25.515 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ] [33m0[39m
25.515 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.515 : DEBUG :  Not a cluster a [33m0[39m
25.515 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.515 : DEBUG :  Not a cluster b [33m0[39m
25.515 : DEBUG :  Extracting node c {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
25.515 : DEBUG :  Not a cluster c [33m0[39m
25.515 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
25.515 : INFO :  cp  a  to  C1  with parent  C1
25.515 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
25.515 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.515 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
25.515 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.515 : INFO :  Edge data { data: [32m'link1'[39m } C1
25.515 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
25.515 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.515 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
25.515 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
25.515 : INFO :  Edge data { data: [32m'link2'[39m } C1
25.515 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
25.515 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
25.515 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
25.515 : DEBUG :  Removing node a
25.515 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.515 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
25.515 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
25.515 : WARN :  Cluster identified C1  Replacement id in edges:  a
25.515 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
25.515 : WARN :  Edge C1 -> b: {"data":"link1"}
25.515 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
25.515 : WARN :  Fixing and trixing - removing XXX C1 b 1
25.515 : WARN :  Fix Replacing with XXX C1 b 1
25.515 : WARN :  Edge C1 -> c: {"v":"C1","w":"c","name":"2"}
25.515 : WARN :  Edge C1 -> c: {"data":"link2"}
25.515 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 c Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
25.515 : WARN :  Fixing and trixing - removing XXX C1 c 2
25.515 : WARN :  Fix Replacing with XXX C1 c 2
25.515 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.515 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.515 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
25.515 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.515 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
25.515 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
25.515 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.515 : WARN :  New list of nodes [ [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ]
25.515 : WARN :   Now next level b { data: [33m2[39m }
25.515 : WARN :   Now next level c { data: [33m3[39m }
25.515 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.515 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
25.514 : DEBUG :  Opting in, graph
25.514 : DEBUG :  Not a cluster  a Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
25.514 : DEBUG :  Not a cluster  b Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
25.514 : DEBUG :  Not a cluster  c Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
25.514 : DEBUG :  Cluster identified A Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
25.514 : DEBUG :  Cluster identified B Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
25.514 : DEBUG :  Cluster identified C Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
25.514 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ] [33m0[39m
25.514 : DEBUG :  Extracting node a Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.514 : DEBUG :  Not a cluster a [33m0[39m
25.514 : DEBUG :  Extracting node b Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.514 : DEBUG :  Not a cluster b [33m0[39m
25.514 : DEBUG :  Extracting node c Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
25.514 : WARN :  Cluster identified A  Replacement id in edges:  a
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
25.514 : DEBUG :  Not a cluster c [33m0[39m
25.514 : DEBUG :  Extracting node A Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.514 : INFO :  cp  a  to  A  with parent  A
25.514 : WARN :  Cluster identified B  Replacement id in edges:  b
25.514 : INFO :  In copy  A root A data [90mundefined[39m A
25.514 : WARN :  Cluster identified C  Replacement id in edges:  c
25.514 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.514 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
25.514 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.514 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.514 : INFO :  Edge data { data: [32m'link1'[39m } A
25.514 : WARN :  Edge A -> B: {"data":"link1"}
25.514 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
25.514 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.514 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
25.514 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.514 : INFO :  Edge data { data: [32m'link2'[39m } A
25.514 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
25.514 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.514 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
25.514 : DEBUG :  Removing node a
25.514 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
25.514 : WARN :  Fix XXX Map(5) {
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
25.514 : WARN :  Fixing and trying - removing XXX A B 1
25.514 : WARN :  Fix Replacing with XXX A B 1
25.514 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
25.514 : WARN :  Edge A -> C: {"data":"link2"}
25.514 : WARN :  Fix XXX Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
25.514 : WARN :  Fixing and trying - removing XXX A C 2
25.514 : WARN :  Fix Replacing with XXX A C 2
25.514 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.514 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.514 : DEBUG :  Extracting node B Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
    { v: [32m'C'[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  ],
25.514 : INFO :  cp  b  to  B  with parent  B
25.514 : INFO :  In copy  B root B data [90mundefined[39m B
25.514 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  edges: [
25.514 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
25.514 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.514 : INFO :  Edge data { data: [32m'link1'[39m } B
25.514 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
25.514 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.514 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
  ],
25.514 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.514 : INFO :  Edge data { data: [32m'link2'[39m } B
} [90mundefined[39m
25.514 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
25.514 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
25.514 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
25.514 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.514 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
25.514 : DEBUG :  Removing node b
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
25.514 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'A'[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  ],
  edges: [
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.514 : DEBUG :  Extracting node C Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.514 : INFO :  cp  c  to  C  with parent  C
25.514 : INFO :  In copy  C root C data [90mundefined[39m C
25.514 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.514 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.514 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.514 : INFO :  Edge data { data: [32m'link1'[39m } C
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.514 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
}
25.514 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.514 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
25.514 : WARN :  Copying children of  A root A data [90mundefined[39m A
25.514 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.514 : INFO :  Edge data { data: [32m'link2'[39m } C
25.514 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
25.514 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
25.514 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.514 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
25.514 : WARN :  New graph after copy node: ( A ) {
25.514 : DEBUG :  Removing node c
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.514 : DEBUG :  Old graph after copy {
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  edges: [],
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.514 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
25.514 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
}
25.514 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
25.514 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m

25.514 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.514 : WARN :  Copying children of  B root B data [90mundefined[39m B
25.514 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
25.514 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.514 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
25.514 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.514 : WARN :  Copying children of  C root C data [90mundefined[39m C
25.514 : WARN :  Copying (nodes) clusterId C nodes [ [32m'c'[39m ]
25.514 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.514 : WARN :  New list of nodes [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
25.514 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.514 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.514 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.514 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.514 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.514 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
25.524 : DEBUG :  Opting in, graph
25.524 : DEBUG :  Cluster identified C Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
25.524 : DEBUG :  Cluster identified D Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
25.524 : WARN :  Cluster identified C  Replacement id in edges:  d
25.524 : WARN :  Cluster identified D  Replacement id in edges:  d
25.524 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.524 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
25.524 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
25.524 : WARN :  Old graph before copy {
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  [32m'D'[39m => [ [32m'd'[39m ]
25.524 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
}
25.524 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
25.524 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
25.524 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
25.524 : WARN :  Setting parent d D
25.524 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.524 : DEBUG :  Not a cluster  d Map(6) {
}
25.524 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.524 : WARN :  New list of nodes [ [32m'C'[39m ]
25.524 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
  [32m'C1'[39m => [ [32m'a'[39m ],
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
    _nodeCount: [33m2[39m
  }
}
25.524 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
25.524 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
  [32m'D'[39m => [ [32m'd'[39m ]
}
25.524 : WARN :  Old graph before copy {
25.524 : DEBUG :  Nodes =  [ [32m'C'[39m, [32m'D'[39m, [32m'd'[39m ] [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.524 : DEBUG :  Extracting node C Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
25.524 : INFO :  cp  d  to  C  with parent  D
25.524 : DEBUG :  Setting parent d D
25.524 : DEBUG :  Copying Edges []
25.524 : DEBUG :  Removing node d
  nodes: [
25.524 : INFO :  cp  D  to  C  with parent  D
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
25.524 : INFO :  In copy  D root C data { data: [33m2[39m } C
25.524 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
    { v: [32m'D'[39m, value: [36m[Object][39m }
25.524 : DEBUG :  Copying Edges []
25.524 : DEBUG :  Removing node D
25.524 : DEBUG :  Removing node D
25.524 : DEBUG :  Old graph after copy {
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.524 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
25.524 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
25.524 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.524 : WARN :  New list of nodes [ [32m'D'[39m ]
  nodes: [ { v: [32m'C'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.524 : WARN :   Now next level D {
}
  clusterNode: [33mtrue[39m,
25.524 : DEBUG :  Extracting node D Map(6) {
  id: [32m'D'[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  clusterData: { data: [33m2[39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  label: [90mundefined[39m,
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  graph: Graph {
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
    _isDirected: [33mtrue[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _isMultigraph: [33mtrue[39m,
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    _isCompound: [33mtrue[39m,
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
25.524 : DEBUG :  Map(6) {
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
}
25.524 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
25.524 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.524 : DEBUG :  Not a cluster d [33m0[39m
25.524 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
25.524 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
25.524 : DEBUG :  Not a cluster d [33m1[39m
25.524 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
25.524 : INFO :  cp  d  to  D  with parent  D
25.524 : INFO :  In copy  D root D data { data: [33m2[39m } D
25.524 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.524 : DEBUG :  Copying Edges []
25.524 : DEBUG :  Removing node d
25.524 : DEBUG :  Old graph after copy {
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
25.522 : WARN :  Cluster identified A  Replacement id in edges:  a
25.522 : WARN :  Cluster identified B  Replacement id in edges:  b
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.524 : DEBUG :  Done, no node has children [ [32m'd'[39m ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
25.522 : DEBUG :  Opting in, graph
25.522 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
25.522 : WARN :  Cluster identified C  Replacement id in edges:  c
25.522 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
25.522 : WARN :  Edge A -> B: {"data":"link1"}
25.522 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
25.522 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
25.522 : DEBUG :  Cluster identified A { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
25.522 : DEBUG :  Cluster identified B { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
25.522 : DEBUG :  Cluster identified C { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
25.522 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ] [33m0[39m
25.522 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
25.522 : WARN :  Fix XXX {
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.522 : DEBUG :  Not a cluster a [33m0[39m
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
25.522 : WARN :  Fixing and trixing - removing XXX A B 1
25.522 : WARN :  Fix Replacing with XXX A B 1
25.522 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
25.522 : WARN :  Edge A -> C: {"data":"link2"}
25.522 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
25.522 : DEBUG :  Extracting node b {
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
25.522 : WARN :  Fixing and trixing - removing XXX A C 2
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
25.522 : WARN :  Fix Replacing with XXX A C 2
25.522 : WARN :  Adjusted Graph {
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.522 : DEBUG :  Not a cluster b [33m0[39m
25.522 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
25.522 : DEBUG :  Not a cluster c [33m0[39m
25.522 : DEBUG :  Extracting node A {
  ],
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
}
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
25.522 : WARN :  extractor -  [33m0[39m {
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.522 : INFO :  cp  a  to  A  with parent  A
25.522 : INFO :  In copy  A root A data [90mundefined[39m A
  nodes: [
25.522 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
25.522 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.522 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
25.522 : INFO :  Edge data { data: [32m'link1'[39m } A
  ],
25.522 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.522 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
25.522 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
25.522 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    { v: [32m'C'[39m }
25.522 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.522 : WARN :  Copying children of  A root A data [90mundefined[39m A
25.522 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
25.522 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.522 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.522 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
25.522 : WARN :  Old graph before copy {
25.522 : INFO :  Edge data { data: [32m'link2'[39m } A
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
25.522 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.522 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.522 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
25.522 : DEBUG :  Removing node a
25.522 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
25.522 : WARN :  Copying children of  B root B data [90mundefined[39m B
25.522 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
25.522 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.522 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
25.522 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.522 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.522 : INFO :  cp  b  to  B  with parent  B
25.522 : INFO :  In copy  B root B data [90mundefined[39m B
25.522 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.522 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.522 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.522 : INFO :  Edge data { data: [32m'link1'[39m } B
25.522 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
25.522 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.522 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
25.522 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.522 : INFO :  Edge data { data: [32m'link2'[39m } B
25.522 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
25.522 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.522 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
25.522 : DEBUG :  Removing node b
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.522 : WARN :  Copying children of  C root C data [90mundefined[39m C
25.522 : WARN :  Copying (nodes) clusterId C nodes [ [32m'c'[39m ]
25.522 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.522 : WARN :  New list of nodes [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
25.522 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
25.522 : WARN :   Now next level A {
  ],
  clusterNode: [33mtrue[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  id: [32m'A'[39m,
25.522 : DEBUG :  Extracting node C {
  clusterData: [90mundefined[39m,
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.522 : INFO :  cp  c  to  C  with parent  C
25.522 : INFO :  In copy  C root C data [90mundefined[39m C
25.522 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.522 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.522 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.522 : INFO :  Edge data { data: [32m'link1'[39m } C
  labelText: [90mundefined[39m,
25.522 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
  graph: Graph {
25.522 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.522 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
    _isDirected: [33mtrue[39m,
25.522 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
    _isMultigraph: [33mtrue[39m,
25.522 : INFO :  Edge data { data: [32m'link2'[39m } C
25.522 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
25.522 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.522 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
25.522 : DEBUG :  Removing node c
25.522 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    _isCompound: [33mtrue[39m,
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.522 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
25.522 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
25.522 : DEBUG :  Done, no node has children [ [32m'c'[39m ]

    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.522 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.522 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.522 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.522 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.522 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
25.536 : DEBUG :  Opting in, graph
25.536 : DEBUG :  Cluster identified C {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
25.536 : DEBUG :  Cluster identified D {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
25.536 : WARN :  Cluster identified C  Replacement id in edges:  d
25.536 : WARN :  Cluster identified D  Replacement id in edges:  d
25.536 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
}
25.536 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
  D: [ [32m'd'[39m ]
}
25.536 : DEBUG :  Not a cluster  d {
25.536 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
25.536 : WARN :  Old graph before copy {
  C1: [ [32m'a'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  C2: [ [32m'b'[39m ],
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
  A: [ [32m'a'[39m ],
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  B: [ [32m'b'[39m ],
  ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  D: [ [32m'd'[39m ]
}
25.536 : DEBUG :  Nodes =  [ [32m'C'[39m, [32m'D'[39m, [32m'd'[39m ] [33m0[39m
}
25.536 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
25.536 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
25.536 : INFO :  cp  d  to  C  with parent  D
25.536 : DEBUG :  Setting parent d D
25.536 : DEBUG :  Copying Edges []
25.536 : DEBUG :  Removing node d
25.536 : INFO :  cp  D  to  C  with parent  D
25.536 : INFO :  In copy  D root C data { data: [33m2[39m } C
25.536 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
25.536 : DEBUG :  Copying Edges []
25.536 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
25.536 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
25.536 : DEBUG :  Removing node D
25.536 : DEBUG :  Removing node D
25.536 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
25.536 : WARN :  Setting parent d D
25.536 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.536 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.536 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.536 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.536 : WARN :  New list of nodes [ [32m'C'[39m ]
25.536 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
25.536 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
25.536 : DEBUG :  Extracting node d {
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.536 : DEBUG :  Not a cluster d [33m0[39m
25.536 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
25.536 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _out: { d: {}, D: {} },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
    _sucs: { d: {}, D: {} },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
25.536 : DEBUG :  Not a cluster d [33m1[39m
25.536 : DEBUG :  Extracting node D {
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
25.536 : INFO :  cp  d  to  D  with parent  D
25.536 : INFO :  In copy  D root D data { data: [33m2[39m } D
25.536 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.536 : DEBUG :  Copying Edges []
25.536 : DEBUG :  Removing node d
25.536 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
25.536 : DEBUG :  Old graph after copy {
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
25.536 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
25.536 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.536 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
25.536 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
25.536 : WARN :  New graph after copy node: ( D ) {
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.536 : DEBUG :  Done, no node has children [ [32m'd'[39m ]

  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.536 : WARN :  New list of nodes [ [32m'D'[39m ]
25.536 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.536 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
25.531 : INFO :  Graph before { data: [33m2[39m }
25.531 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : DEBUG :  Opting in, graph
25.531 : DEBUG :  Cluster identified C Map(6) {
} [90mundefined[39m

  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
25.531 : DEBUG :  Cluster identified D Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
25.531 : DEBUG :  Not a cluster  d Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
25.531 : DEBUG :  Cluster identified B Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
25.531 : DEBUG :  Not a cluster  b Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
25.531 : DEBUG :  Cluster identified A Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
25.531 : DEBUG :  Not a cluster  a Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
25.531 : DEBUG :  Nodes =  [
  [32m'C'[39m, [32m'D'[39m, [32m'd'[39m,
  [32m'B'[39m, [32m'b'[39m, [32m'A'[39m,
  [32m'a'[39m
] [33m0[39m
25.531 : DEBUG :  Extracting node C Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
25.531 : INFO :  cp  d  to  C  with parent  D
25.531 : DEBUG :  Setting parent d D
25.531 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.531 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.531 : INFO :  Edge data { data: [32m'link1'[39m } C
25.531 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
25.531 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.531 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
25.531 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.531 : INFO :  Edge data { data: [32m'link2'[39m } C
25.531 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
25.531 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.531 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
25.531 : DEBUG :  Removing node d
25.531 : INFO :  cp  D  to  C  with parent  D
25.531 : INFO :  In copy  D root C data { data: [33m2[39m } C
25.531 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
25.531 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.531 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.531 : INFO :  Edge data { data: [32m'link1'[39m } C
25.531 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
25.531 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.531 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
25.531 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.531 : INFO :  Edge data { data: [32m'link2'[39m } C
25.531 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
25.531 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.531 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
25.531 : DEBUG :  Removing node D
25.531 : DEBUG :  Removing node D
25.531 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.531 : DEBUG :  Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
25.531 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.531 : DEBUG :  Not a cluster d [33m0[39m
25.531 : DEBUG :  Extracting node B Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
25.531 : INFO :  cp  b  to  B  with parent  B
25.531 : INFO :  In copy  B root B data { data: [33m4[39m } B
25.531 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.531 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.531 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.531 : INFO :  Edge data { data: [32m'link1'[39m } B
25.531 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
25.531 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.531 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
25.531 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.531 : INFO :  Edge data { data: [32m'link2'[39m } B
25.531 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
25.531 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.531 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
25.531 : DEBUG :  Removing node b
25.531 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : DEBUG :  Extracting node b Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.531 : DEBUG :  Not a cluster b [33m0[39m
25.531 : DEBUG :  Extracting node A Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m6[39m } [90mundefined[39m  Depth  [33m0[39m
25.531 : INFO :  cp  a  to  A  with parent  A
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
25.531 : WARN :  Cluster identified C  Replacement id in edges:  d
25.531 : WARN :  Cluster identified D  Replacement id in edges:  d
25.531 : WARN :  Cluster identified B  Replacement id in edges:  b
25.531 : WARN :  Cluster identified A  Replacement id in edges:  a
25.531 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
25.531 : WARN :  Edge A -> B: {"data":"link1"}
25.531 : WARN :  Fix XXX Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }
25.531 : INFO :  In copy  A root A data { data: [33m6[39m } A
25.531 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.531 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.531 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.531 : INFO :  Edge data { data: [32m'link1'[39m } A
25.531 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
25.531 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.531 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
25.531 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.531 : INFO :  Edge data { data: [32m'link2'[39m } A
25.531 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
25.531 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.531 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
25.531 : WARN :  Fixing and trying - removing XXX A B 1
25.531 : WARN :  Fix Replacing with XXX A B 1
25.531 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
25.531 : WARN :  Edge A -> C: {"data":"link2"}
25.531 : WARN :  Fix XXX Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'D'[39m, clusterData: { data: [33m1[39m } }
25.531 : WARN :  Fixing and trying - removing XXX A C 2
25.531 : WARN :  Fix Replacing with XXX A C 2
25.531 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
25.531 : DEBUG :  Removing node a
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
25.531 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : DEBUG :  Extracting node a Map(6) {
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.531 : DEBUG :  Not a cluster a [33m0[39m
25.531 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
25.531 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
25.531 : DEBUG :  Not a cluster d [33m1[39m
25.531 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
25.531 : INFO :  cp  d  to  D  with parent  D
25.531 : INFO :  In copy  D root D data { data: [33m2[39m } D
25.531 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.531 : DEBUG :  Copying Edges []
25.531 : DEBUG :  Removing node d
25.531 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.531 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
25.531 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
25.531 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
25.531 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
25.531 : INFO :  A [ [32m'a'[39m ]

  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
25.531 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
25.531 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
25.531 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
25.531 : WARN :  Setting parent d D
25.531 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.531 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
25.531 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : WARN :  Copying children of  B root B data { data: [33m4[39m } B
25.531 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
25.531 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
25.531 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : WARN :  Copying children of  A root A data { data: [33m6[39m } A
25.531 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
25.531 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : WARN :  New list of nodes [ [32m'C'[39m, [32m'B'[39m, [32m'A'[39m ]
25.531 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
25.531 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
25.531 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
25.531 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
25.531 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
25.531 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.531 : WARN :  New list of nodes [ [32m'D'[39m ]
25.531 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.531 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.531 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.531 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.531 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: { data: [33m6[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
25.531 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
25.546 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.546 : DEBUG :  Opting in, graph
25.546 : DEBUG :  Not a cluster  a Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
25.546 : DEBUG :  Cluster identified b Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
25.546 : DEBUG :  Not a cluster  c Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
25.546 : DEBUG :  Not a cluster  d Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
25.546 : DEBUG :  Not a cluster  e Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
25.546 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ] [33m0[39m
25.546 : DEBUG :  Extracting node a Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.546 : DEBUG :  Not a cluster a [33m0[39m
25.546 : DEBUG :  Extracting node b Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.546 : INFO :  cp  c  to  b  with parent  b
25.546 : INFO :  In copy  b root b data { data: [33m2[39m } b
25.546 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.546 : DEBUG :  Copying Edges [
  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m },
  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m },
  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
]
25.546 : INFO :  Edge { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
25.546 : INFO :  Edge data { data: [32m'link2'[39m } b
25.546 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.546 : INFO :  Edge is  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
25.546 : INFO :  Copying as  c d { data: [32m'link2'[39m } 2
25.546 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
25.546 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
25.546 : INFO :  Edge data { data: [32m'link2'[39m } b
25.546 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.546 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
25.546 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
25.546 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
25.546 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.546 : INFO :  Edge data { data: [32m'link1'[39m } b
25.546 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.546 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.546 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
25.546 : DEBUG :  Removing node c
25.546 : INFO :  cp  d  to  b  with parent  b
25.546 : INFO :  In copy  b root b data { data: [33m2[39m } b
25.546 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.546 : DEBUG :  Copying Edges [ { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }, { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
25.546 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
25.546 : INFO :  Edge data { data: [32m'link2'[39m } b
25.546 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.546 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
25.546 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
25.546 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
25.546 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.546 : INFO :  Edge data { data: [32m'link1'[39m } b
25.546 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.546 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.546 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
25.546 : DEBUG :  Removing node d
25.546 : INFO :  cp  e  to  b  with parent  b
25.546 : INFO :  In copy  b root b data { data: [33m2[39m } b
25.546 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.546 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
25.546 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.546 : INFO :  Edge data { data: [32m'link1'[39m } b
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
25.546 : WARN :  Cluster identified b  Replacement id in edges:  c
25.546 : WARN :  Edge a -> b: {"v":"a","w":"b","name":"1"}
25.546 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.546 : WARN :  Edge a -> b: {"data":"link1"}
25.546 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.546 : WARN :  Fix XXX Map(7) {
25.546 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
25.546 : DEBUG :  Removing node e
25.546 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m }, { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.546 : DEBUG :  Extracting node c Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: a b Translating:  [90mundefined[39m  ---  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
25.546 : WARN :  Fixing and trying - removing XXX a b 1
25.546 : WARN :  Fix Replacing with XXX a b 1
25.546 : WARN :  Edge c -> d: {"v":"c","w":"d","name":"2"}
25.546 : WARN :  Edge c -> d: {"data":"link2"}
25.546 : WARN :  Fix XXX Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: c d Translating:  [90mundefined[39m  ---  [90mundefined[39m
25.546 : WARN :  Edge d -> e: {"v":"d","w":"e","name":"2"}
25.546 : WARN :  Edge d -> e: {"data":"link2"}
25.546 : WARN :  Fix XXX Map(7) {
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.546 : DEBUG :  Not a cluster c [33m0[39m
25.546 : DEBUG :  Extracting node d Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: d e Translating:  [90mundefined[39m  ---  [90mundefined[39m
25.546 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.546 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.546 : WARN :  Cluster without external connections, without a parent and with children b [33m0[39m
25.546 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.546 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.546 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.546 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.546 : WARN :  New list of nodes [ [32m'a'[39m, [32m'b'[39m ]
25.546 : WARN :   Now next level a { data: [33m1[39m }
25.546 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
25.546 : DEBUG :  Not a cluster d [33m0[39m
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
25.546 : DEBUG :  Extracting node e Map(7) {
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _nodes: { c: [36m[Object][39m, d: [36m[Object][39m, e: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m, d: [32m'\x00'[39m, e: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, d: {}, e: {} },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    _in: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    _preds: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _out: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _sucs: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
    _edgeObjs: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
    _edgeLabels: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    _nodeCount: [33m3[39m,
25.546 : DEBUG :  Not a cluster e [33m0[39m
    _edgeCount: [33m2[39m
25.546 : DEBUG :  Done, no node has children [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  }
25.546 : INFO :  Graph after {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.546 : WARN :  extractor -  [33m1[39m {
  nodes: [
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m }
    { v: [32m'c'[39m, value: [36m[Object][39m },
  ],
    { v: [32m'd'[39m, value: [36m[Object][39m },
  edges: [
    { v: [32m'e'[39m, value: [36m[Object][39m }
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
25.555 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  edges: [
}
25.555 : DEBUG :  Opting in, graph
25.555 : DEBUG :  Cluster identified a Map(9) {
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  [32m'C1'[39m => [ [32m'a'[39m ],
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  [32m'C2'[39m => [ [32m'b'[39m ],
  ],
  [32m'A'[39m => [ [32m'a'[39m ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

  [32m'B'[39m => [ [32m'b'[39m ],
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
25.555 : WARN :  Cluster identified a  Replacement id in edges:  e
  [32m'D'[39m => [ [32m'd'[39m ],
25.555 : WARN :  Cluster identified b  Replacement id in edges:  e
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
25.555 : WARN :  Cluster identified c  Replacement id in edges:  e
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
25.555 : WARN :  Adjusted Graph {
  [32m'c'[39m => [ [32m'e'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.555 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.555 : WARN :  Cluster without external connections, without a parent and with children a [33m0[39m
25.555 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
}
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
25.555 : DEBUG :  Cluster identified b Map(9) {
  ],
  [32m'C1'[39m => [ [32m'a'[39m ],
  edges: [],
  [32m'C2'[39m => [ [32m'b'[39m ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'A'[39m => [ [32m'a'[39m ],
}
  [32m'B'[39m => [ [32m'b'[39m ],
25.555 : WARN :  Copying children of  a root a data { data: [33m1[39m } a
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
25.555 : WARN :  Copying (nodes) clusterId a nodes [ [32m'b'[39m ]
  [32m'D'[39m => [ [32m'd'[39m ],
25.555 : WARN :  Copying children of  b root a data { data: [33m2[39m } a
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
25.555 : DEBUG :  Cluster identified c Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
25.555 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'b'[39m ]
}
25.555 : WARN :  Copying children of  c root a data { data: [33m3[39m } a
25.555 : DEBUG :  Not a cluster  e Map(9) {
25.555 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m, [32m'c'[39m ]
  [32m'C1'[39m => [ [32m'a'[39m ],
25.555 : WARN :  Setting parent e c
  [32m'C2'[39m => [ [32m'b'[39m ],
25.555 : WARN :  Setting parent c b
  [32m'A'[39m => [ [32m'a'[39m ],
25.555 : WARN :  New graph after copy node: ( a ) {
  [32m'B'[39m => [ [32m'b'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  nodes: [
  [32m'D'[39m => [ [32m'd'[39m ],
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.555 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.555 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.555 : WARN :  New list of nodes [ [32m'a'[39m ]
25.555 : WARN :   Now next level a {
  clusterNode: [33mtrue[39m,
  id: [32m'a'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  graph: Graph {
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
    _isDirected: [33mtrue[39m,
25.555 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ] [33m0[39m
    _isMultigraph: [33mtrue[39m,
25.555 : DEBUG :  Extracting node a Map(9) {
    _isCompound: [33mtrue[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.555 : INFO :  cp  e  to  a  with parent  c
25.555 : DEBUG :  Setting parent e c
25.555 : DEBUG :  Copying Edges []
25.555 : DEBUG :  Removing node e
25.555 : INFO :  cp  c  to  a  with parent  c
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
25.555 : INFO :  In copy  c root a data { data: [33m3[39m } a
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
25.555 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
    _nodes: { e: [36m[Object][39m, c: [36m[Object][39m, b: [36m[Object][39m },
25.555 : DEBUG :  Copying Edges []
    _parent: { e: [32m'c'[39m, c: [32m'b'[39m, b: [32m'\x00'[39m },
25.555 : DEBUG :  Removing node c
    _children: { [32m'\x00'[39m: [36m[Object][39m, e: {}, c: [36m[Object][39m, b: [36m[Object][39m },
25.555 : DEBUG :  Removing node c
    _in: { e: {}, c: {}, b: {} },
25.555 : INFO :  cp  b  to  a  with parent  b
    _preds: { e: {}, c: {}, b: {} },
25.555 : INFO :  In copy  b root a data { data: [33m2[39m } a
25.555 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
    _out: { e: {}, c: {}, b: {} },
25.555 : DEBUG :  Copying Edges []
    _sucs: { e: {}, c: {}, b: {} },
25.555 : DEBUG :  Removing node b
25.555 : DEBUG :  Removing node b
25.555 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.555 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
    _edgeObjs: {},
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _edgeLabels: {},
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.555 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    _nodeCount: [33m3[39m
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  }
}
}
25.555 : DEBUG :  Extracting node c Map(9) {
25.555 : WARN :  extractor -  [33m1[39m {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.555 : WARN :  Cluster without external connections, without a parent and with children c [33m1[39m
25.555 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  ],
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  edges: [],
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.555 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
}
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
25.555 : WARN :  Copying children of  c root c data { data: [33m3[39m } c
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
25.555 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m ]
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
25.555 : WARN :  New graph after copy node: ( c ) {
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.555 : DEBUG :  Extracting node e Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  nodes: [ { v: [32m'e'[39m, value: [36m[Object][39m } ],
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.555 : DEBUG :  Not a cluster e [33m0[39m
  edges: [],
25.555 : DEBUG :  Nodes =  [ [32m'e'[39m, [32m'c'[39m, [32m'b'[39m ] [33m1[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.555 : DEBUG :  Extracting node e Map(9) {
}
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
25.555 : WARN :  Cluster without external connections, without a parent and with children b [33m1[39m
25.555 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  nodes: [
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  ],
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  edges: [],
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.555 : DEBUG :  Not a cluster e [33m1[39m
25.555 : DEBUG :  Extracting node c Map(9) {
}
25.555 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
25.555 : INFO :  cp  e  to  c  with parent  c
25.555 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m ]
25.555 : WARN :  New graph after copy node: ( b ) {
25.555 : INFO :  In copy  c root c data { data: [33m3[39m } c
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.555 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
25.555 : DEBUG :  Copying Edges []
  edges: [],
25.555 : DEBUG :  Removing node e
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.555 : DEBUG :  Old graph after copy {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.555 : WARN :  New list of nodes [ [32m'b'[39m ]
  nodes: [
25.555 : WARN :   Now next level b {
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  clusterNode: [33mtrue[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m }
  id: [32m'b'[39m,
  ],
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
    _edgeObjs: {},
25.555 : DEBUG :  Extracting node b Map(9) {
    _edgeLabels: {},
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _nodeCount: [33m1[39m
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  }
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
}
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
25.555 : WARN :  extractor -  [33m2[39m {
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
25.555 : INFO :  cp  c  to  b  with parent  b
25.555 : INFO :  In copy  b root b data { data: [33m2[39m } b
25.555 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.555 : DEBUG :  Copying Edges []
25.555 : DEBUG :  Removing node c
25.555 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
}
25.555 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
25.555 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
25.543 : INFO :  Graph before { data: [33m2[39m }
25.543 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  edges: [],
  nodes: [
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'C'[39m, value: [36m[Object][39m },
} [90mundefined[39m
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },

    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
    { v: [32m'A'[39m, value: [36m[Object][39m },
25.543 : WARN :  Cluster identified C  Replacement id in edges:  d
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
25.543 : WARN :  Cluster identified D  Replacement id in edges:  d
  ],
25.543 : WARN :  Cluster identified B  Replacement id in edges:  b
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
25.543 : WARN :  Cluster identified A  Replacement id in edges:  a
  ],
25.543 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.543 : WARN :  Edge A -> B: {"data":"link1"}
}
25.543 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
25.543 : DEBUG :  Opting in, graph
25.543 : DEBUG :  Cluster identified C {
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  C1: [ [32m'a'[39m ],
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  C2: [ [32m'b'[39m ],
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  A: [ [32m'a'[39m ],
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  B: [ [32m'b'[39m ],
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  C: [ [32m'D'[39m, [32m'd'[39m ],
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }
  D: [ [32m'd'[39m ]
25.543 : WARN :  Fixing and trixing - removing XXX A B 1
}
25.543 : WARN :  Fix Replacing with XXX A B 1
25.543 : DEBUG :  Cluster identified D {
25.543 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
25.543 : DEBUG :  Not a cluster  d {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
25.543 : WARN :  Edge A -> C: {"data":"link2"}
25.543 : DEBUG :  Cluster identified B {
25.543 : WARN :  Fix XXX {
  C1: [ [32m'a'[39m ],
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: [ [32m'b'[39m ],
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: [ [32m'a'[39m ],
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: [ [32m'b'[39m ],
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: [ [32m'D'[39m, [32m'd'[39m ],
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: [ [32m'd'[39m ]
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'D'[39m, clusterData: { data: [33m1[39m } }
25.543 : DEBUG :  Not a cluster  b {
25.543 : WARN :  Fixing and trixing - removing XXX A C 2
  C1: [ [32m'a'[39m ],
25.543 : WARN :  Fix Replacing with XXX A C 2
  C2: [ [32m'b'[39m ],
25.543 : WARN :  Adjusted Graph {
  A: [ [32m'a'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  B: [ [32m'b'[39m ],
  nodes: [
  C: [ [32m'D'[39m, [32m'd'[39m ],
    { v: [32m'C'[39m, value: [36m[Object][39m },
  D: [ [32m'd'[39m ]
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
}
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.543 : DEBUG :  Cluster identified A {
  C1: [ [32m'a'[39m ],
}
  C2: [ [32m'b'[39m ],
25.543 : WARN :  extractor -  [33m0[39m {
  A: [ [32m'a'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  B: [ [32m'b'[39m ],
  nodes: [
  C: [ [32m'D'[39m, [32m'd'[39m ],
    { v: [32m'C'[39m, value: [36m[Object][39m },
  D: [ [32m'd'[39m ]
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
}
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
25.543 : DEBUG :  Not a cluster  a {
    { v: [32m'B'[39m, value: [36m[Object][39m },
  C1: [ [32m'a'[39m ],
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
25.543 : DEBUG :  Nodes =  [
  [32m'C'[39m, [32m'D'[39m, [32m'd'[39m,
  [32m'B'[39m, [32m'b'[39m, [32m'A'[39m,
  [32m'a'[39m
] [33m0[39m
25.543 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'A'[39m, value: [36m[Object][39m },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  ],
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  edges: [
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
25.543 : INFO :  cp  d  to  C  with parent  D
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
25.543 : DEBUG :  Setting parent d D
25.543 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
  ],
25.543 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
25.543 : INFO :  Edge data { data: [32m'link1'[39m } C
25.543 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
25.543 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
25.543 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.543 : WARN :  Old graph before copy {
25.543 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.543 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.543 : INFO :  Edge data { data: [32m'link2'[39m } C
25.543 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
  nodes: [
25.543 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
    { v: [32m'C'[39m, value: [36m[Object][39m },
25.543 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
25.543 : DEBUG :  Removing node d
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
25.543 : INFO :  cp  D  to  C  with parent  D
    { v: [32m'B'[39m, value: [36m[Object][39m },
25.543 : INFO :  In copy  D root C data { data: [33m2[39m } C
25.543 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.543 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
25.543 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
25.543 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
25.543 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
25.543 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.543 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.543 : INFO :  Edge data { data: [32m'link1'[39m } C
25.543 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
25.543 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.543 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
25.543 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.543 : INFO :  Edge data { data: [32m'link2'[39m } C
25.543 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
25.543 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.543 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
25.543 : WARN :  Setting parent d D
25.543 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.543 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.543 : DEBUG :  Removing node D
25.543 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
25.543 : DEBUG :  Removing node D
25.543 : WARN :  Old graph before copy {
25.543 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  ],
  edges: [
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.543 : WARN :  Copying children of  B root B data { data: [33m4[39m } B
25.543 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
25.543 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
25.543 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
  ],
25.543 : WARN :  Old graph before copy {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
}
  nodes: [
25.543 : DEBUG :  Extracting node D {
    { v: [32m'C'[39m, value: [36m[Object][39m },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'B'[39m, value: [36m[Object][39m },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.543 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.543 : WARN :  Copying children of  A root A data { data: [33m6[39m } A
25.543 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
25.543 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
25.543 : DEBUG :  Extracting node d {
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.543 : WARN :  New list of nodes [ [32m'C'[39m, [32m'B'[39m, [32m'A'[39m ]
25.543 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    _in: { d: {}, D: {} },
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    _preds: { d: {}, D: {} },
25.543 : DEBUG :  Not a cluster d [33m0[39m
    _out: { d: {}, D: {} },
25.543 : DEBUG :  Extracting node B {
    _sucs: { d: {}, D: {} },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
25.543 : INFO :  cp  b  to  B  with parent  B
25.543 : INFO :  In copy  B root B data { data: [33m4[39m } B
25.543 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.543 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
25.543 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    _edgeObjs: {},
    _edgeLabels: {},
25.543 : INFO :  Edge data { data: [32m'link1'[39m } B
25.543 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
25.543 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.543 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
25.543 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.543 : INFO :  Edge data { data: [32m'link2'[39m } B
25.543 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
25.543 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
25.543 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
25.543 : DEBUG :  Removing node b
25.543 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    _nodeCount: [33m2[39m
    { v: [32m'C'[39m, value: [36m[Object][39m },
  }
    { v: [32m'B'[39m, value: [36m[Object][39m },
}
    { v: [32m'A'[39m, value: [36m[Object][39m },
25.543 : WARN :  extractor -  [33m1[39m {
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.543 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  nodes: [
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
25.543 : DEBUG :  Not a cluster b [33m0[39m
    { v: [32m'D'[39m, value: [36m[Object][39m }
25.543 : DEBUG :  Extracting node A {
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
} [ [32m'd'[39m ]
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
25.543 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
25.543 : WARN :  Old graph before copy {
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  nodes: [
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
} [33mtrue[39m [33mtrue[39m { data: [33m6[39m } [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'D'[39m, value: [36m[Object][39m }
25.543 : INFO :  cp  a  to  A  with parent  A
  ],
25.543 : INFO :  In copy  A root A data { data: [33m6[39m } A
  edges: [],
25.543 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.543 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
}
25.543 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.543 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
25.543 : INFO :  Edge data { data: [32m'link1'[39m } A
25.543 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
25.543 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
25.543 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
25.543 : WARN :  New graph after copy node: ( D ) {
25.543 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.543 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
25.543 : INFO :  Edge data { data: [32m'link2'[39m } A
  edges: [],
25.543 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.543 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
}
25.543 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
25.543 : WARN :  New list of nodes [ [32m'D'[39m ]
25.543 : DEBUG :  Removing node a
25.543 : WARN :   Now next level D {
25.543 : DEBUG :  Old graph after copy {
  clusterNode: [33mtrue[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  id: [32m'D'[39m,
  nodes: [
  clusterData: { data: [33m2[39m },
    { v: [32m'C'[39m, value: [36m[Object][39m },
  labelText: [90mundefined[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m },
  graph: Graph {
    { v: [32m'A'[39m, value: [36m[Object][39m }
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
  ],
    _edgeObjs: {},
  edges: [
    _edgeLabels: {},
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    _nodeCount: [33m1[39m
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  }
  ],
}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.543 : WARN :  extractor -  [33m2[39m {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.543 : DEBUG :  Extracting node a {
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  edges: [],
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.543 : WARN :   Now next level B {
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  clusterNode: [33mtrue[39m,
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  id: [32m'B'[39m,
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  clusterData: { data: [33m4[39m },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  labelText: [90mundefined[39m,
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  graph: Graph {
25.543 : DEBUG :  Not a cluster a [33m0[39m
    _isDirected: [33mtrue[39m,
25.543 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
    _isMultigraph: [33mtrue[39m,
25.543 : DEBUG :  Extracting node d {
    _isCompound: [33mtrue[39m,
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    _nodes: { b: [36m[Object][39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _parent: { b: [32m'\x00'[39m },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
25.543 : DEBUG :  Not a cluster d [33m1[39m
25.543 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
25.543 : INFO :  cp  d  to  D  with parent  D
25.543 : INFO :  In copy  D root D data { data: [33m2[39m } D
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
25.543 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    _in: { b: {} },
25.543 : DEBUG :  Copying Edges []
    _preds: { b: {} },
25.543 : DEBUG :  Removing node d
    _out: { b: {} },
25.543 : DEBUG :  Old graph after copy {
    _sucs: { b: {} },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    _edgeObjs: {},
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
    _edgeLabels: {},
  edges: [],
    _nodeCount: [33m1[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  }
}
}
25.543 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
25.543 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
25.543 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
25.543 : INFO :  A [ [32m'a'[39m ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
25.557 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
25.543 : WARN :  extractor -  [33m1[39m {
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  ],
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [
  edges: [],
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
} [90mundefined[39m
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
25.543 : WARN :   Now next level A {
  ],
  clusterNode: [33mtrue[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.557 : DEBUG :  Opting in, graph
25.557 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
25.557 : DEBUG :  Cluster identified b {
  C1: [ [32m'a'[39m ],
  id: [32m'A'[39m,
  C2: [ [32m'b'[39m ],
  clusterData: { data: [33m6[39m },
  A: [ [32m'a'[39m ],
  labelText: [90mundefined[39m,
  B: [ [32m'b'[39m ],
  graph: Graph {
  C: [ [32m'D'[39m, [32m'd'[39m ],
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
  D: [ [32m'd'[39m ],
    _edgeLabels: {},
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
    _nodeCount: [33m1[39m
  }
}
25.543 : WARN :  extractor -  [33m1[39m {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
25.557 : DEBUG :  Not a cluster  c {
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
25.557 : DEBUG :  Not a cluster  d {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  edges: [],
  B: [ [32m'b'[39m ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C: [ [32m'D'[39m, [32m'd'[39m ],
} [90mundefined[39m
  D: [ [32m'd'[39m ],

  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
25.557 : DEBUG :  Not a cluster  e {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
25.557 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ] [33m0[39m
25.557 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.557 : DEBUG :  Not a cluster a [33m0[39m
25.557 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
25.557 : INFO :  cp  c  to  b  with parent  b
25.557 : INFO :  In copy  b root b data { data: [33m2[39m } b
25.557 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.557 : DEBUG :  Copying Edges [
  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m },
  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m },
  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
]
25.557 : INFO :  Edge { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
25.557 : INFO :  Edge data { data: [32m'link2'[39m } b
25.557 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.557 : INFO :  Edge is  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
25.557 : INFO :  Copying as  c d { data: [32m'link2'[39m } 2
25.557 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
25.557 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
25.557 : INFO :  Edge data { data: [32m'link2'[39m } b
25.557 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.557 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
25.557 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
25.557 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
25.557 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.557 : INFO :  Edge data { data: [32m'link1'[39m } b
25.557 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.557 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.557 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
25.557 : DEBUG :  Removing node c
25.557 : INFO :  cp  d  to  b  with parent  b
25.557 : INFO :  In copy  b root b data { data: [33m2[39m } b
25.557 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.557 : DEBUG :  Copying Edges [ { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }, { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
25.557 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
25.557 : INFO :  Edge data { data: [32m'link2'[39m } b
25.557 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.557 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
25.557 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
25.557 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
25.557 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.557 : INFO :  Edge data { data: [32m'link1'[39m } b
25.557 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.557 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.557 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
25.557 : DEBUG :  Removing node d
25.557 : INFO :  cp  e  to  b  with parent  b
25.557 : INFO :  In copy  b root b data { data: [33m2[39m } b
25.557 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.557 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
25.557 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.557 : INFO :  Edge data { data: [32m'link1'[39m } b
25.557 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.557 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
25.557 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
25.557 : DEBUG :  Removing node e
25.557 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m }, { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.557 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.557 : DEBUG :  Not a cluster c [33m0[39m
25.557 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.557 : DEBUG :  Not a cluster d [33m0[39m
25.557 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.557 : DEBUG :  Not a cluster e [33m0[39m
25.557 : DEBUG :  Done, no node has children [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.557 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
25.560 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.560 : DEBUG :  Opting in, graph
25.560 : DEBUG :  Cluster identified A Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
25.560 : DEBUG :  Cluster identified B Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
25.560 : DEBUG :  Not a cluster  b Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
25.560 : DEBUG :  Not a cluster  c Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
25.560 : DEBUG :  Not a cluster  a Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
25.560 : DEBUG :  Nodes =  [ [32m'A'[39m, [32m'B'[39m, [32m'b'[39m, [32m'c'[39m, [32m'a'[39m ] [33m0[39m
25.560 : DEBUG :  Extracting node A Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m0[39m
25.560 : INFO :  cp  c  to  A  with parent  B
25.560 : DEBUG :  Setting parent c B
25.560 : DEBUG :  Copying Edges [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
25.560 : INFO :  Edge { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
25.560 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} A
25.560 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
25.560 : INFO :  Edge is  { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
25.560 : INFO :  Copying as  b c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} 1
25.560 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
25.560 : INFO :  Edge { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
25.560 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
25.560 : WARN :  Cluster identified A  Replacement id in edges:  c
25.560 : WARN :  Cluster identified B  Replacement id in edges:  c
25.560 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }  leaves cluster  B
25.560 : WARN :  Descendants of XXX  B :  [ [32m'c'[39m ]
25.560 : WARN :  Edge b -> B: {"v":"b","w":"B","name":"1"}
25.560 : WARN :  Edge b -> B: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-b-B","cssClasses":"flowchart-link LS-b LE-B"}
25.560 : WARN :  Fix XXX Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  labelStyle: [32m''[39m,
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  arrowheadStyle: [32m'fill: #333'[39m,
  [32m'A'[39m => {
    id: [32m'c'[39m,
  labelpos: [32m'c'[39m,
    clusterData: {
  labelType: [32m'text'[39m,
      labelStyle: [32m''[39m,
  label: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
  id: [32m'L-a-c'[39m,
      id: [32m'A'[39m,
  cssClasses: [32m'flowchart-link LS-a LE-c'[39m
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
} A
      class: [32m'default'[39m,
25.560 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
      style: [32m''[39m,
25.560 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
      id: [32m'B'[39m,
25.560 : INFO :  Copying as  a c {
      width: [33m500[39m,
  minlen: [33m1[39m,
      type: [32m'group'[39m,
  arrowhead: [32m'normal'[39m,
      padding: [33m15[39m
  arrowTypeStart: [32m'arrow_open'[39m,
    },
  arrowTypeEnd: [32m'arrow_point'[39m,
    externalConnections: [33mtrue[39m
  },
  thickness: [32m'normal'[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  pattern: [32m'solid'[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: b B Translating:  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }  ---  {
  id: [32m'c'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    labelText: [32m'B'[39m,
    rx: [33m0[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  cssClasses: [32m'flowchart-link LS-a LE-c'[39m
} 2
25.560 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
    ry: [33m0[39m,
    class: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'B'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
    padding: [33m15[39m
  },
  externalConnections: [33mtrue[39m
  arrowTypeEnd: [32m'arrow_point'[39m,
}
  thickness: [32m'normal'[39m,
25.560 : WARN :  Fixing and trying - removing XXX b B 1
  pattern: [32m'solid'[39m,
25.560 : WARN :  Fix Replacing with XXX b c 1
  style: [32m'fill:none'[39m,
25.560 : WARN :  Edge a -> c: {"v":"a","w":"c","name":"2"}
  labelStyle: [32m''[39m,
25.560 : WARN :  Edge a -> c: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-a-c","cssClasses":"flowchart-link LS-a LE-c"}
25.560 : WARN :  Fix XXX Map(9) {
  arrowheadStyle: [32m'fill: #333'[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
  labelpos: [32m'c'[39m,
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  labelType: [32m'text'[39m,
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
25.560 : DEBUG :  Removing node c
25.560 : INFO :  cp  B  to  A  with parent  B
25.560 : INFO :  In copy  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: a c Translating:  { id: [32m'c'[39m, clusterData: { data: [33m1[39m } }  ---  { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
25.560 : WARN :  Fixing and trying - removing XXX a c 2
25.560 : WARN :  Fix Replacing with XXX a c 2
25.560 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  width: [33m500[39m,
  type: [32m'group'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  padding: [33m15[39m
} A
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
25.560 : DEBUG :  Not Setting parent for node= B cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
25.560 : DEBUG :  Copying Edges []
25.560 : DEBUG :  Removing node B
25.560 : DEBUG :  Removing node B
25.560 : INFO :  cp  b  to  A  with parent  A
25.560 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  ],
  padding: [33m15[39m
} A
25.560 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.560 : DEBUG :  Copying Edges []
25.560 : DEBUG :  Removing node b
25.560 : INFO :  cp  a  to  A  with parent  A
25.560 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  edges: [
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
25.560 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.560 : DEBUG :  Copying Edges []
25.560 : DEBUG :  Removing node a
25.560 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'A'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.560 : DEBUG :  Extracting node B Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
25.560 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.560 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
25.560 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
      style: [32m''[39m,
      id: [32m'B'[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.560 : WARN :  Copying children of  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
      width: [33m500[39m,
  style: [32m''[39m,
      type: [32m'group'[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
25.560 : WARN :  Copying (nodes) clusterId A nodes [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
25.560 : WARN :  Copying children of  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
      padding: [33m15[39m
    },
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
25.560 : WARN :  Copying (nodes) clusterId B nodes [ [32m'c'[39m, [32m'B'[39m ]
25.560 : WARN :  Setting parent c B
25.560 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    externalConnections: [33mtrue[39m
  },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.560 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
25.560 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.560 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.560 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.560 : WARN :  New list of nodes [ [32m'A'[39m ]
25.560 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  clusterData: {
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    labelText: [32m'A'[39m,
    rx: [33m0[39m,
    ry: [33m0[39m,
    cssClass: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'A'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
    padding: [33m15[39m
  },
  label: [90mundefined[39m,
25.560 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
  graph: Graph {
    _isDirected: [33mtrue[39m,
    }
  },
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, B: [36m[Object][39m, b: [36m[Object][39m, a: [36m[Object][39m },
    _parent: { c: [32m'B'[39m, B: [32m'\x00'[39m, b: [32m'\x00'[39m, a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, B: [36m[Object][39m, b: {}, a: {} },
  [32m'B'[39m => {
    _in: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    id: [32m'c'[39m,
    _preds: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _out: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    clusterData: {
    _sucs: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _edgeObjs: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
      labelStyle: [32m''[39m,
    _nodeCount: [33m4[39m,
    _edgeCount: [33m2[39m
      shape: [32m'rect'[39m,
  }
}
      labelText: [32m'B'[39m,
25.560 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      rx: [33m0[39m,
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      ry: [33m0[39m,
} [90mundefined[39m
25.560 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mfalse[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
25.560 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
25.560 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
25.560 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
25.560 : WARN :  New list of nodes [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
25.560 : WARN :   Now next level c {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
      class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
      style: [32m''[39m,
  padding: [33m15[39m
}
25.560 : WARN :   Now next level B {
      id: [32m'B'[39m,
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
      width: [33m500[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
      type: [32m'group'[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
}
25.560 : WARN :   Now next level b {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
      padding: [33m15[39m
  ry: [33m0[39m,
    },
  class: [32m'default'[39m,
    externalConnections: [33mtrue[39m
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.560 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
}
25.560 : WARN :   Now next level a {
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
}

      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.560 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.560 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.560 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.560 : DEBUG :  Extracting node a Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.560 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.560 : DEBUG :  Nodes =  [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ] [33m1[39m
25.560 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
25.560 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.560 : DEBUG :  Extracting node B Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
25.560 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.560 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
25.560 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.560 : DEBUG :  Extracting node a Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
25.560 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.560 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

 ✓ packages/mermaid/src/diagrams/xychart/parser/xychart.jison.spec.ts (48 tests) 83ms
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
25.557 : WARN :  Cluster identified b  Replacement id in edges:  c
25.557 : WARN :  Edge a -> b: {"v":"a","w":"b","name":"1"}
25.557 : WARN :  Edge a -> b: {"data":"link1"}
25.557 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
25.563 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.563 : DEBUG :  Opting in, graph
25.563 : DEBUG :  Cluster identified a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
} ids: a b Translating:  [90mundefined[39m  ---  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
25.557 : WARN :  Fixing and trixing - removing XXX a b 1
25.557 : WARN :  Fix Replacing with XXX a b 1
25.557 : WARN :  Edge c -> d: {"v":"c","w":"d","name":"2"}
25.557 : WARN :  Edge c -> d: {"data":"link2"}
25.557 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
25.563 : DEBUG :  Cluster identified b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: c d Translating:  [90mundefined[39m  ---  [90mundefined[39m
25.557 : WARN :  Edge d -> e: {"v":"d","w":"e","name":"2"}
25.557 : WARN :  Edge d -> e: {"data":"link2"}
25.557 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: d e Translating:  [90mundefined[39m  ---  [90mundefined[39m
25.557 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.557 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
25.563 : DEBUG :  Cluster identified c {
  C1: [ [32m'a'[39m ],
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.557 : WARN :  Cluster without external connections, without a parent and with children b [33m0[39m
25.557 : WARN :  Old graph before copy {
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
}
25.563 : DEBUG :  Not a cluster  e {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
25.557 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
25.557 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
25.557 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
25.563 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ] [33m0[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.557 : WARN :  New list of nodes [ [32m'a'[39m, [32m'b'[39m ]
25.563 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
25.563 : INFO :  cp  e  to  a  with parent  c
25.563 : DEBUG :  Setting parent e c
25.557 : WARN :   Now next level a { data: [33m1[39m }
25.557 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
25.563 : DEBUG :  Copying Edges []
25.563 : DEBUG :  Removing node e
25.563 : INFO :  cp  c  to  a  with parent  c
25.563 : INFO :  In copy  c root a data { data: [33m3[39m } a
25.563 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
25.563 : DEBUG :  Copying Edges []
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, d: [36m[Object][39m, e: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m, d: [32m'\x00'[39m, e: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, d: {}, e: {} },
    _in: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
25.563 : DEBUG :  Removing node c
25.563 : DEBUG :  Removing node c
25.563 : INFO :  cp  b  to  a  with parent  b
25.563 : INFO :  In copy  b root a data { data: [33m2[39m } a
25.563 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
25.563 : DEBUG :  Copying Edges []
25.563 : DEBUG :  Removing node b
25.563 : DEBUG :  Removing node b
25.563 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
    _preds: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _out: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _sucs: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _edgeObjs: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m2[39m
  }
25.563 : DEBUG :  Extracting node b {
}
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
25.557 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
25.563 : WARN :  Cluster identified a  Replacement id in edges:  e
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.563 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.563 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
25.563 : WARN :  Cluster identified b  Replacement id in edges:  e
25.563 : WARN :  Cluster identified c  Replacement id in edges:  e
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
25.563 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.563 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.563 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
}
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.563 : WARN :  Cluster without external connections, without a parent and with children a [33m0[39m
25.563 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
25.563 : DEBUG :  Extracting node e {
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.563 : WARN :  Copying children of  a root a data { data: [33m1[39m } a
25.563 : WARN :  Copying (nodes) clusterId a nodes [ [32m'b'[39m ]
25.563 : WARN :  Copying children of  b root a data { data: [33m2[39m } a
25.563 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'b'[39m ]
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
25.563 : WARN :  Copying children of  c root a data { data: [33m3[39m } a
25.563 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m, [32m'c'[39m ]
25.563 : WARN :  Setting parent e c
25.563 : WARN :  Setting parent c b
25.563 : WARN :  New graph after copy node: ( a ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.563 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.563 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.563 : WARN :  New list of nodes [ [32m'a'[39m ]
25.563 : WARN :   Now next level a {
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  clusterNode: [33mtrue[39m,
  id: [32m'a'[39m,
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { e: [36m[Object][39m, c: [36m[Object][39m, b: [36m[Object][39m },
    _parent: { e: [32m'c'[39m, c: [32m'b'[39m, b: [32m'\x00'[39m },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    _children: { [32m'\x00'[39m: [36m[Object][39m, e: {}, c: [36m[Object][39m, b: [36m[Object][39m },
    _in: { e: {}, c: {}, b: {} },
    _preds: { e: {}, c: {}, b: {} },
    _out: { e: {}, c: {}, b: {} },
    _sucs: { e: {}, c: {}, b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
    _nodeCount: [33m3[39m
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  }
}
25.563 : DEBUG :  Not a cluster e [33m0[39m
25.563 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
25.563 : DEBUG :  Nodes =  [ [32m'e'[39m, [32m'c'[39m, [32m'b'[39m ] [33m1[39m
} [90mundefined[39m
25.563 : WARN :  Cluster without external connections, without a parent and with children c [33m1[39m
25.563 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
25.563 : DEBUG :  Extracting node e {
  edges: [],
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
25.563 : DEBUG :  Not a cluster e [33m1[39m
25.563 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
25.563 : WARN :  Copying children of  c root c data { data: [33m3[39m } c
25.563 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m ]
25.563 : WARN :  New graph after copy node: ( c ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'e'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.563 : WARN :  Cluster without external connections, without a parent and with children b [33m1[39m
25.563 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.563 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
25.563 : INFO :  cp  e  to  c  with parent  c
25.563 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m ]
25.563 : INFO :  In copy  c root c data { data: [33m3[39m } c
25.563 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
25.563 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.563 : DEBUG :  Copying Edges []
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.563 : WARN :  New list of nodes [ [32m'b'[39m ]
25.563 : DEBUG :  Removing node e
25.563 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
25.563 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
  nodes: [
    _isDirected: [33mtrue[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    _isMultigraph: [33mtrue[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m }
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  ],
  edges: [],
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
}
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
25.563 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _edgeObjs: {},
    _edgeLabels: {},
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _nodeCount: [33m1[39m
  }
}
25.563 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
25.572 : WARN :  Cluster identified A  Replacement id in edges:  c
25.572 : WARN :  Cluster identified B  Replacement id in edges:  c
25.572 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }  leaves cluster  B
25.572 : WARN :  Descendants of XXX  B :  [ [32m'c'[39m ]
25.572 : WARN :  Edge b -> B: {"v":"b","w":"B","name":"1"}
25.572 : WARN :  Edge b -> B: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-b-B","classes":"flowchart-link LS-b LE-B"}
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
25.572 : WARN :  Fix XXX {
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  A: {
    id: [32m'c'[39m,
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
25.563 : INFO :  cp  c  to  b  with parent  b
25.563 : INFO :  In copy  b root b data { data: [33m2[39m } b
25.563 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.563 : DEBUG :  Copying Edges []
25.563 : DEBUG :  Removing node c
25.563 : DEBUG :  Old graph after copy {
      width: [33m500[39m,
      type: [32m'group'[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.563 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
25.563 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      padding: [33m15[39m
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

    }
  },
  B: {
    id: [32m'c'[39m,
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
25.572 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    clusterData: {
      labelStyle: [32m''[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
      shape: [32m'rect'[39m,
  edges: [
    { v: [32m'b'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      labelText: [32m'B'[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
      rx: [33m0[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
      ry: [33m0[39m,
      class: [32m'default'[39m,
25.572 : DEBUG :  Opting in, graph
25.572 : DEBUG :  Cluster identified A {
      style: [32m''[39m,
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
25.572 : DEBUG :  Cluster identified B {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
} ids: b B Translating:  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }  ---  {
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  id: [32m'c'[39m,
  c: [ [32m'e'[39m ]
  clusterData: {
}
25.572 : DEBUG :  Not a cluster  b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
25.572 : DEBUG :  Not a cluster  c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
25.572 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
    labelText: [32m'B'[39m,
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
    rx: [33m0[39m,
}
25.572 : DEBUG :  Nodes =  [ [32m'A'[39m, [32m'B'[39m, [32m'b'[39m, [32m'c'[39m, [32m'a'[39m ] [33m0[39m
25.572 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
    ry: [33m0[39m,
      shape: [32m'rect'[39m,
    class: [32m'default'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
    style: [32m''[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'B'[39m,
    id: [32m'c'[39m,
    clusterData: {
    width: [33m500[39m,
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
    type: [32m'group'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  externalConnections: [33mtrue[39m
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
}
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m0[39m
25.572 : INFO :  cp  c  to  A  with parent  B
25.572 : WARN :  Fixing and trixing - removing XXX b B 1
25.572 : DEBUG :  Setting parent c B
25.572 : DEBUG :  Copying Edges [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
25.572 : INFO :  Edge { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
25.572 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
25.572 : WARN :  Fix Replacing with XXX b c 1
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
25.572 : WARN :  Edge a -> c: {"v":"a","w":"c","name":"2"}
  style: [32m'fill:none'[39m,
25.572 : WARN :  Edge a -> c: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-a-c","classes":"flowchart-link LS-a LE-c"}
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} A
25.572 : WARN :  Fix XXX {
25.572 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
25.572 : INFO :  Edge is  { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
25.572 : INFO :  Copying as  b c {
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  A: {
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
    id: [32m'c'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
    clusterData: {
} 1
      labelStyle: [32m''[39m,
25.572 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
      labelText: [32m'A'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
      rx: [33m0[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
      ry: [33m0[39m,
  toCluster: [32m'B'[39m
}
      class: [32m'default'[39m,
25.572 : INFO :  Edge { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
25.572 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
  label: [32m''[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
  id: [32m'L-a-c'[39m,
  classes: [32m'flowchart-link LS-a LE-c'[39m
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
} A
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: a c Translating:  { id: [32m'c'[39m, clusterData: { data: [33m1[39m } }  ---  { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
25.572 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
25.572 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
25.572 : WARN :  Fixing and trixing - removing XXX a c 2
25.572 : WARN :  Fix Replacing with XXX a c 2
25.572 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
25.572 : INFO :  Copying as  a c {
  minlen: [33m1[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.572 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.572 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
25.572 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.572 : WARN :  Copying children of  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  classes: [32m'flowchart-link LS-a LE-c'[39m
} 2
25.572 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ] {
  padding: [33m15[39m
} A
25.572 : WARN :  Copying (nodes) clusterId A nodes [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
25.572 : WARN :  Copying children of  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
25.572 : WARN :  Copying (nodes) clusterId B nodes [ [32m'c'[39m, [32m'B'[39m ]
25.572 : WARN :  Setting parent c B
25.572 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
25.572 : DEBUG :  Removing node c
25.572 : INFO :  cp  B  to  A  with parent  B
25.572 : INFO :  In copy  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
25.572 : DEBUG :  Not Setting parent for node= B cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
25.572 : DEBUG :  Copying Edges []
25.572 : DEBUG :  Removing node B
25.572 : DEBUG :  Removing node B
25.572 : INFO :  cp  b  to  A  with parent  A
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
25.572 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
25.572 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.572 : DEBUG :  Copying Edges []
25.572 : DEBUG :  Removing node b
25.572 : INFO :  cp  a  to  A  with parent  A
25.572 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.572 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
25.572 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.572 : DEBUG :  Copying Edges []
25.572 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.572 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.572 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
25.572 : WARN :  New list of nodes [ [32m'A'[39m ]
25.572 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    labelText: [32m'A'[39m,
    rx: [33m0[39m,
25.572 : DEBUG :  Removing node a
25.572 : DEBUG :  Old graph after copy {
    ry: [33m0[39m,
    class: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'A'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
    padding: [33m15[39m
  },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'A'[39m, value: [36m[Object][39m } ],
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, B: [36m[Object][39m, b: [36m[Object][39m, a: [36m[Object][39m },
    _parent: { c: [32m'B'[39m, B: [32m'\x00'[39m, b: [32m'\x00'[39m, a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, B: [36m[Object][39m, b: {}, a: {} },
    _in: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _preds: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _out: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _sucs: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
  edges: [],
    _edgeObjs: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m4[39m,
    _edgeCount: [33m2[39m
  }
}
25.572 : WARN :  extractor -  [33m1[39m {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
25.572 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
25.572 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mfalse[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
25.572 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
25.572 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
25.572 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
25.572 : WARN :  New list of nodes [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
25.572 : WARN :   Now next level c {
  labelStyle: [32m''[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
}
25.572 : WARN :   Now next level B {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
      padding: [33m15[39m
    },
  ry: [33m0[39m,
  class: [32m'default'[39m,
    externalConnections: [33mtrue[39m
  },
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
}
25.572 : WARN :   Now next level b {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  style: [32m''[39m,
  id: [32m'b'[39m,
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.572 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  padding: [33m15[39m
}
25.572 : WARN :   Now next level a {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
  A: {
    id: [32m'c'[39m,
}

    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.572 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.572 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.572 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.572 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.572 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
25.572 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.572 : DEBUG :  Nodes =  [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ] [33m1[39m
25.572 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
25.572 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.572 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
25.572 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.572 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
25.572 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.572 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
25.572 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
25.572 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

 ✓ packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js (15 tests) 132ms
 ✓ packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js (15 tests) 114ms
stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with a node
Found block-beta
.

Lex: NODE_ID id
.

Lex: EOF
Rule: node (NODE_ID separator):  id
Rule: nodeStatement (node)  { id: [32m'id'[39m }
Rule: statement:  {
  id: [32m'id'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a node with a square shape and a label
Found block
.

Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: [32m'[]'[39m, label: [32m'A label'[39m }
Rule: nodeStatement (node)  { id: [32m'id'[39m, label: [32m'A label'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'id'[39m,
  label: [32m'A label'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [32m'A label'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes
Found block
.

Lex: NODE_ID id1
.

Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: [32m'id1'[39m }
.

Lex: EOF
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
Rule: statement:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id1'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id1'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes
Found block
.

Lex: NODE_ID id1
.

Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: [32m'id1'[39m }
.

Lex: NODE_ID id3
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
.

Lex: EOF
Rule: node (NODE_ID separator):  id3
Rule: nodeStatement (node)  { id: [32m'id3'[39m }
Rule: statement:  {
  id: [32m'id3'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id1'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id1'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id3'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a node with a square shape and a label
Found block
.

Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID id2
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: [32m'[]'[39m, label: [32m'A label'[39m }
Rule: nodeStatement (node)  { id: [32m'id'[39m, label: [32m'A label'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lex: EOF
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
Rule: statement:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id'[39m,
  label: [32m'A label'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [32m'A label'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-1 should handle a simple root definition abc122
26.248 : INFO :  Node:  root
26.248 : INFO :  addNode [33m4[39m root root [33m0[39m
26.248 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-2 should handle a hierarchical mindmap definition
26.258 : INFO :  Node:  root
26.258 : INFO :  addNode [33m4[39m root root [33m0[39m
26.258 : TRACE :  Stop NL
26.258 : INFO :  Node:  child1
26.258 : INFO :  addNode [33m6[39m child1 child1 [33m0[39m
26.258 : TRACE :  Stop NL
26.258 : INFO :  Node:  child2
26.258 : INFO :  addNode [33m6[39m child2 child2 [33m0[39m
26.258 : TRACE :  Stop NL
26.258 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > 3 should handle a simple root definition with a shape and without an id abc123
26.262 : TRACE :  Long description: root
26.262 : TRACE :  node end )
26.262 : TRACE :  node found .. (
26.262 : DEBUG :  In get type ( )
26.262 : INFO :  Node:  root
26.262 : INFO :  addNode [33m4[39m root root [33m1[39m
26.262 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-4 should handle a deeper hierarchical mindmap definition
26.264 : INFO :  Node:  root
26.264 : INFO :  addNode [33m4[39m root root [33m0[39m
26.264 : TRACE :  Stop NL
26.264 : INFO :  Node:  child1
26.264 : INFO :  addNode [33m6[39m child1 child1 [33m0[39m
26.264 : TRACE :  Stop NL
26.264 : INFO :  Node:  leaf1
26.264 : INFO :  addNode [33m8[39m leaf1 leaf1 [33m0[39m
26.264 : TRACE :  Stop NL
26.264 : INFO :  Node:  child2
26.264 : INFO :  addNode [33m6[39m child2 child2 [33m0[39m
26.264 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > 5 Multiple roots are illegal
26.268 : INFO :  Node:  root
26.268 : INFO :  addNode [33m4[39m root root [33m0[39m
26.268 : TRACE :  Stop NL
26.268 : INFO :  Node:  fakeRoot
26.268 : INFO :  addNode [33m4[39m fakeRoot fakeRoot [33m0[39m

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-6 real root in wrong place
26.272 : INFO :  Node:  root
26.272 : INFO :  addNode [33m10[39m root root [33m0[39m
26.272 : TRACE :  Stop NL
26.272 : INFO :  Node:  fakeRoot
26.272 : INFO :  addNode [33m8[39m fakeRoot fakeRoot [33m0[39m

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-7 should handle an id and type for a node definition
26.275 : TRACE :  Long description: The root
26.275 : TRACE :  node end ... ]
26.275 : TRACE :  node found .. root
26.275 : DEBUG :  In get type [ ]
26.275 : INFO :  Node:  root
26.275 : INFO :  addNode [33m4[39m root The root [33m2[39m
26.275 : TRACE :  Stop NL
26.275 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-8 should handle an id and type for a node definition
26.277 : INFO :  Node:  root
26.277 : INFO :  addNode [33m4[39m root root [33m0[39m
26.277 : TRACE :  Stop NL
26.277 : TRACE :  Long description: child1
26.277 : TRACE :  node end )
26.277 : TRACE :  node found .. theId
26.277 : DEBUG :  In get type ( )
26.277 : INFO :  Node:  theId
26.277 : INFO :  addNode [33m6[39m theId child1 [33m1[39m
26.277 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-9 should handle an id and type for a node definition
26.280 : TRACE :  Node:  root
26.280 : INFO :  addNode [33m0[39m root root [33m0[39m
26.280 : TRACE :  Stop NL
26.280 : TRACE :  Long description: child1
26.280 : TRACE :  node end )
26.280 : TRACE :  node found .. theId
26.280 : DEBUG :  In get type ( )
26.280 : INFO :  Node:  theId
26.280 : INFO :  addNode [33m6[39m theId child1 [33m1[39m
26.280 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-10 multiple types (circle)
26.283 : TRACE :  Long description: the root
26.283 : TRACE :  node end ))
26.283 : TRACE :  node found .. root
26.283 : DEBUG :  In get type (( ))
26.283 : INFO :  Node:  root
26.283 : INFO :  addNode [33m1[39m root the root [33m3[39m
26.283 : TRACE :  Stop NL
26.283 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-11 multiple types (cloud)
26.285 : TRACE :  Cloud Bang
26.285 : TRACE :  Long description: the root
26.285 : TRACE :  node end ((
26.285 : TRACE :  node found .. root
26.284 : DEBUG :  In get type ) (
26.284 : INFO :  Node:  root
26.284 : INFO :  addNode [33m1[39m root the root [33m4[39m
26.285 : TRACE :  Stop NL
26.285 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12 multiple types (bang)
26.286 : TRACE :  Explosion Bang
26.286 : TRACE :  Long description: the root
26.286 : TRACE :  node end ((
26.286 : TRACE :  node found .. root
26.286 : DEBUG :  In get type )) ((
26.286 : INFO :  Node:  root
26.286 : INFO :  addNode [33m1[39m root the root [33m5[39m
26.286 : TRACE :  Stop NL
26.286 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12-a multiple types (hexagon)
26.288 : TRACE :  Long description: the root
26.288 : TRACE :  node end ((
26.288 : TRACE :  node found .. root
26.288 : DEBUG :  In get type {{ }}
26.288 : INFO :  Node:  root
26.288 : INFO :  addNode [33m1[39m root the root [33m6[39m
26.288 : TRACE :  Stop NL
26.288 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-13 should be possible to set an icon for the node
26.290 : TRACE :  Long description: The root
26.290 : TRACE :  node end ... ]
26.290 : TRACE :  node found .. root
26.290 : DEBUG :  In get type [ ]
26.290 : INFO :  Node:  root
26.290 : INFO :  addNode [33m4[39m root The root [33m2[39m
26.290 : TRACE :  Stop NL
26.290 : TRACE :  Begin icon
26.290 : TRACE :  end icon
26.290 : TRACE :  Icon:  bomb
26.290 : TRACE :  Stop NL
26.290 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-14 should be possible to set classes for the node
26.293 : TRACE :  Long description: The root
26.293 : TRACE :  node end ... ]
26.293 : TRACE :  node found .. root
26.293 : DEBUG :  In get type [ ]
26.293 : INFO :  Node:  root
26.293 : INFO :  addNode [33m4[39m root The root [33m2[39m
26.293 : TRACE :  Stop NL
26.293 : TRACE :  Stop NL
26.293 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-15 should be possible to set both classes and icon for the node
26.300 : TRACE :  Long description: The root
26.300 : TRACE :  node end ... ]
26.300 : TRACE :  node found .. root
26.300 : DEBUG :  In get type [ ]
26.300 : INFO :  Node:  root
26.300 : INFO :  addNode [33m4[39m root The root [33m2[39m
26.300 : TRACE :  Stop NL
26.300 : TRACE :  Stop NL
26.300 : TRACE :  Begin icon
26.300 : TRACE :  end icon
26.300 : TRACE :  Icon:  bomb
26.300 : TRACE :  Stop NL
26.300 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-16 should be possible to set both classes and icon for the node
26.303 : TRACE :  Long description: The root
26.303 : TRACE :  node end ... ]
26.303 : TRACE :  node found .. root
26.303 : DEBUG :  In get type [ ]
26.303 : INFO :  Node:  root
26.303 : INFO :  addNode [33m4[39m root The root [33m2[39m
26.303 : TRACE :  Stop NL
26.303 : TRACE :  Begin icon
26.303 : TRACE :  end icon
26.303 : TRACE :  Icon:  bomb
26.303 : TRACE :  Stop NL
26.303 : TRACE :  Stop NL
26.303 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-17 should be possible to use node syntax in the descriptions
26.307 : TRACE :  Starting NSTR
26.307 : TRACE :  description: String containing []
26.307 : TRACE :  node end ... ]
26.307 : TRACE :  node found .. root
26.307 : DEBUG :  In get type [ ]
26.307 : INFO :  Node:  root
26.307 : INFO :  addNode [33m4[39m root String containing [] [33m2[39m
26.307 : TRACE :  Stop NL
26.307 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-18 should be possible to use node syntax in the descriptions in children
26.309 : TRACE :  Starting NSTR
26.309 : TRACE :  description: String containing []
26.309 : TRACE :  node end ... ]
26.309 : TRACE :  node found .. root
26.309 : DEBUG :  In get type [ ]
26.309 : INFO :  Node:  root
26.309 : INFO :  addNode [33m4[39m root String containing [] [33m2[39m
26.309 : TRACE :  Stop NL
26.309 : TRACE :  Starting NSTR
26.309 : TRACE :  description: String containing ()
26.309 : TRACE :  node end ... ]
26.309 : TRACE :  node found .. child1
26.309 : DEBUG :  In get type [ ]
26.309 : INFO :  Node:  child1
26.309 : INFO :  addNode [33m6[39m child1 String containing () [33m2[39m
26.309 : TRACE :  Stop NL
26.309 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-19 should be possible to have a child after a class assignment
26.311 : TRACE :  Long description: Root
26.311 : TRACE :  node end )
26.311 : TRACE :  node found .. root
26.311 : DEBUG :  In get type ( )
26.311 : INFO :  Node:  root
26.311 : INFO :  addNode [33m2[39m root Root [33m1[39m
26.311 : TRACE :  Stop NL
26.311 : TRACE :  Long description: Child
26.311 : TRACE :  node end )
26.311 : TRACE :  node found .. Child
26.311 : DEBUG :  In get type ( )
26.311 : INFO :  Node:  Child
26.311 : INFO :  addNode [33m4[39m Child Child [33m1[39m
26.311 : TRACE :  Stop NL
26.311 : TRACE :  Stop NL
26.311 : TRACE :  Long description: a
26.311 : TRACE :  node end )
26.311 : TRACE :  node found .. a
26.311 : DEBUG :  In get type ( )
26.311 : INFO :  Node:  a
26.311 : INFO :  addNode [33m6[39m a a [33m1[39m
26.311 : TRACE :  Stop NL
26.311 : TRACE :  Long description: New Stuff
26.311 : TRACE :  node end ... ]
26.311 : TRACE :  node found .. b
26.311 : DEBUG :  In get type [ ]
26.311 : INFO :  Node:  b
26.311 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
26.311 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-20 should be possible to have meaningless empty rows in a mindmap abc124
26.317 : TRACE :  Long description: Root
26.317 : TRACE :  node end )
26.317 : TRACE :  node found .. root
26.317 : DEBUG :  In get type ( )
26.317 : INFO :  Node:  root
26.317 : INFO :  addNode [33m2[39m root Root [33m1[39m
26.317 : TRACE :  Stop NL
26.317 : TRACE :  Long description: Child
26.317 : TRACE :  node end )
26.317 : TRACE :  node found .. Child
26.317 : DEBUG :  In get type ( )
26.317 : INFO :  Node:  Child
26.317 : INFO :  addNode [33m4[39m Child Child [33m1[39m
26.317 : TRACE :  Stop NL
26.317 : TRACE :  Long description: a
26.317 : TRACE :  node end )
26.317 : TRACE :  SPACELINE
26.317 : TRACE :  node found .. a
26.317 : DEBUG :  In get type ( )
26.317 : INFO :  Node:  a
26.317 : INFO :  addNode [33m6[39m a a [33m1[39m
26.317 : TRACE :  Long description: New Stuff
26.317 : TRACE :  node end ... ]
26.317 : TRACE :  node found .. b
26.317 : DEBUG :  In get type [ ]
26.317 : INFO :  Node:  b
26.317 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
26.317 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-21 should be possible to have comments in a mindmap
26.321 : TRACE :  Long description: Root
26.321 : TRACE :  node end )
26.321 : TRACE :  node found .. root
26.321 : DEBUG :  In get type ( )
26.321 : INFO :  Node:  root
26.321 : INFO :  addNode [33m2[39m root Root [33m1[39m
26.321 : TRACE :  Stop NL
26.321 : TRACE :  Long description: Child
26.321 : TRACE :  node end )
26.321 : TRACE :  node found .. Child
26.321 : DEBUG :  In get type ( )
26.321 : INFO :  Node:  Child
26.321 : INFO :  addNode [33m4[39m Child Child [33m1[39m
26.321 : TRACE :  Stop NL
26.321 : TRACE :  Long description: a
26.321 : TRACE :  node end )
26.321 : TRACE :  Found comment

      %% This is a comment
26.321 : TRACE :  node found .. a
26.321 : DEBUG :  In get type ( )
26.321 : INFO :  Node:  a
26.321 : INFO :  addNode [33m6[39m a a [33m1[39m
26.321 : TRACE :  Stop NL2
26.321 : TRACE :  Long description: New Stuff
26.321 : TRACE :  node end ... ]
26.321 : TRACE :  node found .. b
26.321 : DEBUG :  In get type [ ]
26.321 : INFO :  Node:  b
26.321 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
26.321 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-22 should be possible to have comments at the end of a line
26.326 : TRACE :  Long description: Root
26.326 : TRACE :  node end )
26.326 : TRACE :  node found .. root
26.326 : DEBUG :  In get type ( )
26.326 : INFO :  Node:  root
26.326 : INFO :  addNode [33m2[39m root Root [33m1[39m
26.326 : TRACE :  Stop NL
26.326 : TRACE :  Long description: Child
26.326 : TRACE :  node end )
26.326 : TRACE :  node found .. Child
26.326 : DEBUG :  In get type ( )
26.326 : INFO :  Node:  Child
26.326 : INFO :  addNode [33m4[39m Child Child [33m1[39m
26.326 : TRACE :  Stop NL
26.326 : TRACE :  Long description: a
26.326 : TRACE :  node end )
26.326 : TRACE :  Found comment  %% This is a comment
26.326 : TRACE :  node found .. a
26.326 : DEBUG :  In get type ( )
26.326 : INFO :  Node:  a
26.326 : INFO :  addNode [33m6[39m a a [33m1[39m
26.326 : TRACE :  Stop NL2
26.326 : TRACE :  Long description: New Stuff
26.326 : TRACE :  node end ... ]
26.326 : TRACE :  node found .. b
26.326 : DEBUG :  In get type [ ]
26.326 : INFO :  Node:  b
26.326 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
26.326 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-23 Rows with only spaces should not interfere
26.331 : TRACE :  Node:  root
26.331 : INFO :  addNode [33m0[39m root root [33m0[39m
26.331 : TRACE :  Stop NL
26.331 : TRACE :  SPACELINE
26.331 : INFO :  Node:  A
26.331 : INFO :  addNode [33m1[39m A A [33m0[39m
26.331 : INFO :  Node:  B
26.331 : INFO :  addNode [33m1[39m B B [33m0[39m
26.331 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-24 Handle rows above the mindmap declarations
26.334 : TRACE :  SPACELINE
26.334 : TRACE :  Node:  root
26.334 : INFO :  addNode [33m0[39m root root [33m0[39m
26.334 : TRACE :  Stop NL
26.334 : TRACE :  SPACELINE
26.334 : INFO :  Node:  A
26.334 : INFO :  addNode [33m1[39m A A [33m0[39m
26.334 : INFO :  Node:  B
26.334 : INFO :  addNode [33m1[39m B B [33m0[39m
26.334 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-25 Handle rows above the mindmap declarations, no space
26.337 : TRACE :  SPACELINE
26.337 : TRACE :  Node:  root
26.337 : INFO :  addNode [33m0[39m root root [33m0[39m
26.337 : TRACE :  Stop NL
26.337 : TRACE :  SPACELINE
26.337 : INFO :  Node:  A
26.337 : INFO :  addNode [33m1[39m A A [33m0[39m
26.337 : INFO :  Node:  B
26.337 : INFO :  addNode [33m1[39m B B [33m0[39m
26.337 : TRACE :  Stop EOF

 ✓ packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts (26 tests) 97ms
stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
Found block
.

Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.
Lex: LINK #-->   #
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: [32m'[]'[39m, label: [32m'first'[39m }
Rule: nodeStatement (node)  { id: [32m'id1'[39m, label: [32m'first'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: link:  -->    -->
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: [32m'[]'[39m, label: [32m'second'[39m }
Rule: (nodeStatement link node)  {
  id: [32m'id1'[39m,
  label: [32m'first'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} { edgeTypeStr: [32m'-->   '[39m, label: [32m''[39m } { id: [32m'id2'[39m, label: [32m'second'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }  typestr:  -->
Rule: statement:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m''[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]
Rule: hierarchy:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m''[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
Found block
.

Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.
Lex: START_LINK --
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: [32m'[]'[39m, label: [32m'first'[39m }
Rule: nodeStatement (node)  { id: [32m'id1'[39m, label: [32m'first'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lex: Starting string
LEX: STR end: a label
LEX: POPPING STR: "
Lex: LINK # -->   #
Rule: LABEL link:  --  a label  -->
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: [32m'[]'[39m, label: [32m'second'[39m }
Rule: (nodeStatement link node)  {
  id: [32m'id1'[39m,
  label: [32m'first'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} { edgeTypeStr: [32m' -->   '[39m, label: [32m'a label'[39m } { id: [32m'id2'[39m, label: [32m'second'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }  typestr:   -->
Rule: statement:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m'a label'[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]
Rule: hierarchy:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m'a label'[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with column statements
Found block
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram without column statements
Found block
.

Lex: NODE_ID block1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with auto column statements
Found block
.

.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [33m-1[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m22[39m }
}
COLUMNS:  [33m-1[39m
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m-1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m-1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks next to each other
Found block
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks on top of each other
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks 2
Found block
.

Found block
.

Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID bBlock
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: [32m'[]'[39m, label: [32m'ABlock'[39m }
Rule: nodeStatement (node)  { id: [32m'aBlock'[39m, label: [32m'ABlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: [32m'[]'[39m, label: [32m'BBlock'[39m }
Rule: nodeStatement (node)  { id: [32m'bBlock'[39m, label: [32m'BBlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'bBlock'[39m,
  label: [32m'BBlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'aBlock'[39m,
  label: [32m'ABlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Lex: EOF
Rule: blockStatement :  block [
  {
    id: [32m'aBlock'[39m,
    label: [32m'ABlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'bBlock'[39m,
    label: [32m'BBlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-zn2u3prqntm-1'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'aBlock'[39m,
      label: [32m'ABlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'bBlock'[39m,
      label: [32m'BBlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'id-zn2u3prqntm-1'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks of compound blocks
Found block
.

Found block
.

Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
.

Found block
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: [32m'[]'[39m, label: [32m'ABlock'[39m }
Rule: nodeStatement (node)  { id: [32m'aBlock'[39m, label: [32m'ABlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
.

Lex: NODE_ID bBlock
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: [32m'[]'[39m, label: [32m'BBlock'[39m }
Rule: nodeStatement (node)  { id: [32m'bBlock'[39m, label: [32m'BBlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'bBlock'[39m,
  label: [32m'BBlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: blockStatement :  block [
  {
    id: [32m'bBlock'[39m,
    label: [32m'BBlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-kf7leykstkn-2'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'bBlock'[39m,
      label: [32m'BBlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'aBlock'[39m,
  label: [32m'ABlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Lex: EOF
Rule: blockStatement :  block [
  {
    id: [32m'aBlock'[39m,
    label: [32m'ABlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-kf7leykstkn-2'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m ]
  }
] end

Rule: statement:  {
  id: [32m'id-lel4dntfxv-3'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'aBlock'[39m,
      label: [32m'ABlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'id-kf7leykstkn-2'[39m,
      type: [32m'composite'[39m,
      label: [32m''[39m,
      children: [36m[Array][39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'id-lel4dntfxv-3'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks with title
Found block
.

Found id-block
Lex: NODE_ID compoundBlock
Lexa: [
Lex: Starting string
LEX: STR end: Compound block
LEX: POPPING STR: "
Lex: ]
.

COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ Compound block ]
Rule: node (NODE_ID nodeShapeNLabel separator):  compoundBlock { typeStr: [32m'[]'[39m, label: [32m'Compound block'[39m }
Rule: nodeStatement (node)  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: NODE_ID block2
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m3[39m, last_line: [33m3[39m, first_column: [33m12[39m, last_column: [33m21[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Lex: EOF
Rule: id-block statement :  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Rule: statement:  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  type: [32m'composite'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m1[39m },
    {
      id: [32m'block2'[39m,
      label: [32m'Block 2'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'compoundBlock'[39m,
    label: [32m'Compound block'[39m,
    type: [32m'composite'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks mixed with compound blocks
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.


Found block
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block2
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m6[39m, last_line: [33m6[39m, first_column: [33m12[39m, last_column: [33m21[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block3
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 3
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Block 3 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block3 { typeStr: [32m'[]'[39m, label: [32m'Block 3'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block3'[39m,
  label: [32m'Block 3'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block3'[39m,
  label: [32m'Block 3'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Lex: EOF
Rule: blockStatement :  block [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block3'[39m,
    label: [32m'Block 3'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-evjsstgv187-5'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m2[39m },
    {
      id: [32m'block2'[39m,
      label: [32m'Block 2'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'block3'[39m,
      label: [32m'Block 3'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-evjsstgv187-5'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > Arrow blocks
Found block
.

COLUMNS (LEX) 3
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID blockArrow
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (right): dir: right
Lex (ARROW_DIR end): ]>
Rule: dirList:  right
Lex: NODE_ID block2
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ [32m'right'[39m ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: [32m'<[]>'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  directions: [ [32m'right'[39m ]
}
Rule: nodeStatement (node)  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  typeStr: [32m'<[]>'[39m,
  directions: [ [32m'right'[39m ]
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  type: [32m'block_arrow'[39m,
  directions: [ [32m'right'[39m ],
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'blockArrow'[39m,
    label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
    type: [32m'block_arrow'[39m,
    directions: [ [32m'right'[39m ],
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > Arrow blocks with multiple points
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID A
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  1
.

Lex: NODE_ID blockArrow
Rule: node (NODE_ID separator):  A
Rule: nodeStatement (node)  { id: [32m'A'[39m }
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (up): up
Lex (down): down
Lex (ARROW_DIR end): ]>
Rule: dirList:  down
Rule: dirList:  up [ [32m'down'[39m ]
Found block
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ [32m'up'[39m, [32m'down'[39m ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: [32m'<[]>'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ]
}
Rule: nodeStatement (node)  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  typeStr: [32m'<[]>'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ]
}
.

COLUMNS (LEX) 3
.

Lex: NODE_ID B
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m6[39m, last_line: [33m6[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  3
.

Lex: NODE_ID C
Rule: node (NODE_ID separator):  B
Rule: nodeStatement (node)  { id: [32m'B'[39m }
.

Lex: NODE_ID D
Rule: node (NODE_ID separator):  C
Rule: nodeStatement (node)  { id: [32m'C'[39m }
.

Rule: node (NODE_ID separator):  D
Rule: nodeStatement (node)  { id: [32m'D'[39m }
Rule: statement:  {
  id: [32m'D'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'C'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Lex: EOF
Rule: blockStatement :  block [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'B'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'C'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'D'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end
Rule: statement:  {
  id: [32m'id-8wvhq90omqq-6'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m3[39m },
    {
      id: [32m'B'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'C'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'D'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  type: [32m'block_arrow'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ],
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'A'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'A'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'blockArrow'[39m,
    label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
    type: [32m'block_arrow'[39m,
    directions: [ [32m'up'[39m, [32m'down'[39m ],
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-8wvhq90omqq-6'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m, [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks with different widths
Found block
.

COLUMNS (LEX) 3
.

Lex: NODE_ID one
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: One Slot
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID two
Rule: nodeShapeNLabel:  [ One Slot ]
Rule: node (NODE_ID nodeShapeNLabel separator):  one { typeStr: [32m'[]'[39m, label: [32m'One Slot'[39m }
Rule: nodeStatement (node)  { id: [32m'one'[39m, label: [32m'One Slot'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lexa: [
Lex: Starting string
LEX: STR end: Two slots
LEX: POPPING STR: "
Lex: ]
Lex: COLON :2
Rule: nodeShapeNLabel:  [ Two slots ]
Rule: node (NODE_ID nodeShapeNLabel separator):  two { typeStr: [32m'[]'[39m, label: [32m'Two slots'[39m }
.

Lex: EOF
Rule: nodeStatement (abc88 node size)  { id: [32m'two'[39m, label: [32m'Two slots'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m } 2
Rule: statement:  {
  id: [32m'two'[39m,
  label: [32m'Two slots'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'one'[39m,
  label: [32m'One Slot'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'one'[39m,
    label: [32m'One Slot'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'two'[39m,
    label: [32m'Two slots'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > empty blocks
Found block
.

COLUMNS (LEX) 3
.

COLUMNS (LEX) 1
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
.

Lex: NODE_ID middle
Lexa: [
Lex: Starting string
LEX: STR end: In the middle
LEX: POPPING STR: "
Lex: ]
.

COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ In the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  middle { typeStr: [32m'[]'[39m, label: [32m'In the middle'[39m }
Rule: nodeStatement (node)  {
  id: [32m'middle'[39m,
  label: [32m'In the middle'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: EOF
Rule: statement:  {
  id: [32m'id-dor7x7i3rti-8'[39m,
  type: [32m'space'[39m,
  label: [32m''[39m,
  width: [33m1[39m,
  children: []
}
Rule: statement #2:  {
  id: [32m'middle'[39m,
  label: [32m'In the middle'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id-ebdiz9gvngc-7'[39m,
  type: [32m'space'[39m,
  label: [32m''[39m,
  width: [33m1[39m,
  children: []
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'id-ebdiz9gvngc-7'[39m,
    type: [32m'space'[39m,
    label: [32m''[39m,
    width: [33m1[39m,
    children: []
  },
  {
    id: [32m'middle'[39m,
    label: [32m'In the middle'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-dor7x7i3rti-8'[39m,
    type: [32m'space'[39m,
    label: [32m''[39m,
    width: [33m1[39m,
    children: []
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > classDef statements applied to a block
Found block
.

.


Lex: NODE_ID mc
Lexa: [
Lex: Starting string
LEX: STR end: Memcache
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Memcache ]
Rule: node (NODE_ID nodeShapeNLabel separator):  mc { typeStr: [32m'[]'[39m, label: [32m'Memcache'[39m }
Rule: nodeStatement (node)  { id: [32m'mc'[39m, label: [32m'Memcache'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
.

Lex: EOF
Rule: statement:  { type: [32m'applyClass'[39m, id: [32m'mc'[39m, styleClass: [32m'black'[39m }
Rule: statement #2:  {
  id: [32m'mc'[39m,
  label: [32m'Memcache'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'classDef'[39m, id: [32m'black'[39m, css: [32m'color:#ffffff, fill:#000000;'[39m }
Rule: hierarchy:  [
  {
    type: [32m'classDef'[39m,
    id: [32m'black'[39m,
    css: [32m'color:#ffffff, fill:#000000;'[39m
  },
  {
    id: [32m'mc'[39m,
    label: [32m'Memcache'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  { type: [32m'applyClass'[39m, id: [32m'mc'[39m, styleClass: [32m'black'[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > style statements applied to a block
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID B
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m0[39m, last_column: [33m9[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: A wide one in the middle
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ A wide one in the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  B { typeStr: [32m'[]'[39m, label: [32m'A wide one in the middle'[39m }
Rule: nodeStatement (node)  {
  id: [32m'B'[39m,
  label: [32m'A wide one in the middle'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: EOF
Rule: statement:  {
  type: [32m'applyStyles'[39m,
  id: [32m'B'[39m,
  stylesStr: [32m'fill:#f9F,stroke:#333,stroke-width:4px'[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [32m'A wide one in the middle'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'B'[39m,
    label: [32m'A wide one in the middle'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'applyStyles'[39m,
    id: [32m'B'[39m,
    stylesStr: [32m'fill:#f9F,stroke:#333,stroke-width:4px'[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > should log a warning when block width exceeds column width
Found block-beta
.

COLUMNS (LEX) 1
.

Lex: NODE_ID A
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m2[39m, last_column: [33m11[39m }
}
COLUMNS:  1
Lex: COLON :1
Rule: node (NODE_ID separator):  A
.

Lex: NODE_ID B
Rule: nodeStatement (abc88 node size)  { id: [32m'A'[39m } 1
Lex: COLON :2
Rule: node (NODE_ID separator):  B
.

Lex: NODE_ID C
Rule: nodeStatement (abc88 node size)  { id: [32m'B'[39m } 2
Lex: COLON :3
Rule: node (NODE_ID separator):  C
.

Lex: NODE_ID D
Rule: nodeStatement (abc88 node size)  { id: [32m'C'[39m } 3
Lex: COLON :4
Rule: node (NODE_ID separator):  D
.

Lex: NODE_ID E
Rule: nodeStatement (abc88 node size)  { id: [32m'D'[39m } 4
Lex: COLON :3
Rule: node (NODE_ID separator):  E
.

Lex: NODE_ID F
Rule: nodeStatement (abc88 node size)  { id: [32m'E'[39m } 3
Lex: COLON :2
Rule: node (NODE_ID separator):  F
.

Lex: NODE_ID G
Rule: nodeStatement (abc88 node size)  { id: [32m'F'[39m } 2
Lex: COLON :1
Rule: node (NODE_ID separator):  G
Lex: EOF
Rule: nodeStatement (abc88 node size)  { id: [32m'G'[39m } 1
Rule: statement:  {
  id: [32m'G'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'F'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'E'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m3[39m
}
Rule: statement #2:  {
  id: [32m'D'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m4[39m
}
Rule: statement #2:  {
  id: [32m'C'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m3[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'A'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'A'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'B'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  },
  {
    id: [32m'C'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m3[39m
  },
  {
    id: [32m'D'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m4[39m
  },
  {
    id: [32m'E'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m3[39m
  },
  {
    id: [32m'F'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  },
  {
    id: [32m'G'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a __proto__ property
Found block
.

Lex: NODE_ID __proto__
Lex: EOF
Rule: node (NODE_ID separator):  __proto__
Rule: nodeStatement (node)  { id: [32m'__proto__'[39m }
Rule: statement:  {
  id: [32m'__proto__'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'__proto__'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Found block
.

Lex: NODE_ID A;
.
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: [32m'A;'[39m }
Lex: EOF
Rule: statement:  {
  type: [32m'classDef'[39m,
  id: [32m'__proto__'[39m,
  css: [32m'color:#ffffff,fill:#000000; class A __proto__'[39m
}
Rule: statement #2:  {
  id: [32m'A;'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'A;'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'classDef'[39m,
    id: [32m'__proto__'[39m,
    css: [32m'color:#ffffff,fill:#000000; class A __proto__'[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a constructor property
Found block
.

Lex: NODE_ID constructor
Lex: EOF
Rule: node (NODE_ID separator):  constructor
Rule: nodeStatement (node)  { id: [32m'constructor'[39m }
Rule: statement:  {
  id: [32m'constructor'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'constructor'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Found block
.

Lex: NODE_ID A;
.
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: [32m'A;'[39m }
Lex: EOF
Rule: statement:  {
  type: [32m'classDef'[39m,
  id: [32m'constructor'[39m,
  css: [32m'color:#ffffff,fill:#000000; class A constructor'[39m
}
Rule: statement #2:  {
  id: [32m'A;'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'A;'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'classDef'[39m,
    id: [32m'constructor'[39m,
    css: [32m'color:#ffffff,fill:#000000; class A constructor'[39m
  }
]

 ✓ packages/mermaid/src/diagrams/block/parser/block.spec.ts (25 tests) 70ms
stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-1 should handle a simple root definition abc122
26.390 : INFO :  Node:  root
26.391 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-2 should handle a hierarchical kanban definition
26.403 : INFO :  Node:  root
26.403 : TRACE :  Stop NL
26.403 : INFO :  Node:  child1
26.403 : TRACE :  Stop NL
26.403 : INFO :  Node:  child2
26.403 : TRACE :  Stop NL
26.403 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > 3 should handle a simple root definition with a shape and without an id abc123
26.409 : TRACE :  Long description: root
26.409 : TRACE :  node end )
26.409 : TRACE :  node found .. (
26.409 : DEBUG :  In get type ( )
26.409 : INFO :  Node:  root
26.409 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-4 should not distinguish between deeper hierarchical levels in the kanban definition
26.411 : INFO :  Node:  root
26.411 : TRACE :  Stop NL
26.411 : INFO :  Node:  child1
26.411 : TRACE :  Stop NL
26.411 : INFO :  Node:  leaf1
26.411 : TRACE :  Stop NL
26.411 : INFO :  Node:  child2
26.411 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > 5 Multiple sections are ok
26.418 : INFO :  Node:  section1
26.418 : TRACE :  Stop NL
26.418 : INFO :  Node:  section2
26.418 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-6 real root in wrong place
26.423 : INFO :  Node:  root
26.423 : TRACE :  Stop NL
26.423 : INFO :  Node:  fakeRoot
26.423 : TRACE :  Stop NL
26.423 : INFO :  Node:  realRootWrongPlace

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-7 should handle an id and type for a node definition
26.431 : TRACE :  Long description: The root
26.431 : TRACE :  node end ... ]
26.431 : TRACE :  node found .. root
26.431 : DEBUG :  In get type [ ]
26.430 : INFO :  Node:  root
26.431 : TRACE :  Stop NL
26.431 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-8 should handle an id and type for a node definition
26.435 : INFO :  Node:  root
26.435 : TRACE :  Stop NL
26.435 : TRACE :  Long description: child1
26.435 : TRACE :  node end )
26.435 : TRACE :  node found .. theId
26.435 : DEBUG :  In get type ( )
26.435 : INFO :  Node:  theId
26.435 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-9 should handle an id and type for a node definition
26.440 : TRACE :  Node:  root
26.440 : TRACE :  Stop NL
26.440 : TRACE :  Long description: child1
26.440 : TRACE :  node end )
26.440 : TRACE :  node found .. theId
26.440 : DEBUG :  In get type ( )
26.440 : INFO :  Node:  theId
26.440 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-13 should be possible to set an icon for the node
26.446 : TRACE :  Long description: The root
26.446 : TRACE :  node end ... ]
26.446 : TRACE :  node found .. root
26.446 : DEBUG :  In get type [ ]
26.446 : INFO :  Node:  root
26.446 : TRACE :  Stop NL
26.446 : TRACE :  Begin icon
26.446 : TRACE :  end icon
26.446 : TRACE :  Icon:  bomb
26.446 : TRACE :  Stop NL
26.446 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-14 should be possible to set classes for the node
26.452 : TRACE :  Long description: The root
26.452 : TRACE :  node end ... ]
26.452 : TRACE :  node found .. root
26.452 : DEBUG :  In get type [ ]
26.452 : INFO :  Node:  root
26.452 : TRACE :  Stop NL
26.452 : TRACE :  Stop NL
26.452 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-15 should be possible to set both classes and icon for the node
26.458 : TRACE :  Long description: The root
26.458 : TRACE :  node end ... ]
26.458 : TRACE :  node found .. root
26.458 : DEBUG :  In get type [ ]
26.458 : INFO :  Node:  root
26.458 : TRACE :  Stop NL
26.458 : TRACE :  Stop NL
26.458 : TRACE :  Begin icon
26.458 : TRACE :  end icon
26.458 : TRACE :  Icon:  bomb
26.458 : TRACE :  Stop NL
26.458 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-16 should be possible to set both classes and icon for the node
26.469 : TRACE :  Long description: The root
26.469 : TRACE :  node end ... ]
26.469 : TRACE :  node found .. root
26.469 : DEBUG :  In get type [ ]
26.469 : INFO :  Node:  root
26.469 : TRACE :  Stop NL
26.469 : TRACE :  Begin icon
26.469 : TRACE :  end icon
26.469 : TRACE :  Icon:  bomb
26.469 : TRACE :  Stop NL
26.469 : TRACE :  Stop NL
26.469 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-17 should be possible to use node syntax in the descriptions
26.476 : TRACE :  Starting NSTR
26.476 : TRACE :  description: String containing []
26.476 : TRACE :  node end ... ]
26.476 : TRACE :  node found .. root
26.476 : DEBUG :  In get type [ ]
26.476 : INFO :  Node:  root
26.476 : TRACE :  Stop NL
26.476 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-18 should be possible to use node syntax in the descriptions in children
26.480 : TRACE :  Starting NSTR
26.480 : TRACE :  description: String containing []
26.480 : TRACE :  node end ... ]
26.480 : TRACE :  node found .. root
26.480 : DEBUG :  In get type [ ]
26.480 : INFO :  Node:  root
26.480 : TRACE :  Stop NL
26.480 : TRACE :  Starting NSTR
26.480 : TRACE :  description: String containing ()
26.480 : TRACE :  node end ... ]
26.480 : TRACE :  node found .. child1
26.480 : DEBUG :  In get type [ ]
26.480 : INFO :  Node:  child1
26.480 : TRACE :  Stop NL
26.480 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-19 should be possible to have a child after a class assignment
26.486 : TRACE :  Long description: Root
26.486 : TRACE :  node end )
26.486 : TRACE :  node found .. root
26.486 : DEBUG :  In get type ( )
26.486 : INFO :  Node:  root
26.486 : TRACE :  Stop NL
26.486 : TRACE :  Long description: Child
26.486 : TRACE :  node end )
26.486 : TRACE :  node found .. Child
26.486 : DEBUG :  In get type ( )
26.486 : INFO :  Node:  Child
26.486 : TRACE :  Stop NL
26.486 : TRACE :  Stop NL
26.486 : TRACE :  Long description: a
26.486 : TRACE :  node end )
26.486 : TRACE :  node found .. a
26.486 : DEBUG :  In get type ( )
26.486 : INFO :  Node:  a
26.486 : TRACE :  Stop NL
26.486 : TRACE :  Long description: New Stuff
26.486 : TRACE :  node end ... ]
26.486 : TRACE :  node found .. b
26.486 : DEBUG :  In get type [ ]
26.486 : INFO :  Node:  b
26.486 : TRACE :  Stop EOF

 ✓ packages/mermaid/src/diagrams/class/classTypes.spec.ts (93 tests) 111ms
stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-20 should be possible to have meaningless empty rows in a kanban abc124
26.496 : TRACE :  Long description: Root
26.496 : TRACE :  node end )
26.496 : TRACE :  node found .. root
26.496 : DEBUG :  In get type ( )
26.496 : INFO :  Node:  root
26.496 : TRACE :  Stop NL
26.496 : TRACE :  Long description: Child
26.496 : TRACE :  node end )
26.496 : TRACE :  node found .. Child
26.496 : DEBUG :  In get type ( )
26.496 : INFO :  Node:  Child
26.496 : TRACE :  Stop NL
26.496 : TRACE :  Long description: a
26.496 : TRACE :  node end )
26.496 : TRACE :  SPACELINE
26.496 : TRACE :  node found .. a
26.496 : DEBUG :  In get type ( )
26.496 : INFO :  Node:  a
26.496 : TRACE :  Long description: New Stuff
26.496 : TRACE :  node end ... ]
26.496 : TRACE :  node found .. b
26.496 : DEBUG :  In get type [ ]
26.496 : INFO :  Node:  b
26.496 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-21 should be possible to have comments in a kanban
26.505 : TRACE :  Long description: Root
26.505 : TRACE :  node end )
26.505 : TRACE :  node found .. root
26.505 : DEBUG :  In get type ( )
26.505 : INFO :  Node:  root
26.505 : TRACE :  Stop NL
26.505 : TRACE :  Long description: Child
26.505 : TRACE :  node end )
26.505 : TRACE :  node found .. Child
26.505 : DEBUG :  In get type ( )
26.505 : INFO :  Node:  Child
26.505 : TRACE :  Stop NL
26.505 : TRACE :  Long description: a
26.505 : TRACE :  node end )
26.505 : TRACE :  Found comment

      %% This is a comment
26.505 : TRACE :  node found .. a
26.505 : DEBUG :  In get type ( )
26.505 : INFO :  Node:  a
26.505 : TRACE :  Stop NL2
26.505 : TRACE :  Long description: New Stuff
26.505 : TRACE :  node end ... ]
26.505 : TRACE :  node found .. b
26.505 : DEBUG :  In get type [ ]
26.505 : INFO :  Node:  b
26.505 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-22 should be possible to have comments at the end of a line
26.513 : TRACE :  Long description: Root
26.513 : TRACE :  node end )
26.513 : TRACE :  node found .. root
26.513 : DEBUG :  In get type ( )
26.513 : INFO :  Node:  root
26.513 : TRACE :  Stop NL
26.513 : TRACE :  Long description: Child
26.513 : TRACE :  node end )
26.513 : TRACE :  node found .. Child
26.513 : DEBUG :  In get type ( )
26.513 : INFO :  Node:  Child
26.513 : TRACE :  Stop NL
26.513 : TRACE :  Long description: a
26.513 : TRACE :  node end )
26.513 : TRACE :  Found comment  %% This is a comment
26.513 : TRACE :  node found .. a
26.513 : DEBUG :  In get type ( )
26.513 : INFO :  Node:  a
26.513 : TRACE :  Stop NL2
26.513 : TRACE :  Long description: New Stuff
26.513 : TRACE :  node end ... ]
26.513 : TRACE :  node found .. b
26.513 : DEBUG :  In get type [ ]
26.513 : INFO :  Node:  b
26.513 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-23 Rows with only spaces should not interfere
26.522 : TRACE :  Node:  root
26.522 : TRACE :  Stop NL
26.522 : TRACE :  SPACELINE
26.521 : INFO :  Node:  A
26.521 : INFO :  Node:  B
26.522 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-24 Handle rows above the kanban declarations
26.526 : TRACE :  SPACELINE
26.526 : TRACE :  Node:  root
26.526 : TRACE :  Stop NL
26.526 : TRACE :  SPACELINE
26.526 : INFO :  Node:  A
26.526 : INFO :  Node:  B
26.526 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-25 Handle rows above the kanban declarations, no space
26.531 : TRACE :  SPACELINE
26.531 : TRACE :  Node:  root
26.531 : TRACE :  Stop NL
26.531 : TRACE :  SPACELINE
26.531 : INFO :  Node:  A
26.531 : INFO :  Node:  B
26.531 : TRACE :  Stop EOF

 ✓ packages/mermaid/src/diagrams/requirement/parser/requirementDiagram.spec.js (43 tests) 75ms
stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-30 should be possible to set the priority
26.536 : INFO :  Node:  root
26.536 : TRACE :  Stop NL
26.536 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-31 should be possible to set the assignment
26.542 : INFO :  Node:  root
26.542 : TRACE :  Stop NL
26.542 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-32 should be possible to set the icon
26.544 : INFO :  Node:  root
26.544 : TRACE :  Stop NL
26.544 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-33 should be possible to set the icon
26.546 : INFO :  Node:  root
26.546 : TRACE :  Stop NL
26.546 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-34 should be possible to set the metadata using multiple lines
26.548 : INFO :  Node:  root
26.548 : TRACE :  Stop NL
26.548 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-35 should be possible to set the metadata using one line
26.550 : INFO :  Node:  root
26.550 : TRACE :  Stop NL
26.550 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-36 should be possible to set the label using the new syntax
26.552 : INFO :  Node:  root
26.552 : TRACE :  Stop NL
26.552 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-37 should be possible to set the external id
26.554 : INFO :  Node:  root
26.554 : TRACE :  Stop NL
26.554 : TRACE :  Stop EOF

 ✓ packages/mermaid/src/diagrams/kanban/kanban.spec.ts (30 tests) 174ms
 ✓ packages/mermaid/src/diagrams/git/gitGraphRenderer.ts (30 tests) 28ms
 ✓ packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js (27 tests) 75ms
 ✓ packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts (43 tests | 1 skipped) 63ms
 ✓ packages/mermaid/src/rendering-util/handle-markdown-text.spec.ts (19 tests) 49ms
 ✓ packages/mermaid/src/utils.spec.ts (53 tests) 149ms
 ✓ packages/parser/tests/treemap.test.ts (17 tests) 49ms
 ✓ packages/mermaid/src/diagrams/er/parser/erDiagram.spec.js (611 tests | 1 skipped) 542ms
 ✓ packages/parser/tests/radar.test.ts (80 tests) 120ms
 ✓ packages/mermaid/src/accessibility.spec.ts (20 tests) 276ms
 ✓ packages/mermaid/src/utils/lineWithOffset.ts (2 tests) 8ms
 ✓ packages/mermaid/src/diagrams/git/gitGraph.spec.ts (69 tests | 4 skipped) 424ms
 ✓ packages/parser/tests/gitGraph.test.ts (27 tests) 52ms
 ✓ packages/mermaid/src/rendering-util/splitText.spec.ts (35 tests) 89ms
 ✓ packages/mermaid/src/rendering-util/rendering-elements/nodes.spec.ts (39 tests) 23ms
 ❯ packages/mermaid/scripts/docs.spec.ts (0 test)
 ✓ packages/mermaid/src/diagrams/class/classDiagram.spec.ts (368 tests | 1 skipped) 1676ms
 ✓ packages/parser/tests/pie.test.ts (32 tests) 55ms
 ✓ packages/mermaid/src/diagrams/sequence/sequenceDiagram.spec.js (116 tests) 1355ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-style.spec.js (24 tests) 96ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-arrows.spec.js (14 tests) 87ms
 ✓ packages/mermaid/src/diagrams/state/parser/state-style.spec.js (15 tests) 78ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-node-data.spec.js (31 tests | 1 skipped) 163ms
 ✓ packages/mermaid/src/diagrams/state/stateDiagram.spec.js (30 tests | 1 skipped) 270ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-vertice-chaining.spec.js (7 tests) 52ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/subgraph.spec.js (22 tests | 1 skipped) 117ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-singlenode.spec.js (148 tests) 261ms
 ✓ packages/mermaid/src/diagrams/state/stateDiagram-v2.spec.js (31 tests) 337ms
 ✓ packages/mermaid/src/diagrams/sequence/svgDraw.spec.js (6 tests) 20ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow.spec.js (25 tests) 165ms
 ✓ packages/mermaid/src/diagrams/git/gitGraphParser.ts (6 tests) 15ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-edges.spec.js (293 tests) 647ms
 ✓ packages/mermaid/src/diagrams/radar/radar.spec.ts (19 tests) 326ms
 ✓ packages/mermaid/src/diagrams/packet/packet.spec.ts (15 tests) 181ms
 ✓ packages/mermaid/src/diagrams/pie/pie.spec.ts (16 tests | 2 skipped) 163ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-text.spec.js (342 tests) 849ms
 ✓ packages/mermaid/src/diagrams/timeline/timeline.spec.js (8 tests) 52ms
 ✓ packages/mermaid/src/diagram-api/frontmatter.spec.ts (12 tests) 38ms
 ✓ packages/mermaid/src/diagrams/flowchart/flowChartShapes.spec.js (11 tests) 29ms
 ✓ packages/mermaid/src/diagrams/requirement/requirementDb.spec.ts (9 tests) 13ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-lines.spec.js (12 tests) 73ms
 ✓ packages/mermaid/src/diagrams/flowchart/flowDb.spec.ts (13 tests) 59ms
 ✓ packages/mermaid/src/diagrams/common/common.spec.ts (20 tests) 42ms
 ✓ packages/mermaid/src/docs/.vitepress/theme/redirect.spec.ts (28 tests) 25ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-interactions.spec.js (13 tests) 64ms
 ✓ packages/mermaid/src/diagrams/user-journey/parser/journey.spec.js (7 tests) 30ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-comments.spec.js (9 tests) 29ms
 ✓ packages/mermaid/src/diagrams/treemap/utils.test.ts (4 tests) 6ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4System.spec.js (42 tests) 94ms
 ✓ packages/mermaid/src/diagrams/state/parser/state-parser.spec.js (9 tests) 55ms
 ✓ packages/mermaid/src/diagram-api/diagram-orchestration.spec.ts (24 tests) 29ms
 ✓ packages/mermaid/src/config.spec.ts (5 tests) 47ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4PersonExt.spec.js (7 tests) 29ms
 ✓ packages/mermaid/src/diagrams/class/classDiagram-styles.spec.js (10 tests) 63ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4Container.spec.js (48 tests) 112ms
 ✓ packages/mermaid/src/mermaid.spec.ts (13 tests) 1474ms
   ✓ when using mermaid and  > when using #registerExternalDiagrams > should throw error (but still render) if registerExternalDiagrams fails 1338ms
 ✓ packages/mermaid/src/rendering-util/rendering-elements/edgeMarker.spec.ts (5 tests) 13ms
 ✓ packages/mermaid/src/dagre-wrapper/edgeMarker.spec.ts (5 tests) 9ms
 ✓ packages/mermaid/src/diagrams/state/stateDb.spec.js (6 tests) 33ms
 ✓ packages/mermaid/src/diagrams/user-journey/journeyDb.spec.js (9 tests) 16ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4Boundary.spec.js (6 tests) 28ms
 ✓ packages/mermaid/src/diagram.spec.ts (6 tests) 464ms
   ✓ diagram detection > should detect inbuilt diagrams 428ms
